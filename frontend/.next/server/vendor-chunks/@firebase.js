"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.11.1\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.3.1\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    if (obj === null || obj === undefined) {\n        return false;\n    }\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Parse the token and check to see if the `exp` claim is in the future.\n// Reports an error to the console if the token or claim could not be parsed, or if `exp` is in\n// the past.\nfunction validateTokenTTL(base64Token, tokenName) {\n    const secondPart = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Decode)(base64Token.split('.')[1]);\n    if (secondPart === null) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: second part could not be parsed.`);\n        return;\n    }\n    const expClaim = JSON.parse(secondPart).exp;\n    if (expClaim === undefined) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: expiration claim could not be parsed`);\n        return;\n    }\n    const exp = JSON.parse(secondPart).exp * 1000;\n    const now = new Date().getTime();\n    const diff = exp - now;\n    if (diff <= 0) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: the token has expired.`);\n    }\n}\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        // Ensure that the current time is within the `authIdtoken` window of validity.\n        if (this._serverConfig.authIdToken) {\n            validateTokenTTL(this._serverConfig.authIdToken, 'authIdToken');\n        }\n        // Ensure that the current time is within the `appCheckToken` window of validity.\n        if (this._serverConfig.appCheckToken) {\n            validateTokenTTL(this._serverConfig.appCheckToken, 'appCheckToken');\n        }\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\nconst MAX_NUM_STORED_HEARTBEATS = 30;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n                // If the number of stored heartbeats exceeds the maximum number of stored heartbeats, remove the heartbeat with the earliest date.\n                // Since this is executed each time a heartbeat is pushed, the limit can only be exceeded by one, so only one needs to be removed.\n                if (this._heartbeatsCache.heartbeats.length > MAX_NUM_STORED_HEARTBEATS) {\n                    const earliestHeartbeatIdx = getEarliestHeartbeatIdx(this._heartbeatsCache.heartbeats);\n                    this._heartbeatsCache.heartbeats.splice(earliestHeartbeatIdx, 1);\n                }\n            }\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n/**\n * Returns the index of the heartbeat with the earliest date.\n * If the heartbeats array is empty, -1 is returned.\n */\nfunction getEarliestHeartbeatIdx(heartbeats) {\n    if (heartbeats.length === 0) {\n        return -1;\n    }\n    let earliestHeartbeatIdx = 0;\n    let earliestHeartbeatDate = heartbeats[0].date;\n    for (let i = 1; i < heartbeats.length; i++) {\n        if (heartbeats[i].date < earliestHeartbeatDate) {\n            earliestHeartbeatDate = heartbeats[i].date;\n            earliestHeartbeatIdx = i;\n        }\n    }\n    return earliestHeartbeatIdx;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'esm2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQ3dIO0FBQ3BLO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLFNBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGLDBFQUEwRSxTQUFTO0FBQ25GLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0EsaUdBQWlHLHNCQUFzQjtBQUN2SCxvR0FBb0csc0JBQXNCO0FBQzFILG9HQUFvRyxzQkFBc0I7QUFDMUgsMkdBQTJHLHNCQUFzQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFZO0FBQ25DO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTLE9BQU8sMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQsaUNBQWlDLDZFQUE2QixrQkFBa0IsMENBQTBDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIHNldFVzZXJMb2dIYW5kbGVyLCBzZXRMb2dMZXZlbCBhcyBzZXRMb2dMZXZlbCQxIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGJhc2U2NERlY29kZSwgZ2V0RGVmYXVsdEFwcENvbmZpZywgZGVlcEVxdWFsLCBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBGaXJlYmFzZUVycm9yLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLy8gSW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBieSBpbnN0YWxsYXRpb25zIG9uXG4gICAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcnMoKTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXG4gICAgICAgIHJldHVybiBwcm92aWRlcnNcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXG4gKlxuICogTk9URTogVXNpbmcgUHJvdmlkZXI8J2FwcC12ZXJzaW9uJz4gaXMgYSBoYWNrIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3ZpZGVyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcbiAqIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcbiAgICByZXR1cm4gKGNvbXBvbmVudCA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudC50eXBlKSA9PT0gXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovO1xufVxuXG5jb25zdCBuYW1lJHEgPSBcIkBmaXJlYmFzZS9hcHBcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiMC4xMS4xXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkcCA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9kYXRhLWNvbm5lY3RcIjtcblxuY29uc3QgbmFtZSRnID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZiA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGUgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnNcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRiID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nXCI7XG5cbmNvbnN0IG5hbWUkYSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2VcIjtcblxuY29uc3QgbmFtZSQ4ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNyA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWdcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ1ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDMgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcblxuY29uc3QgbmFtZSQyID0gXCJAZmlyZWJhc2UvdmVydGV4YWlcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMTEuMy4xXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcbiAgICBbbmFtZSRxXTogJ2ZpcmUtY29yZScsXG4gICAgW25hbWUkcF06ICdmaXJlLWNvcmUtY29tcGF0JyxcbiAgICBbbmFtZSRuXTogJ2ZpcmUtYW5hbHl0aWNzJyxcbiAgICBbbmFtZSRvXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXG4gICAgW25hbWUkbF06ICdmaXJlLWFwcC1jaGVjaycsXG4gICAgW25hbWUkbV06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxuICAgIFtuYW1lJGtdOiAnZmlyZS1hdXRoJyxcbiAgICBbbmFtZSRqXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxuICAgIFtuYW1lJGldOiAnZmlyZS1ydGRiJyxcbiAgICBbbmFtZSRoXTogJ2ZpcmUtZGF0YS1jb25uZWN0JyxcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxuICAgIFtuYW1lJGZdOiAnZmlyZS1mbicsXG4gICAgW25hbWUkZV06ICdmaXJlLWZuLWNvbXBhdCcsXG4gICAgW25hbWUkZF06ICdmaXJlLWlpZCcsXG4gICAgW25hbWUkY106ICdmaXJlLWlpZC1jb21wYXQnLFxuICAgIFtuYW1lJGJdOiAnZmlyZS1mY20nLFxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20tY29tcGF0JyxcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtcGVyZicsXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYtY29tcGF0JyxcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcmMnLFxuICAgIFtuYW1lJDZdOiAnZmlyZS1yYy1jb21wYXQnLFxuICAgIFtuYW1lJDVdOiAnZmlyZS1nY3MnLFxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MtY29tcGF0JyxcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZnN0JyxcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXG4gICAgW25hbWUkMl06ICdmaXJlLXZlcnRleCcsXG4gICAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsIC8vIFBsYXRmb3JtIGlkZW50aWZpZXIgZm9yIEpTIFNESy5cbiAgICBbbmFtZV06ICdmaXJlLWpzLWFsbCdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IF9zZXJ2ZXJBcHBzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFwcC5jb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZhaWxlZCB0byByZWdpc3RlciB3aXRoIEZpcmViYXNlQXBwICR7YXBwLm5hbWV9YCwgZSk7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XG4gICAgLy8gYWRkIHRoZSBjb21wb25lbnQgdG8gZXhpc3RpbmcgYXBwIGluc3RhbmNlc1xuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xuICAgICAgICBfYWRkQ29tcG9uZW50KHNlcnZlckFwcCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKlxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpIHtcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXG4gICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpLmNsZWFySW5zdGFuY2UoaW5zdGFuY2VJZGVudGlmaWVyKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZSBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZUFwcC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5vcHRpb25zICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfaXNGaXJlYmFzZVNlcnZlckFwcChvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5zZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBUZXN0IG9ubHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2NsZWFyQ29tcG9uZW50cygpIHtcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRVJST1JTID0ge1xuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxuICAgIFtcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqL106IFwiSWxsZWdhbCBBcHAgbmFtZTogJ3skYXBwTmFtZX0nXCIsXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcbiAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLkFQUF9ERUxFVEVEICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICAgIFtcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqL106ICdGaXJlYmFzZSBTZXJ2ZXIgQXBwIGhhcyBiZWVuIGRlbGV0ZWQnLFxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcbiAgICAgICAgJ0ZpcmViYXNlIEFwcCBpbnN0YW5jZS4nLFxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovXTogJ0Vycm9yIHRocm93biB3aGVuIHJlYWRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcbiAgICBbXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGRlbGV0ZU9uRGVyZWYgZmllbGQgZGVmaW5lZCBidXQgdGhlIEpTIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCBGaW5hbGl6YXRpb25SZWdpc3RyeS4nLFxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXG59O1xuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2FwcCcsICdGaXJlYmFzZScsIEVSUk9SUyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcbiAgICB9XG4gICAgZ2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICAgIH1cbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XG4gICAgfVxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFBhcnNlIHRoZSB0b2tlbiBhbmQgY2hlY2sgdG8gc2VlIGlmIHRoZSBgZXhwYCBjbGFpbSBpcyBpbiB0aGUgZnV0dXJlLlxuLy8gUmVwb3J0cyBhbiBlcnJvciB0byB0aGUgY29uc29sZSBpZiB0aGUgdG9rZW4gb3IgY2xhaW0gY291bGQgbm90IGJlIHBhcnNlZCwgb3IgaWYgYGV4cGAgaXMgaW5cbi8vIHRoZSBwYXN0LlxuZnVuY3Rpb24gdmFsaWRhdGVUb2tlblRUTChiYXNlNjRUb2tlbiwgdG9rZW5OYW1lKSB7XG4gICAgY29uc3Qgc2Vjb25kUGFydCA9IGJhc2U2NERlY29kZShiYXNlNjRUb2tlbi5zcGxpdCgnLicpWzFdKTtcbiAgICBpZiAoc2Vjb25kUGFydCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGaXJlYmFzZVNlcnZlckFwcCAke3Rva2VuTmFtZX0gaXMgaW52YWxpZDogc2Vjb25kIHBhcnQgY291bGQgbm90IGJlIHBhcnNlZC5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHBDbGFpbSA9IEpTT04ucGFyc2Uoc2Vjb25kUGFydCkuZXhwO1xuICAgIGlmIChleHBDbGFpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZpcmViYXNlU2VydmVyQXBwICR7dG9rZW5OYW1lfSBpcyBpbnZhbGlkOiBleHBpcmF0aW9uIGNsYWltIGNvdWxkIG5vdCBiZSBwYXJzZWRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHAgPSBKU09OLnBhcnNlKHNlY29uZFBhcnQpLmV4cCAqIDEwMDA7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgZGlmZiA9IGV4cCAtIG5vdztcbiAgICBpZiAoZGlmZiA8PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZpcmViYXNlU2VydmVyQXBwICR7dG9rZW5OYW1lfSBpcyBpbnZhbGlkOiB0aGUgdG9rZW4gaGFzIGV4cGlyZWQuYCk7XG4gICAgfVxufVxuY2xhc3MgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIGV4dGVuZHMgRmlyZWJhc2VBcHBJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzZXJ2ZXJDb25maWcsIG5hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cbiAgICAgICAgY29uc3QgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHNlcnZlckNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWRcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgRmlyZWJhc2VBcHBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBGaXJlYmFzZUFwcEltcCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwYXJlbnQgRmlyZWJhc2VBcHBJbXAgb2JqZWN0LlxuICAgICAgICAgICAgc3VwZXIob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBwSW1wbCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY29uc3RydWN0IHRoZSBkYXRhIGZvciB0aGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjdXJyZW50IHRpbWUgaXMgd2l0aGluIHRoZSBgYXV0aElkdG9rZW5gIHdpbmRvdyBvZiB2YWxpZGl0eS5cbiAgICAgICAgaWYgKHRoaXMuX3NlcnZlckNvbmZpZy5hdXRoSWRUb2tlbikge1xuICAgICAgICAgICAgdmFsaWRhdGVUb2tlblRUTCh0aGlzLl9zZXJ2ZXJDb25maWcuYXV0aElkVG9rZW4sICdhdXRoSWRUb2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjdXJyZW50IHRpbWUgaXMgd2l0aGluIHRoZSBgYXBwQ2hlY2tUb2tlbmAgd2luZG93IG9mIHZhbGlkaXR5LlxuICAgICAgICBpZiAodGhpcy5fc2VydmVyQ29uZmlnLmFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVG9rZW5UVEwodGhpcy5fc2VydmVyQ29uZmlnLmFwcENoZWNrVG9rZW4sICdhcHBDaGVja1Rva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b21hdGljQ2xlYW51cCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmluY1JlZkNvdW50KHRoaXMuX3NlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZik7XG4gICAgICAgIC8vIERvIG5vdCByZXRhaW4gYSBoYXJkIHJlZmVyZW5jZSB0byB0aGUgZHJlZiBvYmplY3QsIG90aGVyd2lzZSB0aGUgRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAgICAgLy8gd2lsbCBuZXZlciB0cmlnZ2VyLlxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcSwgdmVyc2lvbiQxLCAnc2VydmVyYXBwJyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHJlZkNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmQ291bnQ7XG4gICAgfVxuICAgIC8vIEluY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgc2VydmVyIGFwcC4gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkLCByZWdpc3RlciBpdFxuICAgIC8vIHdpdGggdGhlIGZpbmFsaXphdGlvbiByZWdpc3RyeS5cbiAgICBpbmNSZWZDb3VudChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmosIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50LlxuICAgIGRlY1JlZkNvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtLXRoaXMuX3JlZkNvdW50O1xuICAgIH1cbiAgICAvLyBJbnZva2VkIGJ5IHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeSBjYWxsYmFjayB0byBub3RlIHRoYXQgdGhpcyBhcHAgc2hvdWxkIGdvIHRocm91Z2ggaXRzXG4gICAgLy8gcmVmZXJlbmNlIGNvdW50cyBhbmQgZGVsZXRlIGl0c2VsZiBpZiBubyByZWZlcmVuY2UgY291bnQgcmVtYWluLiBUaGUgY29vcmRpbmF0aW5nIGxvZ2ljIHRoYXRcbiAgICAvLyBoYW5kbGVzIHRoaXMgaXMgaW4gZGVsZXRlQXBwKC4uLikuXG4gICAgYXV0b21hdGljQ2xlYW51cCgpIHtcbiAgICAgICAgdm9pZCBkZWxldGVBcHAodGhpcyk7XG4gICAgfVxuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxuICAgICAqL1xuICAgIGNoZWNrRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBTREtfVkVSU0lPTiA9IHZlcnNpb247XG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKF9vcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiByYXdDb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlIH0sIHJhd0NvbmZpZyk7XG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi8sIHtcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9hcHBzLmdldChuYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cbiAgICAgICAgaWYgKGRlZXBFcXVhbChvcHRpb25zLCBleGlzdGluZ0FwcC5vcHRpb25zKSAmJlxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VBcHBJbXBsKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcbiAgICByZXR1cm4gbmV3QXBwO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNlcnZlckFwcChfb3B0aW9ucywgX3NlcnZlckFwcENvbmZpZykge1xuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICAvLyBGaXJlYmFzZVNlcnZlckFwcCBpc24ndCBkZXNpZ25lZCB0byBiZSBydW4gaW4gYnJvd3NlcnMuXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcbiAgICB9XG4gICAgaWYgKF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGFwcE9wdGlvbnM7XG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnMub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgY29uc3QgbmFtZU9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3NlcnZlckFwcENvbmZpZyksIGFwcE9wdGlvbnMpO1xuICAgIC8vIEhvd2V2ZXIsIERvIG5vdCBtYW5nbGUgdGhlIG5hbWUgYmFzZWQgb24gcmVsZWFzZU9uRGVyZWYsIHNpbmNlIGl0IHdpbGwgdmFyeSBiZXR3ZWVuIHRoZVxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgaWYgKG5hbWVPYmoucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbmFtZU9iai5yZWxlYXNlT25EZXJlZjtcbiAgICB9XG4gICAgY29uc3QgaGFzaENvZGUgPSAocykgPT4ge1xuICAgICAgICByZXR1cm4gWy4uLnNdLnJlZHVjZSgoaGFzaCwgYykgPT4gKE1hdGguaW11bCgzMSwgaGFzaCkgKyBjLmNoYXJDb2RlQXQoMCkpIHwgMCwgMCk7XG4gICAgfTtcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfc2VydmVyQXBwcy5nZXQobmFtZVN0cmluZyk7XG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZVN0cmluZyk7XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsKGFwcE9wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcsIG5hbWVTdHJpbmcsIGNvbnRhaW5lcik7XG4gICAgX3NlcnZlckFwcHMuc2V0KG5hbWVTdHJpbmcsIG5ld0FwcCk7XG4gICAgcmV0dXJuIG5ld0FwcDtcbn1cbi8qKlxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuIFdoZW4gYW4gYXBwIG5hbWVcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICpcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGFwcCBiZWluZyByZXRyaWV2ZWQgaGFzIG5vdCB5ZXQgYmVlblxuICogaW5pdGlhbGl6ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcbiAqIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxuICogY29uc3Qgb3RoZXJBcHAgPSBnZXRBcHAoXCJvdGhlckFwcFwiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgYXBwIHRvIHJldHVybi4gSWYgbm8gbmFtZSBpc1xuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxuICpcbiAqIEByZXR1cm5zIFRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgYXBwIG5hbWUuXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRBcHAobmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgIGNvbnN0IGFwcCA9IF9hcHBzLmdldChuYW1lKTtcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XG4gICAgfVxuICAgIGlmICghYXBwKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcHA7XG59XG4vKipcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFwcHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXG4gKiBzZXJ2aWNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogZGVsZXRlQXBwKGFwcClcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBcHAgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZGVsZXRpbmcgYXBwOlwiLCBlcnJvcik7XG4gKiAgIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBcHAoYXBwKSB7XG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XG4gICAgaWYgKF9hcHBzLmhhcyhuYW1lKSkge1xuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTZXJ2ZXJBcHAgPSBhcHA7XG4gICAgICAgIGlmIChmaXJlYmFzZVNlcnZlckFwcC5kZWNSZWZDb3VudCgpIDw9IDApIHtcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGVhbnVwUHJvdmlkZXJzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFwcC5jb250YWluZXJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xuICAgICAgICBhcHAuaXNEZWxldGVkID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQ3VycmVudCB2ZXJzaW9uIG9mIHRoYXQgbGlicmFyeS5cbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cbiAgICBsZXQgbGlicmFyeSA9IChfYSA9IFBMQVRGT1JNX0xPR19TVFJJTkdbbGlicmFyeUtleU9yTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxpYnJhcnlLZXlPck5hbWU7XG4gICAgaWYgKHZhcmlhbnQpIHtcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xuICAgIH1cbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggfHwgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xufVxuLyoqXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxuICogdGhlIEZpcmViYXNlIFNESyBtYWtlcyBhIGxvZ2dpbmcgY2FsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi8pO1xuICAgIH1cbiAgICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XG59XG4vKipcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXG4gKiBgdmVyYm9zZWAgbG9ncyBhcmUgbm90KS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgc2V0TG9nTGV2ZWwkMShsb2dMZXZlbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XG5jb25zdCBEQl9WRVJTSU9OID0gMTtcbmNvbnN0IFNUT1JFX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LXN0b3JlJztcbmxldCBkYlByb21pc2UgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xuICAgIGlmICghZGJQcm9taXNlKSB7XG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpL2lPUyBicm93c2VycyB0aHJvdyBvY2Nhc2lvbmFsIGV4Y2VwdGlvbnMgb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYi5jcmVhdGVPYmplY3RTdG9yZSgpIHRoYXQgbWF5IGJlIGEgYnVnLiBBdm9pZCBibG9ja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKS5nZXQoY29tcHV0ZUtleShhcHApKTtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYXdhaXQgaXQgaGVyZSB0byBjYXRjaCBlcnJvcnNcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIoYXBwLCBoZWFydGJlYXRPYmplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KGhlYXJ0YmVhdE9iamVjdCwgY29tcHV0ZUtleShhcHApKTtcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcCkge1xuICAgIHJldHVybiBgJHthcHAubmFtZX0hJHthcHAub3B0aW9ucy5hcHBJZH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XG5jb25zdCBNQVhfTlVNX1NUT1JFRF9IRUFSVEJFQVRTID0gMzA7XG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxuICAgICAgICAgKiB0aGUgaGVhZGVyIHN0cmluZy5cbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxuICAgICAgICAgKiBQb3B1bGF0ZWQgZnJvbSBpbmRleGVkREIgd2hlbiB0aGUgY29udHJvbGxlciBpcyBpbnN0YW50aWF0ZWQgYW5kIHNob3VsZFxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgSGVhcnRiZWF0U3RvcmFnZUltcGwoYXBwKTtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcbiAgICAgKiB0byBJbmRleGVkREIuXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxuICAgICAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcbiAgICAgICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID09PSBkYXRlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIHN0b3JlZCBoZWFydGJlYXRzIGV4Y2VlZHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0b3JlZCBoZWFydGJlYXRzLCByZW1vdmUgdGhlIGhlYXJ0YmVhdCB3aXRoIHRoZSBlYXJsaWVzdCBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgZXhlY3V0ZWQgZWFjaCB0aW1lIGEgaGVhcnRiZWF0IGlzIHB1c2hlZCwgdGhlIGxpbWl0IGNhbiBvbmx5IGJlIGV4Y2VlZGVkIGJ5IG9uZSwgc28gb25seSBvbmUgbmVlZHMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID4gTUFYX05VTV9TVE9SRURfSEVBUlRCRUFUUykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlYXJsaWVzdEhlYXJ0YmVhdElkeCA9IGdldEVhcmxpZXN0SGVhcnRiZWF0SWR4KHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc3BsaWNlKGVhcmxpZXN0SGVhcnRiZWF0SWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXG4gICAgICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XG4gICAgICAgICAgICAvLyBTdG9yZSBsYXN0IHNlbnQgZGF0ZSB0byBwcmV2ZW50IGFub3RoZXIgYmVpbmcgbG9nZ2VkL3NlbnQgZm9yIHRoZSBzYW1lIGRheS5cbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcbiAgICByZXR1cm4gdG9kYXkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xufVxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xuICAgIC8vIEhlYXJ0YmVhdHMgZ3JvdXBlZCBieSB1c2VyIGFnZW50IGluIHRoZSBzdGFuZGFyZCBmb3JtYXQgdG8gYmUgc2VudCBpblxuICAgIC8vIHRoZSBoZWFkZXIuXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xuICAgIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgICAgICAvLyBMb29rIGZvciBhbiBleGlzdGluZyBlbnRyeSB3aXRoIHRoZSBzYW1lIHVzZXIgYWdlbnQuXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gZW50cnkgZm9yIHRoaXMgdXNlciBhZ2VudCBleGlzdHMsIGNyZWF0ZSBvbmUuXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxuICAgICAgICAgICAgICAgIGRhdGVzOiBbc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBoZWFydGJlYXRcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxuICAgICAgICAgICAgLy8gYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgdW5zZW50IGVudHJ5IGZyb20gcXVldWUuIChTa2lwcGVkIGlmIGFkZGluZyB0aGUgZW50cnkgZXhjZWVkZWRcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxuICAgICAgICB1bnNlbnRFbnRyaWVzXG4gICAgfTtcbn1cbmNsYXNzIEhlYXJ0YmVhdFN0b3JhZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2UgPSB0aGlzLnJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKTtcbiAgICB9XG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcbiAgICAgICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3ZlcndyaXRlIHRoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIGhlYXJ0YmVhdHNcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgaGVhcnRiZWF0c1xuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXG4gKiB0byBiYXNlIDY0LlxuICovXG5mdW5jdGlvbiBjb3VudEJ5dGVzKGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBoZWFydGJlYXQgd2l0aCB0aGUgZWFybGllc3QgZGF0ZS5cbiAqIElmIHRoZSBoZWFydGJlYXRzIGFycmF5IGlzIGVtcHR5LCAtMSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWFybGllc3RIZWFydGJlYXRJZHgoaGVhcnRiZWF0cykge1xuICAgIGlmIChoZWFydGJlYXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBlYXJsaWVzdEhlYXJ0YmVhdElkeCA9IDA7XG4gICAgbGV0IGVhcmxpZXN0SGVhcnRiZWF0RGF0ZSA9IGhlYXJ0YmVhdHNbMF0uZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYXJ0YmVhdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhlYXJ0YmVhdHNbaV0uZGF0ZSA8IGVhcmxpZXN0SGVhcnRiZWF0RGF0ZSkge1xuICAgICAgICAgICAgZWFybGllc3RIZWFydGJlYXREYXRlID0gaGVhcnRiZWF0c1tpXS5kYXRlO1xuICAgICAgICAgICAgZWFybGllc3RIZWFydGJlYXRJZHggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlYXJsaWVzdEhlYXJ0YmVhdElkeDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudCkge1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdwbGF0Zm9ybS1sb2dnZXInLCBjb250YWluZXIgPT4gbmV3IFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XG4gICAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcSwgdmVyc2lvbiQxLCAnZXNtMjAxNycpO1xuICAgIC8vIFJlZ2lzdGVyIHBsYXRmb3JtIFNESyBpZGVudGlmaWVyIChubyB2ZXJzaW9uKS5cbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XG59XG5cbi8qKlxuICogRmlyZWJhc2UgQXBwXG4gKlxuICogQHJlbWFya3MgVGhpcyBwYWNrYWdlIGNvb3JkaW5hdGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGRpZmZlcmVudCBGaXJlYmFzZSBjb21wb25lbnRzXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnJyk7XG5cbmV4cG9ydCB7IFNES19WRVJTSU9OLCBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZENvbXBvbmVudCwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCBfYXBwcywgX2NsZWFyQ29tcG9uZW50cywgX2NvbXBvbmVudHMsIF9nZXRQcm92aWRlciwgX2lzRmlyZWJhc2VBcHAsIF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9zZXJ2ZXJBcHBzLCBkZWxldGVBcHAsIGdldEFwcCwgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCwgaW5pdGlhbGl6ZVNlcnZlckFwcCwgb25Mb2csIHJlZ2lzdGVyVmVyc2lvbiwgc2V0TG9nTGV2ZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuY2xhc3MgQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBwdWJsaWMgc2VydmljZSBuYW1lLCBlLmcuIGFwcCwgYXV0aCwgZmlyZXN0b3JlLCBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxuICAgICAqIEBwYXJhbSB0eXBlIHdoZXRoZXIgdGhlIHNlcnZpY2UgcHJvdmlkZWQgYnkgdGhlIGNvbXBvbmVudCBpcyBwdWJsaWMgb3IgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlRmFjdG9yeSA9IGluc3RhbmNlRmFjdG9yeTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0ge307XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gbnVsbDtcbiAgICB9XG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBtdWx0aXBsZUluc3RhbmNlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFNlcnZpY2VQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcbiAqL1xuY2xhc3MgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXG4gICAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBnZXQoaWRlbnRpZmllcikge1xuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBkZWZlcnJlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNlcnZpY2UgaWYgaXQgY2FuIGJlIGF1dG8taW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCByZXR1cm4gdGhlIHVucmVzb2x2ZWQgcHJvbWlzZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmdldChub3JtYWxpemVkSWRlbnRpZmllcikucHJvbWlzZTtcbiAgICB9XG4gICAgZ2V0SW1tZWRpYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3B0aW9uYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxuICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBhIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIHNob3VsZC9jYW5ub3QgYmUgYXV0by1pbml0aWFsaXplZCBhdCB0aGUgbW9tZW50LCByZXR1cm4gbnVsbCBpZiB0aGUgb3B0aW9uYWwgZmxhZyBpcyBzZXQsIG9yIHRocm93XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQ7XG4gICAgfVxuICAgIHNldENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNlcnZpY2UgaXMgZWFnZXIsIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXI6IERFRkFVTFRfRU5UUllfTkFNRSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSBmb3IgYW4gZWFnZXIgQ29tcG9uZW50IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHRoZSBlYWdlclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlIGEgZmF0YWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IgaW4gdGhpcyBjYXNlP1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlcyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlc29sdmUgdGhlbVxuICAgICAgICAvLyBOT1RFOiBpZiB0aGlzLm11bHRpcGxlSW5zdGFuY2VzIGlzIGZhbHNlLCBvbmx5IHRoZSBkZWZhdWx0IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gYGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoKWAgc2hvdWxkIGFsd2F5cyByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBzaW5jZSBhIGNvbXBvbmVudCBpcyBndWFyYW50ZWVkLiB1c2UgISB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHkuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFySW5zdGFuY2UoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcbiAgICAvLyBUT0RPOiBzaG91bGQgd2UgbWFyayB0aGUgcHJvdmlkZXIgYXMgZGVsZXRlZD9cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5JTlRFUk5BTC5kZWxldGUoKSksXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnX2RlbGV0ZScgaW4gc2VydmljZSkgLy8gbW9kdWxhcml6ZWQgc2VydmljZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgIT0gbnVsbDtcbiAgICB9XG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlcy5oYXMoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNPcHRpb25zLmdldChpZGVudGlmaWVyKSB8fCB7fTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zID0ge30gfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0cy5pbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYCR7dGhpcy5uYW1lfSgke25vcm1hbGl6ZWRJZGVudGlmaWVyfSkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50ICR7dGhpcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRJZGVudGlmaWVyID09PSBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxuICAgICAqIFRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIFNZTkNIUk9OT1VTTFksIHNvIGl0IHNob3VsZCBub3QgZXhlY3V0ZSBhbnkgbG9uZ3J1bm5pbmcgdGFza3MgaW4gb3JkZXIgdG8gbm90IGJsb2NrIHRoZSBwcm9ncmFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcbiAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3Muc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBleGlzdGluZ0NhbGxiYWNrcyk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXhpc3RpbmdJbnN0YW5jZSwgbm9ybWFsaXplZElkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XG4gICAgICogQHBhcmFtIGluc3RhbmNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlYFxuICAgICAqL1xuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5zdGFuY2UsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25Jbml0IGNhbGxiYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyA9IHt9IH0pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmICghaW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2VGYWN0b3J5KHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAqIE5vdGUgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQgaXMgZGlmZmVyZW50LCB3aGljaCBpcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQgY3JlYXRvcixcbiAgICAgICAgICAgICAqIHdoaWxlIG9uSW5pdCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgYnkgY29uc3VtZXJzIG9mIHRoZSBwcm92aWRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxuICAgICAgICAgICAgICogb25JbnN0YW5jZUNyZWF0ZWQoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTsgd2hpY2hcbiAgICAgICAgICAgICAqIG1ha2VzIGBpc0luaXRpYWxpemVkKClgIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZSB8fCBudWxsO1xuICAgIH1cbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyA/IGlkZW50aWZpZXIgOiBERUZBVUxUX0VOVFJZX05BTUU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjsgLy8gYXNzdW1lIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgc3VwcG9ydGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEF1dG9Jbml0aWFsaXplKCkge1xuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlICE9PSBcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pO1xuICAgIH1cbn1cbi8vIHVuZGVmaW5lZCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IGluc3RhbmNlXG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XG59XG5mdW5jdGlvbiBpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxuICovXG5jbGFzcyBDb21wb25lbnRDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIFdoZW4gYSBjb21wb25lbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCxcbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgdHJ1ZTogb3ZlcndyaXRlIHRoZSBleGlzdGluZyBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGNvbXBvbmVudCBhbmQgY3JlYXRlIGEgbmV3XG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXG4gICAgICogZm9yIGRpZmZlcmVudCB0ZXN0cy5cbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgZmFsc2U6IHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAqL1xuICAgIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB3aXRoICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICBhZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgcHJvdmlkZXIgZnJvbSB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gcmVnaXN0ZXIgdGhlIG5ldyBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvdmlkZXIgcHJvdmlkZXMgYSB0eXBlIHNhZmUgaW50ZXJmYWNlIHdoZXJlIGl0IGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgZmllbGQgbmFtZVxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEZpcmViYXNlIFNES3MgcHJvdmlkaW5nIHNlcnZpY2VzIHNob3VsZCBleHRlbmQgTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZSB0byByZWdpc3RlclxuICAgICAqIHRoZW1zZWx2ZXMuXG4gICAgICovXG4gICAgZ2V0UHJvdmlkZXIobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKG5hbWUsIHRoaXMpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmFtZSwgcHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGdldFByb3ZpZGVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* binding */ LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   VectorValue: () => (/* binding */ VectorValue),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* binding */ AutoId),\n/* harmony export */   _ByteString: () => (/* binding */ ByteString),\n/* harmony export */   _DatabaseId: () => (/* binding */ DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* binding */ DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* binding */ FieldPath$1),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* binding */ cast),\n/* harmony export */   _debugAssert: () => (/* binding */ debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* binding */ _internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* binding */ _internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* binding */ isBase64Available),\n/* harmony export */   _logWarn: () => (/* binding */ logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   disableNetwork: () => (/* binding */ disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* binding */ enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* binding */ loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* binding */ namedQuery),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   vector: () => (/* binding */ vector),\n/* harmony export */   waitForPendingWrites: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"4.7.8\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nclass User {\n    constructor(uid) {\n        this.uid = uid;\n    }\n    isAuthenticated() {\n        return this.uid != null;\n    }\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    toKey() {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    }\n    isEqual(otherUser) {\n        return otherUser.uid === this.uid;\n    }\n}\n/** A user with a null UID. */\nUser.UNAUTHENTICATED = new User(null);\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\nUser.FIRST_PARTY = new User('first-party-uid');\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"11.3.1\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet SDK_VERSION = version;\nfunction setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Formats an object as a JSON string, suitable for logging. */\nfunction formatJSON(value) {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    return logClient.logLevel;\n}\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nfunction setLogLevel(logLevel) {\n    logClient.setLogLevel(logLevel);\n}\nfunction logDebug(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n        const args = obj.map(argToString);\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction logError(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\n        const args = obj.map(argToString);\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * @internal\n */\nfunction logWarn(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\n        const args = obj.map(argToString);\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction fail(failure = 'Unexpected state') {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\n    logError(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n */\nfunction hardAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n *\n * @internal\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nfunction debugCast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    return obj;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller cannot be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/** An error returned by a Firestore operation. */\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\n    /** @hideconstructor */\n    constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    code, \n    /**\n     * A custom error description.\n     */\n    message) {\n        super(code, message);\n        this.code = code;\n        this.message = message;\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass OAuthToken {\n    constructor(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.headers = new Map();\n        this.headers.set('Authorization', `Bearer ${value}`);\n    }\n}\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nclass EmptyAuthCredentialsProvider {\n    getToken() {\n        return Promise.resolve(null);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\n    }\n    shutdown() { }\n}\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nclass EmulatorAuthCredentialsProvider {\n    constructor(token) {\n        this.token = token;\n        /**\n         * Stores the listener registered with setChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.changeListener = null;\n    }\n    getToken() {\n        return Promise.resolve(this.token);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        this.changeListener = changeListener;\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\n    }\n    shutdown() {\n        this.changeListener = null;\n    }\n}\nclass FirebaseAuthCredentialsProvider {\n    constructor(authProvider) {\n        this.authProvider = authProvider;\n        /** Tracks the current User. */\n        this.currentUser = User.UNAUTHENTICATED;\n        /**\n         * Counter used to detect if the token changed while a getToken request was\n         * outstanding.\n         */\n        this.tokenCounter = 0;\n        this.forceRefresh = false;\n        this.auth = null;\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        let lastTokenId = this.tokenCounter;\n        // A change listener that prevents double-firing for the same token change.\n        const guardedChangeListener = user => {\n            if (this.tokenCounter !== lastTokenId) {\n                lastTokenId = this.tokenCounter;\n                return changeListener(user);\n            }\n            else {\n                return Promise.resolve();\n            }\n        };\n        // A promise that can be waited on to block on the next token change.\n        // This promise is re-created after each change.\n        let nextToken = new Deferred();\n        this.tokenListener = () => {\n            this.tokenCounter++;\n            this.currentUser = this.getUser();\n            nextToken.resolve();\n            nextToken = new Deferred();\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\n        };\n        const awaitNextToken = () => {\n            const currentTokenAttempt = nextToken;\n            asyncQueue.enqueueRetryable(async () => {\n                await currentTokenAttempt.promise;\n                await guardedChangeListener(this.currentUser);\n            });\n        };\n        const registerAuth = (auth) => {\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\n            this.auth = auth;\n            if (this.tokenListener) {\n                this.auth.addAuthTokenListener(this.tokenListener);\n                awaitNextToken();\n            }\n        };\n        this.authProvider.onInit(auth => registerAuth(auth));\n        // Our users can initialize Auth right after Firestore, so we give it\n        // a chance to register itself with the component framework before we\n        // determine whether to start up in unauthenticated mode.\n        setTimeout(() => {\n            if (!this.auth) {\n                const auth = this.authProvider.getImmediate({ optional: true });\n                if (auth) {\n                    registerAuth(auth);\n                }\n                else {\n                    // If auth is still not available, proceed with `null` user\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\n                    nextToken.resolve();\n                    nextToken = new Deferred();\n                }\n            }\n        }, 0);\n        awaitNextToken();\n    }\n    getToken() {\n        // Take note of the current value of the tokenCounter so that this method\n        // can fail (with an ABORTED error) if there is a token change while the\n        // request is outstanding.\n        const initialTokenCounter = this.tokenCounter;\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.auth) {\n            return Promise.resolve(null);\n        }\n        return this.auth.getToken(forceRefresh).then(tokenData => {\n            // Cancel the request since the token changed while the request was\n            // outstanding so the response is potentially for a previous user (which\n            // user, we can't be sure).\n            if (this.tokenCounter !== initialTokenCounter) {\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\n                return this.getToken();\n            }\n            else {\n                if (tokenData) {\n                    hardAssert(typeof tokenData.accessToken === 'string');\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.auth && this.tokenListener) {\n            this.auth.removeAuthTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n    // Auth.getUid() can return null even with a user logged in. It is because\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n    // This method should only be called in the AuthTokenListener callback\n    // to guarantee to get the actual user.\n    getUser() {\n        const currentUid = this.auth && this.auth.getUid();\n        hardAssert(currentUid === null || typeof currentUid === 'string');\n        return new User(currentUid);\n    }\n}\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nclass FirstPartyToken {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        this._headers = new Map();\n    }\n    /**\n     * Gets an authorization token, using a provided factory function, or return\n     * null.\n     */\n    getAuthToken() {\n        if (this.authTokenFactory) {\n            return this.authTokenFactory();\n        }\n        else {\n            return null;\n        }\n    }\n    get headers() {\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\n        // Use array notation to prevent minification\n        const authHeaderTokenValue = this.getAuthToken();\n        if (authHeaderTokenValue) {\n            this._headers.set('Authorization', authHeaderTokenValue);\n        }\n        if (this.iamToken) {\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\n        }\n        return this._headers;\n    }\n}\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nclass FirstPartyAuthCredentialsProvider {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n    }\n    getToken() {\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\n    }\n    start(asyncQueue, changeListener) {\n        // Fire with initial uid.\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\n    }\n    shutdown() { }\n    invalidateToken() { }\n}\nclass AppCheckToken {\n    constructor(value) {\n        this.value = value;\n        this.type = 'AppCheck';\n        this.headers = new Map();\n        if (value && value.length > 0) {\n            this.headers.set('x-firebase-appcheck', this.value);\n        }\n    }\n}\nclass FirebaseAppCheckTokenProvider {\n    constructor(app, appCheckProvider) {\n        this.appCheckProvider = appCheckProvider;\n        this.forceRefresh = false;\n        this.appCheck = null;\n        this.latestAppCheckToken = null;\n        this.serverAppAppCheckToken = null;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(app) && app.settings.appCheckToken) {\n            this.serverAppAppCheckToken = app.settings.appCheckToken;\n        }\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        const onTokenChanged = tokenResult => {\n            if (tokenResult.error != null) {\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\n            }\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\n            this.latestAppCheckToken = tokenResult.token;\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\n            return tokenUpdated\n                ? changeListener(tokenResult.token)\n                : Promise.resolve();\n        };\n        this.tokenListener = (tokenResult) => {\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\n        };\n        const registerAppCheck = (appCheck) => {\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\n            this.appCheck = appCheck;\n            if (this.tokenListener) {\n                this.appCheck.addTokenListener(this.tokenListener);\n            }\n        };\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\n        // Our users can initialize AppCheck after Firestore, so we give it\n        // a chance to register itself with the component framework.\n        setTimeout(() => {\n            if (!this.appCheck) {\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\n                if (appCheck) {\n                    registerAppCheck(appCheck);\n                }\n                else {\n                    // If AppCheck is still not available, proceed without it.\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\n                }\n            }\n        }, 0);\n    }\n    getToken() {\n        if (this.serverAppAppCheckToken) {\n            return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));\n        }\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.appCheck) {\n            return Promise.resolve(null);\n        }\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\n            if (tokenResult) {\n                hardAssert(typeof tokenResult.token === 'string');\n                this.latestAppCheckToken = tokenResult.token;\n                return new AppCheckToken(tokenResult.token);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.appCheck && this.tokenListener) {\n            this.appCheck.removeTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n}\n/**\n * An AppCheck token provider that always yields an empty token.\n * @internal\n */\nclass EmptyAppCheckTokenProvider {\n    getToken() {\n        return Promise.resolve(new AppCheckToken(''));\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) { }\n    shutdown() { }\n}\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeAuthCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyAuthCredentialsProvider();\n    }\n    switch (credentials['type']) {\n        case 'firstParty':\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\n        case 'provider':\n            return credentials['client'];\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nfunction randomBytes(nBytes) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A utility class for generating unique alphanumeric IDs of a specified length.\n *\n * @internal\n * Exported internally for testing purposes.\n */\nclass AutoId {\n    static newId() {\n        // Alphanumeric characters\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        // The largest byte value that is a multiple of `char.length`.\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n        let autoId = '';\n        const targetLength = 20;\n        while (autoId.length < targetLength) {\n            const bytes = randomBytes(40);\n            for (let i = 0; i < bytes.length; ++i) {\n                // Only accept values that are [0, maxMultiple), this ensures they can\n                // be evenly mapped to indices of `chars` via a modulo operation.\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n                    autoId += chars.charAt(bytes[i] % chars.length);\n                }\n            }\n        }\n        return autoId;\n    }\n}\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/** Helper to compare arrays using isEqual(). */\nfunction arrayEquals(left, right, comparator) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    return left.every((value, index) => comparator(value, right[index]));\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @returns a new timestamp representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @param date - The date to initialize the `Timestamp` from.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @param milliseconds - Number of milliseconds since Unix epoch\n     *     1970-01-01T00:00:00Z.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Creates a new timestamp.\n     *\n     * @param seconds - The number of seconds of UTC time since Unix epoch\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     *     9999-12-31T23:59:59Z inclusive.\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\n     *     resolution. Negative second values with fractions must still have\n     *     non-negative nanoseconds values that count forward in time. Must be\n     *     from 0 to 999,999,999 inclusive.\n     */\n    constructor(\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    seconds, \n    /**\n     * The fractions of a second at nanosecond resolution.*\n     */\n    nanoseconds) {\n        this.seconds = seconds;\n        this.nanoseconds = nanoseconds;\n        if (nanoseconds < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (nanoseconds >= 1e9) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (seconds < MIN_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n        // This will break in the year 10,000.\n        if (seconds >= 253402300800) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n     * causes a loss of precision since `Date` objects only support millisecond\n     * precision.\n     *\n     * @returns JavaScript `Date` object representing the same point in time as\n     *     this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this.toMillis());\n    }\n    /**\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n     * epoch). This operation causes a loss of precision.\n     *\n     * @returns The point in time corresponding to this timestamp, represented as\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n    }\n    _compareTo(other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    }\n    /**\n     * Returns true if this `Timestamp` is equal to the provided one.\n     *\n     * @param other - The `Timestamp` to compare against.\n     * @returns true if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\n    }\n    /** Returns a textual representation of this `Timestamp`. */\n    toString() {\n        return ('Timestamp(seconds=' +\n            this.seconds +\n            ', nanoseconds=' +\n            this.nanoseconds +\n            ')');\n    }\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\n    toJSON() {\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\n    }\n    /**\n     * Converts this object to a primitive string, which allows `Timestamp` objects\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where\n        // <seconds> is translated to have a non-negative value and both <seconds>\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n        // Strings with this format then have a lexicographical ordering that matches\n        // the expected ordering. The <seconds> translation is done to avoid having\n        // a leading negative sign (i.e. a leading '-' character) in its string\n        // representation, which would affect its lexicographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid\n        // 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nclass SnapshotVersion {\n    static fromTimestamp(value) {\n        return new SnapshotVersion(value);\n    }\n    static min() {\n        return new SnapshotVersion(new Timestamp(0, 0));\n    }\n    static max() {\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n    }\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n    }\n    compareTo(other) {\n        return this.timestamp._compareTo(other.timestamp);\n    }\n    isEqual(other) {\n        return this.timestamp.isEqual(other.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */\n    toMicroseconds() {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n    }\n    toString() {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    }\n    toTimestamp() {\n        return this.timestamp;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nclass BasePath {\n    constructor(segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail();\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail();\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    }\n    get length() {\n        return this.len;\n    }\n    isEqual(other) {\n        return BasePath.comparator(this, other) === 0;\n    }\n    child(nameOrPath) {\n        const segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof BasePath) {\n            nameOrPath.forEach(segment => {\n                segments.push(segment);\n            });\n        }\n        else {\n            segments.push(nameOrPath);\n        }\n        return this.construct(segments);\n    }\n    /** The index of one past the last segment of the path. */\n    limit() {\n        return this.offset + this.length;\n    }\n    popFirst(size) {\n        size = size === undefined ? 1 : size;\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    }\n    popLast() {\n        return this.construct(this.segments, this.offset, this.length - 1);\n    }\n    firstSegment() {\n        return this.segments[this.offset];\n    }\n    lastSegment() {\n        return this.get(this.length - 1);\n    }\n    get(index) {\n        return this.segments[this.offset + index];\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    isPrefixOf(other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isImmediateParentOf(potentialChild) {\n        if (this.length + 1 !== potentialChild.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== potentialChild.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    forEach(fn) {\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    }\n    toArray() {\n        return this.segments.slice(this.offset, this.limit());\n    }\n    /**\n     * Compare 2 paths segment by segment, prioritizing numeric IDs\n     * (e.g., \"__id123__\") in numeric ascending order, followed by string\n     * segments in lexicographical order.\n     */\n    static comparator(p1, p2) {\n        const len = Math.min(p1.length, p2.length);\n        for (let i = 0; i < len; i++) {\n            const comparison = BasePath.compareSegments(p1.get(i), p2.get(i));\n            if (comparison !== 0) {\n                return comparison;\n            }\n        }\n        return Math.sign(p1.length - p2.length);\n    }\n    static compareSegments(lhs, rhs) {\n        const isLhsNumeric = BasePath.isNumericId(lhs);\n        const isRhsNumeric = BasePath.isNumericId(rhs);\n        if (isLhsNumeric && !isRhsNumeric) {\n            // Only lhs is numeric\n            return -1;\n        }\n        else if (!isLhsNumeric && isRhsNumeric) {\n            // Only rhs is numeric\n            return 1;\n        }\n        else if (isLhsNumeric && isRhsNumeric) {\n            // both numeric\n            return BasePath.extractNumericId(lhs).compare(BasePath.extractNumericId(rhs));\n        }\n        else {\n            // both non-numeric\n            if (lhs < rhs) {\n                return -1;\n            }\n            if (lhs > rhs) {\n                return 1;\n            }\n            return 0;\n        }\n    }\n    // Checks if a segment is a numeric ID (starts with \"__id\" and ends with \"__\").\n    static isNumericId(segment) {\n        return segment.startsWith('__id') && segment.endsWith('__');\n    }\n    static extractNumericId(segment) {\n        return _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromString(segment.substring(4, segment.length - 2));\n    }\n}\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nclass ResourcePath extends BasePath {\n    construct(segments, offset, length) {\n        return new ResourcePath(segments, offset, length);\n    }\n    canonicalString() {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns a string representation of this path\n     * where each path segment has been encoded with\n     * `encodeURIComponent`.\n     */\n    toUriEncodedString() {\n        return this.toArray().map(encodeURIComponent).join('/');\n    }\n    /**\n     * Creates a resource path from the given slash-delimited string. If multiple\n     * arguments are provided, all components are combined. Leading and trailing\n     * slashes from all components are ignored.\n     */\n    static fromString(...pathComponents) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        const segments = [];\n        for (const path of pathComponents) {\n            if (path.indexOf('//') >= 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\n            }\n            // Strip leading and trailing slashed.\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\n        }\n        return new ResourcePath(segments);\n    }\n    static emptyPath() {\n        return new ResourcePath([]);\n    }\n}\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nclass FieldPath$1 extends BasePath {\n    construct(segments, offset, length) {\n        return new FieldPath$1(segments, offset, length);\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    static isValidIdentifier(segment) {\n        return identifierRegExp.test(segment);\n    }\n    canonicalString() {\n        return this.toArray()\n            .map(str => {\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\n            if (!FieldPath$1.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    isKeyField() {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    }\n    /**\n     * The field designating the key of a document.\n     */\n    static keyField() {\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\n    }\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    static fromServerFormat(path) {\n        const segments = [];\n        let current = '';\n        let i = 0;\n        const addCurrentSegment = () => {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\n                    `with '.', end with '.', or contain '..'`);\n            }\n            segments.push(current);\n            current = '';\n        };\n        let inBackticks = false;\n        while (i < path.length) {\n            const c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                const next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath$1(segments);\n    }\n    static emptyPath() {\n        return new FieldPath$1([]);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nclass DocumentKey {\n    constructor(path) {\n        this.path = path;\n    }\n    static fromPath(path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    }\n    static fromName(name) {\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n    }\n    static empty() {\n        return new DocumentKey(ResourcePath.emptyPath());\n    }\n    get collectionGroup() {\n        return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */\n    hasCollectionId(collectionId) {\n        return (this.path.length >= 2 &&\n            this.path.get(this.path.length - 2) === collectionId);\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n    getCollectionGroup() {\n        return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */\n    getCollectionPath() {\n        return this.path.popLast();\n    }\n    isEqual(other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    }\n    toString() {\n        return this.path.toString();\n    }\n    static comparator(k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    }\n    static isDocumentKey(path) {\n        return path.length % 2 === 0;\n    }\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param segments - The segments of the path to the document\n     * @returns A new instance of DocumentKey\n     */\n    static fromSegments(segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The initial mutation batch id for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_LARGEST_BATCH_ID = -1;\n/**\n * The initial sequence number for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_SEQUENCE_NUMBER = 0;\n/**\n * An index definition for field indexes in Firestore.\n *\n * Every index is associated with a collection. The definition contains a list\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\n *\n * Unlike the backend, the SDK does not differentiate between collection or\n * collection group-scoped indices. Every index can be used for both single\n * collection and collection group queries.\n */\nclass FieldIndex {\n    constructor(\n    /**\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\n     * has not yet been persisted).\n     */\n    indexId, \n    /** The collection ID this index applies to. */\n    collectionGroup, \n    /** The field segments for this index. */\n    fields, \n    /** Shows how up-to-date the index is for the current user. */\n    indexState) {\n        this.indexId = indexId;\n        this.collectionGroup = collectionGroup;\n        this.fields = fields;\n        this.indexState = indexState;\n    }\n}\n/** An ID for an index that has not yet been added to persistence.  */\nFieldIndex.UNKNOWN_ID = -1;\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\nfunction fieldIndexGetArraySegment(fieldIndex) {\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\n}\n/** Returns all directional (ascending/descending) segments for this index. */\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\n}\n/**\n * Returns the order of the document key component for the given index.\n *\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\n */\nfunction fieldIndexGetKeyOrder(fieldIndex) {\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\n    return directionalSegments.length === 0\n        ? 0 /* IndexKind.ASCENDING */\n        : directionalSegments[directionalSegments.length - 1].kind;\n}\n/**\n * Compares indexes by collection group and segments. Ignores update time and\n * index ID.\n */\nfunction fieldIndexSemanticComparator(left, right) {\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    return primitiveComparator(left.fields.length, right.fields.length);\n}\n/** Returns a debug representation of the field index */\nfunction fieldIndexToString(fieldIndex) {\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\n}\n/** An index component consisting of field path and index type.  */\nclass IndexSegment {\n    constructor(\n    /** The field path of the component. */\n    fieldPath, \n    /** The fields sorting order. */\n    kind) {\n        this.fieldPath = fieldPath;\n        this.kind = kind;\n    }\n}\nfunction indexSegmentComparator(left, right) {\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.kind, right.kind);\n}\n/**\n * Stores the \"high water mark\" that indicates how updated the Index is for the\n * current user.\n */\nclass IndexState {\n    constructor(\n    /**\n     * Indicates when the index was last updated (relative to other indexes).\n     */\n    sequenceNumber, \n    /** The the latest indexed read time, document and batch id. */\n    offset) {\n        this.sequenceNumber = sequenceNumber;\n        this.offset = offset;\n    }\n    /** The state of an index that has not yet been backfilled. */\n    static empty() {\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\n    }\n}\n/**\n * Creates an offset that matches all documents with a read time higher than\n * `readTime`.\n */\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\n    // We want to create an offset that matches all documents with a read time\n    // greater than the provided read time. To do so, we technically need to\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\n    // all valid document IDs.\n    const successorSeconds = readTime.toTimestamp().seconds;\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\n        ? new Timestamp(successorSeconds + 1, 0)\n        : new Timestamp(successorSeconds, successorNanos));\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\n}\n/** Creates a new offset based on the provided document. */\nfunction newIndexOffsetFromDocument(document) {\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\n}\n/**\n * Stores the latest read time, document and batch ID that were processed for an\n * index.\n */\nclass IndexOffset {\n    constructor(\n    /**\n     * The latest read time version that has been indexed by Firestore for this\n     * field index.\n     */\n    readTime, \n    /**\n     * The key of the last document that was indexed for this query. Use\n     * `DocumentKey.empty()` if no document has been indexed.\n     */\n    documentKey, \n    /*\n     * The largest mutation batch id that's been processed by Firestore.\n     */\n    largestBatchId) {\n        this.readTime = readTime;\n        this.documentKey = documentKey;\n        this.largestBatchId = largestBatchId;\n    }\n    /** Returns an offset that sorts before all regular offsets. */\n    static min() {\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n    /** Returns an offset that sorts after all regular offsets. */\n    static max() {\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n}\nfunction indexOffsetComparator(left, right) {\n    let cmp = left.readTime.compareTo(right.readTime);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\n    'It might be necessary to refresh the browser tab.';\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nclass PersistenceTransaction {\n    constructor() {\n        this.onCommittedListeners = [];\n    }\n    addOnCommittedListener(listener) {\n        this.onCommittedListeners.push(listener);\n    }\n    raiseOnCommittedEvent() {\n        this.onCommittedListeners.forEach(listener => listener());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err - An error returned by a LocalStore operation.\n * @returns A Promise that resolves after we recovered, or the original error.\n */\nasync function ignoreIfPrimaryLeaseLoss(err) {\n    if (err.code === Code.FAILED_PRECONDITION &&\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\n    }\n    else {\n        throw err;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * PersistencePromise is essentially a re-implementation of Promise except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nclass PersistencePromise {\n    constructor(callback) {\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(value => {\n            this.isDone = true;\n            this.result = value;\n            if (this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                this.nextCallback(value);\n            }\n        }, error => {\n            this.isDone = true;\n            this.error = error;\n            if (this.catchCallback) {\n                this.catchCallback(error);\n            }\n        });\n    }\n    catch(fn) {\n        return this.next(undefined, fn);\n    }\n    next(nextFn, catchFn) {\n        if (this.callbackAttached) {\n            fail();\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise((resolve, reject) => {\n                this.nextCallback = (value) => {\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                this.catchCallback = (error) => {\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    }\n    toPromise() {\n        return new Promise((resolve, reject) => {\n            this.next(resolve, reject);\n        });\n    }\n    wrapUserFunction(fn) {\n        try {\n            const result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    }\n    wrapSuccess(nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(() => nextFn(value));\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T\n            return PersistencePromise.resolve(value);\n        }\n    }\n    wrapFailure(catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(() => catchFn(error));\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    }\n    static resolve(result) {\n        return new PersistencePromise((resolve, reject) => {\n            resolve(result);\n        });\n    }\n    static reject(error) {\n        return new PersistencePromise((resolve, reject) => {\n            reject(error);\n        });\n    }\n    static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all) {\n        return new PersistencePromise((resolve, reject) => {\n            let expectedCount = 0;\n            let resolvedCount = 0;\n            let done = false;\n            all.forEach(element => {\n                ++expectedCount;\n                element.next(() => {\n                    ++resolvedCount;\n                    if (done && resolvedCount === expectedCount) {\n                        resolve();\n                    }\n                }, err => reject(err));\n            });\n            done = true;\n            if (resolvedCount === expectedCount) {\n                resolve();\n            }\n        });\n    }\n    /**\n     * Given an array of predicate functions that asynchronously evaluate to a\n     * boolean, implements a short-circuiting `or` between the results. Predicates\n     * will be evaluated until one of them returns `true`, then stop. The final\n     * result will be whether any of them returned `true`.\n     */\n    static or(predicates) {\n        let p = PersistencePromise.resolve(false);\n        for (const predicate of predicates) {\n            p = p.next(isTrue => {\n                if (isTrue) {\n                    return PersistencePromise.resolve(isTrue);\n                }\n                else {\n                    return predicate();\n                }\n            });\n        }\n        return p;\n    }\n    static forEach(collection, f) {\n        const promises = [];\n        collection.forEach((r, s) => {\n            promises.push(f.call(this, r, s));\n        });\n        return this.waitFor(promises);\n    }\n    /**\n     * Concurrently map all array elements through asynchronous function.\n     */\n    static mapArray(array, f) {\n        return new PersistencePromise((resolve, reject) => {\n            const expectedCount = array.length;\n            const results = new Array(expectedCount);\n            let resolvedCount = 0;\n            for (let i = 0; i < expectedCount; i++) {\n                const current = i;\n                f(array[current]).next(result => {\n                    results[current] = result;\n                    ++resolvedCount;\n                    if (resolvedCount === expectedCount) {\n                        resolve(results);\n                    }\n                }, err => reject(err));\n            }\n        });\n    }\n    /**\n     * An alternative to recursive PersistencePromise calls, that avoids\n     * potential memory problems from unbounded chains of promises.\n     *\n     * The `action` will be called repeatedly while `condition` is true.\n     */\n    static doWhile(condition, action) {\n        return new PersistencePromise((resolve, reject) => {\n            const process = () => {\n                if (condition() === true) {\n                    action().next(() => {\n                        process();\n                    }, reject);\n                }\n                else {\n                    resolve();\n                }\n            };\n            process();\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// References to `window` are guarded by SimpleDb.isAvailable()\n/* eslint-disable no-restricted-globals */\nconst LOG_TAG$i = 'SimpleDb';\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nclass SimpleDbTransaction {\n    static open(db, action, mode, objectStoreNames) {\n        try {\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\n        }\n        catch (e) {\n            throw new IndexedDbTransactionError(action, e);\n        }\n    }\n    constructor(action, transaction) {\n        this.action = action;\n        this.transaction = transaction;\n        this.aborted = false;\n        /**\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\n         */\n        this.completionDeferred = new Deferred();\n        this.transaction.oncomplete = () => {\n            this.completionDeferred.resolve();\n        };\n        this.transaction.onabort = () => {\n            if (transaction.error) {\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\n            }\n            else {\n                this.completionDeferred.resolve();\n            }\n        };\n        this.transaction.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\n        };\n    }\n    get completionPromise() {\n        return this.completionDeferred.promise;\n    }\n    abort(error) {\n        if (error) {\n            this.completionDeferred.reject(error);\n        }\n        if (!this.aborted) {\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    }\n    maybeCommit() {\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\n        // speed up index DB processing if the event loop remains blocks.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const maybeV3IndexedDb = this.transaction;\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\n            maybeV3IndexedDb.commit();\n        }\n    }\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    store(storeName) {\n        const store = this.transaction.objectStore(storeName);\n        return new SimpleDbStore(store);\n    }\n}\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nclass SimpleDb {\n    /** Deletes the specified database. */\n    static delete(name) {\n        logDebug(LOG_TAG$i, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    }\n    /** Returns true if IndexedDB is available in the current environment. */\n    static isAvailable() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        if (SimpleDb.isMockPersistence()) {\n            return true;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        // iOS Safari: Disable for users running iOS version < 10.\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n        // Android browser: Disable for users running version < 4.5.\n        const androidVersion = getAndroidVersion(ua);\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0 ||\n            isUnsupportedIOS ||\n            isUnsupportedAndroid) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n     * (see https://github.com/axemclion/IndexedDBShim).\n     */\n    static isMockPersistence() {\n        var _a;\n        return (typeof process !== 'undefined' &&\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\n    }\n    /** Helper to get a typed SimpleDbStore from a transaction. */\n    static getStore(txn, store) {\n        return txn.store(store);\n    }\n    // visible for testing\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n    static getIOSVersion(ua) {\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n        const version = iOSVersionRegex\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\n            : '-1';\n        return Number(version);\n    }\n    /*\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\n     *\n     * Note that `version` must not be a downgrade. IndexedDB does not support\n     * downgrading the schema version. We currently do not support any way to do\n     * versioning outside of IndexedDB's versioning mechanism, as only\n     * version-upgrade transactions are allowed to do things like create\n     * objectstores.\n     */\n    constructor(name, version, schemaConverter) {\n        this.name = name;\n        this.version = version;\n        this.schemaConverter = schemaConverter;\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\n        // log on 12.2.\n        if (iOSVersion === 12.2) {\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\n                'Safari that may cause your app to stop working. See ' +\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\n                'and a potential workaround.');\n        }\n    }\n    /**\n     * Opens the specified database, creating or upgrading it if necessary.\n     */\n    async ensureDb(action) {\n        if (!this.db) {\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\n            this.db = await new Promise((resolve, reject) => {\n                // TODO(mikelehen): Investigate browser compatibility.\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n                // suggests IE9 and older WebKit browsers handle upgrade\n                // differently. They expect setVersion, as described here:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n                const request = indexedDB.open(this.name, this.version);\n                request.onsuccess = (event) => {\n                    const db = event.target.result;\n                    resolve(db);\n                };\n                request.onblocked = () => {\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\n                };\n                request.onerror = (event) => {\n                    const error = event.target.error;\n                    if (error.name === 'VersionError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                            'will operate with persistence disabled. If you need persistence, please ' +\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                            'data for your app to start fresh.'));\n                    }\n                    else if (error.name === 'InvalidStateError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\n                            'private browsing session on a browser whose private browsing sessions do not ' +\n                            'support IndexedDB: ' +\n                            error));\n                    }\n                    else {\n                        reject(new IndexedDbTransactionError(action, error));\n                    }\n                };\n                request.onupgradeneeded = (event) => {\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\n                    const db = event.target.result;\n                    this.schemaConverter\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\n                        .next(() => {\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\n                    });\n                };\n            });\n        }\n        if (this.versionchangelistener) {\n            this.db.onversionchange = event => this.versionchangelistener(event);\n        }\n        return this.db;\n    }\n    setVersionChangeListener(versionChangeListener) {\n        this.versionchangelistener = versionChangeListener;\n        if (this.db) {\n            this.db.onversionchange = (event) => {\n                return versionChangeListener(event);\n            };\n        }\n    }\n    async runTransaction(action, mode, objectStores, transactionFn) {\n        const readonly = mode === 'readonly';\n        let attemptNumber = 0;\n        while (true) {\n            ++attemptNumber;\n            try {\n                this.db = await this.ensureDb(action);\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\n                const transactionFnResult = transactionFn(transaction)\n                    .next(result => {\n                    transaction.maybeCommit();\n                    return result;\n                })\n                    .catch(error => {\n                    // Abort the transaction if there was an error.\n                    transaction.abort(error);\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\n                    // completion promise to be rejected. This in turn means that we won't use\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\n                    // possibility of returning `void` to the type of `transactionFnResult`.\n                    return PersistencePromise.reject(error);\n                })\n                    .toPromise();\n                // As noted above, errors are propagated by aborting the transaction. So\n                // we swallow any error here to avoid the browser logging it as unhandled.\n                transactionFnResult.catch(() => { });\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n                // fire), but still return the original transactionFnResult back to the\n                // caller.\n                await transaction.completionPromise;\n                return transactionFnResult;\n            }\n            catch (e) {\n                const error = e;\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\n                // not retry exceptions that are likely unrecoverable (such as quota\n                // exceeded errors).\n                // Note: We cannot use an instanceof check for FirestoreException, since the\n                // exception is wrapped in a generic error by our async/await handling.\n                const retryable = error.name !== 'FirebaseError' &&\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\n                this.close();\n                if (!retryable) {\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    close() {\n        if (this.db) {\n            this.db.close();\n        }\n        this.db = undefined;\n    }\n}\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\nfunction getAndroidVersion(ua) {\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n    const version = androidVersionRegex\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\n        : '-1';\n    return Number(version);\n}\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nclass IterationController {\n    constructor(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    get isDone() {\n        return this.shouldStop;\n    }\n    get skipToKey() {\n        return this.nextKey;\n    }\n    set cursor(value) {\n        this.dbCursor = value;\n    }\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    done() {\n        this.shouldStop = true;\n    }\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    skip(key) {\n        this.nextKey = key;\n    }\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    delete() {\n        return wrapRequest(this.dbCursor.delete());\n    }\n}\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nclass IndexedDbTransactionError extends FirestoreError {\n    constructor(actionName, cause) {\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\n        this.name = 'IndexedDbTransactionError';\n    }\n}\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nfunction isIndexedDbTransactionError(e) {\n    // Use name equality, as instanceof checks on errors don't work with errors\n    // that wrap other errors.\n    return e.name === 'IndexedDbTransactionError';\n}\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nclass SimpleDbStore {\n    constructor(store) {\n        this.store = store;\n    }\n    put(keyOrValue, value) {\n        let request;\n        if (value !== undefined) {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    }\n    /**\n     * Adds a new value into an Object Store and returns the new key. Similar to\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\n     *\n     * @param value - The object to write.\n     * @returns The key of the value to add.\n     */\n    add(value) {\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\n        const request = this.store.add(value);\n        return wrapRequest(request);\n    }\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @returns The object with the specified key or null if no object exists.\n     */\n    get(key) {\n        const request = this.store.get(key);\n        // We're doing an unsafe cast to ValueType.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return wrapRequest(request).next(result => {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\n            return result;\n        });\n    }\n    delete(key) {\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\n        const request = this.store.delete(key);\n        return wrapRequest(request);\n    }\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    count() {\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\n        const request = this.store.count();\n        return wrapRequest(request);\n    }\n    loadAll(indexOrRange, range) {\n        const iterateOptions = this.options(indexOrRange, range);\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\n        // 20% faster.\n        const store = iterateOptions.index\n            ? this.store.index(iterateOptions.index)\n            : this.store;\n        if (typeof store.getAll === 'function') {\n            const request = store.getAll(iterateOptions.range);\n            return new PersistencePromise((resolve, reject) => {\n                request.onerror = (event) => {\n                    reject(event.target.error);\n                };\n                request.onsuccess = (event) => {\n                    resolve(event.target.result);\n                };\n            });\n        }\n        else {\n            const cursor = this.cursor(iterateOptions);\n            const results = [];\n            return this.iterateCursor(cursor, (key, value) => {\n                results.push(value);\n            }).next(() => {\n                return results;\n            });\n        }\n    }\n    /**\n     * Loads the first `count` elements from the provided index range. Loads all\n     * elements if no limit is provided.\n     */\n    loadFirst(range, count) {\n        const request = this.store.getAll(range, count === null ? undefined : count);\n        return new PersistencePromise((resolve, reject) => {\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n        });\n    }\n    deleteAll(indexOrRange, range) {\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\n        const options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, (key, value, control) => {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    }\n    iterate(optionsOrCallback, callback) {\n        let options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    }\n    /**\n     * Iterates over a store, but waits for the given callback to complete for\n     * each entry before iterating the next entry. This allows the callback to do\n     * asynchronous work to determine if this iteration should continue.\n     *\n     * The provided callback should return `true` to continue iteration, and\n     * `false` otherwise.\n     */\n    iterateSerial(callback) {\n        const cursorRequest = this.cursor({});\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                const error = checkForAndReportiOSError(event.target.error);\n                reject(error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\n                    if (shouldContinue) {\n                        cursor.continue();\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            };\n        });\n    }\n    iterateCursor(cursorRequest, fn) {\n        const results = [];\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                const controller = new IterationController(cursor);\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    const userPromise = userResult.catch(err => {\n                        controller.done();\n                        return PersistencePromise.reject(err);\n                    });\n                    results.push(userPromise);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(() => PersistencePromise.waitFor(results));\n    }\n    options(indexOrRange, range) {\n        let indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range };\n    }\n    cursor(options) {\n        let direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            const index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    }\n}\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise((resolve, reject) => {\n        request.onsuccess = (event) => {\n            const result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            reject(error);\n        };\n    });\n}\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error) {\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\n            // Wrap error in a more descriptive one.\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n                `for details and a potential workaround.`);\n            if (!reportedIOSError) {\n                reportedIOSError = true;\n                // Throw a global exception outside of this promise chain, for the user to\n                // potentially catch.\n                setTimeout(() => {\n                    throw newError;\n                }, 0);\n            }\n            return newError;\n        }\n    }\n    return error;\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\n/** How long we wait to try running index backfill after SDK initialization. */\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\n/** Minimum amount of time between backfill checks, after the first one. */\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\n/** The maximum number of documents to process each time backfill() is called. */\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\n/** This class is responsible for the scheduling of Index Backfiller. */\nclass IndexBackfillerScheduler {\n    constructor(asyncQueue, backfiller) {\n        this.asyncQueue = asyncQueue;\n        this.backfiller = backfiller;\n        this.task = null;\n    }\n    start() {\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\n    }\n    stop() {\n        if (this.task) {\n            this.task.cancel();\n            this.task = null;\n        }\n    }\n    get started() {\n        return this.task !== null;\n    }\n    schedule(delay) {\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\n            this.task = null;\n            try {\n                const documentsProcessed = await this.backfiller.backfill();\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\n        });\n    }\n}\n/** Implements the steps for backfilling indexes. */\nclass IndexBackfiller {\n    constructor(\n    /**\n     * LocalStore provides access to IndexManager and LocalDocumentView.\n     * These properties will update when the user changes. Consequently,\n     * making a local copy of IndexManager and LocalDocumentView will require\n     * updates over time. The simpler solution is to rely on LocalStore to have\n     * an up-to-date references to IndexManager and LocalDocumentStore.\n     */\n    localStore, persistence) {\n        this.localStore = localStore;\n        this.persistence = persistence;\n    }\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\n    }\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\n    writeIndexEntries(transaction, maxDocumentsToProcess) {\n        const processedCollectionGroups = new Set();\n        let documentsRemaining = maxDocumentsToProcess;\n        let continueLoop = true;\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\n            return this.localStore.indexManager\n                .getNextCollectionGroupToUpdate(transaction)\n                .next((collectionGroup) => {\n                if (collectionGroup === null ||\n                    processedCollectionGroups.has(collectionGroup)) {\n                    continueLoop = false;\n                }\n                else {\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\n                    return this.writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemaining).next(documentsProcessed => {\n                        documentsRemaining -= documentsProcessed;\n                        processedCollectionGroups.add(collectionGroup);\n                    });\n                }\n            });\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\n    }\n    /**\n     * Writes entries for the provided collection group. Returns the number of documents processed.\n     */\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\n        // Use the earliest offset of all field indexes to query the local cache.\n        return this.localStore.indexManager\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\n            .next(existingOffset => this.localStore.localDocuments\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\n            .next(nextBatch => {\n            const docs = nextBatch.changes;\n            return this.localStore.indexManager\n                .updateIndexEntries(transaction, docs)\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\n                .next(newOffset => {\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\n            })\n                .next(() => docs.size);\n        }));\n    }\n    /** Returns the next offset based on the provided documents. */\n    getNewOffset(existingOffset, lookupResult) {\n        let maxOffset = existingOffset;\n        lookupResult.changes.forEach((key, document) => {\n            const newOffset = newIndexOffsetFromDocument(document);\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\n                maxOffset = newOffset;\n            }\n        });\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\n    }\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nclass ListenSequence {\n    constructor(previousValue, sequenceNumberSyncer) {\n        this.previousValue = previousValue;\n        if (sequenceNumberSyncer) {\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n        }\n    }\n    setPreviousValue(externalPreviousValue) {\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n        return this.previousValue;\n    }\n    next() {\n        const nextValue = ++this.previousValue;\n        if (this.writeNewSequenceNumber) {\n            this.writeNewSequenceNumber(nextValue);\n        }\n        return nextValue;\n    }\n}\nListenSequence.INVALID = -1;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encodeResourcePath(path) {\n    let result = '';\n    for (let i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    let result = resultBuf;\n    const length = segment.length;\n    for (let i = 0; i < length; i++) {\n        const c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decodeResourcePath(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    const length = path.length;\n    hardAssert(length >= 2);\n    if (length === 2) {\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\n        return ResourcePath.emptyPath();\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    const lastReasonableEscapeIndex = length - 2;\n    const segments = [];\n    let segmentBuilder = '';\n    for (let start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        const end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail();\n        }\n        const next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                const currentPiece = path.substring(start, end);\n                let segment;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail();\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Name of the IndexedDb object store.\n *\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\n * older clients that only supported single locked access to the persistence\n * layer.\n */\nconst DbPrimaryClientStore = 'owner';\n/**\n * The key string used for the single object that exists in the\n * DbPrimaryClient store.\n */\nconst DbPrimaryClientKey = 'owner';\n/** Name of the IndexedDb object store.  */\nconst DbMutationQueueStore = 'mutationQueues';\n/** Keys are automatically assigned via the userId property. */\nconst DbMutationQueueKeyPath = 'userId';\n/** Name of the IndexedDb object store.  */\nconst DbMutationBatchStore = 'mutations';\n/** Keys are automatically assigned via the userId, batchId properties. */\nconst DbMutationBatchKeyPath = 'batchId';\n/** The index name for lookup of mutations by user. */\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\n/** The user mutations index is keyed by [userId, batchId] pairs. */\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\n/**\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n * over all of a user's document mutations.\n */\nfunction newDbDocumentMutationPrefixForUser(userId) {\n    return [userId];\n}\n/**\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n * index to iterate over all at document mutations for a given path or lower.\n */\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\n    return [userId, encodeResourcePath(path)];\n}\n/**\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\n * and deleting into the DbDocumentMutations index.\n */\nfunction newDbDocumentMutationKey(userId, path, batchId) {\n    return [userId, encodeResourcePath(path), batchId];\n}\n/**\n * Because we store all the useful information for this store in the key,\n * there is no useful information to store as the value. The raw (unencoded)\n * path cannot be stored because IndexedDb doesn't store prototype\n * information.\n */\nconst DbDocumentMutationPlaceholder = {};\nconst DbDocumentMutationStore = 'documentMutations';\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\n/**\n * The primary key of the remote documents store, which allows for efficient\n * access by collection path and read time.\n */\nconst DbRemoteDocumentKeyPath = [\n    'prefixPath',\n    'collectionGroup',\n    'readTime',\n    'documentId'\n];\n/** An index that provides access to documents by key. */\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\nconst DbRemoteDocumentDocumentKeyIndexPath = [\n    'prefixPath',\n    'collectionGroup',\n    'documentId'\n];\n/**\n * An index that provides access to documents by collection group and read\n * time.\n *\n * This index is used by the index backfiller.\n */\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\nconst DbRemoteDocumentCollectionGroupIndexPath = [\n    'collectionGroup',\n    'readTime',\n    'prefixPath',\n    'documentId'\n];\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\nconst DbTargetStore = 'targets';\n/** Keys are automatically assigned via the targetId property. */\nconst DbTargetKeyPath = 'targetId';\n/** The name of the queryTargets index. */\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\n/**\n * The index of all canonicalIds to the targets that they match. This is not\n * a unique mapping because canonicalId does not promise a unique name for all\n * possible queries, so we append the targetId to make the mapping unique.\n */\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\n/** Name of the IndexedDb object store.  */\nconst DbTargetDocumentStore = 'targetDocuments';\n/** Keys are automatically assigned via the targetId, path properties. */\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\n/** The index name for the reverse index. */\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\n/** We also need to create the reverse index for these properties. */\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\n/**\n * The key string used for the single object that exists in the\n * DbTargetGlobal store.\n */\nconst DbTargetGlobalKey = 'targetGlobalKey';\nconst DbTargetGlobalStore = 'targetGlobal';\n/** Name of the IndexedDb object store. */\nconst DbCollectionParentStore = 'collectionParents';\n/** Keys are automatically assigned via the collectionId, parent properties. */\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\n/** Name of the IndexedDb object store. */\nconst DbClientMetadataStore = 'clientMetadata';\n/** Keys are automatically assigned via the clientId properties. */\nconst DbClientMetadataKeyPath = 'clientId';\n/** Name of the IndexedDb object store. */\nconst DbBundleStore = 'bundles';\nconst DbBundleKeyPath = 'bundleId';\n/** Name of the IndexedDb object store. */\nconst DbNamedQueryStore = 'namedQueries';\nconst DbNamedQueryKeyPath = 'name';\n/** Name of the IndexedDb object store. */\nconst DbIndexConfigurationStore = 'indexConfiguration';\nconst DbIndexConfigurationKeyPath = 'indexId';\n/**\n * An index that provides access to the index configurations by collection\n * group.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\n/** Name of the IndexedDb object store. */\nconst DbIndexStateStore = 'indexState';\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\n/**\n * An index that provides access to documents in a collection sorted by last\n * update time. Used by the backfiller.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\n/** Name of the IndexedDb object store. */\nconst DbIndexEntryStore = 'indexEntries';\nconst DbIndexEntryKeyPath = [\n    'indexId',\n    'uid',\n    'arrayValue',\n    'directionalValue',\n    'orderedDocumentKey',\n    'documentKey'\n];\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\nconst DbIndexEntryDocumentKeyIndexPath = [\n    'indexId',\n    'uid',\n    'orderedDocumentKey'\n];\n/** Name of the IndexedDb object store. */\nconst DbDocumentOverlayStore = 'documentOverlays';\nconst DbDocumentOverlayKeyPath = [\n    'userId',\n    'collectionPath',\n    'documentId'\n];\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\n    'userId',\n    'collectionPath',\n    'largestBatchId'\n];\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\n    'userId',\n    'collectionGroup',\n    'largestBatchId'\n];\n/** Name of the IndexedDb object store. */\nconst DbGlobalsStore = 'globals';\nconst DbGlobalsKeyPath = 'name';\n// Visible for testing\nconst V1_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore$1,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore\n];\n// Visible for testing\nconst V3_STORES = V1_STORES;\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\nconst V13_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore,\n    DbClientMetadataStore,\n    DbRemoteDocumentGlobalStore,\n    DbCollectionParentStore,\n    DbBundleStore,\n    DbNamedQueryStore,\n    DbDocumentOverlayStore\n];\nconst V14_STORES = V13_STORES;\nconst V15_STORES = [\n    ...V14_STORES,\n    DbIndexConfigurationStore,\n    DbIndexStateStore,\n    DbIndexEntryStore\n];\nconst V16_STORES = V15_STORES;\nconst V17_STORES = [...V15_STORES, DbGlobalsStore];\n/** Returns the object stores for the provided schema. */\nfunction getObjectStores(schemaVersion) {\n    if (schemaVersion === 17) {\n        return V17_STORES;\n    }\n    else if (schemaVersion === 16) {\n        return V16_STORES;\n    }\n    else if (schemaVersion === 15) {\n        return V15_STORES;\n    }\n    else if (schemaVersion === 14) {\n        return V14_STORES;\n    }\n    else if (schemaVersion === 13) {\n        return V13_STORES;\n    }\n    else if (schemaVersion === 12) {\n        return V12_STORES;\n    }\n    else if (schemaVersion === 11) {\n        return V11_STORES;\n    }\n    else {\n        fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTransaction extends PersistenceTransaction {\n    constructor(simpleDbTransaction, currentSequenceNumber) {\n        super();\n        this.simpleDbTransaction = simpleDbTransaction;\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nfunction getStore(txn, store) {\n    const indexedDbTransaction = debugCast(txn);\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction objectSize(obj) {\n    let count = 0;\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction forEach(obj, fn) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction mapToArray(obj, fn) {\n    const result = [];\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result.push(fn(obj[key], key, obj));\n        }\n    }\n    return result;\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nclass SortedMap {\n    constructor(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    insert(key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n    remove(key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n    get(key) {\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    indexOf(key) {\n        // Number of nodes that were pruned when descending right\n        let prunedNodes = 0;\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    }\n    isEmpty() {\n        return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n    get size() {\n        return this.root.size;\n    }\n    // Returns the minimum key in the map.\n    minKey() {\n        return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n    maxKey() {\n        return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.root.inorderTraversal(action);\n    }\n    forEach(fn) {\n        this.inorderTraversal((k, v) => {\n            fn(k, v);\n            return false;\n        });\n    }\n    toString() {\n        const descriptions = [];\n        this.inorderTraversal((k, v) => {\n            descriptions.push(`${k}:${v}`);\n            return false;\n        });\n        return `{${descriptions.join(', ')}}`;\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.root.reverseTraversal(action);\n    }\n    // Returns an iterator over the SortedMap.\n    getIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    }\n    getIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    }\n    getReverseIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    }\n    getReverseIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    }\n} // end SortedMap\n// An iterator over an LLRBNode.\nclass SortedMapIterator {\n    constructor(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        let cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (startKey && isReverse) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        let node = this.nodeStack.pop();\n        const result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack.length > 0;\n    }\n    peek() {\n        if (this.nodeStack.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    }\n} // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nclass LLRBNode {\n    constructor(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    isEmpty() {\n        return false;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    }\n    // Returns the minimum node in the tree.\n    min() {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    }\n    // Returns the maximum key in the tree.\n    minKey() {\n        return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n    maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    }\n    // Returns new tree, with the key/value added.\n    insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    }\n    removeMin() {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        let n = this;\n        if (!n.left.isRed() && !n.left.left.isRed()) {\n            n = n.moveRedLeft();\n        }\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n    remove(key, comparator) {\n        let smallest;\n        let n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed()) {\n                n = n.rotateRight();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    }\n    isRed() {\n        return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n    fixUp() {\n        let n = this;\n        if (n.right.isRed() && !n.left.isRed()) {\n            n = n.rotateLeft();\n        }\n        if (n.left.isRed() && n.left.left.isRed()) {\n            n = n.rotateRight();\n        }\n        if (n.left.isRed() && n.right.isRed()) {\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedLeft() {\n        let n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedRight() {\n        let n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    rotateLeft() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    rotateRight() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    colorFlip() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    // For testing.\n    checkMaxDepth() {\n        const blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    check() {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail();\n        }\n        if (this.right.isRed()) {\n            throw fail();\n        }\n        const blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail();\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    }\n} // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nLLRBNode.EMPTY = null;\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n// Represents an empty node (a leaf node in the Red-Black Tree).\nclass LLRBEmptyNode {\n    constructor() {\n        this.size = 0;\n    }\n    get key() {\n        throw fail();\n    }\n    get value() {\n        throw fail();\n    }\n    get color() {\n        throw fail();\n    }\n    get left() {\n        throw fail();\n    }\n    get right() {\n        throw fail();\n    }\n    // Returns a copy of the current node.\n    copy(key, value, color, left, right) {\n        return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n    insert(key, value, comparator) {\n        return new LLRBNode(key, value);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n    remove(key, comparator) {\n        return this;\n    }\n    isEmpty() {\n        return true;\n    }\n    inorderTraversal(action) {\n        return false;\n    }\n    reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    isRed() {\n        return false;\n    }\n    // For testing.\n    checkMaxDepth() {\n        return true;\n    }\n    check() {\n        return 0;\n    }\n} // end LLRBEmptyNode\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nclass SortedSet {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    has(elem) {\n        return this.data.get(elem) !== null;\n    }\n    first() {\n        return this.data.minKey();\n    }\n    last() {\n        return this.data.maxKey();\n    }\n    get size() {\n        return this.data.size;\n    }\n    indexOf(elem) {\n        return this.data.indexOf(elem);\n    }\n    /** Iterates elements in order defined by \"comparator\" */\n    forEach(cb) {\n        this.data.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n    forEachInRange(range, cb) {\n        const iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0) {\n                return;\n            }\n            cb(elem.key);\n        }\n    }\n    /**\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n     */\n    forEachWhile(cb, start) {\n        let iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            const result = cb(elem.key);\n            if (!result) {\n                return;\n            }\n        }\n    }\n    /** Finds the least element greater than or equal to `elem`. */\n    firstAfterOrEqual(elem) {\n        const iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    }\n    getIterator() {\n        return new SortedSetIterator(this.data.getIterator());\n    }\n    getIteratorFrom(key) {\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\n    }\n    /** Inserts or updates an element */\n    add(elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    }\n    /** Deletes an element */\n    delete(elem) {\n        if (!this.has(elem)) {\n            return this;\n        }\n        return this.copy(this.data.remove(elem));\n    }\n    isEmpty() {\n        return this.data.isEmpty();\n    }\n    unionWith(other) {\n        let result = this;\n        // Make sure `result` always refers to the larger one of the two sets.\n        if (result.size < other.size) {\n            result = other;\n            other = this;\n        }\n        other.forEach(elem => {\n            result = result.add(elem);\n        });\n        return result;\n    }\n    isEqual(other) {\n        if (!(other instanceof SortedSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.data.getIterator();\n        const otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            const thisElem = thisIt.getNext().key;\n            const otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toArray() {\n        const res = [];\n        this.forEach(targetId => {\n            res.push(targetId);\n        });\n        return res;\n    }\n    toString() {\n        const result = [];\n        this.forEach(elem => result.push(elem));\n        return 'SortedSet(' + result.toString() + ')';\n    }\n    copy(data) {\n        const result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    }\n}\nclass SortedSetIterator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    getNext() {\n        return this.iter.getNext().key;\n    }\n    hasNext() {\n        return this.iter.hasNext();\n    }\n}\n/**\n * Compares two sorted sets for equality using their natural ordering. The\n * method computes the intersection and invokes `onAdd` for every element that\n * is in `after` but not `before`. `onRemove` is invoked for every element in\n * `before` but missing from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original set.\n * @param after - The elements to diff against the original set.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\n    const beforeIt = before.getIterator();\n    const afterIt = after.getIterator();\n    let beforeValue = advanceIterator(beforeIt);\n    let afterValue = advanceIterator(afterIt);\n    // Walk through the two sets at the same time, using the ordering defined by\n    // `comparator`.\n    while (beforeValue || afterValue) {\n        let added = false;\n        let removed = false;\n        if (beforeValue && afterValue) {\n            const cmp = comparator(beforeValue, afterValue);\n            if (cmp < 0) {\n                // The element was removed if the next element in our ordered\n                // walkthrough is only in `before`.\n                removed = true;\n            }\n            else if (cmp > 0) {\n                // The element was added if the next element in our ordered walkthrough\n                // is only in `after`.\n                added = true;\n            }\n        }\n        else if (beforeValue != null) {\n            removed = true;\n        }\n        else {\n            added = true;\n        }\n        if (added) {\n            onAdd(afterValue);\n            afterValue = advanceIterator(afterIt);\n        }\n        else if (removed) {\n            onRemove(beforeValue);\n            beforeValue = advanceIterator(beforeIt);\n        }\n        else {\n            beforeValue = advanceIterator(beforeIt);\n            afterValue = advanceIterator(afterIt);\n        }\n    }\n}\n/**\n * Returns the next element from the iterator or `undefined` if none available.\n */\nfunction advanceIterator(it) {\n    return it.hasNext() ? it.getNext() : undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nclass FieldMask {\n    constructor(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n        fields.sort(FieldPath$1.comparator);\n    }\n    static empty() {\n        return new FieldMask([]);\n    }\n    /**\n     * Returns a new FieldMask object that is the result of adding all the given\n     * fields paths to this field mask.\n     */\n    unionWith(extraFields) {\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\n        for (const fieldPath of this.fields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        for (const fieldPath of extraFields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        return new FieldMask(mergedMaskSet.toArray());\n    }\n    /**\n     * Verifies that `fieldPath` is included by at least one field in this field\n     * mask.\n     *\n     * This is an O(n) operation, where `n` is the size of the field mask.\n     */\n    covers(fieldPath) {\n        for (const fieldMaskPath of this.fields) {\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isEqual(other) {\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Note: We used to validate the base64 string here via a regular expression.\n    // This was removed to improve the performance of indexing.\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n/** Converts a binary string to a Base64 encoded string. */\nfunction encodeBase64(raw) {\n    return Buffer.from(raw, 'binary').toString('base64');\n}\n/** True if and only if the Base64 conversion functions are available. */\nfunction isBase64Available() {\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nclass ByteString {\n    constructor(binaryString) {\n        this.binaryString = binaryString;\n    }\n    static fromBase64String(base64) {\n        const binaryString = decodeBase64(base64);\n        return new ByteString(binaryString);\n    }\n    static fromUint8Array(array) {\n        // TODO(indexing); Remove the copy of the byte string here as this method\n        // is frequently called during indexing.\n        const binaryString = binaryStringFromUint8Array(array);\n        return new ByteString(binaryString);\n    }\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: () => {\n                if (i < this.binaryString.length) {\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n    toBase64() {\n        return encodeBase64(this.binaryString);\n    }\n    toUint8Array() {\n        return uint8ArrayFromBinaryString(this.binaryString);\n    }\n    approximateByteSize() {\n        return this.binaryString.length * 2;\n    }\n    compareTo(other) {\n        return primitiveComparator(this.binaryString, other.binaryString);\n    }\n    isEqual(other) {\n        return this.binaryString === other.binaryString;\n    }\n}\nByteString.EMPTY_BYTE_STRING = new ByteString('');\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nfunction binaryStringFromUint8Array(array) {\n    let binaryString = '';\n    for (let i = 0; i < array.length; ++i) {\n        binaryString += String.fromCharCode(array[i]);\n    }\n    return binaryString;\n}\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nfunction uint8ArrayFromBinaryString(binaryString) {\n    const buffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        buffer[i] = binaryString.charCodeAt(i);\n    }\n    return buffer;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nfunction normalizeTimestamp(date) {\n    hardAssert(!!date);\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        let nanos = 0;\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n        hardAssert(!!fraction);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            let nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        const parsedDate = new Date(date);\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\n        return { seconds, nanos };\n    }\n    else {\n        // TODO(b/37282237): Use strings for Proto3 timestamps\n        // assert(!this.options.useProto3Json,\n        //   'The timestamp instance format requires Proto JS.');\n        const seconds = normalizeNumber(date.seconds);\n        const nanos = normalizeNumber(date.nanos);\n        return { seconds, nanos };\n    }\n}\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nfunction normalizeNumber(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return 0;\n    }\n}\n/** Converts the possible Proto types for Blobs into a ByteString. */\nfunction normalizeByteString(blob) {\n    if (typeof blob === 'string') {\n        return ByteString.fromBase64String(blob);\n    }\n    else {\n        return ByteString.fromUint8Array(blob);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY$1 = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\nfunction isServerTimestamp(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY$1]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === SERVER_TIMESTAMP_SENTINEL;\n}\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nfunction serverTimestamp$1(localWriteTime, previousValue) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY$1]: {\n                stringValue: SERVER_TIMESTAMP_SENTINEL\n            },\n            [LOCAL_WRITE_TIME_KEY]: {\n                timestampValue: {\n                    seconds: localWriteTime.seconds,\n                    nanos: localWriteTime.nanoseconds\n                }\n            }\n        }\n    };\n    // We should avoid storing deeply nested server timestamp map values\n    // because we never use the intermediate \"previous values\".\n    // For example:\n    // previous: 42L, add: t1, result: t1 -> 42L\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\n    // `getPreviousValue` recursively traverses server timestamps to find the\n    // least recent Value.\n    if (previousValue && isServerTimestamp(previousValue)) {\n        previousValue = getPreviousValue(previousValue);\n    }\n    if (previousValue) {\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\n    }\n    return { mapValue };\n}\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nfunction getPreviousValue(value) {\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\n    if (isServerTimestamp(previousValue)) {\n        return getPreviousValue(previousValue);\n    }\n    return previousValue;\n}\n/**\n * Returns the local time at which this timestamp was first set.\n */\nfunction getLocalWriteTime(value) {\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass DatabaseInfo {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId - The database to use.\n     * @param appId - The Firebase App Id.\n     * @param persistenceKey - A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host - The Firestore backend host to connect to.\n     * @param ssl - Whether to use SSL when connecting.\n     * @param forceLongPolling - Whether to use the forceLongPolling option\n     * when using WebChannel as the network transport.\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n     * option when using WebChannel as the network transport.\n     * @param longPollingOptions Options that configure long-polling.\n     * @param useFetchStreams Whether to use the Fetch API instead of\n     * XMLHTTPRequest\n     */\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams) {\n        this.databaseId = databaseId;\n        this.appId = appId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n        this.forceLongPolling = forceLongPolling;\n        this.autoDetectLongPolling = autoDetectLongPolling;\n        this.longPollingOptions = longPollingOptions;\n        this.useFetchStreams = useFetchStreams;\n    }\n}\n/** The default database name for a project. */\nconst DEFAULT_DATABASE_NAME = '(default)';\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nclass DatabaseId {\n    constructor(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    static empty() {\n        return new DatabaseId('', '');\n    }\n    get isDefaultDatabase() {\n        return this.database === DEFAULT_DATABASE_NAME;\n    }\n    isEqual(other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    }\n}\nfunction databaseIdFromApp(app, database) {\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n    return new DatabaseId(app.options.projectId, database);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Sentinel value that sorts before any Mutation Batch ID. */\nconst BATCHID_UNKNOWN = -1;\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/** Returns whether the value represents -0. */\nfunction isNegativeZero(value) {\n    // Detect if the value is -0.0. Based on polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    return value === 0 && 1 / value === 1 / -0;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (typeof value === 'number' &&\n        Number.isInteger(value) &&\n        !isNegativeZero(value) &&\n        value <= Number.MAX_SAFE_INTEGER &&\n        value >= Number.MIN_SAFE_INTEGER);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst TYPE_KEY = '__type__';\nconst MAX_VALUE_TYPE = '__max__';\nconst MAX_VALUE = {\n    mapValue: {\n        fields: {\n            '__type__': { stringValue: MAX_VALUE_TYPE }\n        }\n    }\n};\nconst VECTOR_VALUE_SENTINEL = '__vector__';\nconst VECTOR_MAP_VECTORS_KEY = 'value';\nconst MIN_VALUE = {\n    nullValue: 'NULL_VALUE'\n};\n/** Extracts the backend's type order for the provided value. */\nfunction typeOrder(value) {\n    if ('nullValue' in value) {\n        return 0 /* TypeOrder.NullValue */;\n    }\n    else if ('booleanValue' in value) {\n        return 1 /* TypeOrder.BooleanValue */;\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return 2 /* TypeOrder.NumberValue */;\n    }\n    else if ('timestampValue' in value) {\n        return 3 /* TypeOrder.TimestampValue */;\n    }\n    else if ('stringValue' in value) {\n        return 5 /* TypeOrder.StringValue */;\n    }\n    else if ('bytesValue' in value) {\n        return 6 /* TypeOrder.BlobValue */;\n    }\n    else if ('referenceValue' in value) {\n        return 7 /* TypeOrder.RefValue */;\n    }\n    else if ('geoPointValue' in value) {\n        return 8 /* TypeOrder.GeoPointValue */;\n    }\n    else if ('arrayValue' in value) {\n        return 9 /* TypeOrder.ArrayValue */;\n    }\n    else if ('mapValue' in value) {\n        if (isServerTimestamp(value)) {\n            return 4 /* TypeOrder.ServerTimestampValue */;\n        }\n        else if (isMaxValue(value)) {\n            return 9007199254740991 /* TypeOrder.MaxValue */;\n        }\n        else if (isVectorValue(value)) {\n            return 10 /* TypeOrder.VectorValue */;\n        }\n        return 11 /* TypeOrder.ObjectValue */;\n    }\n    else {\n        return fail();\n    }\n}\n/** Tests `left` and `right` for equality based on the backend semantics. */\nfunction valueEquals(left, right) {\n    if (left === right) {\n        return true;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return false;\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n            return true;\n        case 1 /* TypeOrder.BooleanValue */:\n            return left.booleanValue === right.booleanValue;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n        case 3 /* TypeOrder.TimestampValue */:\n            return timestampEquals(left, right);\n        case 5 /* TypeOrder.StringValue */:\n            return left.stringValue === right.stringValue;\n        case 6 /* TypeOrder.BlobValue */:\n            return blobEquals(left, right);\n        case 7 /* TypeOrder.RefValue */:\n            return left.referenceValue === right.referenceValue;\n        case 8 /* TypeOrder.GeoPointValue */:\n            return geoPointEquals(left, right);\n        case 2 /* TypeOrder.NumberValue */:\n            return numberEquals(left, right);\n        case 9 /* TypeOrder.ArrayValue */:\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return objectEquals(left, right);\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return true;\n        default:\n            return fail();\n    }\n}\nfunction timestampEquals(left, right) {\n    if (typeof left.timestampValue === 'string' &&\n        typeof right.timestampValue === 'string' &&\n        left.timestampValue.length === right.timestampValue.length) {\n        // Use string equality for ISO 8601 timestamps\n        return left.timestampValue === right.timestampValue;\n    }\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\n        leftTimestamp.nanos === rightTimestamp.nanos);\n}\nfunction geoPointEquals(left, right) {\n    return (normalizeNumber(left.geoPointValue.latitude) ===\n        normalizeNumber(right.geoPointValue.latitude) &&\n        normalizeNumber(left.geoPointValue.longitude) ===\n            normalizeNumber(right.geoPointValue.longitude));\n}\nfunction blobEquals(left, right) {\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\n}\nfunction numberEquals(left, right) {\n    if ('integerValue' in left && 'integerValue' in right) {\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\n    }\n    else if ('doubleValue' in left && 'doubleValue' in right) {\n        const n1 = normalizeNumber(left.doubleValue);\n        const n2 = normalizeNumber(right.doubleValue);\n        if (n1 === n2) {\n            return isNegativeZero(n1) === isNegativeZero(n2);\n        }\n        else {\n            return isNaN(n1) && isNaN(n2);\n        }\n    }\n    return false;\n}\nfunction objectEquals(left, right) {\n    const leftMap = left.mapValue.fields || {};\n    const rightMap = right.mapValue.fields || {};\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\n        return false;\n    }\n    for (const key in leftMap) {\n        if (leftMap.hasOwnProperty(key)) {\n            if (rightMap[key] === undefined ||\n                !valueEquals(leftMap[key], rightMap[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Returns true if the ArrayValue contains the specified element. */\nfunction arrayValueContains(haystack, needle) {\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\n}\nfunction valueCompare(left, right) {\n    if (left === right) {\n        return 0;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return primitiveComparator(leftType, rightType);\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return 0;\n        case 1 /* TypeOrder.BooleanValue */:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case 2 /* TypeOrder.NumberValue */:\n            return compareNumbers(left, right);\n        case 3 /* TypeOrder.TimestampValue */:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\n        case 5 /* TypeOrder.StringValue */:\n            return primitiveComparator(left.stringValue, right.stringValue);\n        case 6 /* TypeOrder.BlobValue */:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case 7 /* TypeOrder.RefValue */:\n            return compareReferences(left.referenceValue, right.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */:\n            return compareArrays(left.arrayValue, right.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n            return compareVectors(left.mapValue, right.mapValue);\n        case 11 /* TypeOrder.ObjectValue */:\n            return compareMaps(left.mapValue, right.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction compareNumbers(left, right) {\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n    if (leftNumber < rightNumber) {\n        return -1;\n    }\n    else if (leftNumber > rightNumber) {\n        return 1;\n    }\n    else if (leftNumber === rightNumber) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(leftNumber)) {\n            return isNaN(rightNumber) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\nfunction compareTimestamps(left, right) {\n    if (typeof left === 'string' &&\n        typeof right === 'string' &&\n        left.length === right.length) {\n        return primitiveComparator(left, right);\n    }\n    const leftTimestamp = normalizeTimestamp(left);\n    const rightTimestamp = normalizeTimestamp(right);\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\nfunction compareReferences(leftPath, rightPath) {\n    const leftSegments = leftPath.split('/');\n    const rightSegments = rightPath.split('/');\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    return primitiveComparator(leftSegments.length, rightSegments.length);\n}\nfunction compareGeoPoints(left, right) {\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\n}\nfunction compareBlobs(left, right) {\n    const leftBytes = normalizeByteString(left);\n    const rightBytes = normalizeByteString(right);\n    return leftBytes.compareTo(rightBytes);\n}\nfunction compareArrays(left, right) {\n    const leftArray = left.values || [];\n    const rightArray = right.values || [];\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n        const compare = valueCompare(leftArray[i], rightArray[i]);\n        if (compare) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftArray.length, rightArray.length);\n}\nfunction compareVectors(left, right) {\n    var _a, _b, _c, _d;\n    const leftMap = left.fields || {};\n    const rightMap = right.fields || {};\n    // The vector is a map, but only vector value is compared.\n    const leftArrayValue = (_a = leftMap[VECTOR_MAP_VECTORS_KEY]) === null || _a === void 0 ? void 0 : _a.arrayValue;\n    const rightArrayValue = (_b = rightMap[VECTOR_MAP_VECTORS_KEY]) === null || _b === void 0 ? void 0 : _b.arrayValue;\n    const lengthCompare = primitiveComparator(((_c = leftArrayValue === null || leftArrayValue === void 0 ? void 0 : leftArrayValue.values) === null || _c === void 0 ? void 0 : _c.length) || 0, ((_d = rightArrayValue === null || rightArrayValue === void 0 ? void 0 : rightArrayValue.values) === null || _d === void 0 ? void 0 : _d.length) || 0);\n    if (lengthCompare !== 0) {\n        return lengthCompare;\n    }\n    return compareArrays(leftArrayValue, rightArrayValue);\n}\nfunction compareMaps(left, right) {\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n        return 0;\n    }\n    else if (left === MAX_VALUE.mapValue) {\n        return 1;\n    }\n    else if (right === MAX_VALUE.mapValue) {\n        return -1;\n    }\n    const leftMap = left.fields || {};\n    const leftKeys = Object.keys(leftMap);\n    const rightMap = right.fields || {};\n    const rightKeys = Object.keys(rightMap);\n    // Even though MapValues are likely sorted correctly based on their insertion\n    // order (e.g. when received from the backend), local modifications can bring\n    // elements out of order. We need to re-sort the elements to ensure that\n    // canonical IDs are independent of insertion order.\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\n        if (keyCompare !== 0) {\n            return keyCompare;\n        }\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nfunction canonicalId(value) {\n    return canonifyValue(value);\n}\nfunction canonifyValue(value) {\n    if ('nullValue' in value) {\n        return 'null';\n    }\n    else if ('booleanValue' in value) {\n        return '' + value.booleanValue;\n    }\n    else if ('integerValue' in value) {\n        return '' + value.integerValue;\n    }\n    else if ('doubleValue' in value) {\n        return '' + value.doubleValue;\n    }\n    else if ('timestampValue' in value) {\n        return canonifyTimestamp(value.timestampValue);\n    }\n    else if ('stringValue' in value) {\n        return value.stringValue;\n    }\n    else if ('bytesValue' in value) {\n        return canonifyByteString(value.bytesValue);\n    }\n    else if ('referenceValue' in value) {\n        return canonifyReference(value.referenceValue);\n    }\n    else if ('geoPointValue' in value) {\n        return canonifyGeoPoint(value.geoPointValue);\n    }\n    else if ('arrayValue' in value) {\n        return canonifyArray(value.arrayValue);\n    }\n    else if ('mapValue' in value) {\n        return canonifyMap(value.mapValue);\n    }\n    else {\n        return fail();\n    }\n}\nfunction canonifyByteString(byteString) {\n    return normalizeByteString(byteString).toBase64();\n}\nfunction canonifyTimestamp(timestamp) {\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\nfunction canonifyGeoPoint(geoPoint) {\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\nfunction canonifyReference(referenceValue) {\n    return DocumentKey.fromName(referenceValue).toString();\n}\nfunction canonifyMap(mapValue) {\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n    // matching canonical IDs for identical maps, we need to sort the keys.\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n    let result = '{';\n    let first = true;\n    for (const key of sortedKeys) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\n    }\n    return result + '}';\n}\nfunction canonifyArray(arrayValue) {\n    let result = '[';\n    let first = true;\n    for (const value of arrayValue.values || []) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += canonifyValue(value);\n    }\n    return result + ']';\n}\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nfunction estimateByteSize(value) {\n    switch (typeOrder(value)) {\n        case 0 /* TypeOrder.NullValue */:\n            return 4;\n        case 1 /* TypeOrder.BooleanValue */:\n            return 4;\n        case 2 /* TypeOrder.NumberValue */:\n            return 8;\n        case 3 /* TypeOrder.TimestampValue */:\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n            return 16;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            const previousValue = getPreviousValue(value);\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n        case 5 /* TypeOrder.StringValue */:\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n            // integer values\"\n            return value.stringValue.length * 2;\n        case 6 /* TypeOrder.BlobValue */:\n            return normalizeByteString(value.bytesValue).approximateByteSize();\n        case 7 /* TypeOrder.RefValue */:\n            return value.referenceValue.length;\n        case 8 /* TypeOrder.GeoPointValue */:\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\n            return 16;\n        case 9 /* TypeOrder.ArrayValue */:\n            return estimateArrayByteSize(value.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return estimateMapByteSize(value.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction estimateMapByteSize(mapValue) {\n    let size = 0;\n    forEach(mapValue.fields, (key, val) => {\n        size += key.length + estimateByteSize(val);\n    });\n    return size;\n}\nfunction estimateArrayByteSize(arrayValue) {\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\n}\n/** Returns a reference value for the provided database and key. */\nfunction refValue(databaseId, key) {\n    return {\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\n    };\n}\n/** Returns true if `value` is an IntegerValue . */\nfunction isInteger(value) {\n    return !!value && 'integerValue' in value;\n}\n/** Returns true if `value` is a DoubleValue. */\nfunction isDouble(value) {\n    return !!value && 'doubleValue' in value;\n}\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nfunction isNumber(value) {\n    return isInteger(value) || isDouble(value);\n}\n/** Returns true if `value` is an ArrayValue. */\nfunction isArray(value) {\n    return !!value && 'arrayValue' in value;\n}\n/** Returns true if `value` is a NullValue. */\nfunction isNullValue(value) {\n    return !!value && 'nullValue' in value;\n}\n/** Returns true if `value` is NaN. */\nfunction isNanValue(value) {\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n/** Returns true if `value` is a MapValue. */\nfunction isMapValue(value) {\n    return !!value && 'mapValue' in value;\n}\n/** Returns true if `value` is a VetorValue. */\nfunction isVectorValue(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === VECTOR_VALUE_SENTINEL;\n}\n/** Creates a deep copy of `source`. */\nfunction deepClone(source) {\n    if (source.geoPointValue) {\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\n    }\n    else if (source.timestampValue &&\n        typeof source.timestampValue === 'object') {\n        return { timestampValue: Object.assign({}, source.timestampValue) };\n    }\n    else if (source.mapValue) {\n        const target = { mapValue: { fields: {} } };\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\n        return target;\n    }\n    else if (source.arrayValue) {\n        const target = { arrayValue: { values: [] } };\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\n        }\n        return target;\n    }\n    else {\n        return Object.assign({}, source);\n    }\n}\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\nfunction isMaxValue(value) {\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\n        MAX_VALUE_TYPE);\n}\nconst MIN_VECTOR_VALUE = {\n    mapValue: {\n        fields: {\n            [TYPE_KEY]: { stringValue: VECTOR_VALUE_SENTINEL },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {}\n            }\n        }\n    }\n};\n/** Returns the lowest value for the given value type (inclusive). */\nfunction valuesGetLowerBound(value) {\n    if ('nullValue' in value) {\n        return MIN_VALUE;\n    }\n    else if ('booleanValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('timestampValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('stringValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('referenceValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('geoPointValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('arrayValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return MIN_VECTOR_VALUE;\n        }\n        return { mapValue: {} };\n    }\n    else {\n        return fail();\n    }\n}\n/** Returns the largest value for the given value type (exclusive). */\nfunction valuesGetUpperBound(value) {\n    if ('nullValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('booleanValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('timestampValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('stringValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('referenceValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('geoPointValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('arrayValue' in value) {\n        return MIN_VECTOR_VALUE;\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return { mapValue: {} };\n        }\n        return MAX_VALUE;\n    }\n    else {\n        return fail();\n    }\n}\nfunction lowerBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return -1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return 1;\n    }\n    return 0;\n}\nfunction upperBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return 1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nclass ObjectValue {\n    constructor(value) {\n        this.value = value;\n    }\n    static empty() {\n        return new ObjectValue({ mapValue: {} });\n    }\n    /**\n     * Returns the value at the given path or null.\n     *\n     * @param path - the path to search\n     * @returns The value at the path or null if the path is not set.\n     */\n    field(path) {\n        if (path.isEmpty()) {\n            return this.value;\n        }\n        else {\n            let currentLevel = this.value;\n            for (let i = 0; i < path.length - 1; ++i) {\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\n                if (!isMapValue(currentLevel)) {\n                    return null;\n                }\n            }\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\n            return currentLevel || null;\n        }\n    }\n    /**\n     * Sets the field to the provided value.\n     *\n     * @param path - The field path to set.\n     * @param value - The value to set.\n     */\n    set(path, value) {\n        const fieldsMap = this.getFieldsMap(path.popLast());\n        fieldsMap[path.lastSegment()] = deepClone(value);\n    }\n    /**\n     * Sets the provided fields to the provided values.\n     *\n     * @param data - A map of fields to values (or null for deletes).\n     */\n    setAll(data) {\n        let parent = FieldPath$1.emptyPath();\n        let upserts = {};\n        let deletes = [];\n        data.forEach((value, path) => {\n            if (!parent.isImmediateParentOf(path)) {\n                // Insert the accumulated changes at this parent location\n                const fieldsMap = this.getFieldsMap(parent);\n                this.applyChanges(fieldsMap, upserts, deletes);\n                upserts = {};\n                deletes = [];\n                parent = path.popLast();\n            }\n            if (value) {\n                upserts[path.lastSegment()] = deepClone(value);\n            }\n            else {\n                deletes.push(path.lastSegment());\n            }\n        });\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n    }\n    /**\n     * Removes the field at the specified path. If there is no field at the\n     * specified path, nothing is changed.\n     *\n     * @param path - The field path to remove.\n     */\n    delete(path) {\n        const nestedValue = this.field(path.popLast());\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n            delete nestedValue.mapValue.fields[path.lastSegment()];\n        }\n    }\n    isEqual(other) {\n        return valueEquals(this.value, other.value);\n    }\n    /**\n     * Returns the map that contains the leaf element of `path`. If the parent\n     * entry does not yet exist, or if it is not a map, a new map will be created.\n     */\n    getFieldsMap(path) {\n        let current = this.value;\n        if (!current.mapValue.fields) {\n            current.mapValue = { fields: {} };\n        }\n        for (let i = 0; i < path.length; ++i) {\n            let next = current.mapValue.fields[path.get(i)];\n            if (!isMapValue(next) || !next.mapValue.fields) {\n                next = { mapValue: { fields: {} } };\n                current.mapValue.fields[path.get(i)] = next;\n            }\n            current = next;\n        }\n        return current.mapValue.fields;\n    }\n    /**\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\n     * entries.\n     */\n    applyChanges(fieldsMap, inserts, deletes) {\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\n        for (const field of deletes) {\n            delete fieldsMap[field];\n        }\n    }\n    clone() {\n        return new ObjectValue(deepClone(this.value));\n    }\n}\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nfunction extractFieldMask(value) {\n    const fields = [];\n    forEach(value.fields, (key, value) => {\n        const currentPath = new FieldPath$1([key]);\n        if (isMapValue(value)) {\n            const nestedMask = extractFieldMask(value.mapValue);\n            const nestedFields = nestedMask.fields;\n            if (nestedFields.length === 0) {\n                // Preserve the empty map by adding it to the FieldMask.\n                fields.push(currentPath);\n            }\n            else {\n                // For nested and non-empty ObjectValues, add the FieldPath of the\n                // leaf nodes.\n                for (const nestedPath of nestedFields) {\n                    fields.push(currentPath.child(nestedPath));\n                }\n            }\n        }\n        else {\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n            // nodes.\n            fields.push(currentPath);\n        }\n    });\n    return new FieldMask(fields);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nclass MutableDocument {\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\n        this.key = key;\n        this.documentType = documentType;\n        this.version = version;\n        this.readTime = readTime;\n        this.createTime = createTime;\n        this.data = data;\n        this.documentState = documentState;\n    }\n    /**\n     * Creates a document with no known version or data, but which can serve as\n     * base document for mutations.\n     */\n    static newInvalidDocument(documentKey) {\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \n        /* version */ SnapshotVersion.min(), \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist with the given data at the\n     * given version.\n     */\n    static newFoundDocument(documentKey, version, createTime, value) {\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\n    }\n    /** Creates a new document that is known to not exist at the given version. */\n    static newNoDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist at the given version but\n     * whose data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    static newUnknownDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\n    }\n    /**\n     * Changes the document type to indicate that it exists and that its version\n     * and data are known.\n     */\n    convertToFoundDocument(version, value) {\n        // If a document is switching state from being an invalid or deleted\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n        // update from Watch or due to applying a local set mutation on top\n        // of a deleted document, our best guess about its createTime would be the\n        // version at which the document transitioned to a FOUND_DOCUMENT.\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\n                this.documentType === 0 /* DocumentType.INVALID */)) {\n            this.createTime = version;\n        }\n        this.version = version;\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\n        this.data = value;\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it doesn't exist at the given\n     * version.\n     */\n    convertToNoDocument(version) {\n        this.version = version;\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it exists at a given version but\n     * that its data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    convertToUnknownDocument(version) {\n        this.version = version;\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasCommittedMutations() {\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasLocalMutations() {\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n        this.version = SnapshotVersion.min();\n        return this;\n    }\n    setReadTime(readTime) {\n        this.readTime = readTime;\n        return this;\n    }\n    get hasLocalMutations() {\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n    }\n    get hasCommittedMutations() {\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n    }\n    get hasPendingWrites() {\n        return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n    isValidDocument() {\n        return this.documentType !== 0 /* DocumentType.INVALID */;\n    }\n    isFoundDocument() {\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\n    }\n    isNoDocument() {\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\n    }\n    isUnknownDocument() {\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n    }\n    isEqual(other) {\n        return (other instanceof MutableDocument &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.documentType === other.documentType &&\n            this.documentState === other.documentState &&\n            this.data.isEqual(other.data));\n    }\n    mutableCopy() {\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n    toString() {\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\n            `{createTime: ${this.createTime}}), ` +\n            `{documentType: ${this.documentType}}), ` +\n            `{documentState: ${this.documentState}})`);\n    }\n}\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nfunction compareDocumentsByField(field, d1, d2) {\n    const v1 = d1.data.field(field);\n    const v2 = d2.data.field(field);\n    if (v1 !== null && v2 !== null) {\n        return valueCompare(v1, v2);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nclass Bound {\n    constructor(position, inclusive) {\n        this.position = position;\n        this.inclusive = inclusive;\n    }\n}\nfunction boundCompareToDocument(bound, orderBy, doc) {\n    let comparison = 0;\n    for (let i = 0; i < bound.position.length; i++) {\n        const orderByComponent = orderBy[i];\n        const component = bound.position[i];\n        if (orderByComponent.field.isKeyField()) {\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\n        }\n        else {\n            const docValue = doc.data.field(orderByComponent.field);\n            comparison = valueCompare(component, docValue);\n        }\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\n            comparison = comparison * -1;\n        }\n        if (comparison !== 0) {\n            break;\n        }\n    }\n    return comparison;\n}\n/**\n * Returns true if a document sorts after a bound using the provided sort\n * order.\n */\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\n}\n/**\n * Returns true if a document sorts before a bound using the provided sort\n * order.\n */\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\n}\nfunction boundEquals(left, right) {\n    if (left === null) {\n        return right === null;\n    }\n    else if (right === null) {\n        return false;\n    }\n    if (left.inclusive !== right.inclusive ||\n        left.position.length !== right.position.length) {\n        return false;\n    }\n    for (let i = 0; i < left.position.length; i++) {\n        const leftPosition = left.position[i];\n        const rightPosition = right.position[i];\n        if (!valueEquals(leftPosition, rightPosition)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nclass OrderBy {\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\n        this.field = field;\n        this.dir = dir;\n    }\n}\nfunction canonifyOrderBy(orderBy) {\n    // TODO(b/29183165): Make this collision robust.\n    return orderBy.field.canonicalString() + orderBy.dir;\n}\nfunction stringifyOrderBy(orderBy) {\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\nfunction orderByEquals(left, right) {\n    return left.dir === right.dir && left.field.isEqual(right.field);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Filter {\n}\nclass FieldFilter extends Filter {\n    constructor(field, op, value) {\n        super();\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(field, op, value) {\n        if (field.isKeyField()) {\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n                return this.createKeyFieldInFilter(field, op, value);\n            }\n            else {\n                return new KeyFieldFilter(field, op, value);\n            }\n        }\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\n            return new ArrayContainsFilter(field, value);\n        }\n        else if (op === \"in\" /* Operator.IN */) {\n            return new InFilter(field, value);\n        }\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\n            return new NotInFilter(field, value);\n        }\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            return new ArrayContainsAnyFilter(field, value);\n        }\n        else {\n            return new FieldFilter(field, op, value);\n        }\n    }\n    static createKeyFieldInFilter(field, op, value) {\n        return op === \"in\" /* Operator.IN */\n            ? new KeyFieldInFilter(field, value)\n            : new KeyFieldNotInFilter(field, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        // Types do not have to match in NOT_EQUAL filters.\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\n            return (other !== null &&\n                this.matchesComparison(valueCompare(other, this.value)));\n        }\n        // Only compare types with matching backend order (such as double and int).\n        return (other !== null &&\n            typeOrder(this.value) === typeOrder(other) &&\n            this.matchesComparison(valueCompare(other, this.value)));\n    }\n    matchesComparison(comparison) {\n        switch (this.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n                return comparison < 0;\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                return comparison <= 0;\n            case \"==\" /* Operator.EQUAL */:\n                return comparison === 0;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n                return comparison !== 0;\n            case \">\" /* Operator.GREATER_THAN */:\n                return comparison > 0;\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                return comparison >= 0;\n            default:\n                return fail();\n        }\n    }\n    isInequality() {\n        return ([\n            \"<\" /* Operator.LESS_THAN */,\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\n            \">\" /* Operator.GREATER_THAN */,\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\n            \"!=\" /* Operator.NOT_EQUAL */,\n            \"not-in\" /* Operator.NOT_IN */\n        ].indexOf(this.op) >= 0);\n    }\n    getFlattenedFilters() {\n        return [this];\n    }\n    getFilters() {\n        return [this];\n    }\n}\nclass CompositeFilter extends Filter {\n    constructor(filters, op) {\n        super();\n        this.filters = filters;\n        this.op = op;\n        this.memoizedFlattenedFilters = null;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(filters, op) {\n        return new CompositeFilter(filters, op);\n    }\n    matches(doc) {\n        if (compositeFilterIsConjunction(this)) {\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\n        }\n        else {\n            // For disjunctions, at least one filter should match.\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\n        }\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\n            return result.concat(subfilter.getFlattenedFilters());\n        }, []);\n        return this.memoizedFlattenedFilters;\n    }\n    // Returns a mutable copy of `this.filters`\n    getFilters() {\n        return Object.assign([], this.filters);\n    }\n}\nfunction compositeFilterIsConjunction(compositeFilter) {\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\n}\nfunction compositeFilterIsDisjunction(compositeFilter) {\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\n}\n/**\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\n */\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\n    return (compositeFilterIsFlat(compositeFilter) &&\n        compositeFilterIsConjunction(compositeFilter));\n}\n/**\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\n */\nfunction compositeFilterIsFlat(compositeFilter) {\n    for (const filter of compositeFilter.filters) {\n        if (filter instanceof CompositeFilter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canonifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (filter.field.canonicalString() +\n            filter.op.toString() +\n            canonicalId(filter.value));\n    }\n    else if (compositeFilterIsFlatConjunction(filter)) {\n        // Older SDK versions use an implicit AND operation between their filters.\n        // In the new SDK versions, the developer may use an explicit AND filter.\n        // To stay consistent with the old usages, we add a special case to ensure\n        // the canonical ID for these two are the same. For example:\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\n    }\n    else {\n        // filter instanceof CompositeFilter\n        const canonicalIdsString = filter.filters\n            .map(filter => canonifyFilter(filter))\n            .join(',');\n        return `${filter.op}(${canonicalIdsString})`;\n    }\n}\nfunction filterEquals(f1, f2) {\n    if (f1 instanceof FieldFilter) {\n        return fieldFilterEquals(f1, f2);\n    }\n    else if (f1 instanceof CompositeFilter) {\n        return compositeFilterEquals(f1, f2);\n    }\n    else {\n        fail();\n    }\n}\nfunction fieldFilterEquals(f1, f2) {\n    return (f2 instanceof FieldFilter &&\n        f1.op === f2.op &&\n        f1.field.isEqual(f2.field) &&\n        valueEquals(f1.value, f2.value));\n}\nfunction compositeFilterEquals(f1, f2) {\n    if (f2 instanceof CompositeFilter &&\n        f1.op === f2.op &&\n        f1.filters.length === f2.filters.length) {\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\n        return subFiltersMatch;\n    }\n    return false;\n}\n/**\n * Returns a new composite filter that contains all filter from\n * `compositeFilter` plus all the given filters in `otherFilters`.\n */\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\n}\n/** Returns a debug description for `filter`. */\nfunction stringifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return stringifyFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return stringifyCompositeFilter(filter);\n    }\n    else {\n        return 'Filter';\n    }\n}\nfunction stringifyCompositeFilter(filter) {\n    return (filter.op.toString() +\n        ` {` +\n        filter.getFilters().map(stringifyFilter).join(' ,') +\n        '}');\n}\nfunction stringifyFieldFilter(filter) {\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\n}\n/** Filter that matches on key fields (i.e. '__name__'). */\nclass KeyFieldFilter extends FieldFilter {\n    constructor(field, op, value) {\n        super(field, op, value);\n        this.key = DocumentKey.fromName(value.referenceValue);\n    }\n    matches(doc) {\n        const comparison = DocumentKey.comparator(doc.key, this.key);\n        return this.matchesComparison(comparison);\n    }\n}\n/** Filter that matches on key fields within an array. */\nclass KeyFieldInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        return this.keys.some(key => key.isEqual(doc.key));\n    }\n}\n/** Filter that matches on key fields not present within an array. */\nclass KeyFieldNotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        return !this.keys.some(key => key.isEqual(doc.key));\n    }\n}\nfunction extractDocumentKeysFromArrayValue(op, value) {\n    var _a;\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\n        return DocumentKey.fromName(v.referenceValue);\n    });\n}\n/** A Filter that implements the array-contains operator. */\nclass ArrayContainsFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n    }\n}\n/** A Filter that implements the IN operator. */\nclass InFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the not-in operator. */\nclass NotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\n            return false;\n        }\n        const other = doc.data.field(this.field);\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the array-contains-any operator. */\nclass ArrayContainsAnyFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        if (!isArray(other) || !other.arrayValue.values) {\n            return false;\n        }\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Visible for testing\nclass TargetImpl {\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.orderBy = orderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n    }\n}\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\n}\nfunction canonifyTarget(target) {\n    const targetImpl = debugCast(target);\n    if (targetImpl.memoizedCanonicalId === null) {\n        let str = targetImpl.path.canonicalString();\n        if (targetImpl.collectionGroup !== null) {\n            str += '|cg:' + targetImpl.collectionGroup;\n        }\n        str += '|f:';\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\n        str += '|ob:';\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\n        if (!isNullOrUndefined(targetImpl.limit)) {\n            str += '|l:';\n            str += targetImpl.limit;\n        }\n        if (targetImpl.startAt) {\n            str += '|lb:';\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\n        }\n        if (targetImpl.endAt) {\n            str += '|ub:';\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\n        }\n        targetImpl.memoizedCanonicalId = str;\n    }\n    return targetImpl.memoizedCanonicalId;\n}\nfunction stringifyTarget(target) {\n    let str = target.path.canonicalString();\n    if (target.collectionGroup !== null) {\n        str += ' collectionGroup=' + target.collectionGroup;\n    }\n    if (target.filters.length > 0) {\n        str += `, filters: [${target.filters\n            .map(f => stringifyFilter(f))\n            .join(', ')}]`;\n    }\n    if (!isNullOrUndefined(target.limit)) {\n        str += ', limit: ' + target.limit;\n    }\n    if (target.orderBy.length > 0) {\n        str += `, orderBy: [${target.orderBy\n            .map(o => stringifyOrderBy(o))\n            .join(', ')}]`;\n    }\n    if (target.startAt) {\n        str += ', startAt: ';\n        str += target.startAt.inclusive ? 'b:' : 'a:';\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\n    }\n    if (target.endAt) {\n        str += ', endAt: ';\n        str += target.endAt.inclusive ? 'a:' : 'b:';\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\n    }\n    return `Target(${str})`;\n}\nfunction targetEquals(left, right) {\n    if (left.limit !== right.limit) {\n        return false;\n    }\n    if (left.orderBy.length !== right.orderBy.length) {\n        return false;\n    }\n    for (let i = 0; i < left.orderBy.length; i++) {\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n            return false;\n        }\n    }\n    if (left.filters.length !== right.filters.length) {\n        return false;\n    }\n    for (let i = 0; i < left.filters.length; i++) {\n        if (!filterEquals(left.filters[i], right.filters[i])) {\n            return false;\n        }\n    }\n    if (left.collectionGroup !== right.collectionGroup) {\n        return false;\n    }\n    if (!left.path.isEqual(right.path)) {\n        return false;\n    }\n    if (!boundEquals(left.startAt, right.startAt)) {\n        return false;\n    }\n    return boundEquals(left.endAt, right.endAt);\n}\nfunction targetIsDocumentTarget(target) {\n    return (DocumentKey.isDocumentKey(target.path) &&\n        target.collectionGroup === null &&\n        target.filters.length === 0);\n}\n/** Returns the field filters that target the given field path. */\nfunction targetGetFieldFiltersForPath(target, path) {\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\n}\n/**\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\n * filters. Returns `null` if there are no such filters.\n */\nfunction targetGetArrayValues(target, fieldIndex) {\n    const segment = fieldIndexGetArraySegment(fieldIndex);\n    if (segment === undefined) {\n        return null;\n    }\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n        switch (fieldFilter.op) {\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n                return fieldFilter.value.arrayValue.values || [];\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\n                return [fieldFilter.value];\n            // Remaining filters are not array filters.\n        }\n    }\n    return null;\n}\n/**\n * Returns the list of values that are used in != or NOT_IN filters. Returns\n * `null` if there are no such filters.\n */\nfunction targetGetNotInValues(target, fieldIndex) {\n    const values = new Map();\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n            switch (fieldFilter.op) {\n                case \"==\" /* Operator.EQUAL */:\n                case \"in\" /* Operator.IN */:\n                    // Encode equality prefix, which is encoded in the index value before\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\n                    // `value != 'ab'`).\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    break;\n                case \"not-in\" /* Operator.NOT_IN */:\n                case \"!=\" /* Operator.NOT_EQUAL */:\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\n                    // segments and hence we can return early here.\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    return Array.from(values.values());\n                // Remaining filters cannot be used as notIn bounds.\n            }\n        }\n    }\n    return null;\n}\n/**\n * Returns a lower bound of field values that can be used as a starting point to\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\n * exists.\n */\nfunction targetGetLowerBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve a lower bound if there is a suitable filter or\n    // startAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns an upper bound of field values that can be used as an ending point\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\n * upper bound exists.\n */\nfunction targetGetUpperBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve an upper bound if there is a suitable filter or\n    // endAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns the value to use as the lower bound for ascending index segment at\n * the provided `fieldPath` (or the upper bound for an descending segment).\n */\nfunction targetGetAscendingBound(target, fieldPath, bound) {\n    let value = MIN_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MIN_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = valuesGetLowerBound(fieldFilter.value);\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MIN_VALUE;\n                break;\n            // Remaining filters cannot be used as lower bounds.\n        }\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/**\n * Returns the value to use as the upper bound for ascending index segment at\n * the provided `fieldPath` (or the lower bound for a descending segment).\n */\nfunction targetGetDescendingBound(target, fieldPath, bound) {\n    let value = MAX_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MAX_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = valuesGetUpperBound(fieldFilter.value);\n                filterInclusive = false;\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \"<\" /* Operator.LESS_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MAX_VALUE;\n                break;\n            // Remaining filters cannot be used as upper bounds.\n        }\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/** Returns the number of segments of a perfect index for this target. */\nfunction targetGetSegmentCount(target) {\n    let fields = new SortedSet(FieldPath$1.comparator);\n    let hasArraySegment = false;\n    for (const filter of target.filters) {\n        for (const subFilter of filter.getFlattenedFilters()) {\n            // __name__ is not an explicit segment of any index, so we don't need to\n            // count it.\n            if (subFilter.field.isKeyField()) {\n                continue;\n            }\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\n            // though these are on the same field, they should be counted as two\n            // separate segments in an index.\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n                hasArraySegment = true;\n            }\n            else {\n                fields = fields.add(subFilter.field);\n            }\n        }\n    }\n    for (const orderBy of target.orderBy) {\n        // __name__ is not an explicit segment of any index, so we don't need to\n        // count it.\n        if (!orderBy.field.isKeyField()) {\n            fields = fields.add(orderBy.field);\n        }\n    }\n    return fields.size + (hasArraySegment ? 1 : 0);\n}\nfunction targetHasLimit(target) {\n    return target.limit !== null;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n *\n * Visible for testing.\n */\nclass QueryImpl {\n    /**\n     * Initializes a Query with a path and optional additional query constraints.\n     * Path must currently be empty if this is a collection group query.\n     */\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedNormalizedOrderBy = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // non-aggregate queries.\n        this.memoizedTarget = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // aggregate queries. Unlike targets for non-aggregate queries,\n        // aggregate query targets do not contain normalized order-bys, they only\n        // contain explicit order-bys.\n        this.memoizedAggregateTarget = null;\n        if (this.startAt) ;\n        if (this.endAt) ;\n    }\n}\n/** Creates a new Query instance with the options provided. */\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\n}\n/** Creates a new Query for a query that matches all documents at `path` */\nfunction newQueryForPath(path) {\n    return new QueryImpl(path);\n}\n/**\n * Helper to convert a collection group query into a collection query at a\n * specific path. This is used when executing collection group queries, since\n * we have to split the query into a set of collection queries at multiple\n * paths.\n */\nfunction asCollectionQueryAtPath(query, path) {\n    return new QueryImpl(path, \n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\n/**\n * Returns true if this query does not specify any query constraints that\n * could remove results.\n */\nfunction queryMatchesAllDocuments(query) {\n    return (query.filters.length === 0 &&\n        query.limit === null &&\n        query.startAt == null &&\n        query.endAt == null &&\n        (query.explicitOrderBy.length === 0 ||\n            (query.explicitOrderBy.length === 1 &&\n                query.explicitOrderBy[0].field.isKeyField())));\n}\n// Returns the sorted set of inequality filter fields used in this query.\nfunction getInequalityFilterFields(query) {\n    let result = new SortedSet(FieldPath$1.comparator);\n    query.filters.forEach((filter) => {\n        const subFilters = filter.getFlattenedFilters();\n        subFilters.forEach((filter) => {\n            if (filter.isInequality()) {\n                result = result.add(filter.field);\n            }\n        });\n    });\n    return result;\n}\n/**\n * Creates a new Query for a collection group query that matches all documents\n * within the provided collection group.\n */\nfunction newQueryForCollectionGroup(collectionId) {\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\n}\n/**\n * Returns whether the query matches a single document by path (rather than a\n * collection).\n */\nfunction isDocumentQuery$1(query) {\n    return (DocumentKey.isDocumentKey(query.path) &&\n        query.collectionGroup === null &&\n        query.filters.length === 0);\n}\n/**\n * Returns whether the query matches a collection group rather than a specific\n * collection.\n */\nfunction isCollectionGroupQuery(query) {\n    return query.collectionGroup !== null;\n}\n/**\n * Returns the normalized order-by constraint that is used to execute the Query,\n * which can be different from the order-by constraints the user provided (e.g.\n * the SDK and backend always orders by `__name__`). The normalized order-by\n * includes implicit order-bys in addition to the explicit user provided\n * order-bys.\n */\nfunction queryNormalizedOrderBy(query) {\n    const queryImpl = debugCast(query);\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\n        queryImpl.memoizedNormalizedOrderBy = [];\n        const fieldsNormalized = new Set();\n        // Any explicit order by fields should be added as is.\n        for (const orderBy of queryImpl.explicitOrderBy) {\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\n            fieldsNormalized.add(orderBy.field.canonicalString());\n        }\n        // The order of the implicit ordering always matches the last explicit order by.\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\n            : \"asc\" /* Direction.ASCENDING */;\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\n        // order. When there are multiple inequality filters on the same field, the field should be added\n        // only once.\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\n        // field to be sorted last.\n        const inequalityFields = getInequalityFilterFields(queryImpl);\n        inequalityFields.forEach(field => {\n            if (!fieldsNormalized.has(field.canonicalString()) &&\n                !field.isKeyField()) {\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\n            }\n        });\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\n        }\n    }\n    return queryImpl.memoizedNormalizedOrderBy;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation.\n */\nfunction queryToTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedTarget) {\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\n    }\n    return queryImpl.memoizedTarget;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation,\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\n * aggregate query targets do not contain normalized order-bys, they only\n * contain explicit order-bys.\n */\nfunction queryToAggregateTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedAggregateTarget) {\n        // Do not include implicit order-bys for aggregate queries.\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\n    }\n    return queryImpl.memoizedAggregateTarget;\n}\nfunction _queryToTarget(queryImpl, orderBys) {\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\n    }\n    else {\n        // Flip the orderBy directions since we want the last results\n        orderBys = orderBys.map(orderBy => {\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\n                ? \"asc\" /* Direction.ASCENDING */\n                : \"desc\" /* Direction.DESCENDING */;\n            return new OrderBy(orderBy.field, dir);\n        });\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = queryImpl.endAt\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\n            : null;\n        const endAt = queryImpl.startAt\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\n            : null;\n        // Now return as a LimitType.First query.\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\n    }\n}\nfunction queryWithAddedFilter(query, filter) {\n    const newFilters = query.filters.concat([filter]);\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithAddedOrderBy(query, orderBy) {\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithLimit(query, limit, limitType) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\n}\nfunction queryWithStartAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\n}\nfunction queryWithEndAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\n}\nfunction queryEquals(left, right) {\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\n        left.limitType === right.limitType);\n}\n// TODO(b/29183165): This is used to get a unique string from a query to, for\n// example, use as a dictionary key, but the implementation is subject to\n// collisions. Make it collision-free.\nfunction canonifyQuery(query) {\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\n}\nfunction stringifyQuery(query) {\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\n}\n/** Returns whether `doc` matches the constraints of `query`. */\nfunction queryMatches(query, doc) {\n    return (doc.isFoundDocument() &&\n        queryMatchesPathAndCollectionGroup(query, doc) &&\n        queryMatchesOrderBy(query, doc) &&\n        queryMatchesFilters(query, doc) &&\n        queryMatchesBounds(query, doc));\n}\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\n    const docPath = doc.key.path;\n    if (query.collectionGroup !== null) {\n        // NOTE: this.path is currently always empty since we don't expose Collection\n        // Group queries rooted at a document path yet.\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\n            query.path.isPrefixOf(docPath));\n    }\n    else if (DocumentKey.isDocumentKey(query.path)) {\n        // exact match for document queries\n        return query.path.isEqual(docPath);\n    }\n    else {\n        // shallow ancestor queries by default\n        return query.path.isImmediateParentOf(docPath);\n    }\n}\n/**\n * A document must have a value for every ordering clause in order to show up\n * in the results.\n */\nfunction queryMatchesOrderBy(query, doc) {\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\n    // it's missing the field 'a'.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        // order-by key always matches\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction queryMatchesFilters(query, doc) {\n    for (const filter of query.filters) {\n        if (!filter.matches(doc)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Makes sure a document is within the bounds, if provided. */\nfunction queryMatchesBounds(query, doc) {\n    if (query.startAt &&\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    if (query.endAt &&\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Returns the collection group that this query targets.\n *\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\n * synchronization for query results.\n */\nfunction queryCollectionGroup(query) {\n    return (query.collectionGroup ||\n        (query.path.length % 2 === 1\n            ? query.path.lastSegment()\n            : query.path.get(query.path.length - 2)));\n}\n/**\n * Returns a new comparator function that can be used to compare two documents\n * based on the Query's ordering constraint.\n */\nfunction newQueryComparator(query) {\n    return (d1, d2) => {\n        let comparedOnKeyField = false;\n        for (const orderBy of queryNormalizedOrderBy(query)) {\n            const comp = compareDocs(orderBy, d1, d2);\n            if (comp !== 0) {\n                return comp;\n            }\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        return 0;\n    };\n}\nfunction compareDocs(orderBy, d1, d2) {\n    const comparison = orderBy.field.isKeyField()\n        ? DocumentKey.comparator(d1.key, d2.key)\n        : compareDocumentsByField(orderBy.field, d1, d2);\n    switch (orderBy.dir) {\n        case \"asc\" /* Direction.ASCENDING */:\n            return comparison;\n        case \"desc\" /* Direction.DESCENDING */:\n            return -1 * comparison;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A map implementation that uses objects as keys. Objects must have an\n * associated equals function and must be immutable. Entries in the map are\n * stored together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nclass ObjectMap {\n    constructor(mapKeyFn, equalsFn) {\n        this.mapKeyFn = mapKeyFn;\n        this.equalsFn = equalsFn;\n        /**\n         * The inner map for a key/value pair. Due to the possibility of collisions we\n         * keep a list of entries that we do a linear search through to find an actual\n         * match. Note that collisions should be rare, so we still expect near\n         * constant time lookups in practice.\n         */\n        this.inner = {};\n        /** The number of entries stored in the map */\n        this.innerSize = 0;\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    get(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (const [otherKey, value] of matches) {\n            if (this.equalsFn(otherKey, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    /** Put this key and value in the map. */\n    set(key, value) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            this.innerSize++;\n            return;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                // This is updating an existing entry and does not increase `innerSize`.\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n        this.innerSize++;\n    }\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    delete(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                this.innerSize--;\n                return true;\n            }\n        }\n        return false;\n    }\n    forEach(fn) {\n        forEach(this.inner, (_, entries) => {\n            for (const [k, v] of entries) {\n                fn(k, v);\n            }\n        });\n    }\n    isEmpty() {\n        return isEmpty(this.inner);\n    }\n    size() {\n        return this.innerSize;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction mutableDocumentMap() {\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\n}\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentMap(...docs) {\n    let map = EMPTY_DOCUMENT_MAP;\n    for (const doc of docs) {\n        map = map.insert(doc.key, doc);\n    }\n    return map;\n}\nfunction newOverlayedDocumentMap() {\n    return newDocumentKeyMap();\n}\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\n    let documents = EMPTY_DOCUMENT_MAP;\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\n    return documents;\n}\nfunction newOverlayMap() {\n    return newDocumentKeyMap();\n}\nfunction newMutationMap() {\n    return newDocumentKeyMap();\n}\nfunction newDocumentKeyMap() {\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n}\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nfunction documentKeySet(...keys) {\n    let set = EMPTY_DOCUMENT_KEY_SET;\n    for (const key of keys) {\n        set = set.add(key);\n    }\n    return set;\n}\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\nfunction targetIdSet() {\n    return EMPTY_TARGET_ID_SET;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an DoubleValue for `value` that is encoded based the serializer's\n * `useProto3Json` setting.\n */\nfunction toDouble(serializer, value) {\n    if (serializer.useProto3Json) {\n        if (isNaN(value)) {\n            return { doubleValue: 'NaN' };\n        }\n        else if (value === Infinity) {\n            return { doubleValue: 'Infinity' };\n        }\n        else if (value === -Infinity) {\n            return { doubleValue: '-Infinity' };\n        }\n    }\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\n}\n/**\n * Returns an IntegerValue for `value`.\n */\nfunction toInteger(value) {\n    return { integerValue: '' + value };\n}\n/**\n * Returns a value for a number that's appropriate to put into a proto.\n * The return value is an IntegerValue if it can safely represent the value,\n * otherwise a DoubleValue is returned.\n */\nfunction toNumber(serializer, value) {\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used to represent a field transform on a mutation. */\nclass TransformOperation {\n    constructor() {\n        // Make sure that the structural type of `TransformOperation` is unique.\n        // See https://github.com/microsoft/TypeScript/issues/5451\n        this._ = undefined;\n    }\n}\n/**\n * Computes the local transform result against the provided `previousValue`,\n * optionally using the provided localWriteTime.\n */\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\n    if (transform instanceof ServerTimestampTransform) {\n        return serverTimestamp$1(localWriteTime, previousValue);\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    else {\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\n    }\n}\n/**\n * Computes a final transform result after the transform has been acknowledged\n * by the server, potentially using the server-provided transformResult.\n */\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    return transformResult;\n}\n/**\n * If this transform operation is not idempotent, returns the base value to\n * persist for this transform. If a base value is returned, the transform\n * operation is always applied to this base value, even if document has\n * already been updated.\n *\n * Base values provide consistent behavior for non-idempotent transforms and\n * allow us to return the same latency-compensated value even if the backend\n * has already applied the transform operation. The base value is null for\n * idempotent transforms, as they can be re-played even if the backend has\n * already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent transforms.\n */\nfunction computeTransformOperationBaseValue(transform, previousValue) {\n    if (transform instanceof NumericIncrementTransformOperation) {\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\n    }\n    return null;\n}\nfunction transformOperationEquals(left, right) {\n    if (left instanceof ArrayUnionTransformOperation &&\n        right instanceof ArrayUnionTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof ArrayRemoveTransformOperation &&\n        right instanceof ArrayRemoveTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof NumericIncrementTransformOperation &&\n        right instanceof NumericIncrementTransformOperation) {\n        return valueEquals(left.operand, right.operand);\n    }\n    return (left instanceof ServerTimestampTransform &&\n        right instanceof ServerTimestampTransform);\n}\n/** Transforms a value into a server-generated timestamp. */\nclass ServerTimestampTransform extends TransformOperation {\n}\n/** Transforms an array value via a union operation. */\nclass ArrayUnionTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\n    const values = coercedFieldValuesArray(previousValue);\n    for (const toUnion of transform.elements) {\n        if (!values.some(element => valueEquals(element, toUnion))) {\n            values.push(toUnion);\n        }\n    }\n    return { arrayValue: { values } };\n}\n/** Transforms an array value via a remove operation. */\nclass ArrayRemoveTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\n    let values = coercedFieldValuesArray(previousValue);\n    for (const toRemove of transform.elements) {\n        values = values.filter(element => !valueEquals(element, toRemove));\n    }\n    return { arrayValue: { values } };\n}\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nclass NumericIncrementTransformOperation extends TransformOperation {\n    constructor(serializer, operand) {\n        super();\n        this.serializer = serializer;\n        this.operand = operand;\n    }\n}\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\n    // precision and resolves overflows by reducing precision, we do not\n    // manually cap overflows at 2^63.\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\n        return toInteger(sum);\n    }\n    else {\n        return toDouble(transform.serializer, sum);\n    }\n}\nfunction asNumber(value) {\n    return normalizeNumber(value.integerValue || value.doubleValue);\n}\nfunction coercedFieldValuesArray(value) {\n    return isArray(value) && value.arrayValue.values\n        ? value.arrayValue.values.slice()\n        : [];\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A field path and the TransformOperation to perform upon it. */\nclass FieldTransform {\n    constructor(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n}\nfunction fieldTransformEquals(left, right) {\n    return (left.field.isEqual(right.field) &&\n        transformOperationEquals(left.transform, right.transform));\n}\nfunction fieldTransformsAreEqual(left, right) {\n    if (left === undefined && right === undefined) {\n        return true;\n    }\n    if (left && right) {\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\n    }\n    return false;\n}\n/** The result of successfully applying a mutation to the backend. */\nclass MutationResult {\n    constructor(\n    /**\n     * The version at which the mutation was committed:\n     *\n     * - For most operations, this is the updateTime in the WriteResult.\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\n     *   not stored and have no updateTime).\n     *\n     * Note that these versions can be different: No-op writes will not change\n     * the updateTime even though the commitTime advances.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a mutation\n     * containing field transforms has been committed. Contains one FieldValue\n     * for each FieldTransform that was in the mutation.\n     *\n     * Will be empty if the mutation did not contain any field transforms.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n}\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nclass Precondition {\n    constructor(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n    }\n    /** Creates a new empty Precondition. */\n    static none() {\n        return new Precondition();\n    }\n    /** Creates a new Precondition with an exists flag. */\n    static exists(exists) {\n        return new Precondition(undefined, exists);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */\n    static updateTime(version) {\n        return new Precondition(version);\n    }\n    /** Returns whether this Precondition is empty. */\n    get isNone() {\n        return this.updateTime === undefined && this.exists === undefined;\n    }\n    isEqual(other) {\n        return (this.exists === other.exists &&\n            (this.updateTime\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\n                : !other.updateTime));\n    }\n}\n/** Returns true if the preconditions is valid for the given document. */\nfunction preconditionIsValidForDocument(precondition, document) {\n    if (precondition.updateTime !== undefined) {\n        return (document.isFoundDocument() &&\n            document.version.isEqual(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return precondition.exists === document.isFoundDocument();\n    }\n    else {\n        return true;\n    }\n}\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set and Patch mutations. For Delete mutations, we\n * reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        InvalidDocument(v0)   Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set and Patch mutations. As deletes have no\n * explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\n * the updated version.\n *\n * Field transforms are used only with Patch and Set Mutations. We use the\n * `updateTransforms` message to store transforms, rather than the `transforms`s\n * messages.\n *\n * ## Subclassing Notes\n *\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\n * example).\n */\nclass Mutation {\n}\n/**\n * A utility method to calculate a `Mutation` representing the overlay from the\n * final state of the document, and a `FieldMask` representing the fields that\n * are mutated by the local mutations.\n */\nfunction calculateOverlayMutation(doc, mask) {\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\n        return null;\n    }\n    // mask is null when sets or deletes are applied to the current document.\n    if (mask === null) {\n        if (doc.isNoDocument()) {\n            return new DeleteMutation(doc.key, Precondition.none());\n        }\n        else {\n            return new SetMutation(doc.key, doc.data, Precondition.none());\n        }\n    }\n    else {\n        const docValue = doc.data;\n        const patchValue = ObjectValue.empty();\n        let maskSet = new SortedSet(FieldPath$1.comparator);\n        for (let path of mask.fields) {\n            if (!maskSet.has(path)) {\n                let value = docValue.field(path);\n                // If we are deleting a nested field, we take the immediate parent as\n                // the mask used to construct the resulting mutation.\n                // Justification: Nested fields can create parent fields implicitly. If\n                // only a leaf entry is deleted in later mutations, the parent field\n                // should still remain, but we may have lost this information.\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\n                // has the correct result, `foo` is not in `mask`, and the resulting\n                // mutation would miss `foo`.\n                if (value === null && path.length > 1) {\n                    path = path.popLast();\n                    value = docValue.field(path);\n                }\n                if (value === null) {\n                    patchValue.delete(path);\n                }\n                else {\n                    patchValue.set(path, value);\n                }\n                maskSet = maskSet.add(path);\n            }\n        }\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing a\n * new remote document. If the input document doesn't match the expected state\n * (e.g. it is invalid or outdated), the document type may transition to\n * unknown.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param mutationResult - The result of applying the mutation from the backend.\n */\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (mutation instanceof SetMutation) {\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else if (mutation instanceof PatchMutation) {\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else {\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing\n * the new local view of a document. If the input document doesn't match the\n * expected state, the document is not modified.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param previousMask - The fields that have been updated before applying this mutation.\n * @param localWriteTime - A timestamp indicating the local write time of the\n *     batch this mutation is a part of.\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\n */\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (mutation instanceof SetMutation) {\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else if (mutation instanceof PatchMutation) {\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else {\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\n    }\n}\n/**\n * If this mutation is not idempotent, returns the base value to persist with\n * this mutation. If a base value is returned, the mutation is always applied\n * to this base value, even if document has already been updated.\n *\n * The base value is a sparse object that consists of only the document\n * fields for which this mutation contains a non-idempotent transformation\n * (e.g. a numeric increment). The provided value guarantees consistent\n * behavior for non-idempotent transforms and allow us to return the same\n * latency-compensated value even if the backend has already applied the\n * mutation. The base value is null for idempotent mutations, as they can be\n * re-played even if the backend has already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent mutations.\n */\nfunction mutationExtractBaseValue(mutation, document) {\n    let baseObject = null;\n    for (const fieldTransform of mutation.fieldTransforms) {\n        const existingValue = document.data.field(fieldTransform.field);\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\n        if (coercedValue != null) {\n            if (baseObject === null) {\n                baseObject = ObjectValue.empty();\n            }\n            baseObject.set(fieldTransform.field, coercedValue);\n        }\n    }\n    return baseObject ? baseObject : null;\n}\nfunction mutationEquals(left, right) {\n    if (left.type !== right.type) {\n        return false;\n    }\n    if (!left.key.isEqual(right.key)) {\n        return false;\n    }\n    if (!left.precondition.isEqual(right.precondition)) {\n        return false;\n    }\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\n        return false;\n    }\n    if (left.type === 0 /* MutationType.Set */) {\n        return left.value.isEqual(right.value);\n    }\n    if (left.type === 1 /* MutationType.Patch */) {\n        return (left.data.isEqual(right.data) &&\n            left.fieldMask.isEqual(right.fieldMask));\n    }\n    return true;\n}\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nclass SetMutation extends Mutation {\n    constructor(key, value, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.value = value;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 0 /* MutationType.Set */;\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\n    // remote document the server has accepted the mutation so the precondition\n    // must have held.\n    const newData = mutation.value.clone();\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // The mutation failed to apply (e.g. a document ID created with add()\n        // caused a name collision).\n        return previousMask;\n    }\n    const newData = mutation.value.clone();\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    return null; // SetMutation overwrites all fields.\n}\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nclass PatchMutation extends Mutation {\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 1 /* MutationType.Patch */;\n    }\n    getFieldMask() {\n        return this.fieldMask;\n    }\n}\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // Since the mutation was not rejected, we know that the precondition\n        // matched on the backend. We therefore must not have the expected version\n        // of the document in our cache and convert to an UnknownDocument with a\n        // known updateTime.\n        document.convertToUnknownDocument(mutationResult.version);\n        return;\n    }\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        return previousMask;\n    }\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    if (previousMask === null) {\n        return null;\n    }\n    return previousMask\n        .unionWith(mutation.fieldMask.fields)\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\n}\n/**\n * Returns a FieldPath/Value map with the content of the PatchMutation.\n */\nfunction getPatch(mutation) {\n    const result = new Map();\n    mutation.fieldMask.fields.forEach(fieldPath => {\n        if (!fieldPath.isEmpty()) {\n            const newValue = mutation.data.field(fieldPath);\n            result.set(fieldPath, newValue);\n        }\n    });\n    return result;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use after a mutation\n * containing transforms has been acknowledged by the server.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param mutableDocument - The current state of the document after applying all\n * previous mutations.\n * @param serverTransformResults - The transform results received by the server.\n * @returns The transform results list.\n */\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\n    const transformResults = new Map();\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\n    for (let i = 0; i < serverTransformResults.length; i++) {\n        const fieldTransform = fieldTransforms[i];\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\n    }\n    return transformResults;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use when applying a\n * transform locally.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param localWriteTime - The local time of the mutation (used to\n *     generate ServerTimestampValues).\n * @param mutableDocument - The document to apply transforms on.\n * @returns The transform results list.\n */\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\n    const transformResults = new Map();\n    for (const fieldTransform of fieldTransforms) {\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\n    }\n    return transformResults;\n}\n/** A mutation that deletes the document at the given key. */\nclass DeleteMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 2 /* MutationType.Delete */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n    document\n        .convertToNoDocument(mutationResult.version)\n        .setHasCommittedMutations();\n}\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\n        document.convertToNoDocument(document.version).setHasLocalMutations();\n        return null;\n    }\n    return previousMask;\n}\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nclass VerifyMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 3 /* MutationType.Verify */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nclass MutationBatch {\n    /**\n     * @param batchId - The unique ID of this mutation batch.\n     * @param localWriteTime - The original write time of this mutation.\n     * @param baseMutations - Mutations that are used to populate the base\n     * values when this mutation is applied locally. This can be used to locally\n     * overwrite values that are persisted in the remote document cache. Base\n     * mutations are never sent to the backend.\n     * @param mutations - The user-provided mutations in this mutation batch.\n     * User-provided mutations are applied both locally and remotely on the\n     * backend.\n     */\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.baseMutations = baseMutations;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to compute the state of the remote document\n     *\n     * @param document - The document to apply mutations to.\n     * @param batchResult - The result of applying the MutationBatch to the\n     * backend.\n     */\n    applyToRemoteDocument(document, batchResult) {\n        const mutationResults = batchResult.mutationResults;\n        for (let i = 0; i < this.mutations.length; i++) {\n            const mutation = this.mutations[i];\n            if (mutation.key.isEqual(document.key)) {\n                const mutationResult = mutationResults[i];\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\n            }\n        }\n    }\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param document - The document to apply mutations to.\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\n     * @returns A `FieldMask` representing all the fields that are mutated.\n     */\n    applyToLocalView(document, mutatedFields) {\n        // First, apply the base state. This allows us to apply non-idempotent\n        // transform against a consistent set of values.\n        for (const mutation of this.baseMutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        // Second, apply all user-provided mutations.\n        for (const mutation of this.mutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        return mutatedFields;\n    }\n    /**\n     * Computes the local view for all provided documents given the mutations in\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\n     * replace all the mutation applications.\n     */\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\n        // to O(n).\n        const overlays = newMutationMap();\n        this.mutations.forEach(m => {\n            const overlayedDocument = documentMap.get(m.key);\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\n            // and we should remove this cast.\n            const mutableDocument = overlayedDocument.overlayedDocument;\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\n            // Set mutatedFields to null if the document is only from local mutations.\n            // This creates a Set or Delete mutation, instead of trying to create a\n            // patch mutation as the overlay.\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\n                ? null\n                : mutatedFields;\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\n            if (overlay !== null) {\n                overlays.set(m.key, overlay);\n            }\n            if (!mutableDocument.isValidDocument()) {\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\n            }\n        });\n        return overlays;\n    }\n    keys() {\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    }\n    isEqual(other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\n    }\n}\n/** The result of applying a mutation batch to the backend. */\nclass MutationBatchResult {\n    constructor(batch, commitVersion, mutationResults, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=&gt;version mapping (docVersions).\n     */\n    static from(batch, commitVersion, results) {\n        hardAssert(batch.mutations.length === results.length);\n        let versionMap = documentVersionMap();\n        const mutations = batch.mutations;\n        for (let i = 0; i < mutations.length; i++) {\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Representation of an overlay computed by Firestore.\n *\n * Holds information about a mutation and the largest batch id in Firestore when\n * the mutation was created.\n */\nclass Overlay {\n    constructor(largestBatchId, mutation) {\n        this.largestBatchId = largestBatchId;\n        this.mutation = mutation;\n    }\n    getKey() {\n        return this.mutation.key;\n    }\n    isEqual(other) {\n        return other !== null && this.mutation === other.mutation;\n    }\n    toString() {\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ExistenceFilter {\n    constructor(count, unchangedNames) {\n        this.count = count;\n        this.unchangedNames = unchangedNames;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a non-write operation.\n *\n * See isPermanentWriteError for classifying write errors.\n */\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail();\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependent on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail();\n    }\n}\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a write operation.\n *\n * Write operations must be handled specially because as of b/119437764, ABORTED\n * errors on the write stream should be retried too (even though ABORTED errors\n * are not generally retryable).\n *\n * Note that during the initial handshake on the write stream an ABORTED error\n * signals that we should discard our stream token (i.e. it is permanent). This\n * means a handshake error should be classified with isPermanentError, above.\n */\nfunction isPermanentWriteError(code) {\n    return isPermanentError(code) && code !== Code.ABORTED;\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        logError('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error encountered while decoding base64 string.\n */\nclass Base64DecodeError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'Base64DecodeError';\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The global, singleton instance of TestingHooksSpi.\n *\n * This variable will be `null` in all cases _except_ when running from\n * integration tests that have registered callbacks to be notified of events\n * that happen during the test execution.\n */\nlet testingHooksSpi = null;\n/**\n * Sets the value of the `testingHooksSpi` object.\n * @param instance the instance to set.\n */\nfunction setTestingHooksSpi(instance) {\n    if (testingHooksSpi) {\n        throw new Error('a TestingHooksSpi instance is already set');\n    }\n    testingHooksSpi = instance;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An instance of the Platform's 'TextEncoder' implementation.\n */\nfunction newTextEncoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\n}\n/**\n * An instance of the Platform's 'TextDecoder' implementation.\n */\nfunction newTextDecoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([0xffffffff, 0xffffffff], 0);\n// Hash a string using md5 hashing algorithm.\nfunction getMd5HashValue(value) {\n    const encodedValue = newTextEncoder().encode(value);\n    const md5 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Md5();\n    md5.update(encodedValue);\n    return new Uint8Array(md5.digest());\n}\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\n// 2’s complement using little endian.\nfunction get64BitUints(Bytes) {\n    const dataView = new DataView(Bytes.buffer);\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\n    const integer1 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk1, chunk2], 0);\n    const integer2 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk3, chunk4], 0);\n    return [integer1, integer2];\n}\nclass BloomFilter {\n    constructor(bitmap, padding, hashCount) {\n        this.bitmap = bitmap;\n        this.padding = padding;\n        this.hashCount = hashCount;\n        if (padding < 0 || padding >= 8) {\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\n        }\n        if (hashCount < 0) {\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length > 0 && this.hashCount === 0) {\n            // Only empty bloom filter can have 0 hash count.\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length === 0 && padding !== 0) {\n            // Empty bloom filter should have 0 padding.\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\n        }\n        this.bitCount = bitmap.length * 8 - padding;\n        // Set the bit count in Integer to avoid repetition in mightContain().\n        this.bitCountInInteger = _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(this.bitCount);\n    }\n    // Calculate the ith hash value based on the hashed 64bit integers,\n    // and calculate its corresponding bit index in the bitmap to be checked.\n    getBitIndex(num1, num2, hashIndex) {\n        // Calculate hashed value h(i) = h1 + (i * h2).\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(hashIndex)));\n        // Wrap if hash value overflow 64bit.\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\n            hashValue = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\n        }\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\n    }\n    // Return whether the bit on the given index in the bitmap is set to 1.\n    isBitSet(index) {\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\n        const byte = this.bitmap[Math.floor(index / 8)];\n        const offset = index % 8;\n        return (byte & (0x01 << offset)) !== 0;\n    }\n    mightContain(value) {\n        // Empty bitmap should always return false on membership check.\n        if (this.bitCount === 0) {\n            return false;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            if (!this.isBitSet(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** Create bloom filter for testing purposes only. */\n    static create(bitCount, hashCount, contains) {\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\n        contains.forEach(item => bloomFilter.insert(item));\n        return bloomFilter;\n    }\n    insert(value) {\n        if (this.bitCount === 0) {\n            return;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            this.setBit(index);\n        }\n    }\n    setBit(index) {\n        const indexOfByte = Math.floor(index / 8);\n        const offset = index % 8;\n        this.bitmap[indexOfByte] |= 0x01 << offset;\n    }\n}\nclass BloomFilterError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BloomFilterError';\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nclass RemoteEvent {\n    constructor(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A map of targets that is known to be inconsistent, and the purpose for\n     * re-listening. Listens for these targets should be re-established without\n     * resume tokens.\n     */\n    targetMismatches, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates, \n    /**\n     * A set of which document updates are due only to limbo resolution targets.\n     */\n    resolvedLimboDocuments) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.targetMismatches = targetMismatches;\n        this.documentUpdates = documentUpdates;\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\n    }\n    /**\n     * HACK: Views require RemoteEvents in order to determine whether the view is\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\n     * used to create a synthesized RemoteEvent that can be used to apply a\n     * CURRENT status change to a View, for queries executed in a different tab.\n     */\n    // PORTING NOTE: Multi-tab only\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\n        const targetChanges = new Map();\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\n    }\n}\n/**\n * A TargetChange specifies the set of changes for a specific target as part of\n * a RemoteEvent. These changes track which documents are added, modified or\n * removed, as well as the target's resume token and whether the target is\n * marked CURRENT.\n * The actual changes *to* documents are not part of the TargetChange since\n * documents may be part of multiple targets.\n */\nclass TargetChange {\n    constructor(\n    /**\n     * An opaque, server-assigned token that allows watching a query to be resumed\n     * after disconnecting without retransmitting all the data that matches the\n     * query. The resume token essentially identifies a point in time from which\n     * the server should resume sending results.\n     */\n    resumeToken, \n    /**\n     * The \"current\" (synced) status of this target. Note that \"current\"\n     * has special meaning in the RPC protocol that implies that a target is\n     * both up-to-date and consistent with the rest of the watch stream.\n     */\n    current, \n    /**\n     * The set of documents that were newly assigned to this target as part of\n     * this remote event.\n     */\n    addedDocuments, \n    /**\n     * The set of documents that were already assigned to this target but received\n     * an update during this remote event.\n     */\n    modifiedDocuments, \n    /**\n     * The set of documents that were removed from this target as part of this\n     * remote event.\n     */\n    removedDocuments) {\n        this.resumeToken = resumeToken;\n        this.current = current;\n        this.addedDocuments = addedDocuments;\n        this.modifiedDocuments = modifiedDocuments;\n        this.removedDocuments = removedDocuments;\n    }\n    /**\n     * This method is used to create a synthesized TargetChanges that can be used to\n     * apply a CURRENT status change to a View (for queries executed in a different\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\n     */\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nclass DocumentWatchChange {\n    constructor(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n}\nclass ExistenceFilterChange {\n    constructor(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n}\nclass WatchTargetChange {\n    constructor(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /** An RPC error indicating why the watch failed. */\n    cause = null) {\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n}\n/** Tracks the internal state of a Watch target. */\nclass TargetState {\n    constructor() {\n        /**\n         * The number of pending responses (adds or removes) that we are waiting on.\n         * We only consider targets active that have no pending responses.\n         */\n        this.pendingResponses = 0;\n        /**\n         * Keeps track of the document changes since the last raised snapshot.\n         *\n         * These changes are continuously updated as we receive document updates and\n         * always reflect the current set of changes against the last issued snapshot.\n         */\n        this.documentChanges = snapshotChangesMap();\n        /** See public getters for explanations of these fields. */\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\n        this._current = false;\n        /**\n         * Whether this target state should be included in the next snapshot. We\n         * initialize to true so that newly-added targets are included in the next\n         * RemoteEvent.\n         */\n        this._hasPendingChanges = true;\n    }\n    /**\n     * Whether this target has been marked 'current'.\n     *\n     * 'Current' has special meaning in the RPC protocol: It implies that the\n     * Watch backend has sent us all changes up to the point at which the target\n     * was added and that the target is consistent with the rest of the watch\n     * stream.\n     */\n    get current() {\n        return this._current;\n    }\n    /** The last resume token sent to us for this target. */\n    get resumeToken() {\n        return this._resumeToken;\n    }\n    /** Whether this target has pending target adds or target removes. */\n    get isPending() {\n        return this.pendingResponses !== 0;\n    }\n    /** Whether we have modified any state that should trigger a snapshot. */\n    get hasPendingChanges() {\n        return this._hasPendingChanges;\n    }\n    /**\n     * Applies the resume token to the TargetChange, but only when it has a new\n     * value. Empty resumeTokens are discarded.\n     */\n    updateResumeToken(resumeToken) {\n        if (resumeToken.approximateByteSize() > 0) {\n            this._hasPendingChanges = true;\n            this._resumeToken = resumeToken;\n        }\n    }\n    /**\n     * Creates a target change from the current set of changes.\n     *\n     * To reset the document changes after raising this snapshot, call\n     * `clearPendingChanges()`.\n     */\n    toTargetChange() {\n        let addedDocuments = documentKeySet();\n        let modifiedDocuments = documentKeySet();\n        let removedDocuments = documentKeySet();\n        this.documentChanges.forEach((key, changeType) => {\n            switch (changeType) {\n                case 0 /* ChangeType.Added */:\n                    addedDocuments = addedDocuments.add(key);\n                    break;\n                case 2 /* ChangeType.Modified */:\n                    modifiedDocuments = modifiedDocuments.add(key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedDocuments = removedDocuments.add(key);\n                    break;\n                default:\n                    fail();\n            }\n        });\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\n    }\n    /**\n     * Resets the document changes and sets `hasPendingChanges` to false.\n     */\n    clearPendingChanges() {\n        this._hasPendingChanges = false;\n        this.documentChanges = snapshotChangesMap();\n    }\n    addDocumentChange(key, changeType) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.insert(key, changeType);\n    }\n    removeDocumentChange(key) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.remove(key);\n    }\n    recordPendingTargetRequest() {\n        this.pendingResponses += 1;\n    }\n    recordTargetResponse() {\n        this.pendingResponses -= 1;\n        hardAssert(this.pendingResponses >= 0);\n    }\n    markCurrent() {\n        this._hasPendingChanges = true;\n        this._current = true;\n    }\n}\nconst LOG_TAG$g = 'WatchChangeAggregator';\n/**\n * A helper class to accumulate watch changes into a RemoteEvent.\n */\nclass WatchChangeAggregator {\n    constructor(metadataProvider) {\n        this.metadataProvider = metadataProvider;\n        /** The internal state of all tracked targets. */\n        this.targetStates = new Map();\n        /** Keeps track of the documents to update since the last raised snapshot. */\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        /** A mapping of document keys to their set of target IDs. */\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        /**\n         * A map of targets with existence filter mismatches. These targets are\n         * known to be inconsistent and their listens needs to be re-established by\n         * RemoteStore.\n         */\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n    }\n    /**\n     * Processes and adds the DocumentWatchChange to the current set of changes.\n     */\n    handleDocumentChange(docChange) {\n        for (const targetId of docChange.updatedTargetIds) {\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\n                this.addDocumentToTarget(targetId, docChange.newDoc);\n            }\n            else {\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n            }\n        }\n        for (const targetId of docChange.removedTargetIds) {\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n        }\n    }\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\n    handleTargetChange(targetChange) {\n        this.forEachTarget(targetChange, targetId => {\n            const targetState = this.ensureTargetState(targetId);\n            switch (targetChange.state) {\n                case 0 /* WatchTargetChangeState.NoChange */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 1 /* WatchTargetChangeState.Added */:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously. This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        targetState.clearPendingChanges();\n                    }\n                    targetState.updateResumeToken(targetChange.resumeToken);\n                    break;\n                case 2 /* WatchTargetChangeState.Removed */:\n                    // We need to keep track of removed targets to we can post-filter and\n                    // remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        this.removeTarget(targetId);\n                    }\n                    break;\n                case 3 /* WatchTargetChangeState.Current */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.markCurrent();\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 4 /* WatchTargetChangeState.Reset */:\n                    if (this.isActiveTarget(targetId)) {\n                        // Reset the target and synthesizes removes for all existing\n                        // documents. The backend will re-add any documents that still\n                        // match the target before it sends the next global snapshot.\n                        this.resetTarget(targetId);\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail();\n            }\n        });\n    }\n    /**\n     * Iterates over all targetIds that the watch change applies to: either the\n     * targetIds explicitly listed in the change or the targetIds of all currently\n     * active targets.\n     */\n    forEachTarget(targetChange, fn) {\n        if (targetChange.targetIds.length > 0) {\n            targetChange.targetIds.forEach(fn);\n        }\n        else {\n            this.targetStates.forEach((_, targetId) => {\n                if (this.isActiveTarget(targetId)) {\n                    fn(targetId);\n                }\n            });\n        }\n    }\n    /**\n     * Handles existence filters and synthesizes deletes for filter mismatches.\n     * Targets that are invalidated by filter mismatches are added to\n     * `pendingTargetResets`.\n     */\n    handleExistenceFilter(watchChange) {\n        const targetId = watchChange.targetId;\n        const expectedCount = watchChange.existenceFilter.count;\n        const targetData = this.targetDataForActiveTarget(targetId);\n        if (targetData) {\n            const target = targetData.target;\n            if (targetIsDocumentTarget(target)) {\n                if (expectedCount === 0) {\n                    // The existence filter told us the document does not exist. We deduce\n                    // that this document does not exist and apply a deleted document to\n                    // our updates. Without applying this deleted document there might be\n                    // another query that will raise this document as part of a snapshot\n                    // until it is resolved, essentially exposing inconsistency between\n                    // queries.\n                    const key = new DocumentKey(target.path);\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\n                }\n                else {\n                    hardAssert(expectedCount === 1);\n                }\n            }\n            else {\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\n                // Existence filter mismatch. Mark the documents as being in limbo, and\n                // raise a snapshot with `isFromCache:true`.\n                if (currentSize !== expectedCount) {\n                    // Apply bloom filter to identify and mark removed documents.\n                    const bloomFilter = this.parseBloomFilter(watchChange);\n                    const status = bloomFilter\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\n                        // If bloom filter application fails, we reset the mapping and\n                        // trigger re-run of the query.\n                        this.resetTarget(targetId);\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\n                    }\n                    testingHooksSpi === null || testingHooksSpi === void 0 ? void 0 : testingHooksSpi.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\n                }\n            }\n        }\n    }\n    /**\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\n     * filter.\n     */\n    parseBloomFilter(watchChange) {\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\n        if (!unchangedNames || !unchangedNames.bits) {\n            return null;\n        }\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\n        let normalizedBitmap;\n        try {\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\n        }\n        catch (err) {\n            if (err instanceof Base64DecodeError) {\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\n                    err.message +\n                    '); ignoring the bloom filter and falling back to full re-query.');\n                return null;\n            }\n            else {\n                throw err;\n            }\n        }\n        let bloomFilter;\n        try {\n            // BloomFilter throws error if the inputs are invalid.\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\n        }\n        catch (err) {\n            if (err instanceof BloomFilterError) {\n                logWarn('BloomFilter error: ', err);\n            }\n            else {\n                logWarn('Applying bloom filter failed: ', err);\n            }\n            return null;\n        }\n        if (bloomFilter.bitCount === 0) {\n            return null;\n        }\n        return bloomFilter;\n    }\n    /**\n     * Apply bloom filter to remove the deleted documents, and return the\n     * application status.\n     */\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\n        const expectedCount = watchChange.existenceFilter.count;\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\n        return expectedCount === currentCount - removedDocumentCount\n            ? 0 /* BloomFilterApplicationStatus.Success */\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\n    }\n    /**\n     * Filter out removed documents based on bloom filter membership result and\n     * return number of documents removed.\n     */\n    filterRemovedDocuments(bloomFilter, targetId) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        let removalCount = 0;\n        existingKeys.forEach(key => {\n            const databaseId = this.metadataProvider.getDatabaseId();\n            const documentPath = `projects/${databaseId.projectId}` +\n                `/databases/${databaseId.database}` +\n                `/documents/${key.path.canonicalString()}`;\n            if (!bloomFilter.mightContain(documentPath)) {\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n                removalCount++;\n            }\n        });\n        return removalCount;\n    }\n    /**\n     * Converts the currently accumulated state into a remote event at the\n     * provided snapshot version. Resets the accumulated changes before returning.\n     */\n    createRemoteEvent(snapshotVersion) {\n        const targetChanges = new Map();\n        this.targetStates.forEach((targetState, targetId) => {\n            const targetData = this.targetDataForActiveTarget(targetId);\n            if (targetData) {\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\n                    // Document queries for document that don't exist can produce an empty\n                    // result set. To update our local cache, we synthesize a document\n                    // delete if we have not previously received the document for this\n                    // target. This resolves the limbo state of the document, removing it\n                    // from limboDocumentRefs.\n                    //\n                    // TODO(dimond): Ideally we would have an explicit lookup target\n                    // instead resulting in an explicit delete message and we could\n                    // remove this special logic.\n                    const key = new DocumentKey(targetData.target.path);\n                    if (!this.ensureDocumentUpdateByTarget(key).has(targetId) &&\n                        !this.targetContainsDocument(targetId, key)) {\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\n                    }\n                }\n                if (targetState.hasPendingChanges) {\n                    targetChanges.set(targetId, targetState.toTargetChange());\n                    targetState.clearPendingChanges();\n                }\n            }\n        });\n        let resolvedLimboDocuments = documentKeySet();\n        // We extract the set of limbo-only document updates as the GC logic\n        // special-cases documents that do not appear in the target cache.\n        //\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\n        // client.\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\n            let isOnlyLimboTarget = true;\n            targets.forEachWhile(targetId => {\n                const targetData = this.targetDataForActiveTarget(targetId);\n                if (targetData &&\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\n                    isOnlyLimboTarget = false;\n                    return false;\n                }\n                return true;\n            });\n            if (isOnlyLimboTarget) {\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\n            }\n        });\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n        return remoteEvent;\n    }\n    /**\n     * Adds the provided document to the internal list of document updates and\n     * its document key to the given target's mapping.\n     */\n    // Visible for testing.\n    addDocumentToTarget(targetId, document) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const changeType = this.targetContainsDocument(targetId, document.key)\n            ? 2 /* ChangeType.Modified */\n            : 0 /* ChangeType.Added */;\n        const targetState = this.ensureTargetState(targetId);\n        targetState.addDocumentChange(document.key, changeType);\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\n        this.pendingDocumentUpdatesByTarget =\n            this.pendingDocumentUpdatesByTarget.insert(document.key, this.ensureDocumentUpdateByTarget(document.key).add(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\n    }\n    /**\n     * Removes the provided document from the target mapping. If the\n     * document no longer matches the target, but the document's state is still\n     * known (e.g. we know that the document was deleted or we received the change\n     * that caused the filter mismatch), the new document can be provided\n     * to update the remote document cache.\n     */\n    // Visible for testing.\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const targetState = this.ensureTargetState(targetId);\n        if (this.targetContainsDocument(targetId, key)) {\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\n        }\n        else {\n            // The document may have entered and left the target before we raised a\n            // snapshot, so we can just ignore the change.\n            targetState.removeDocumentChange(key);\n        }\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).add(targetId));\n        if (updatedDocument) {\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\n        }\n    }\n    removeTarget(targetId) {\n        this.targetStates.delete(targetId);\n    }\n    /**\n     * Returns the current count of documents in the target. This includes both\n     * the number of documents that the LocalStore considers to be part of the\n     * target as well as any accumulated changes.\n     */\n    getCurrentDocumentCountForTarget(targetId) {\n        const targetState = this.ensureTargetState(targetId);\n        const targetChange = targetState.toTargetChange();\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\n            targetChange.addedDocuments.size -\n            targetChange.removedDocuments.size);\n    }\n    /**\n     * Increment the number of acks needed from watch before we can consider the\n     * server to be 'in-sync' with the client's active targets.\n     */\n    recordPendingTargetRequest(targetId) {\n        // For each request we get we need to record we need a response for it.\n        const targetState = this.ensureTargetState(targetId);\n        targetState.recordPendingTargetRequest();\n    }\n    ensureTargetState(targetId) {\n        let result = this.targetStates.get(targetId);\n        if (!result) {\n            result = new TargetState();\n            this.targetStates.set(targetId, result);\n        }\n        return result;\n    }\n    ensureDocumentTargetMapping(key) {\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentTargetMapping =\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    ensureDocumentUpdateByTarget(key) {\n        let targetMapping = this.pendingDocumentUpdatesByTarget.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentUpdatesByTarget =\n                this.pendingDocumentUpdatesByTarget.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    /**\n     * Verifies that the user is still interested in this target (by calling\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\n     * from watch.\n     */\n    isActiveTarget(targetId) {\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\n        if (!targetActive) {\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\n        }\n        return targetActive;\n    }\n    /**\n     * Returns the TargetData for an active target (i.e. a target that the user\n     * is still interested in that has no outstanding target change requests).\n     */\n    targetDataForActiveTarget(targetId) {\n        const targetState = this.targetStates.get(targetId);\n        return targetState && targetState.isPending\n            ? null\n            : this.metadataProvider.getTargetDataForTarget(targetId);\n    }\n    /**\n     * Resets the state of a Watch target to its initial state (e.g. sets\n     * 'current' to false, clears the resume token and removes its target mapping\n     * from all documents).\n     */\n    resetTarget(targetId) {\n        this.targetStates.set(targetId, new TargetState());\n        // Trigger removal for any documents currently mapped to this target.\n        // These removals will be part of the initial snapshot if Watch does not\n        // resend these documents.\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        existingKeys.forEach(key => {\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n        });\n    }\n    /**\n     * Returns whether the LocalStore considers the document to be part of the\n     * specified target.\n     */\n    targetContainsDocument(targetId, key) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        return existingKeys.has(key);\n    }\n}\nfunction documentTargetMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction snapshotChangesMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\n    var _a, _b, _c, _d, _e, _f;\n    const result = {\n        localCacheCount,\n        existenceFilterCount: existenceFilter.count,\n        databaseId: databaseId.database,\n        projectId: databaseId.projectId\n    };\n    const unchangedNames = existenceFilter.unchangedNames;\n    if (unchangedNames) {\n        result.bloomFilter = {\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\n            hashCount: (_a = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.hashCount) !== null && _a !== void 0 ? _a : 0,\n            bitmapLength: (_d = (_c = (_b = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _b === void 0 ? void 0 : _b.bitmap) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n            padding: (_f = (_e = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _e === void 0 ? void 0 : _e.padding) !== null && _f !== void 0 ? _f : 0,\n            mightContain: (value) => { var _a; return (_a = bloomFilter === null || bloomFilter === void 0 ? void 0 : bloomFilter.mightContain(value)) !== null && _a !== void 0 ? _a : false; }\n        };\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DIRECTIONS = (() => {\n    const dirs = {};\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\n    return dirs;\n})();\nconst OPERATORS = (() => {\n    const ops = {};\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\n    ops[\"in\" /* Operator.IN */] = 'IN';\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\n    return ops;\n})();\nconst COMPOSITE_OPERATORS = (() => {\n    const ops = {};\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n}\n/**\n * This class generates JsonObject values for the Datastore API suitable for\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\n *\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\n * format.\n *\n * For a description of the Proto3 JSON format check\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n *\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nclass JsonProtoSerializer {\n    constructor(databaseId, useProto3Json) {\n        this.databaseId = databaseId;\n        this.useProto3Json = useProto3Json;\n    }\n}\nfunction fromRpcStatus(status) {\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n}\n/**\n * Returns a value for a number (or null) that's appropriate to put into\n * a google.protobuf.Int32Value proto.\n * DO NOT USE THIS FOR ANYTHING ELSE.\n * This method cheats. It's typed as returning \"number\" because that's what\n * our generated proto interfaces say Int32Value must be. But GRPC actually\n * expects a { value: <number> } struct.\n */\nfunction toInt32Proto(serializer, val) {\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\n        return val;\n    }\n    else {\n        return { value: val };\n    }\n}\n/**\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\n */\nfunction fromInt32Proto(val) {\n    let result;\n    if (typeof val === 'object') {\n        result = val.value;\n    }\n    else {\n        result = val;\n    }\n    return isNullOrUndefined(result) ? null : result;\n}\n/**\n * Returns a value for a Date that's appropriate to put into a proto.\n */\nfunction toTimestamp(serializer, timestamp) {\n    if (serializer.useProto3Json) {\n        // Serialize to ISO-8601 date format, but with full nano resolution.\n        // Since JS Date has only millis, let's only use it for the seconds and\n        // then manually add the fractions to the end.\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n        // Remove .xxx frac part and Z in the end.\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\n        // Pad the fraction out to 9 digits (nanos).\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\n        return `${strUntilSeconds}.${nanoStr}Z`;\n    }\n    else {\n        return {\n            seconds: '' + timestamp.seconds,\n            nanos: timestamp.nanoseconds\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        };\n    }\n}\nfunction fromTimestamp(date) {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n}\n/**\n * Returns a value for bytes that's appropriate to put in a proto.\n *\n * Visible for testing.\n */\nfunction toBytes(serializer, bytes) {\n    if (serializer.useProto3Json) {\n        return bytes.toBase64();\n    }\n    else {\n        return bytes.toUint8Array();\n    }\n}\n/**\n * Returns a ByteString based on the proto string value.\n */\nfunction fromBytes(serializer, value) {\n    if (serializer.useProto3Json) {\n        hardAssert(value === undefined || typeof value === 'string');\n        return ByteString.fromBase64String(value ? value : '');\n    }\n    else {\n        hardAssert(value === undefined ||\n            // Check if the value is an instance of both Buffer and Uint8Array,\n            // despite the fact that Buffer extends Uint8Array. In some\n            // environments, such as jsdom, the prototype chain of Buffer\n            // does not indicate that it extends Uint8Array.\n            value instanceof Buffer ||\n            value instanceof Uint8Array);\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\n    }\n}\nfunction toVersion(serializer, version) {\n    return toTimestamp(serializer, version.toTimestamp());\n}\nfunction fromVersion(version) {\n    hardAssert(!!version);\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\n}\nfunction toResourceName(databaseId, path) {\n    return toResourcePath(databaseId, path).canonicalString();\n}\nfunction toResourcePath(databaseId, path) {\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\n    return path === undefined ? resourcePath : resourcePath.child(path);\n}\nfunction fromResourceName(name) {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(isValidResourceName(resource));\n    return resource;\n}\nfunction toName(serializer, key) {\n    return toResourceName(serializer.databaseId, key.path);\n}\nfunction fromName(serializer, name) {\n    const resource = fromResourceName(name);\n    if (resource.get(1) !== serializer.databaseId.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            serializer.databaseId.projectId);\n    }\n    if (resource.get(3) !== serializer.databaseId.database) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            serializer.databaseId.database);\n    }\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\n}\nfunction toQueryPath(serializer, path) {\n    return toResourceName(serializer.databaseId, path);\n}\nfunction fromQueryPath(name) {\n    const resourceName = fromResourceName(name);\n    // In v1beta1 queries for collections at the root did not have a trailing\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\n    // ability to read the v1beta1 form for compatibility with queries persisted\n    // in the local target cache.\n    if (resourceName.length === 4) {\n        return ResourcePath.emptyPath();\n    }\n    return extractLocalPathFromResourceName(resourceName);\n}\nfunction getEncodedDatabaseId(serializer) {\n    const path = new ResourcePath([\n        'projects',\n        serializer.databaseId.projectId,\n        'databases',\n        serializer.databaseId.database\n    ]);\n    return path.canonicalString();\n}\nfunction fullyQualifiedPrefixPath(databaseId) {\n    return new ResourcePath([\n        'projects',\n        databaseId.projectId,\n        'databases',\n        databaseId.database\n    ]);\n}\nfunction extractLocalPathFromResourceName(resourceName) {\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\n    return resourceName.popFirst(5);\n}\n/** Creates a Document proto from key and fields (but no create/update time) */\nfunction toMutationDocument(serializer, key, fields) {\n    return {\n        name: toName(serializer, key),\n        fields: fields.value.mapValue.fields\n    };\n}\nfunction toDocument(serializer, document) {\n    return {\n        name: toName(serializer, document.key),\n        fields: document.data.value.mapValue.fields,\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\n    };\n}\nfunction fromDocument(serializer, document, hasCommittedMutations) {\n    const key = fromName(serializer, document.name);\n    const version = fromVersion(document.updateTime);\n    // If we read a document from persistence that is missing createTime, it's due\n    // to older SDK versions not storing this information. In such cases, we'll\n    // set the createTime to zero. This can be removed in the long term.\n    const createTime = document.createTime\n        ? fromVersion(document.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\n    if (hasCommittedMutations) {\n        result.setHasCommittedMutations();\n    }\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\n}\nfunction fromFound(serializer, doc) {\n    hardAssert(!!doc.found);\n    assertPresent(doc.found.name);\n    assertPresent(doc.found.updateTime);\n    const key = fromName(serializer, doc.found.name);\n    const version = fromVersion(doc.found.updateTime);\n    const createTime = doc.found.createTime\n        ? fromVersion(doc.found.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\n}\nfunction fromMissing(serializer, result) {\n    hardAssert(!!result.missing);\n    hardAssert(!!result.readTime);\n    const key = fromName(serializer, result.missing);\n    const version = fromVersion(result.readTime);\n    return MutableDocument.newNoDocument(key, version);\n}\nfunction fromBatchGetDocumentsResponse(serializer, result) {\n    if ('found' in result) {\n        return fromFound(serializer, result);\n    }\n    else if ('missing' in result) {\n        return fromMissing(serializer, result);\n    }\n    return fail();\n}\nfunction fromWatchChange(serializer, change) {\n    let watchChange;\n    if ('targetChange' in change) {\n        assertPresent(change.targetChange);\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n        // if unset\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n        const targetIds = change.targetChange.targetIds || [];\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\n        const causeProto = change.targetChange.cause;\n        const cause = causeProto && fromRpcStatus(causeProto);\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n    }\n    else if ('documentChange' in change) {\n        assertPresent(change.documentChange);\n        const entityChange = change.documentChange;\n        assertPresent(entityChange.document);\n        assertPresent(entityChange.document.name);\n        assertPresent(entityChange.document.updateTime);\n        const key = fromName(serializer, entityChange.document.name);\n        const version = fromVersion(entityChange.document.updateTime);\n        const createTime = entityChange.document.createTime\n            ? fromVersion(entityChange.document.createTime)\n            : SnapshotVersion.min();\n        const data = new ObjectValue({\n            mapValue: { fields: entityChange.document.fields }\n        });\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\n        const updatedTargetIds = entityChange.targetIds || [];\n        const removedTargetIds = entityChange.removedTargetIds || [];\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n    }\n    else if ('documentDelete' in change) {\n        assertPresent(change.documentDelete);\n        const docDelete = change.documentDelete;\n        assertPresent(docDelete.document);\n        const key = fromName(serializer, docDelete.document);\n        const version = docDelete.readTime\n            ? fromVersion(docDelete.readTime)\n            : SnapshotVersion.min();\n        const doc = MutableDocument.newNoDocument(key, version);\n        const removedTargetIds = docDelete.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    }\n    else if ('documentRemove' in change) {\n        assertPresent(change.documentRemove);\n        const docRemove = change.documentRemove;\n        assertPresent(docRemove.document);\n        const key = fromName(serializer, docRemove.document);\n        const removedTargetIds = docRemove.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    }\n    else if ('filter' in change) {\n        // TODO(dimond): implement existence filter parsing with strategy.\n        assertPresent(change.filter);\n        const filter = change.filter;\n        assertPresent(filter.targetId);\n        const { count = 0, unchangedNames } = filter;\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\n        const targetId = filter.targetId;\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    }\n    else {\n        return fail();\n    }\n    return watchChange;\n}\nfunction fromWatchTargetChangeState(state) {\n    if (state === 'NO_CHANGE') {\n        return 0 /* WatchTargetChangeState.NoChange */;\n    }\n    else if (state === 'ADD') {\n        return 1 /* WatchTargetChangeState.Added */;\n    }\n    else if (state === 'REMOVE') {\n        return 2 /* WatchTargetChangeState.Removed */;\n    }\n    else if (state === 'CURRENT') {\n        return 3 /* WatchTargetChangeState.Current */;\n    }\n    else if (state === 'RESET') {\n        return 4 /* WatchTargetChangeState.Reset */;\n    }\n    else {\n        return fail();\n    }\n}\nfunction versionFromListenResponse(change) {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    if (!('targetChange' in change)) {\n        return SnapshotVersion.min();\n    }\n    const targetChange = change.targetChange;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n        return SnapshotVersion.min();\n    }\n    if (!targetChange.readTime) {\n        return SnapshotVersion.min();\n    }\n    return fromVersion(targetChange.readTime);\n}\nfunction toMutation(serializer, mutation) {\n    let result;\n    if (mutation instanceof SetMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\n        };\n    }\n    else if (mutation instanceof DeleteMutation) {\n        result = { delete: toName(serializer, mutation.key) };\n    }\n    else if (mutation instanceof PatchMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\n            updateMask: toDocumentMask(mutation.fieldMask)\n        };\n    }\n    else if (mutation instanceof VerifyMutation) {\n        result = {\n            verify: toName(serializer, mutation.key)\n        };\n    }\n    else {\n        return fail();\n    }\n    if (mutation.fieldTransforms.length > 0) {\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\n    }\n    if (!mutation.precondition.isNone) {\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\n    }\n    return result;\n}\nfunction fromMutation(serializer, proto) {\n    const precondition = proto.currentDocument\n        ? fromPrecondition(proto.currentDocument)\n        : Precondition.none();\n    const fieldTransforms = proto.updateTransforms\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\n        : [];\n    if (proto.update) {\n        assertPresent(proto.update.name);\n        const key = fromName(serializer, proto.update.name);\n        const value = new ObjectValue({\n            mapValue: { fields: proto.update.fields }\n        });\n        if (proto.updateMask) {\n            const fieldMask = fromDocumentMask(proto.updateMask);\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, value, precondition, fieldTransforms);\n        }\n    }\n    else if (proto.delete) {\n        const key = fromName(serializer, proto.delete);\n        return new DeleteMutation(key, precondition);\n    }\n    else if (proto.verify) {\n        const key = fromName(serializer, proto.verify);\n        return new VerifyMutation(key, precondition);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toPrecondition(serializer, precondition) {\n    if (precondition.updateTime !== undefined) {\n        return {\n            updateTime: toVersion(serializer, precondition.updateTime)\n        };\n    }\n    else if (precondition.exists !== undefined) {\n        return { exists: precondition.exists };\n    }\n    else {\n        return fail();\n    }\n}\nfunction fromPrecondition(precondition) {\n    if (precondition.updateTime !== undefined) {\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return Precondition.exists(precondition.exists);\n    }\n    else {\n        return Precondition.none();\n    }\n}\nfunction fromWriteResult(proto, commitTime) {\n    // NOTE: Deletes don't have an updateTime.\n    let version = proto.updateTime\n        ? fromVersion(proto.updateTime)\n        : fromVersion(commitTime);\n    if (version.isEqual(SnapshotVersion.min())) {\n        // The Firestore Emulator currently returns an update time of 0 for\n        // deletes of non-existing documents (rather than null). This breaks the\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\n        // TODO(#2149): Remove this when Emulator is fixed\n        version = fromVersion(commitTime);\n    }\n    return new MutationResult(version, proto.transformResults || []);\n}\nfunction fromWriteResults(protos, commitTime) {\n    if (protos && protos.length > 0) {\n        hardAssert(commitTime !== undefined);\n        return protos.map(proto => fromWriteResult(proto, commitTime));\n    }\n    else {\n        return [];\n    }\n}\nfunction toFieldTransform(serializer, fieldTransform) {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            appendMissingElements: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            removeAllFromArray: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof NumericIncrementTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            increment: transform.operand\n        };\n    }\n    else {\n        throw fail();\n    }\n}\nfunction fromFieldTransform(serializer, proto) {\n    let transform = null;\n    if ('setToServerValue' in proto) {\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\n        transform = new ServerTimestampTransform();\n    }\n    else if ('appendMissingElements' in proto) {\n        const values = proto.appendMissingElements.values || [];\n        transform = new ArrayUnionTransformOperation(values);\n    }\n    else if ('removeAllFromArray' in proto) {\n        const values = proto.removeAllFromArray.values || [];\n        transform = new ArrayRemoveTransformOperation(values);\n    }\n    else if ('increment' in proto) {\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\n    }\n    else {\n        fail();\n    }\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\n    return new FieldTransform(fieldPath, transform);\n}\nfunction toDocumentsTarget(serializer, target) {\n    return { documents: [toQueryPath(serializer, target.path)] };\n}\nfunction fromDocumentsTarget(documentsTarget) {\n    const count = documentsTarget.documents.length;\n    hardAssert(count === 1);\n    const name = documentsTarget.documents[0];\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\n}\nfunction toQueryTarget(serializer, target) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const queryTarget = { structuredQuery: {} };\n    const path = target.path;\n    let parent;\n    if (target.collectionGroup !== null) {\n        parent = path;\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: target.collectionGroup,\n                allDescendants: true\n            }\n        ];\n    }\n    else {\n        parent = path.popLast();\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n    }\n    queryTarget.parent = toQueryPath(serializer, parent);\n    const where = toFilters(target.filters);\n    if (where) {\n        queryTarget.structuredQuery.where = where;\n    }\n    const orderBy = toOrder(target.orderBy);\n    if (orderBy) {\n        queryTarget.structuredQuery.orderBy = orderBy;\n    }\n    const limit = toInt32Proto(serializer, target.limit);\n    if (limit !== null) {\n        queryTarget.structuredQuery.limit = limit;\n    }\n    if (target.startAt) {\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\n    }\n    if (target.endAt) {\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\n    }\n    return { queryTarget, parent };\n}\nfunction toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\n    const aliasMap = {};\n    const aggregations = [];\n    let aggregationNum = 0;\n    aggregates.forEach(aggregate => {\n        // Map all client-side aliases to a unique short-form\n        // alias. This avoids issues with client-side aliases that\n        // exceed the 1500-byte string size limit.\n        const serverAlias = skipAliasing\n            ? aggregate.alias\n            : `aggregate_${aggregationNum++}`;\n        aliasMap[serverAlias] = aggregate.alias;\n        if (aggregate.aggregateType === 'count') {\n            aggregations.push({\n                alias: serverAlias,\n                count: {}\n            });\n        }\n        else if (aggregate.aggregateType === 'avg') {\n            aggregations.push({\n                alias: serverAlias,\n                avg: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n        else if (aggregate.aggregateType === 'sum') {\n            aggregations.push({\n                alias: serverAlias,\n                sum: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n    });\n    return {\n        request: {\n            structuredAggregationQuery: {\n                aggregations,\n                structuredQuery: queryTarget.structuredQuery\n            },\n            parent: queryTarget.parent\n        },\n        aliasMap,\n        parent\n    };\n}\nfunction convertQueryTargetToQuery(target) {\n    let path = fromQueryPath(target.parent);\n    const query = target.structuredQuery;\n    const fromCount = query.from ? query.from.length : 0;\n    let collectionGroup = null;\n    if (fromCount > 0) {\n        hardAssert(fromCount === 1);\n        const from = query.from[0];\n        if (from.allDescendants) {\n            collectionGroup = from.collectionId;\n        }\n        else {\n            path = path.child(from.collectionId);\n        }\n    }\n    let filterBy = [];\n    if (query.where) {\n        filterBy = fromFilters(query.where);\n    }\n    let orderBy = [];\n    if (query.orderBy) {\n        orderBy = fromOrder(query.orderBy);\n    }\n    let limit = null;\n    if (query.limit) {\n        limit = fromInt32Proto(query.limit);\n    }\n    let startAt = null;\n    if (query.startAt) {\n        startAt = fromStartAtCursor(query.startAt);\n    }\n    let endAt = null;\n    if (query.endAt) {\n        endAt = fromEndAtCursor(query.endAt);\n    }\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\n}\nfunction fromQueryTarget(target) {\n    return queryToTarget(convertQueryTargetToQuery(target));\n}\nfunction toListenRequestLabels(serializer, targetData) {\n    const value = toLabel(targetData.purpose);\n    if (value == null) {\n        return null;\n    }\n    else {\n        return {\n            'goog-listen-tags': value\n        };\n    }\n}\nfunction toLabel(purpose) {\n    switch (purpose) {\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\n            return null;\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\n            return 'existence-filter-mismatch';\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\n            return 'existence-filter-mismatch-bloom';\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\n            return 'limbo-document';\n        default:\n            return fail();\n    }\n}\nfunction toTarget(serializer, targetData) {\n    let result;\n    const target = targetData.target;\n    if (targetIsDocumentTarget(target)) {\n        result = { documents: toDocumentsTarget(serializer, target) };\n    }\n    else {\n        result = { query: toQueryTarget(serializer, target).queryTarget };\n    }\n    result.targetId = targetData.targetId;\n    if (targetData.resumeToken.approximateByteSize() > 0) {\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        // TODO(wuandy): Consider removing above check because it is most likely true.\n        // Right now, many tests depend on this behaviour though (leaving min() out\n        // of serialization).\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    return result;\n}\nfunction toFilters(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\n}\nfunction fromFilters(filter) {\n    const result = fromFilter(filter);\n    if (result instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(result)) {\n        return result.getFilters();\n    }\n    return [result];\n}\nfunction fromFilter(filter) {\n    if (filter.unaryFilter !== undefined) {\n        return fromUnaryFilter(filter);\n    }\n    else if (filter.fieldFilter !== undefined) {\n        return fromFieldFilter(filter);\n    }\n    else if (filter.compositeFilter !== undefined) {\n        return fromCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toOrder(orderBys) {\n    if (orderBys.length === 0) {\n        return;\n    }\n    return orderBys.map(order => toPropertyOrder(order));\n}\nfunction fromOrder(orderBys) {\n    return orderBys.map(order => fromPropertyOrder(order));\n}\nfunction toStartAtCursor(cursor) {\n    return {\n        before: cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction toEndAtCursor(cursor) {\n    return {\n        before: !cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction fromStartAtCursor(cursor) {\n    const inclusive = !!cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\nfunction fromEndAtCursor(cursor) {\n    const inclusive = !cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\n// visible for testing\nfunction toDirection(dir) {\n    return DIRECTIONS[dir];\n}\n// visible for testing\nfunction fromDirection(dir) {\n    switch (dir) {\n        case 'ASCENDING':\n            return \"asc\" /* Direction.ASCENDING */;\n        case 'DESCENDING':\n            return \"desc\" /* Direction.DESCENDING */;\n        default:\n            return undefined;\n    }\n}\n// visible for testing\nfunction toOperatorName(op) {\n    return OPERATORS[op];\n}\nfunction toCompositeOperatorName(op) {\n    return COMPOSITE_OPERATORS[op];\n}\nfunction fromOperatorName(op) {\n    switch (op) {\n        case 'EQUAL':\n            return \"==\" /* Operator.EQUAL */;\n        case 'NOT_EQUAL':\n            return \"!=\" /* Operator.NOT_EQUAL */;\n        case 'GREATER_THAN':\n            return \">\" /* Operator.GREATER_THAN */;\n        case 'GREATER_THAN_OR_EQUAL':\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\n        case 'LESS_THAN':\n            return \"<\" /* Operator.LESS_THAN */;\n        case 'LESS_THAN_OR_EQUAL':\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\n        case 'ARRAY_CONTAINS':\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\n        case 'IN':\n            return \"in\" /* Operator.IN */;\n        case 'NOT_IN':\n            return \"not-in\" /* Operator.NOT_IN */;\n        case 'ARRAY_CONTAINS_ANY':\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromCompositeOperatorName(op) {\n    switch (op) {\n        case 'AND':\n            return \"and\" /* CompositeOperator.AND */;\n        case 'OR':\n            return \"or\" /* CompositeOperator.OR */;\n        default:\n            return fail();\n    }\n}\nfunction toFieldPathReference(path) {\n    return { fieldPath: path.canonicalString() };\n}\nfunction fromFieldPathReference(fieldReference) {\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\n}\n// visible for testing\nfunction toPropertyOrder(orderBy) {\n    return {\n        field: toFieldPathReference(orderBy.field),\n        direction: toDirection(orderBy.dir)\n    };\n}\nfunction fromPropertyOrder(orderBy) {\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\n}\n// visible for testing\nfunction toFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return toUnaryOrFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return toCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toCompositeFilter(filter) {\n    const protos = filter.getFilters().map(filter => toFilter(filter));\n    if (protos.length === 1) {\n        return protos[0];\n    }\n    return {\n        compositeFilter: {\n            op: toCompositeOperatorName(filter.op),\n            filters: protos\n        }\n    };\n}\nfunction toUnaryOrFieldFilter(filter) {\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n    }\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NULL'\n                }\n            };\n        }\n    }\n    return {\n        fieldFilter: {\n            field: toFieldPathReference(filter.field),\n            op: toOperatorName(filter.op),\n            value: filter.value\n        }\n    };\n}\nfunction fromUnaryFilter(filter) {\n    switch (filter.unaryFilter.op) {\n        case 'IS_NAN':\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NULL':\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'IS_NOT_NAN':\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NOT_NULL':\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromFieldFilter(filter) {\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\n}\nfunction fromCompositeFilter(filter) {\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\n}\nfunction toDocumentMask(fieldMask) {\n    const canonicalFields = [];\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\n    return {\n        fieldPaths: canonicalFields\n    };\n}\nfunction fromDocumentMask(proto) {\n    const paths = proto.fieldPaths || [];\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\n}\nfunction isValidResourceName(path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (path.length >= 4 &&\n        path.get(0) === 'projects' &&\n        path.get(2) === 'databases');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable set of metadata that the local store tracks for each target.\n */\nclass TargetData {\n    constructor(\n    /** The target being listened to. */\n    target, \n    /**\n     * The target ID to which the target corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the target. */\n    purpose, \n    /**\n     * The sequence number of the last transaction during which this target data\n     * was modified.\n     */\n    sequenceNumber, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion = SnapshotVersion.min(), \n    /**\n     * The maximum snapshot version at which the associated view\n     * contained no limbo documents.\n     */\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /**\n     * The number of documents that last matched the query at the resume token or\n     * read time. Documents are counted only when making a listen request with\n     * resume token or read time, otherwise, keep it null.\n     */\n    expectedCount = null) {\n        this.target = target;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.sequenceNumber = sequenceNumber;\n        this.snapshotVersion = snapshotVersion;\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\n        this.resumeToken = resumeToken;\n        this.expectedCount = expectedCount;\n    }\n    /** Creates a new target data instance with an updated sequence number. */\n    withSequenceNumber(sequenceNumber) {\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated resume token and\n     * snapshot version.\n     */\n    withResumeToken(resumeToken, snapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \n        /* expectedCount= */ null);\n    }\n    /**\n     * Creates a new target data instance with an updated expected count.\n     */\n    withExpectedCount(expectedCount) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated last limbo free\n     * snapshot version number.\n     */\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Serializer for values stored in the LocalStore. */\nclass LocalSerializer {\n    constructor(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n}\n/** Decodes a remote document from storage locally to a Document. */\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\n    let doc;\n    if (remoteDoc.document) {\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\n    }\n    else if (remoteDoc.noDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\n        doc = MutableDocument.newNoDocument(key, version);\n        if (remoteDoc.hasCommittedMutations) {\n            doc.setHasCommittedMutations();\n        }\n    }\n    else if (remoteDoc.unknownDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\n        doc = MutableDocument.newUnknownDocument(key, version);\n    }\n    else {\n        return fail();\n    }\n    if (remoteDoc.readTime) {\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\n    }\n    return doc;\n}\n/** Encodes a document for storage locally. */\nfunction toDbRemoteDocument(localSerializer, document) {\n    const key = document.key;\n    const remoteDoc = {\n        prefixPath: key.getCollectionPath().popLast().toArray(),\n        collectionGroup: key.collectionGroup,\n        documentId: key.path.lastSegment(),\n        readTime: toDbTimestampKey(document.readTime),\n        hasCommittedMutations: document.hasCommittedMutations\n    };\n    if (document.isFoundDocument()) {\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\n    }\n    else if (document.isNoDocument()) {\n        remoteDoc.noDocument = {\n            path: key.path.toArray(),\n            readTime: toDbTimestamp(document.version)\n        };\n    }\n    else if (document.isUnknownDocument()) {\n        remoteDoc.unknownDocument = {\n            path: key.path.toArray(),\n            version: toDbTimestamp(document.version)\n        };\n    }\n    else {\n        return fail();\n    }\n    return remoteDoc;\n}\nfunction toDbTimestampKey(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return [timestamp.seconds, timestamp.nanoseconds];\n}\nfunction fromDbTimestampKey(dbTimestampKey) {\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\nfunction toDbTimestamp(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\n}\nfunction fromDbTimestamp(dbTimestamp) {\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\nfunction toDbMutationBatch(localSerializer, userId, batch) {\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    return {\n        userId,\n        batchId: batch.batchId,\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\n        baseMutations: serializedBaseMutations,\n        mutations: serializedMutations\n    };\n}\n/** Decodes a DbMutationBatch into a MutationBatch */\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\n    // Squash old transform mutations into existing patch or set mutations.\n    // The replacement of representing `transforms` with `update_transforms`\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\n    // to be updated to `update_transforms`.\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\n        const currentMutation = dbBatch.mutations[i];\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\n            dbBatch.mutations[i + 1].transform !== undefined;\n        if (hasTransform) {\n            const transformMutation = dbBatch.mutations[i + 1];\n            currentMutation.updateTransforms =\n                transformMutation.transform.fieldTransforms;\n            dbBatch.mutations.splice(i + 1, 1);\n            ++i;\n        }\n    }\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\n}\n/** Decodes a DbTarget into TargetData */\nfunction fromDbTarget(dbTarget) {\n    const version = fromDbTimestamp(dbTarget.readTime);\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\n        : SnapshotVersion.min();\n    let target;\n    if (isDocumentQuery(dbTarget.query)) {\n        target = fromDocumentsTarget(dbTarget.query);\n    }\n    else {\n        target = fromQueryTarget(dbTarget.query);\n    }\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\n}\n/** Encodes TargetData into a DbTarget for storage locally. */\nfunction toDbTarget(localSerializer, targetData) {\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\n    let queryProto;\n    if (targetIsDocumentTarget(targetData.target)) {\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\n    }\n    else {\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\n    }\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\n    // convert it to a base64 string for storage.\n    const resumeToken = targetData.resumeToken.toBase64();\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return {\n        targetId: targetData.targetId,\n        canonicalId: canonifyTarget(targetData.target),\n        readTime: dbTimestamp,\n        resumeToken,\n        lastListenSequenceNumber: targetData.sequenceNumber,\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\n        query: queryProto\n    };\n}\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n/** Encodes a DbBundle to a BundleMetadata object. */\nfunction fromDbBundle(dbBundle) {\n    return {\n        id: dbBundle.bundleId,\n        createTime: fromDbTimestamp(dbBundle.createTime),\n        version: dbBundle.version\n    };\n}\n/** Encodes a BundleMetadata to a DbBundle. */\nfunction toDbBundle(metadata) {\n    return {\n        bundleId: metadata.id,\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\n        version: metadata.version\n    };\n}\n/** Encodes a DbNamedQuery to a NamedQuery. */\nfunction fromDbNamedQuery(dbNamedQuery) {\n    return {\n        name: dbNamedQuery.name,\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\n    };\n}\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\nfunction toDbNamedQuery(query) {\n    return {\n        name: query.name,\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\n        bundledQuery: query.bundledQuery\n    };\n}\n/**\n * Encodes a `BundledQuery` from bundle proto to a Query object.\n *\n * This reconstructs the original query used to build the bundle being loaded,\n * including features exists only in SDKs (for example: limit-to-last).\n */\nfunction fromBundledQuery(bundledQuery) {\n    const query = convertQueryTargetToQuery({\n        parent: bundledQuery.parent,\n        structuredQuery: bundledQuery.structuredQuery\n    });\n    if (bundledQuery.limitType === 'LAST') {\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\n    }\n    return query;\n}\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\nfunction fromProtoNamedQuery(namedQuery) {\n    return {\n        name: namedQuery.name,\n        query: fromBundledQuery(namedQuery.bundledQuery),\n        readTime: fromVersion(namedQuery.readTime)\n    };\n}\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\nfunction fromBundleMetadata(metadata) {\n    return {\n        id: metadata.id,\n        version: metadata.version,\n        createTime: fromVersion(metadata.createTime)\n    };\n}\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\n}\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\n    return {\n        userId,\n        collectionPath,\n        documentId,\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\n        largestBatchId: overlay.largestBatchId,\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\n    };\n}\n/**\n * Returns the DbDocumentOverlayKey corresponding to the given user and\n * document key.\n */\nfunction toDbDocumentOverlayKey(userId, docKey) {\n    const docId = docKey.path.lastSegment();\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\n    return [userId, collectionPath, docId];\n}\nfunction toDbIndexConfiguration(index) {\n    return {\n        indexId: index.indexId,\n        collectionGroup: index.collectionGroup,\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\n    };\n}\nfunction fromDbIndexConfiguration(index, state) {\n    const decodedState = state\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\n        : IndexState.empty();\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\n}\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\n    return {\n        indexId,\n        uid,\n        sequenceNumber,\n        readTime: toDbTimestamp(offset.readTime),\n        documentKey: encodeResourcePath(offset.documentKey.path),\n        largestBatchId: offset.largestBatchId\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbBundleCache {\n    getBundleMetadata(transaction, bundleId) {\n        return bundlesStore(transaction)\n            .get(bundleId)\n            .next(bundle => {\n            if (bundle) {\n                return fromDbBundle(bundle);\n            }\n            return undefined;\n        });\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\n    }\n    getNamedQuery(transaction, queryName) {\n        return namedQueriesStore(transaction)\n            .get(queryName)\n            .next(query => {\n            if (query) {\n                return fromDbNamedQuery(query);\n            }\n            return undefined;\n        });\n    }\n    saveNamedQuery(transaction, query) {\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the bundles object store.\n */\nfunction bundlesStore(txn) {\n    return getStore(txn, DbBundleStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\n */\nfunction namedQueriesStore(txn) {\n    return getStore(txn, DbNamedQueryStore);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Implementation of DocumentOverlayCache using IndexedDb.\n */\nclass IndexedDbDocumentOverlayCache {\n    /**\n     * @param serializer - The document serializer.\n     * @param userId - The userId for which we are accessing overlays.\n     */\n    constructor(serializer, userId) {\n        this.serializer = serializer;\n        this.userId = userId;\n    }\n    static forUser(serializer, user) {\n        const userId = user.uid || '';\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\n    }\n    getOverlay(transaction, key) {\n        return documentOverlayStore(transaction)\n            .get(toDbDocumentOverlayKey(this.userId, key))\n            .next(dbOverlay => {\n            if (dbOverlay) {\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\n            }\n            return null;\n        });\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        const promises = [];\n        overlays.forEach((_, mutation) => {\n            const overlay = new Overlay(largestBatchId, mutation);\n            promises.push(this.saveOverlay(transaction, overlay));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const collectionPaths = new Set();\n        // Get the set of unique collection paths.\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\n        const promises = [];\n        collectionPaths.forEach(collectionPath => {\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \n            /*lowerOpen=*/ false, \n            /*upperOpen=*/ true);\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const collectionPath = encodeResourcePath(collection);\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\n            .next(dbOverlays => {\n            for (const dbOverlay of dbOverlays) {\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n                result.set(overlay.getKey(), overlay);\n            }\n            return result;\n        });\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        const result = newOverlayMap();\n        let currentBatchId = undefined;\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .iterate({\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\n            range\n        }, (_, dbOverlay, control) => {\n            // We do not want to return partial batch overlays, even if the size\n            // of the result set exceeds the given `count` argument. Therefore, we\n            // continue to aggregate results even after the result size exceeds\n            // `count` if there are more overlays from the `currentBatchId`.\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n            if (result.size() < count ||\n                overlay.largestBatchId === currentBatchId) {\n                result.set(overlay.getKey(), overlay);\n                currentBatchId = overlay.largestBatchId;\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    saveOverlay(transaction, overlay) {\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the document overlay object store.\n */\nfunction documentOverlayStore(txn) {\n    return getStore(txn, DbDocumentOverlayStore);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbGlobalsCache {\n    globalsStore(txn) {\n        return getStore(txn, DbGlobalsStore);\n    }\n    getSessionToken(txn) {\n        const globals = this.globalsStore(txn);\n        return globals.get('sessionToken').next(global => {\n            const value = global === null || global === void 0 ? void 0 : global.value;\n            return value\n                ? ByteString.fromUint8Array(value)\n                : ByteString.EMPTY_BYTE_STRING;\n        });\n    }\n    setSessionToken(txn, sessionToken) {\n        const globals = this.globalsStore(txn);\n        return globals.put({\n            name: 'sessionToken',\n            value: sessionToken.toUint8Array()\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Note: This code is copied from the backend. Code that is not used by\n// Firestore was removed.\nconst INDEX_TYPE_NULL = 5;\nconst INDEX_TYPE_BOOLEAN = 10;\nconst INDEX_TYPE_NAN = 13;\nconst INDEX_TYPE_NUMBER = 15;\nconst INDEX_TYPE_TIMESTAMP = 20;\nconst INDEX_TYPE_STRING = 25;\nconst INDEX_TYPE_BLOB = 30;\nconst INDEX_TYPE_REFERENCE = 37;\nconst INDEX_TYPE_GEOPOINT = 45;\nconst INDEX_TYPE_ARRAY = 50;\nconst INDEX_TYPE_VECTOR = 53;\nconst INDEX_TYPE_MAP = 55;\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\n// A terminator that indicates that a truncatable value was not truncated.\n// This must be smaller than all other type labels.\nconst NOT_TRUNCATED = 2;\n/** Firestore index value writer.  */\nclass FirestoreIndexValueWriter {\n    constructor() { }\n    // The write methods below short-circuit writing terminators for values\n    // containing a (terminating) truncated value.\n    //\n    // As an example, consider the resulting encoding for:\n    //\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\n    /** Writes an index value.  */\n    writeIndexValue(value, encoder) {\n        this.writeIndexValueAux(value, encoder);\n        // Write separator to split index values\n        // (see go/firestore-storage-format#encodings).\n        encoder.writeInfinity();\n    }\n    writeIndexValueAux(indexValue, encoder) {\n        if ('nullValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\n        }\n        else if ('booleanValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\n        }\n        else if ('integerValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\n        }\n        else if ('doubleValue' in indexValue) {\n            const n = normalizeNumber(indexValue.doubleValue);\n            if (isNaN(n)) {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\n            }\n            else {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n                if (isNegativeZero(n)) {\n                    // -0.0, 0 and 0.0 are all considered the same\n                    encoder.writeNumber(0.0);\n                }\n                else {\n                    encoder.writeNumber(n);\n                }\n            }\n        }\n        else if ('timestampValue' in indexValue) {\n            let timestamp = indexValue.timestampValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\n            if (typeof timestamp === 'string') {\n                timestamp = normalizeTimestamp(timestamp);\n            }\n            encoder.writeString(`${timestamp.seconds || ''}`);\n            encoder.writeNumber(timestamp.nanos || 0);\n        }\n        else if ('stringValue' in indexValue) {\n            this.writeIndexString(indexValue.stringValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('bytesValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('referenceValue' in indexValue) {\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\n        }\n        else if ('geoPointValue' in indexValue) {\n            const geoPoint = indexValue.geoPointValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\n            encoder.writeNumber(geoPoint.latitude || 0);\n            encoder.writeNumber(geoPoint.longitude || 0);\n        }\n        else if ('mapValue' in indexValue) {\n            if (isMaxValue(indexValue)) {\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\n            }\n            else if (isVectorValue(indexValue)) {\n                this.writeIndexVector(indexValue.mapValue, encoder);\n            }\n            else {\n                this.writeIndexMap(indexValue.mapValue, encoder);\n                this.writeTruncationMarker(encoder);\n            }\n        }\n        else if ('arrayValue' in indexValue) {\n            this.writeIndexArray(indexValue.arrayValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else {\n            fail();\n        }\n    }\n    writeIndexString(stringIndexValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\n    }\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\n        encoder.writeString(stringIndexValue);\n    }\n    writeIndexMap(mapIndexValue, encoder) {\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\n        for (const key of Object.keys(map)) {\n            this.writeIndexString(key, encoder);\n            this.writeIndexValueAux(map[key], encoder);\n        }\n    }\n    writeIndexVector(mapIndexValue, encoder) {\n        var _a, _b;\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_VECTOR);\n        // Vectors sort first by length\n        const key = VECTOR_MAP_VECTORS_KEY;\n        const length = ((_b = (_a = map[key].arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n        encoder.writeNumber(normalizeNumber(length));\n        // Vectors then sort by position value\n        this.writeIndexString(key, encoder);\n        this.writeIndexValueAux(map[key], encoder);\n    }\n    writeIndexArray(arrayIndexValue, encoder) {\n        const values = arrayIndexValue.values || [];\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\n        for (const element of values) {\n            this.writeIndexValueAux(element, encoder);\n        }\n    }\n    writeIndexEntityRef(referenceValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\n        const path = DocumentKey.fromName(referenceValue).path;\n        path.forEach(segment => {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\n            this.writeUnlabeledIndexString(segment, encoder);\n        });\n    }\n    writeValueTypeLabel(encoder, typeOrder) {\n        encoder.writeNumber(typeOrder);\n    }\n    writeTruncationMarker(encoder) {\n        // While the SDK does not implement truncation, the truncation marker is\n        // used to terminate all variable length values (which are strings, bytes,\n        // references, arrays and maps).\n        encoder.writeNumber(NOT_TRUNCATED);\n    }\n}\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law | agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** These constants are taken from the backend. */\nconst MIN_SURROGATE = '\\uD800';\nconst MAX_SURROGATE = '\\uDBFF';\nconst ESCAPE1 = 0x00;\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\nconst ESCAPE2 = 0xff;\nconst INFINITY = 0xff; // Combined with ESCAPE2\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\nconst LONG_SIZE = 64;\nconst BYTE_SIZE = 8;\n/**\n * The default size of the buffer. This is arbitrary, but likely larger than\n * most index values so that less copies of the underlying buffer will be made.\n * For large values, a single copy will made to double the buffer length.\n */\nconst DEFAULT_BUFFER_SIZE = 1024;\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\nfunction doubleToLongBits(value) {\n    const dv = new DataView(new ArrayBuffer(8));\n    dv.setFloat64(0, value, /* littleEndian= */ false);\n    return new Uint8Array(dv.buffer);\n}\n/**\n * Counts the number of zeros in a byte.\n *\n * Visible for testing.\n */\nfunction numberOfLeadingZerosInByte(x) {\n    if (x === 0) {\n        return 8;\n    }\n    let zeros = 0;\n    if (x >> 4 === 0) {\n        // Test if the first four bits are zero.\n        zeros += 4;\n        x = x << 4;\n    }\n    if (x >> 6 === 0) {\n        // Test if the first two (or next two) bits are zero.\n        zeros += 2;\n        x = x << 2;\n    }\n    if (x >> 7 === 0) {\n        // Test if the remaining bit is zero.\n        zeros += 1;\n    }\n    return zeros;\n}\n/** Counts the number of leading zeros in the given byte array. */\nfunction numberOfLeadingZeros(bytes) {\n    let leadingZeros = 0;\n    for (let i = 0; i < 8; ++i) {\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\n        leadingZeros += zeros;\n        if (zeros !== 8) {\n            break;\n        }\n    }\n    return leadingZeros;\n}\n/**\n * Returns the number of bytes required to store \"value\". Leading zero bytes\n * are skipped.\n */\nfunction unsignedNumLength(value) {\n    // This is just the number of bytes for the unsigned representation of the number.\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\n    return Math.ceil(numBits / BYTE_SIZE);\n}\n/**\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\n * behavior defined by the backend.\n *\n * The code is ported from its Java counterpart.\n */\nclass OrderedCodeWriter {\n    constructor() {\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\n        this.position = 0;\n    }\n    writeBytesAscending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteAscending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorAscending();\n    }\n    writeBytesDescending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteDescending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorDescending();\n    }\n    /** Writes utf8 bytes into this byte sequence, ascending. */\n    writeUtf8Ascending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteAscending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorAscending();\n    }\n    /** Writes utf8 bytes into this byte sequence, descending */\n    writeUtf8Descending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteDescending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorDescending();\n    }\n    writeNumberAscending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // actual value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = len & 0xff; // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = value[i] & 0xff;\n        }\n    }\n    writeNumberDescending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // inverted value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = ~(value[i] & 0xff);\n        }\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\n     * sequences written in ascending order.\n     */\n    writeInfinityAscending() {\n        this.writeEscapedByteAscending(ESCAPE2);\n        this.writeEscapedByteAscending(INFINITY);\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\n     * sequences written in descending order.\n     */\n    writeInfinityDescending() {\n        this.writeEscapedByteDescending(ESCAPE2);\n        this.writeEscapedByteDescending(INFINITY);\n    }\n    /**\n     * Resets the buffer such that it is the same as when it was newly\n     * constructed.\n     */\n    reset() {\n        this.position = 0;\n    }\n    seed(encodedBytes) {\n        this.ensureAvailable(encodedBytes.length);\n        this.buffer.set(encodedBytes, this.position);\n        this.position += encodedBytes.length;\n    }\n    /** Makes a copy of the encoded bytes in this buffer.  */\n    encodedBytes() {\n        return this.buffer.slice(0, this.position);\n    }\n    /**\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\n     * floating-point comparison results with the following exceptions:\n     *   -0.0 < 0.0\n     *   all non-NaN < NaN\n     *   NaN = NaN\n     */\n    toOrderedBits(val) {\n        const value = doubleToLongBits(val);\n        // Check if the first bit is set. We use a bit mask since value[0] is\n        // encoded as a number from 0 to 255.\n        const isNegative = (value[0] & 0x80) !== 0;\n        // Revert the two complement to get natural ordering\n        value[0] ^= isNegative ? 0xff : 0x80;\n        for (let i = 1; i < value.length; ++i) {\n            value[i] ^= isNegative ? 0xff : 0x00;\n        }\n        return value;\n    }\n    /** Writes a single byte ascending to the buffer. */\n    writeByteAscending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteAscending(ESCAPE1);\n            this.writeEscapedByteAscending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteAscending(ESCAPE2);\n            this.writeEscapedByteAscending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteAscending(masked);\n        }\n    }\n    /** Writes a single byte descending to the buffer.  */\n    writeByteDescending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteDescending(ESCAPE1);\n            this.writeEscapedByteDescending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteDescending(ESCAPE2);\n            this.writeEscapedByteDescending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteDescending(b);\n        }\n    }\n    writeSeparatorAscending() {\n        this.writeEscapedByteAscending(ESCAPE1);\n        this.writeEscapedByteAscending(SEPARATOR);\n    }\n    writeSeparatorDescending() {\n        this.writeEscapedByteDescending(ESCAPE1);\n        this.writeEscapedByteDescending(SEPARATOR);\n    }\n    writeEscapedByteAscending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = b;\n    }\n    writeEscapedByteDescending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = ~b;\n    }\n    ensureAvailable(bytes) {\n        const minCapacity = bytes + this.position;\n        if (minCapacity <= this.buffer.length) {\n            return;\n        }\n        // Try doubling.\n        let newLength = this.buffer.length * 2;\n        // Still not big enough? Just allocate the right size.\n        if (newLength < minCapacity) {\n            newLength = minCapacity;\n        }\n        // Create the new buffer.\n        const newBuffer = new Uint8Array(newLength);\n        newBuffer.set(this.buffer); // copy old data\n        this.buffer = newBuffer;\n    }\n}\n\nclass AscendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesAscending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Ascending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberAscending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityAscending();\n    }\n}\nclass DescendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesDescending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Descending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberDescending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityDescending();\n    }\n}\n/**\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\n * actual encoding.\n */\nclass IndexByteEncoder {\n    constructor() {\n        this.orderedCode = new OrderedCodeWriter();\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\n    }\n    seed(encodedBytes) {\n        this.orderedCode.seed(encodedBytes);\n    }\n    forKind(kind) {\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\n    }\n    encodedBytes() {\n        return this.orderedCode.encodedBytes();\n    }\n    reset() {\n        this.orderedCode.reset();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Represents an index entry saved by the SDK in persisted storage. */\nclass IndexEntry {\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\n        this.indexId = indexId;\n        this.documentKey = documentKey;\n        this.arrayValue = arrayValue;\n        this.directionalValue = directionalValue;\n    }\n    /**\n     * Returns an IndexEntry entry that sorts immediately after the current\n     * directional value.\n     */\n    successor() {\n        const currentLength = this.directionalValue.length;\n        const newLength = currentLength === 0 || this.directionalValue[currentLength - 1] === 255\n            ? currentLength + 1\n            : currentLength;\n        const successor = new Uint8Array(newLength);\n        successor.set(this.directionalValue, 0);\n        if (newLength !== currentLength) {\n            successor.set([0], this.directionalValue.length);\n        }\n        else {\n            ++successor[successor.length - 1];\n        }\n        return new IndexEntry(this.indexId, this.documentKey, this.arrayValue, successor);\n    }\n}\nfunction indexEntryComparator(left, right) {\n    let cmp = left.indexId - right.indexId;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.directionalValue, right.directionalValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return DocumentKey.comparator(left.documentKey, right.documentKey);\n}\nfunction compareByteArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; ++i) {\n        const compare = left[i] - right[i];\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return left.length - right.length;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A light query planner for Firestore.\n *\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\n * determines whether a given index can be used to serve the specified target.\n *\n * The following table showcases some possible index configurations:\n *\n * Query                                               | Index\n * -----------------------------------------------------------------------------\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\n */\nclass TargetIndexMatcher {\n    constructor(target) {\n        // The inequality filters of the target (if it exists).\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\n        // comparator.\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\n        this.collectionId =\n            target.collectionGroup != null\n                ? target.collectionGroup\n                : target.path.lastSegment();\n        this.orderBys = target.orderBy;\n        this.equalityFilters = [];\n        for (const filter of target.filters) {\n            const fieldFilter = filter;\n            if (fieldFilter.isInequality()) {\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\n            }\n            else {\n                this.equalityFilters.push(fieldFilter);\n            }\n        }\n    }\n    get hasMultipleInequality() {\n        return this.inequalityFilters.size > 1;\n    }\n    /**\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\n     * target.\n     *\n     * An index is considered capable of serving the target when:\n     * - The target uses all index segments for its filters and orderBy clauses.\n     *   The target can have additional filter and orderBy clauses, but not\n     *   fewer.\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\n     *   have a corresponding `CONTAINS` segment.\n     * - All directional index segments can be mapped to the target as a series of\n     *   equality filters, a single inequality filter and a series of orderBy\n     *   clauses.\n     * - The segments that represent the equality filters may appear out of order.\n     * - The optional segment for the inequality filter must appear after all\n     *   equality segments.\n     * - The segments that represent that orderBy clause of the target must appear\n     *   in order after all equality and inequality segments. Single orderBy\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\n     *   omitted.\n     */\n    servedByIndex(index) {\n        hardAssert(index.collectionGroup === this.collectionId);\n        if (this.hasMultipleInequality) {\n            // Only single inequality is supported for now.\n            // TODO(Add support for multiple inequality query): b/298441043\n            return false;\n        }\n        // If there is an array element, find a matching filter.\n        const arraySegment = fieldIndexGetArraySegment(index);\n        if (arraySegment !== undefined &&\n            !this.hasMatchingEqualityFilter(arraySegment)) {\n            return false;\n        }\n        const segments = fieldIndexGetDirectionalSegments(index);\n        let equalitySegments = new Set();\n        let segmentIndex = 0;\n        let orderBysIndex = 0;\n        // Process all equalities first. Equalities can appear out of order.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            // We attempt to greedily match all segments to equality filters. If a\n            // filter matches an index segment, we can mark the segment as used.\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\n            }\n            else {\n                // If we cannot find a matching filter, we need to verify whether the\n                // remaining segments map to the target's inequality and its orderBy\n                // clauses.\n                break;\n            }\n        }\n        // If we already have processed all segments, all segments are used to serve\n        // the equality filters and we do not need to map any segments to the\n        // target's inequality and orderBy clauses.\n        if (segmentIndex === segments.length) {\n            return true;\n        }\n        if (this.inequalityFilters.size > 0) {\n            // Only a single inequality is currently supported. Get the only entry in the set.\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\n            // If there is an inequality filter and the field was not in one of the\n            // equality filters above, the next segment must match both the filter\n            // and the first orderBy clause.\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\n                const segment = segments[segmentIndex];\n                if (!this.matchesFilter(inequalityFilter, segment) ||\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                    return false;\n                }\n            }\n            ++segmentIndex;\n        }\n        // All remaining segments need to represent the prefix of the target's\n        // orderBy.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            const segment = segments[segmentIndex];\n            if (orderBysIndex >= this.orderBys.length ||\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a full matched field index for this target. Currently multiple\n     * inequality query is not supported so function returns null.\n     */\n    buildTargetIndex() {\n        if (this.hasMultipleInequality) {\n            return null;\n        }\n        // We want to make sure only one segment created for one field. For example,\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\n        // once.\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\n        const segments = [];\n        for (const filter of this.equalityFilters) {\n            if (filter.field.isKeyField()) {\n                continue;\n            }\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n            if (isArrayOperator) {\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\n            }\n            else {\n                if (uniqueFields.has(filter.field)) {\n                    continue;\n                }\n                uniqueFields = uniqueFields.add(filter.field);\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\n            }\n        }\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\n        // on the target defining an appropriate \"order by\" to ensure that the\n        // required index segment is added. The query engine would reject a query\n        // with an inequality filter that lacks the required order-by clause.\n        for (const orderBy of this.orderBys) {\n            // Stop adding more segments if we see a order-by on key. Typically this\n            // is the default implicit order-by which is covered in the index_entry\n            // table as a separate column. If it is not the default order-by, the\n            // generated index will be missing some segments optimized for order-bys,\n            // which is probably fine.\n            if (orderBy.field.isKeyField()) {\n                continue;\n            }\n            if (uniqueFields.has(orderBy.field)) {\n                continue;\n            }\n            uniqueFields = uniqueFields.add(orderBy.field);\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\n                ? 0 /* IndexKind.ASCENDING */\n                : 1 /* IndexKind.DESCENDING */));\n        }\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\n    }\n    hasMatchingEqualityFilter(segment) {\n        for (const filter of this.equalityFilters) {\n            if (this.matchesFilter(filter, segment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    matchesFilter(filter, segment) {\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\n    }\n    matchesOrderBy(orderBy, segment) {\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides utility functions that help with boolean logic transformations needed for handling\n * complex filters used in queries.\n */\n/**\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\n * input into a disjunction of equality filters and returns the expanded filter.\n */\nfunction computeInExpansion(filter) {\n    var _a, _b;\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        if (filter instanceof InFilter) {\n            const expandedFilters = ((_b = (_a = filter.value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value))) || [];\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\n        }\n        else {\n            // We have reached other kinds of field filters.\n            return filter;\n        }\n    }\n    // We have a composite filter.\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\n    return CompositeFilter.create(expandedFilters, filter.op);\n}\n/**\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\n *\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\n * with two elements: a composite filter that performs (A && C), and a composite filter that\n * performs (B && C).\n *\n * @param filter the composite filter to calculate DNF transform for.\n * @return the terms in the DNF transform.\n */\nfunction getDnfTerms(filter) {\n    if (filter.getFilters().length === 0) {\n        return [];\n    }\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\n    hardAssert(isDisjunctiveNormalForm(result));\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\n        return [result];\n    }\n    return result.getFilters();\n}\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\nfunction isSingleFieldFilter(filter) {\n    return filter instanceof FieldFilter;\n}\n/**\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\n * && b == 20)\n */\nfunction isFlatConjunction(filter) {\n    return (filter instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(filter));\n}\n/**\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\n *\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\n */\nfunction isDisjunctiveNormalForm(filter) {\n    return (isSingleFieldFilter(filter) ||\n        isFlatConjunction(filter) ||\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\n}\n/**\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\n * field filters. e.g. (a == 10) || (b==20 && c==30)\n */\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\n    if (filter instanceof CompositeFilter) {\n        if (compositeFilterIsDisjunction(filter)) {\n            for (const subFilter of filter.getFilters()) {\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction computeDistributedNormalForm(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    if (filter.filters.length === 1) {\n        return computeDistributedNormalForm(filter.filters[0]);\n    }\n    // Compute DNF for each of the subfilters first\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\n    let newFilter = CompositeFilter.create(result, filter.op);\n    newFilter = applyAssociation(newFilter);\n    if (isDisjunctiveNormalForm(newFilter)) {\n        return newFilter;\n    }\n    hardAssert(newFilter instanceof CompositeFilter);\n    hardAssert(compositeFilterIsConjunction(newFilter));\n    hardAssert(newFilter.filters.length > 1);\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\n}\nfunction applyDistribution(lhs, rhs) {\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter);\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter);\n    let result;\n    if (lhs instanceof FieldFilter) {\n        if (rhs instanceof FieldFilter) {\n            // FieldFilter FieldFilter\n            result = applyDistributionFieldFilters(lhs, rhs);\n        }\n        else {\n            // FieldFilter CompositeFilter\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\n        }\n    }\n    else {\n        if (rhs instanceof FieldFilter) {\n            // CompositeFilter FieldFilter\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\n        }\n        else {\n            // CompositeFilter CompositeFilter\n            result = applyDistributionCompositeFilters(lhs, rhs);\n        }\n    }\n    return applyAssociation(result);\n}\nfunction applyDistributionFieldFilters(lhs, rhs) {\n    // Conjunction distribution for two field filters is the conjunction of them.\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\n}\nfunction applyDistributionCompositeFilters(lhs, rhs) {\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0);\n    // There are four cases:\n    // (A & B) & (C & D) --> (A & B & C & D)\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\n    // Case 1 is a merge.\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\n    }\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\n    // we should take each element of the disjunction and distribute it over the other side, and\n    // return the disjunction of the distribution results.\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\n}\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\n    // There are two cases:\n    // A & (B & C) --> (A & B & C)\n    // A & (B | C) --> (A & B) | (A & C)\n    if (compositeFilterIsConjunction(compositeFilter)) {\n        // Case 1\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\n    }\n    else {\n        // Case 2\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\n    }\n}\n/**\n * Applies the associativity property to the given filter and returns the resulting filter.\n *\n * <ul>\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\n * </ul>\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\n */\nfunction applyAssociation(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    const filters = filter.getFilters();\n    // If the composite filter only contains 1 filter, apply associativity to it.\n    if (filters.length === 1) {\n        return applyAssociation(filters[0]);\n    }\n    // Associativity applied to a flat composite filter results is itself.\n    if (compositeFilterIsFlat(filter)) {\n        return filter;\n    }\n    // First apply associativity to all subfilters. This will in turn recursively apply\n    // associativity to all nested composite filters and field filters.\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\n    // take out their filters and add them to `compositeFilter`. For example:\n    // compositeFilter = (A | (B | C | D))\n    // compositeSubfilter = (B | C | D)\n    // Result: (A | B | C | D)\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\n    // added to the top-level \"compositeFilter\".\n    const newSubfilters = [];\n    updatedFilters.forEach(subfilter => {\n        if (subfilter instanceof FieldFilter) {\n            newSubfilters.push(subfilter);\n        }\n        else if (subfilter instanceof CompositeFilter) {\n            if (subfilter.op === filter.op) {\n                // compositeFilter: (A | (B | C))\n                // compositeSubfilter: (B | C)\n                // Result: (A | B | C)\n                newSubfilters.push(...subfilter.filters);\n            }\n            else {\n                // compositeFilter: (A | (B & C))\n                // compositeSubfilter: (B & C)\n                // Result: (A | (B & C))\n                newSubfilters.push(subfilter);\n            }\n        }\n    });\n    if (newSubfilters.length === 1) {\n        return newSubfilters[0];\n    }\n    return CompositeFilter.create(newSubfilters, filter.op);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of IndexManager.\n */\nclass MemoryIndexManager {\n    constructor() {\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\n    }\n    addToCollectionParentIndex(transaction, collectionPath) {\n        this.collectionParentIndex.add(collectionPath);\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\n    }\n    addFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteAllFieldIndexes(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    createTargetIndexes(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getIndexType(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve([]);\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    updateIndexEntries(transaction, documents) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n}\n/**\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\n * in indexeddb_schema.ts\n */\nclass MemoryCollectionParentIndex {\n    constructor() {\n        this.index = {};\n    }\n    // Returns false if the entry already existed.\n    add(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        const added = !existingParents.has(parentPath);\n        this.index[collectionId] = existingParents.add(parentPath);\n        return added;\n    }\n    has(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId];\n        return existingParents && existingParents.has(parentPath);\n    }\n    getEntries(collectionId) {\n        const parentPaths = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        return parentPaths.toArray();\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$f = 'IndexedDbIndexManager';\nconst EMPTY_VALUE = new Uint8Array(0);\n/**\n * A persisted implementation of IndexManager.\n *\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\n * data as it supports multi-tab access.\n */\nclass IndexedDbIndexManager {\n    constructor(user, databaseId) {\n        this.databaseId = databaseId;\n        /**\n         * An in-memory copy of the index entries we've already written since the SDK\n         * launched. Used to avoid re-writing the same entry repeatedly.\n         *\n         * This is *NOT* a complete cache of what's in persistence and so can never be\n         * used to satisfy reads.\n         */\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\n        /**\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\n         * contains only one term from the target's disjunctive normal form (DNF).\n         */\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\n        this.uid = user.uid || '';\n    }\n    /**\n     * Adds a new entry to the collection parent index.\n     *\n     * Repeated calls for the same collectionPath should be avoided within a\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\n     * has been committed.\n     */\n    addToCollectionParentIndex(transaction, collectionPath) {\n        if (!this.collectionParentsCache.has(collectionPath)) {\n            const collectionId = collectionPath.lastSegment();\n            const parentPath = collectionPath.popLast();\n            transaction.addOnCommittedListener(() => {\n                // Add the collection to the in memory cache only if the transaction was\n                // successfully committed.\n                this.collectionParentsCache.add(collectionPath);\n            });\n            const collectionParent = {\n                collectionId,\n                parent: encodeResourcePath(parentPath)\n            };\n            return collectionParentsStore(transaction).put(collectionParent);\n        }\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        const parentPaths = [];\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return collectionParentsStore(transaction)\n            .loadAll(range)\n            .next(entries => {\n            for (const entry of entries) {\n                // This collectionId guard shouldn't be necessary (and isn't as long\n                // as we're running in a real browser), but there's a bug in\n                // indexeddbshim that breaks our range in our tests running in node:\n                // https://github.com/axemclion/IndexedDBShim/issues/334\n                if (entry.collectionId !== collectionId) {\n                    break;\n                }\n                parentPaths.push(decodeResourcePath(entry.parent));\n            }\n            return parentPaths;\n        });\n    }\n    addFieldIndex(transaction, index) {\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\n        // Safari & Firefox.\n        const indexes = indexConfigurationStore(transaction);\n        const dbIndex = toDbIndexConfiguration(index);\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\n        const result = indexes.add(dbIndex);\n        if (index.indexState) {\n            const states = indexStateStore(transaction);\n            return result.next(indexId => {\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\n            });\n        }\n        else {\n            return result.next();\n        }\n    }\n    deleteFieldIndex(transaction, index) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        return indexes\n            .delete(index.indexId)\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)))\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)));\n    }\n    deleteAllFieldIndexes(transaction) {\n        const indexes = indexConfigurationStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        const states = indexStateStore(transaction);\n        return indexes\n            .deleteAll()\n            .next(() => entries.deleteAll())\n            .next(() => states.deleteAll());\n    }\n    createTargetIndexes(transaction, target) {\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getIndexType(transaction, subTarget).next(type => {\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\n                    if (fieldIndex != null) {\n                        return this.addFieldIndex(transaction, fieldIndex);\n                    }\n                }\n            });\n        });\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        const indexEntries = indexEntriesStore(transaction);\n        let canServeTarget = true;\n        const indexes = new Map();\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getFieldIndex(transaction, subTarget).next(index => {\n                canServeTarget && (canServeTarget = !!index);\n                indexes.set(subTarget, index);\n            });\n        }).next(() => {\n            if (!canServeTarget) {\n                return PersistencePromise.resolve(null);\n            }\n            else {\n                let existingKeys = documentKeySet();\n                const result = [];\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\n                    const arrayValues = targetGetArrayValues(subTarget, index);\n                    const notInValues = targetGetNotInValues(subTarget, index);\n                    const lowerBound = targetGetLowerBound(subTarget, index);\n                    const upperBound = targetGetUpperBound(subTarget, index);\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\n                        return indexEntries\n                            .loadFirst(indexRange, target.limit)\n                            .next(entries => {\n                            entries.forEach(entry => {\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\n                                if (!existingKeys.has(documentKey)) {\n                                    existingKeys = existingKeys.add(documentKey);\n                                    result.push(documentKey);\n                                }\n                            });\n                        });\n                    });\n                }).next(() => result);\n            }\n        });\n    }\n    getSubTargets(target) {\n        let subTargets = this.targetToDnfSubTargets.get(target);\n        if (subTargets) {\n            return subTargets;\n        }\n        if (target.filters.length === 0) {\n            subTargets = [target];\n        }\n        else {\n            // There is an implicit AND operation between all the filters stored in the target\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\n        }\n        this.targetToDnfSubTargets.set(target, subTargets);\n        return subTargets;\n    }\n    /**\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\n     * bounds.\n     */\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\n        // The number of total index scans we union together. This is similar to a\n        // distributed normal form, but adapted for array values. We create a single\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\n        // combined with the values from the query bounds.\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\n            Math.max(lowerBounds.length, upperBounds.length);\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\n        const indexRanges = [];\n        for (let i = 0; i < totalScans; ++i) {\n            const arrayValue = arrayValues\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\n                : EMPTY_VALUE;\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \n            /* inclusive= */ true));\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\n        }\n        return indexRanges;\n    }\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry : entry.successor();\n    }\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry.successor() : entry;\n    }\n    getFieldIndex(transaction, target) {\n        const targetIndexMatcher = new TargetIndexMatcher(target);\n        const collectionGroup = target.collectionGroup != null\n            ? target.collectionGroup\n            : target.path.lastSegment();\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\n            // Return the index with the most number of segments.\n            let index = null;\n            for (const candidate of indexes) {\n                const matches = targetIndexMatcher.servedByIndex(candidate);\n                if (matches &&\n                    (!index || candidate.fields.length > index.fields.length)) {\n                    index = candidate;\n                }\n            }\n            return index;\n        });\n    }\n    getIndexType(transaction, target) {\n        let indexType = 2 /* IndexType.FULL */;\n        const subTargets = this.getSubTargets(target);\n        return PersistencePromise.forEach(subTargets, (target) => {\n            return this.getFieldIndex(transaction, target).next(index => {\n                if (!index) {\n                    indexType = 0 /* IndexType.NONE */;\n                }\n                else if (indexType !== 0 /* IndexType.NONE */ &&\n                    index.fields.length < targetGetSegmentCount(target)) {\n                    indexType = 1 /* IndexType.PARTIAL */;\n                }\n            });\n        }).next(() => {\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\n            // and apply the limit in memory as a post-processing step.\n            if (targetHasLimit(target) &&\n                subTargets.length > 1 &&\n                indexType === 2 /* IndexType.FULL */) {\n                return 1 /* IndexType.PARTIAL */;\n            }\n            return indexType;\n        });\n    }\n    /**\n     * Returns the byte encoded form of the directional values in the field index.\n     * Returns `null` if the document does not have all fields specified in the\n     * index.\n     */\n    encodeDirectionalElements(fieldIndex, document) {\n        const encoder = new IndexByteEncoder();\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const field = document.data.field(segment.fieldPath);\n            if (field == null) {\n                return null;\n            }\n            const directionalEncoder = encoder.forKind(segment.kind);\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\n        }\n        return encoder.encodedBytes();\n    }\n    /** Encodes a single value to the ascending index format. */\n    encodeSingleElement(value) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Returns an encoded form of the document key that sorts based on the key\n     * ordering of the field index.\n     */\n    encodeDirectionalKey(fieldIndex, documentKey) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Encodes the given field values according to the specification in `target`.\n     * For IN queries, a list of possible values is returned.\n     */\n    encodeValues(fieldIndex, target, values) {\n        if (values === null) {\n            return [];\n        }\n        let encoders = [];\n        encoders.push(new IndexByteEncoder());\n        let valueIdx = 0;\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const value = values[valueIdx++];\n            for (const encoder of encoders) {\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\n                    encoders = this.expandIndexValues(encoders, segment, value);\n                }\n                else {\n                    const directionalEncoder = encoder.forKind(segment.kind);\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\n                }\n            }\n        }\n        return this.getEncodedBytes(encoders);\n    }\n    /**\n     * Encodes the given bounds according to the specification in `target`. For IN\n     * queries, a list of possible values is returned.\n     */\n    encodeBound(fieldIndex, target, bound) {\n        return this.encodeValues(fieldIndex, target, bound.position);\n    }\n    /** Returns the byte representation for the provided encoders. */\n    getEncodedBytes(encoders) {\n        const result = [];\n        for (let i = 0; i < encoders.length; ++i) {\n            result[i] = encoders[i].encodedBytes();\n        }\n        return result;\n    }\n    /**\n     * Creates a separate encoder for each element of an array.\n     *\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\n     * list of new encoders is returned.\n     */\n    expandIndexValues(encoders, segment, value) {\n        const prefixes = [...encoders];\n        const results = [];\n        for (const arrayElement of value.arrayValue.values || []) {\n            for (const prefix of prefixes) {\n                const clonedEncoder = new IndexByteEncoder();\n                clonedEncoder.seed(prefix.encodedBytes());\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\n                results.push(clonedEncoder);\n            }\n        }\n        return results;\n    }\n    isInFilter(target, fieldPath) {\n        return !!target.filters.find(f => f instanceof FieldFilter &&\n            f.field.isEqual(fieldPath) &&\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return (collectionGroup\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            : indexes.loadAll()).next(indexConfigs => {\n            const result = [];\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\n                return states\n                    .get([indexConfig.indexId, this.uid])\n                    .next(indexState => {\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\n                });\n            }).next(() => result);\n        });\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        return this.getFieldIndexes(transaction).next(indexes => {\n            if (indexes.length === 0) {\n                return null;\n            }\n            indexes.sort((l, r) => {\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\n                return cmp !== 0\n                    ? cmp\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\n            });\n            return indexes[0].collectionGroup;\n        });\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\n    }\n    updateIndexEntries(transaction, documents) {\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\n        // it could be used across different IndexedDB transactions. As any cached\n        // data might be invalidated by other multi-tab clients, we can only trust\n        // data within a single IndexedDB transaction. We therefore add a cache\n        // here.\n        const memoizedIndexes = new Map();\n        return PersistencePromise.forEach(documents, (key, doc) => {\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\n            const fieldIndexes = memoizedCollectionIndexes\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\n                : this.getFieldIndexes(transaction, key.collectionGroup);\n            return fieldIndexes.next(fieldIndexes => {\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\n                        if (!existingEntries.isEqual(newEntries)) {\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\n                        }\n                        return PersistencePromise.resolve();\n                    });\n                });\n            });\n        });\n    }\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.put({\n            indexId: indexEntry.indexId,\n            uid: this.uid,\n            arrayValue: indexEntry.arrayValue,\n            directionalValue: indexEntry.directionalValue,\n            orderedDocumentKey: this.encodeDirectionalKey(fieldIndex, document.key),\n            documentKey: document.key.path.toArray()\n        });\n    }\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.delete([\n            indexEntry.indexId,\n            this.uid,\n            indexEntry.arrayValue,\n            indexEntry.directionalValue,\n            this.encodeDirectionalKey(fieldIndex, document.key),\n            document.key.path.toArray()\n        ]);\n    }\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\n        const indexEntries = indexEntriesStore(transaction);\n        let results = new SortedSet(indexEntryComparator);\n        return indexEntries\n            .iterate({\n            index: DbIndexEntryDocumentKeyIndex,\n            range: IDBKeyRange.only([\n                fieldIndex.indexId,\n                this.uid,\n                this.encodeDirectionalKey(fieldIndex, documentKey)\n            ])\n        }, (_, entry) => {\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\n        })\n            .next(() => results);\n    }\n    /** Creates the index entries for the given document. */\n    computeIndexEntries(document, fieldIndex) {\n        let results = new SortedSet(indexEntryComparator);\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\n        if (directionalValue == null) {\n            return results;\n        }\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\n        if (arraySegment != null) {\n            const value = document.data.field(arraySegment.fieldPath);\n            if (isArray(value)) {\n                for (const arrayValue of value.arrayValue.values || []) {\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\n                }\n            }\n        }\n        else {\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\n        }\n        return results;\n    }\n    /**\n     * Updates the index entries for the provided document by deleting entries\n     * that are no longer referenced in `newEntries` and adding all newly added\n     * entries.\n     */\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\n        const promises = [];\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \n        /* onAdd= */ entry => {\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\n        }, \n        /* onRemove= */ entry => {\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getNextSequenceNumber(transaction) {\n        let nextSequenceNumber = 1;\n        const states = indexStateStore(transaction);\n        return states\n            .iterate({\n            index: DbIndexStateSequenceNumberIndex,\n            reverse: true,\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\n        }, (_, state, controller) => {\n            controller.done();\n            nextSequenceNumber = state.sequenceNumber + 1;\n        })\n            .next(() => nextSequenceNumber);\n    }\n    /**\n     * Returns a new set of IDB ranges that splits the existing range and excludes\n     * any values that match the `notInValue` from these ranges. As an example,\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\n     */\n    createRange(lower, upper, notInValues) {\n        // The notIn values need to be sorted and unique so that we can return a\n        // sorted set of non-overlapping ranges.\n        notInValues = notInValues\n            .sort((l, r) => indexEntryComparator(l, r))\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\n        const bounds = [];\n        bounds.push(lower);\n        for (const notInValue of notInValues) {\n            const cmpToLower = indexEntryComparator(notInValue, lower);\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\n            if (cmpToLower === 0) {\n                // `notInValue` is the lower bound. We therefore need to raise the bound\n                // to the next value.\n                bounds[0] = lower.successor();\n            }\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\n                // `notInValue` is in the middle of the range\n                bounds.push(notInValue);\n                bounds.push(notInValue.successor());\n            }\n            else if (cmpToUpper > 0) {\n                // `notInValue` (and all following values) are out of the range\n                break;\n            }\n        }\n        bounds.push(upper);\n        const ranges = [];\n        for (let i = 0; i < bounds.length; i += 2) {\n            // If we encounter two bounds that will create an unmatchable key range,\n            // then we return an empty set of key ranges.\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\n                return [];\n            }\n            const lowerBound = [\n                bounds[i].indexId,\n                this.uid,\n                bounds[i].arrayValue,\n                bounds[i].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            const upperBound = [\n                bounds[i + 1].indexId,\n                this.uid,\n                bounds[i + 1].arrayValue,\n                bounds[i + 1].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\n        }\n        return ranges;\n    }\n    isRangeMatchable(lowerBound, upperBound) {\n        // If lower bound is greater than the upper bound, then the key\n        // range can never be matched.\n        return indexEntryComparator(lowerBound, upperBound) > 0;\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail())).next(getMinOffsetFromFieldIndexes);\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the collectionParents\n * document store.\n */\nfunction collectionParentsStore(txn) {\n    return getStore(txn, DbCollectionParentStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index entry object store.\n */\nfunction indexEntriesStore(txn) {\n    return getStore(txn, DbIndexEntryStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index configuration object store.\n */\nfunction indexConfigurationStore(txn) {\n    return getStore(txn, DbIndexConfigurationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index state object store.\n */\nfunction indexStateStore(txn) {\n    return getStore(txn, DbIndexStateStore);\n}\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\n    hardAssert(fieldIndexes.length !== 0);\n    let minOffset = fieldIndexes[0].indexState.offset;\n    let maxBatchId = minOffset.largestBatchId;\n    for (let i = 1; i < fieldIndexes.length; i++) {\n        const newOffset = fieldIndexes[i].indexState.offset;\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\n            minOffset = newOffset;\n        }\n        if (maxBatchId < newOffset.largestBatchId) {\n            maxBatchId = newOffset.largestBatchId;\n        }\n    }\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Delete a mutation batch and the associated document mutations.\n * @returns A PersistencePromise of the document mutations that were removed.\n */\nfunction removeMutationBatch(txn, userId, batch) {\n    const mutationStore = txn.store(DbMutationBatchStore);\n    const indexTxn = txn.store(DbDocumentMutationStore);\n    const promises = [];\n    const range = IDBKeyRange.only(batch.batchId);\n    let numDeleted = 0;\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n    });\n    promises.push(removePromise.next(() => {\n        hardAssert(numDeleted === 1);\n    }));\n    const removedDocuments = [];\n    for (const mutation of batch.mutations) {\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n        removedDocuments.push(mutation.key);\n    }\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\n}\n/**\n * Returns an approximate size for the given document.\n */\nfunction dbDocumentSize(doc) {\n    if (!doc) {\n        return 0;\n    }\n    let value;\n    if (doc.document) {\n        value = doc.document;\n    }\n    else if (doc.unknownDocument) {\n        value = doc.unknownDocument;\n    }\n    else if (doc.noDocument) {\n        value = doc.noDocument;\n    }\n    else {\n        throw fail();\n    }\n    return JSON.stringify(value).length;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A mutation queue for a specific user, backed by IndexedDB. */\nclass IndexedDbMutationQueue {\n    constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer, indexManager, referenceDelegate) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * Caches the document keys for pending mutation batches. If the mutation\n         * has been removed from IndexedDb, the cached value may continue to\n         * be used to retrieve the batch's document keys. To remove a cached value\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\n         * or through `removeMutationBatches()`.\n         *\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\n         * this cache is used by secondary clients to invalidate the local\n         * view of the documents that were previously affected by the mutation.\n         */\n        // PORTING NOTE: Multi-tab only.\n        this.documentKeysByBatchId = {};\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user - The user for which to create a mutation queue.\n     * @param serializer - The serializer to use when persisting to IndexedDb.\n     */\n    static forUser(user, serializer, indexManager, referenceDelegate) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        hardAssert(user.uid !== '');\n        const userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\n    }\n    checkEmpty(transaction) {\n        let empty = true;\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\n            empty = false;\n            control.done();\n        })\n            .next(() => empty);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const documentStore = documentMutationsStore(transaction);\n        const mutationStore = mutationsStore(transaction);\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\n        // compound indices that include auto-generated keys correctly. To ensure\n        // that the index entry is added correctly in all browsers, we perform two\n        // writes: The first write is used to retrieve the next auto-generated Batch\n        // ID, and the second write populates the index and stores the actual\n        // mutation batch.\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\n        // We write an empty object to obtain key\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return mutationStore.add({}).next(batchId => {\n            hardAssert(typeof batchId === 'number');\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\n            const promises = [];\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n            for (const mutation of mutations) {\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\n                promises.push(mutationStore.put(dbBatch));\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\n            }\n            collectionParents.forEach(parent => {\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\n            });\n            transaction.addOnCommittedListener(() => {\n                this.documentKeysByBatchId[batchId] = batch.keys();\n            });\n            return PersistencePromise.waitFor(promises).next(() => batch);\n        });\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return mutationsStore(transaction)\n            .get(batchId)\n            .next(dbBatch => {\n            if (dbBatch) {\n                hardAssert(dbBatch.userId === this.userId);\n                return fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            return null;\n        });\n    }\n    /**\n     * Returns the document keys for the mutation batch with the given batchId.\n     * For primary clients, this method returns `null` after\n     * `removeMutationBatches()` has been called. Secondary clients return a\n     * cached result until `removeCachedMutationKeys()` is invoked.\n     */\n    // PORTING NOTE: Multi-tab only.\n    lookupMutationKeys(transaction, batchId) {\n        if (this.documentKeysByBatchId[batchId]) {\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\n        }\n        else {\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\n                if (batch) {\n                    const keys = batch.keys();\n                    this.documentKeysByBatchId[batchId] = keys;\n                    return keys;\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\n        let foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\n            if (dbBatch.userId === this.userId) {\n                hardAssert(dbBatch.batchId >= nextBatchId);\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            control.done();\n        })\n            .next(() => foundBatch);\n    }\n    getHighestUnacknowledgedBatchId(transaction) {\n        const range = IDBKeyRange.upperBound([\n            this.userId,\n            Number.POSITIVE_INFINITY\n        ]);\n        let batchId = BATCHID_UNKNOWN;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\n            batchId = dbBatch.batchId;\n            control.done();\n        })\n            .next(() => batchId);\n    }\n    getAllMutationBatches(transaction) {\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        const results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchId] = indexKey;\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            // Look up the mutation batch in the store.\n            return mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (!mutation) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            });\n        })\n            .next(() => results);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        const promises = [];\n        documentKeys.forEach(documentKey => {\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n            const range = IDBKeyRange.lowerBound(indexStart);\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\n                const [userID, encodedPath, batchID] = indexKey;\n                // Only consider rows matching exactly the specific key of\n                // interest. Note that because we order by path first, and we\n                // order terminators before path separators, we'll encounter all\n                // the index rows for documentKey contiguously. In particular, all\n                // the rows for documentKey will occur before any rows for\n                // documents nested in a subcollection beneath documentKey so we\n                // can stop as soon as we hit any such row.\n                const path = decodeResourcePath(encodedPath);\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                    control.done();\n                    return;\n                }\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n            });\n            promises.push(promise);\n        });\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        const queryPath = query.path;\n        const immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchID] = indexKey;\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    lookupMutationBatches(transaction, batchIDs) {\n        const results = [];\n        const promises = [];\n        // TODO(rockwood): Implement this using iterate.\n        batchIDs.forEach(batchId => {\n            promises.push(mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (mutation === null) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n    }\n    removeMutationBatch(transaction, batch) {\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\n            transaction.addOnCommittedListener(() => {\n                this.removeCachedMutationKeys(batch.batchId);\n            });\n            return PersistencePromise.forEach(removedDocuments, (key) => {\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\n            });\n        });\n    }\n    /**\n     * Clears the cached keys for a mutation batch. This method should be\n     * called by secondary clients after they process mutation updates.\n     *\n     * Note that this method does not have to be called from primary clients as\n     * the corresponding cache entries are cleared when an acknowledged or\n     * rejected batch is removed from the mutation queue.\n     */\n    // PORTING NOTE: Multi-tab only\n    removeCachedMutationKeys(batchId) {\n        delete this.documentKeysByBatchId[batchId];\n    }\n    performConsistencyCheck(txn) {\n        return this.checkEmpty(txn).next(empty => {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\n            const danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, (key, _, control) => {\n                const userID = key[0];\n                if (userID !== this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    const path = decodeResourcePath(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(() => {\n                hardAssert(danglingMutationReferences.length === 0);\n            });\n        });\n    }\n    containsKey(txn, key) {\n        return mutationQueueContainsKey(txn, this.userId, key);\n    }\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\n    /** Returns the mutation queue's metadata from IndexedDb. */\n    getMutationQueueMetadata(transaction) {\n        return mutationQueuesStore(transaction)\n            .get(this.userId)\n            .next((metadata) => {\n            return (metadata || {\n                userId: this.userId,\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\n                lastStreamToken: ''\n            });\n        });\n    }\n}\n/**\n * @returns true if the mutation queue for the given user contains a pending\n *         mutation for the given key.\n */\nfunction mutationQueueContainsKey(txn, userId, key) {\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\n        const [userID, keyPath, /*batchID*/ _] = key;\n        if (userID === userId && keyPath === encodedPath) {\n            containsKey = true;\n        }\n        control.done();\n    })\n        .next(() => containsKey);\n}\n/** Returns true if any mutation queue contains the given document. */\nfunction mutationQueuesContainKey(txn, docKey) {\n    let found = false;\n    return mutationQueuesStore(txn)\n        .iterateSerial(userId => {\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\n            if (containsKey) {\n                found = true;\n            }\n            return PersistencePromise.resolve(!containsKey);\n        });\n    })\n        .next(() => found);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatchStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueueStore);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Offset to ensure non-overlapping target ids. */\nconst OFFSET = 2;\n/**\n * Generates monotonically increasing target IDs for sending targets to the\n * watch stream.\n *\n * The client constructs two generators, one for the target cache, and one for\n * for the sync engine (to generate limbo documents targets). These\n * generators produce non-overlapping IDs (by using even and odd IDs\n * respectively).\n *\n * By separating the target ID space, the query cache can generate target IDs\n * that persist across client restarts, while sync engine can independently\n * generate in-memory target IDs that are transient and can be reused after a\n * restart.\n */\nclass TargetIdGenerator {\n    constructor(lastId) {\n        this.lastId = lastId;\n    }\n    next() {\n        this.lastId += OFFSET;\n        return this.lastId;\n    }\n    static forTargetCache() {\n        // The target cache generator must return '2' in its first call to `next()`\n        // as there is no differentiation in the protocol layer between an unset\n        // number and the number '0'. If we were to sent a target with target ID\n        // '0', the backend would consider it unset and replace it with its own ID.\n        return new TargetIdGenerator(2 - OFFSET);\n    }\n    static forSyncEngine() {\n        // Sync engine assigns target IDs for limbo document detection.\n        return new TargetIdGenerator(1 - OFFSET);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTargetCache {\n    constructor(referenceDelegate, serializer) {\n        this.referenceDelegate = referenceDelegate;\n        this.serializer = serializer;\n    }\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\n    // some of it (in particular `highestTargetId`) can be modified by secondary\n    // tabs. We could perhaps be more granular (and e.g. still cache\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\n    // out to have a meaningful performance impact.\n    allocateTargetId(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\n            metadata.highestTargetId = targetIdGenerator.next();\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\n        });\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\n        });\n    }\n    getHighestSequenceNumber(transaction) {\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            if (lastRemoteSnapshotVersion) {\n                metadata.lastRemoteSnapshotVersion =\n                    lastRemoteSnapshotVersion.toTimestamp();\n            }\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            }\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    addTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData).next(() => {\n            return this.retrieveMetadata(transaction).next(metadata => {\n                metadata.targetCount += 1;\n                this.updateMetadataFromTargetData(targetData, metadata);\n                return this.saveMetadata(transaction, metadata);\n            });\n        });\n    }\n    updateTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData);\n    }\n    removeTargetData(transaction, targetData) {\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\n            .next(() => this.retrieveMetadata(transaction))\n            .next(metadata => {\n            hardAssert(metadata.targetCount > 0);\n            metadata.targetCount -= 1;\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    /**\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\n     * Returns the number of targets removed.\n     */\n    removeTargets(txn, upperBound, activeTargetIds) {\n        let count = 0;\n        const promises = [];\n        return targetsStore(txn)\n            .iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                count++;\n                promises.push(this.removeTargetData(txn, targetData));\n            }\n        })\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => count);\n    }\n    /**\n     * Call provided function with each `TargetData` that we have cached.\n     */\n    forEachTarget(txn, f) {\n        return targetsStore(txn).iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            f(targetData);\n        });\n    }\n    retrieveMetadata(transaction) {\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobalKey)\n            .next(metadata => {\n            hardAssert(metadata !== null);\n            return metadata;\n        });\n    }\n    saveMetadata(transaction, metadata) {\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\n    }\n    saveTargetData(transaction, targetData) {\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\n    }\n    /**\n     * In-place updates the provided metadata to account for values in the given\n     * TargetData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    updateMetadataFromTargetData(targetData, metadata) {\n        let updated = false;\n        if (targetData.targetId > metadata.highestTargetId) {\n            metadata.highestTargetId = targetData.targetId;\n            updated = true;\n        }\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\n            updated = true;\n        }\n        return updated;\n    }\n    getTargetCount(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\n    }\n    getTargetData(transaction, target) {\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficient.\n        const canonicalId = canonifyTarget(target);\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        let result = null;\n        return targetsStore(transaction)\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\n            const found = fromDbTarget(value);\n            // After finding a potential match, check that the target is\n            // actually equal to the requested target.\n            if (targetEquals(target, found.target)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const promises = [];\n        const store = documentTargetStore(txn);\n        keys.forEach(key => {\n            const path = encodeResourcePath(key.path);\n            promises.push(store.put({ targetId, path }));\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const store = documentTargetStore(txn);\n        return PersistencePromise.forEach(keys, (key) => {\n            const path = encodeResourcePath(key.path);\n            return PersistencePromise.waitFor([\n                store.delete([targetId, path]),\n                this.referenceDelegate.removeReference(txn, targetId, key)\n            ]);\n        });\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        const store = documentTargetStore(txn);\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return store.delete(range);\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        const store = documentTargetStore(txn);\n        let result = documentKeySet();\n        return store\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\n            const path = decodeResourcePath(key[1]);\n            const docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(() => result);\n    }\n    containsKey(txn, key) {\n        const path = encodeResourcePath(key.path);\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        let count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex,\n            keysOnly: true,\n            range\n        }, ([targetId, path], _, control) => {\n            // Having a sentinel row for a document does not count as containing that document;\n            // For the target cache, containing the document means the document is part of some\n            // target.\n            if (targetId !== 0) {\n                count++;\n                control.done();\n            }\n        })\n            .next(() => count > 0);\n    }\n    /**\n     * Looks up a TargetData entry by target ID.\n     *\n     * @param targetId - The target ID of the TargetData entry to look up.\n     * @returns The cached TargetData entry, or null if the cache has no entry for\n     * the target.\n     */\n    // PORTING NOTE: Multi-tab only.\n    getTargetDataForTarget(transaction, targetId) {\n        return targetsStore(transaction)\n            .get(targetId)\n            .next(found => {\n            if (found) {\n                return fromDbTarget(found);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTargetStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocumentStore);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst GC_DID_NOT_RUN = {\n    didRun: false,\n    sequenceNumbersCollected: 0,\n    targetsRemoved: 0,\n    documentsRemoved: 0\n};\nconst LRU_COLLECTION_DISABLED = -1;\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\nclass LruParams {\n    static withCacheSize(cacheSize) {\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n    }\n    constructor(\n    // When we attempt to collect, we will only do so if the cache size is greater than this\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\n    cacheSizeCollectionThreshold, \n    // The percentage of sequence numbers that we will attempt to collect\n    percentileToCollect, \n    // A cap on the total number of sequence numbers that will be collected. This prevents\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\n    maximumSequenceNumbersToCollect) {\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\n        this.percentileToCollect = percentileToCollect;\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\n    }\n}\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$e = 'LruGarbageCollector';\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n/** How long we wait to try running LRU GC after SDK initialization. */\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\n/** Minimum amount of time between GC checks, after the first one. */\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\n    const seqCmp = primitiveComparator(aSequence, bSequence);\n    if (seqCmp === 0) {\n        // This order doesn't matter, but we can bias against churn by sorting\n        // entries created earlier as less than newer entries.\n        return primitiveComparator(aIndex, bIndex);\n    }\n    else {\n        return seqCmp;\n    }\n}\n/**\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\n * lowest n values passed to `addElement`, and finally reports the largest of\n * them in `maxValue`.\n */\nclass RollingSequenceNumberBuffer {\n    constructor(maxElements) {\n        this.maxElements = maxElements;\n        this.buffer = new SortedSet(bufferEntryComparator);\n        this.previousIndex = 0;\n    }\n    nextIndex() {\n        return ++this.previousIndex;\n    }\n    addElement(sequenceNumber) {\n        const entry = [sequenceNumber, this.nextIndex()];\n        if (this.buffer.size < this.maxElements) {\n            this.buffer = this.buffer.add(entry);\n        }\n        else {\n            const highestValue = this.buffer.last();\n            if (bufferEntryComparator(entry, highestValue) < 0) {\n                this.buffer = this.buffer.delete(highestValue).add(entry);\n            }\n        }\n    }\n    get maxValue() {\n        // Guaranteed to be non-empty. If we decide we are not collecting any\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\n        // decided that we are collecting n sequence numbers, it's because n is some\n        // percentage of the existing sequence numbers. That means we should never\n        // be in a situation where we are collecting sequence numbers but don't\n        // actually have any.\n        return this.buffer.last()[0];\n    }\n}\n/**\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\n * whether or not GC is enabled, as well as which delay to use before the next run.\n */\nclass LruScheduler {\n    constructor(garbageCollector, asyncQueue, localStore) {\n        this.garbageCollector = garbageCollector;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.gcTask = null;\n    }\n    start() {\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\n            LRU_COLLECTION_DISABLED) {\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\n        }\n    }\n    stop() {\n        if (this.gcTask) {\n            this.gcTask.cancel();\n            this.gcTask = null;\n        }\n    }\n    get started() {\n        return this.gcTask !== null;\n    }\n    scheduleGC(delay) {\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\n            this.gcTask = null;\n            try {\n                await this.localStore.collectGarbage(this.garbageCollector);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\n        });\n    }\n}\n/**\n * Implements the steps for LRU garbage collection.\n */\nclass LruGarbageCollectorImpl {\n    constructor(delegate, params) {\n        this.delegate = delegate;\n        this.params = params;\n    }\n    calculateTargetCount(txn, percentile) {\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\n            return Math.floor((percentile / 100.0) * targetCount);\n        });\n    }\n    nthSequenceNumber(txn, n) {\n        if (n === 0) {\n            return PersistencePromise.resolve(ListenSequence.INVALID);\n        }\n        const buffer = new RollingSequenceNumberBuffer(n);\n        return this.delegate\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\n            .next(() => {\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\n        })\n            .next(() => buffer.maxValue);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\n    }\n    collect(txn, activeTargetIds) {\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\n        }\n        return this.getCacheSize(txn).next(cacheSize => {\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\n                return GC_DID_NOT_RUN;\n            }\n            else {\n                return this.runGarbageCollection(txn, activeTargetIds);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.delegate.getCacheSize(txn);\n    }\n    runGarbageCollection(txn, activeTargetIds) {\n        let upperBoundSequenceNumber;\n        let sequenceNumbersToCollect, targetsRemoved;\n        // Timestamps for various pieces of the process\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\n        const startTs = Date.now();\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\n            .next(sequenceNumbers => {\n            // Cap at the configured max\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\n                    `from ${sequenceNumbers}`);\n                sequenceNumbersToCollect =\n                    this.params.maximumSequenceNumbersToCollect;\n            }\n            else {\n                sequenceNumbersToCollect = sequenceNumbers;\n            }\n            countedTargetsTs = Date.now();\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\n        })\n            .next(upperBound => {\n            upperBoundSequenceNumber = upperBound;\n            foundUpperBoundTs = Date.now();\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\n        })\n            .next(numTargetsRemoved => {\n            targetsRemoved = numTargetsRemoved;\n            removedTargetsTs = Date.now();\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\n        })\n            .next(documentsRemoved => {\n            removedDocumentsTs = Date.now();\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                const desc = 'LRU Garbage Collection\\n' +\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\n                    `\\tRemoved ${targetsRemoved} targets in ` +\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\n                    `\\tRemoved ${documentsRemoved} documents in ` +\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\n                logDebug('LruGarbageCollector', desc);\n            }\n            return PersistencePromise.resolve({\n                didRun: true,\n                sequenceNumbersCollected: sequenceNumbersToCollect,\n                targetsRemoved,\n                documentsRemoved\n            });\n        });\n    }\n}\nfunction newLruGarbageCollector(delegate, params) {\n    return new LruGarbageCollectorImpl(delegate, params);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Provides LRU functionality for IndexedDB persistence. */\nclass IndexedDbLruDelegateImpl {\n    constructor(db, params) {\n        this.db = db;\n        this.garbageCollector = newLruGarbageCollector(this, params);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachTarget(txn, f) {\n        return this.db.getTargetCache().forEachTarget(txn, f);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\n    }\n    addReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Returns true if anything would prevent this document from being garbage\n     * collected, given that the document in question is not present in any\n     * targets and has a sequence number less than or equal to the upper bound for\n     * the collection run.\n     */\n    isPinned(txn, docKey) {\n        return mutationQueuesContainKey(txn, docKey);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        const documentCache = this.db.getRemoteDocumentCache();\n        const changeBuffer = documentCache.newChangeBuffer();\n        const promises = [];\n        let documentCount = 0;\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\n            if (sequenceNumber <= upperBound) {\n                const p = this.isPinned(txn, docKey).next(isPinned => {\n                    if (!isPinned) {\n                        documentCount++;\n                        // Our size accounting requires us to read all documents before\n                        // removing them.\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\n                        });\n                    }\n                });\n                promises.push(p);\n            }\n        });\n        return iteration\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => changeBuffer.apply(txn))\n            .next(() => documentCount);\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.db.getTargetCache().updateTargetData(txn, updated);\n    }\n    updateLimboDocument(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\n     * means not a part of any target, so the only entry in the target-document index for\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\n     * number for the last time the document was accessed.\n     */\n    forEachOrphanedDocument(txn, f) {\n        const store = documentTargetStore(txn);\n        let nextToReport = ListenSequence.INVALID;\n        let nextPath;\n        return store\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\n            if (targetId === 0) {\n                // if nextToReport is valid, report it, this is a new key so the\n                // last one must not be a member of any targets.\n                if (nextToReport !== ListenSequence.INVALID) {\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n                }\n                // set nextToReport to be this sequence number. It's the next one we\n                // might report, if we don't find any targets for this document.\n                // Note that the sequence number must be defined when the targetId\n                // is 0.\n                nextToReport = sequenceNumber;\n                nextPath = path;\n            }\n            else {\n                // set nextToReport to be invalid, we know we don't need to report\n                // this one since we found a target for it.\n                nextToReport = ListenSequence.INVALID;\n            }\n        })\n            .next(() => {\n            // Since we report sequence numbers after getting to the next key, we\n            // need to check if the last key we iterated over was an orphaned\n            // document and report it.\n            if (nextToReport !== ListenSequence.INVALID) {\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.db.getRemoteDocumentCache().getSize(txn);\n    }\n}\nfunction sentinelKey$1(key) {\n    return [0, encodeResourcePath(key.path)];\n}\n/**\n * @returns A value suitable for writing a sentinel row in the target-document\n * store.\n */\nfunction sentinelRow(key, sequenceNumber) {\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\n}\nfunction writeSentinelKey(txn, key) {\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * Entries added to the cache *must* be read first. This is to facilitate\n * calculating the size delta of the pending changes.\n *\n * PORTING NOTE: This class was implemented then removed from other platforms.\n * If byte-counting ends up being needed on the other platforms, consider\n * porting this class as part of that implementation work.\n */\nclass RemoteDocumentChangeBuffer {\n    constructor() {\n        // A mapping of document key to the new cache entry that should be written.\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n        this.changesApplied = false;\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\n     *\n     * You can only modify documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    addEntry(document) {\n        this.assertNotApplied();\n        this.changes.set(document.key, document);\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\n     *\n     * You can only remove documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    removeEntry(key, readTime) {\n        this.assertNotApplied();\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\n    }\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document or an invalid document if we have nothing\n     * cached.\n     */\n    getEntry(transaction, documentKey) {\n        this.assertNotApplied();\n        const bufferedEntry = this.changes.get(documentKey);\n        if (bufferedEntry !== undefined) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.getFromCache(transaction, documentKey);\n        }\n    }\n    /**\n     * Looks up several entries in the cache, forwarding to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKeys - The keys of the entries to look up.\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\n     *     found, the corresponding key will be mapped to an invalid document.\n     */\n    getEntries(transaction, documentKeys) {\n        return this.getAllFromCache(transaction, documentKeys);\n    }\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    apply(transaction) {\n        this.assertNotApplied();\n        this.changesApplied = true;\n        return this.applyChanges(transaction);\n    }\n    /** Helper to assert this.changes is not null  */\n    assertNotApplied() {\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newIndexedDbRemoteDocumentCache()`.\n */\nclass IndexedDbRemoteDocumentCacheImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entries to the cache.\n     *\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    addEntry(transaction, key, doc) {\n        const documentStore = remoteDocumentsStore(transaction);\n        return documentStore.put(doc);\n    }\n    /**\n     * Removes a document from the cache.\n     *\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    removeEntry(transaction, documentKey, readTime) {\n        const store = remoteDocumentsStore(transaction);\n        return store.delete(dbReadTimeKey(documentKey, readTime));\n    }\n    /**\n     * Updates the current cache size.\n     *\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\n     * cache's metadata.\n     */\n    updateMetadata(transaction, sizeDelta) {\n        return this.getMetadata(transaction).next(metadata => {\n            metadata.byteSize += sizeDelta;\n            return this.setMetadata(transaction, metadata);\n        });\n    }\n    getEntry(transaction, documentKey) {\n        let doc = MutableDocument.newInvalidDocument(documentKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\n        })\n            .next(() => doc);\n    }\n    /**\n     * Looks up an entry in the cache.\n     *\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document entry and its size.\n     */\n    getSizedEntry(transaction, documentKey) {\n        let result = {\n            size: 0,\n            document: MutableDocument.newInvalidDocument(documentKey)\n        };\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            result = {\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\n                size: dbDocumentSize(dbRemoteDoc)\n            };\n        })\n            .next(() => result);\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n        }).next(() => results);\n    }\n    /**\n     * Looks up several entries in the cache.\n     *\n     * @param documentKeys - The set of keys entries to look up.\n     * @returns A map of documents indexed by key and a map of sizes indexed by\n     *     key (zero if the document does not exist).\n     */\n    getSizedEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        let sizeMap = new SortedMap(DocumentKey.comparator);\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\n        }).next(() => {\n            return { documents: results, sizeMap };\n        });\n    }\n    forEachDbEntry(transaction, documentKeys, callback) {\n        if (documentKeys.isEmpty()) {\n            return PersistencePromise.resolve();\n        }\n        let sortedKeys = new SortedSet(dbKeyComparator);\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\n        const keyIter = sortedKeys.getIterator();\n        let nextKey = keyIter.getNext();\n        return remoteDocumentsStore(transaction)\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\n            const potentialKey = DocumentKey.fromSegments([\n                ...dbRemoteDoc.prefixPath,\n                dbRemoteDoc.collectionGroup,\n                dbRemoteDoc.documentId\n            ]);\n            // Go through keys not found in cache.\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\n                callback(nextKey, null);\n                nextKey = keyIter.getNext();\n            }\n            if (nextKey && nextKey.isEqual(potentialKey)) {\n                // Key found in cache.\n                callback(nextKey, dbRemoteDoc);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n            // Skip to the next key (if there is one).\n            if (nextKey) {\n                control.skip(dbKey(nextKey));\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => {\n            // The rest of the keys are not in the cache. One case where `iterate`\n            // above won't go through them is when the cache is empty.\n            while (nextKey) {\n                callback(nextKey, null);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n        });\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\n        const collection = query.path;\n        const startKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            toDbTimestampKey(offset.readTime),\n            offset.documentKey.path.isEmpty()\n                ? ''\n                : offset.documentKey.path.lastSegment()\n        ];\n        const endKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n            ''\n        ];\n        return remoteDocumentsStore(transaction)\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\n            .next(dbRemoteDocs => {\n            context === null || context === void 0 ? void 0 : context.incrementDocumentReadCount(dbRemoteDocs.length);\n            let results = mutableDocumentMap();\n            for (const dbRemoteDoc of dbRemoteDocs) {\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n                if (document.isFoundDocument() &&\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\n                    // Either the document matches the given query, or it is mutated.\n                    results = results.insert(document.key, document);\n                }\n            }\n            return results;\n        });\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        let results = mutableDocumentMap();\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentCollectionGroupIndex,\n            range: IDBKeyRange.bound(startKey, endKey, true)\n        }, (_, dbRemoteDoc, control) => {\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n            results = results.insert(document.key, document);\n            if (results.size === limit) {\n                control.done();\n            }\n        })\n            .next(() => results);\n    }\n    newChangeBuffer(options) {\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\n    }\n    getSize(txn) {\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\n    }\n    getMetadata(txn) {\n        return documentGlobalStore(txn)\n            .get(DbRemoteDocumentGlobalKey)\n            .next(metadata => {\n            hardAssert(!!metadata);\n            return metadata;\n        });\n    }\n    setMetadata(txn, metadata) {\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\n    }\n    /**\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\n     * the document corresponds to the format used for sentinel deletes).\n     */\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\n        if (dbRemoteDoc) {\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\n            // Whether the document is a sentinel removal and should only be used in the\n            // `getNewDocumentChanges()`\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\n            if (!isSentinelRemoval) {\n                return doc;\n            }\n        }\n        return MutableDocument.newInvalidDocument(documentKey);\n    }\n}\n/** Creates a new IndexedDbRemoteDocumentCache. */\nfunction newIndexedDbRemoteDocumentCache(serializer) {\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\n}\n/**\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\n *\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\n * when we apply the changes.\n */\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    /**\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\n     * `getNewDocumentChanges()`.\n     */\n    constructor(documentCache, trackRemovals) {\n        super();\n        this.documentCache = documentCache;\n        this.trackRemovals = trackRemovals;\n        // A map of document sizes and read times prior to applying the changes in\n        // this buffer.\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        let sizeDelta = 0;\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n        this.changes.forEach((key, documentChange) => {\n            const previousDoc = this.documentStates.get(key);\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\n            if (documentChange.isValidDocument()) {\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\n                collectionParents = collectionParents.add(key.path.popLast());\n                const size = dbDocumentSize(doc);\n                sizeDelta += size - previousDoc.size;\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\n            }\n            else {\n                sizeDelta -= previousDoc.size;\n                if (this.trackRemovals) {\n                    // In order to track removals, we store a \"sentinel delete\" in the\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\n                    // preserved in `getNewDocumentChanges()`.\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\n                }\n            }\n        });\n        collectionParents.forEach(parent => {\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\n        });\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        // Record the size of everything we load from the cache so we can compute a delta later.\n        return this.documentCache\n            .getSizedEntry(transaction, documentKey)\n            .next(getResult => {\n            this.documentStates.set(documentKey, {\n                size: getResult.size,\n                readTime: getResult.document.readTime\n            });\n            return getResult.document;\n        });\n    }\n    getAllFromCache(transaction, documentKeys) {\n        // Record the size of everything we load from the cache so we can compute\n        // a delta later.\n        return this.documentCache\n            .getSizedEntries(transaction, documentKeys)\n            .next(({ documents, sizeMap }) => {\n            // Note: `getAllFromCache` returns two maps instead of a single map from\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\n            // `MutableDocumentMap` directly, without a conversion.\n            sizeMap.forEach((documentKey, size) => {\n                this.documentStates.set(documentKey, {\n                    size,\n                    readTime: documents.get(documentKey).readTime\n                });\n            });\n            return documents;\n        });\n    }\n}\nfunction documentGlobalStore(txn) {\n    return getStore(txn, DbRemoteDocumentGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    return getStore(txn, DbRemoteDocumentStore);\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentKeyIndex` index.\n */\nfunction dbKey(documentKey) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups via the primary key of\n * the DbRemoteDocument object store.\n */\nfunction dbReadTimeKey(documentKey, readTime) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        toDbTimestampKey(readTime),\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\n */\nfunction dbCollectionGroupKey(collectionGroup, offset) {\n    const path = offset.documentKey.path.toArray();\n    return [\n        /* collection id */ collectionGroup,\n        toDbTimestampKey(offset.readTime),\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\n    ];\n}\n/**\n * Comparator that compares document keys according to the primary key sorting\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\n * and then document ID).\n *\n * Visible for testing.\n */\nfunction dbKeyComparator(l, r) {\n    const left = l.path.toArray();\n    const right = r.path.toArray();\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\n    let cmp = 0;\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\n        cmp = primitiveComparator(left[i], right[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    cmp = primitiveComparator(left.length, right.length);\n    if (cmp) {\n        return cmp;\n    }\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\n    if (cmp) {\n        return cmp;\n    }\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Schema Version for the Web client:\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\n *     Document Cache\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\n *     longer required because migration 3 unconditionally clears it.\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\n *     to limbo resolution. Addresses\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\n * 4.  Multi-Tab Support.\n * 5.  Removal of held write acks.\n * 6.  Create document global for tracking document cache size.\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\n * 8.  Add collection-parent index for Collection Group queries.\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\n *     an auto-incrementing ID. This is required for Index-Free queries.\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\n * 11. Add bundles and named_queries for bundle support.\n * 12. Add document overlays.\n * 13. Rewrite the keys of the remote document cache to allow for efficient\n *     document lookup via `getAll()`.\n * 14. Add overlays.\n * 15. Add indexing support.\n * 16. Parse timestamp strings before creating index entries.\n */\nconst SCHEMA_VERSION = 17;\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a local view (overlay) of a document, and the fields that are\n * locally mutated.\n */\nclass OverlayedDocument {\n    constructor(overlayedDocument, \n    /**\n     * The fields that are locally mutated by patch mutations.\n     *\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\n     */\n    mutatedFields) {\n        this.overlayedDocument = overlayedDocument;\n        this.mutatedFields = mutatedFields;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nclass LocalDocumentsView {\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n        this.documentOverlayCache = documentOverlayCache;\n        this.indexManager = indexManager;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @returns Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    getDocument(transaction, key) {\n        let overlay = null;\n        return this.documentOverlayCache\n            .getOverlay(transaction, key)\n            .next(value => {\n            overlay = value;\n            return this.remoteDocumentCache.getEntry(transaction, key);\n        })\n            .next(document => {\n            if (overlay !== null) {\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n            }\n            return document;\n        });\n    }\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    getDocuments(transaction, keys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, keys)\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\n    }\n    /**\n     * Similar to `getDocuments`, but creates the local view from the given\n     * `baseDocs` without retrieving documents from the local store.\n     *\n     * @param transaction - The transaction this operation is scoped to.\n     * @param docs - The documents to apply local mutations to get the local views.\n     * @param existenceStateChanged - The set of document keys whose existence state\n     *   is changed. This is useful to determine if some documents overlay needs\n     *   to be recalculated.\n     */\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\n                let result = documentMap();\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\n                });\n                return result;\n            });\n        });\n    }\n    /**\n     * Gets the overlayed documents for the given document map, which will include\n     * the local view of those documents and a `FieldMask` indicating which fields\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\n     */\n    getOverlayedDocuments(transaction, docs) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\n    }\n    /**\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\n     * if the map does not already contain an entry for the given document key.\n     */\n    populateOverlays(transaction, overlays, docs) {\n        const missingOverlays = [];\n        docs.forEach(key => {\n            if (!overlays.has(key)) {\n                missingOverlays.push(key);\n            }\n        });\n        return this.documentOverlayCache\n            .getOverlays(transaction, missingOverlays)\n            .next(result => {\n            result.forEach((key, val) => {\n                overlays.set(key, val);\n            });\n        });\n    }\n    /**\n     * Computes the local view for the given documents.\n     *\n     * @param docs - The documents to compute views for. It also has the base\n     *   version of the documents.\n     * @param overlays - The overlays that need to be applied to the given base\n     *   version of the documents.\n     * @param existenceStateChanged - A set of documents whose existence states\n     *   might have changed. This is used to determine if we need to re-calculate\n     *   overlays from mutation queues.\n     * @return A map represents the local documents view.\n     */\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\n        let recalculateDocuments = mutableDocumentMap();\n        const mutatedFields = newDocumentKeyMap();\n        const results = newOverlayedDocumentMap();\n        docs.forEach((_, doc) => {\n            const overlay = overlays.get(doc.key);\n            // Recalculate an overlay if the document's existence state changed due to\n            // a remote event *and* the overlay is a PatchMutation. This is because\n            // document existence state can change if some patch mutation's\n            // preconditions are met.\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\n            // might be a patch mutation whose precondition does not match before the\n            // change (hence overlay is undefined), but would now match.\n            if (existenceStateChanged.has(doc.key) &&\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\n            }\n            else if (overlay !== undefined) {\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\n            }\n            else {\n                // no overlay exists\n                // Using EMPTY to indicate there is no overlay for the document.\n                mutatedFields.set(doc.key, FieldMask.empty());\n            }\n        });\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\n            docs.forEach((documentKey, document) => {\n                var _a;\n                return results.set(documentKey, new OverlayedDocument(document, (_a = mutatedFields.get(documentKey)) !== null && _a !== void 0 ? _a : null));\n            });\n            return results;\n        });\n    }\n    recalculateAndSaveOverlays(transaction, docs) {\n        const masks = newDocumentKeyMap();\n        // A reverse lookup map from batch id to the documents within that batch.\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\n        let processed = documentKeySet();\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\n            .next(batches => {\n            for (const batch of batches) {\n                batch.keys().forEach(key => {\n                    const baseDoc = docs.get(key);\n                    if (baseDoc === null) {\n                        return;\n                    }\n                    let mask = masks.get(key) || FieldMask.empty();\n                    mask = batch.applyToLocalView(baseDoc, mask);\n                    masks.set(key, mask);\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\n                });\n            }\n        })\n            .next(() => {\n            const promises = [];\n            // Iterate in descending order of batch IDs, and skip documents that are\n            // already saved.\n            const iter = documentsByBatchId.getReverseIterator();\n            while (iter.hasNext()) {\n                const entry = iter.getNext();\n                const batchId = entry.key;\n                const keys = entry.value;\n                const overlays = newMutationMap();\n                keys.forEach(key => {\n                    if (!processed.has(key)) {\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\n                        if (overlayMutation !== null) {\n                            overlays.set(key, overlayMutation);\n                        }\n                        processed = processed.add(key);\n                    }\n                });\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(() => masks);\n    }\n    /**\n     * Recalculates overlays by reading the documents from remote document cache\n     * first, and saves them after they are calculated.\n     */\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, documentKeys)\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\n    }\n    /**\n     * Performs a query against the local view of all documents.\n     *\n     * @param transaction - The persistence transaction.\n     * @param query - The query to match documents against.\n     * @param offset - Read time and key to start scanning by (exclusive).\n     * @param context - A optional tracker to keep a record of important details\n     *   during database local query execution.\n     */\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\n        if (isDocumentQuery$1(query)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else if (isCollectionGroupQuery(query)) {\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\n        }\n    }\n    /**\n     * Given a collection group, returns the next documents that follow the provided offset, along\n     * with an updated batch ID.\n     *\n     * <p>The documents returned by this method are ordered by remote version from the provided\n     * offset. If there are no more remote documents after the provided offset, documents with\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\n     * returned together, the total number of documents returned can exceed {@code count}.\n     *\n     * @param transaction\n     * @param collectionGroup The collection group for the documents.\n     * @param offset The offset to index into.\n     * @param count The number of documents to return\n     * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\n     */\n    getNextDocuments(transaction, collectionGroup, offset, count) {\n        return this.remoteDocumentCache\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\n            .next((originalDocs) => {\n            const overlaysPromise = count - originalDocs.size > 0\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\n                : PersistencePromise.resolve(newOverlayMap());\n            // The callsite will use the largest batch ID together with the latest read time to create\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\n            // no overlay will increase the overall read time. This is why we only need to special case\n            // the batch id.\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\n            let modifiedDocs = originalDocs;\n            return overlaysPromise.next(overlays => {\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\n                    if (largestBatchId < overlay.largestBatchId) {\n                        largestBatchId = overlay.largestBatchId;\n                    }\n                    if (originalDocs.get(key)) {\n                        return PersistencePromise.resolve();\n                    }\n                    return this.remoteDocumentCache\n                        .getEntry(transaction, key)\n                        .next(doc => {\n                        modifiedDocs = modifiedDocs.insert(key, doc);\n                    });\n                })\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\n                    .next(localDocs => ({\n                    batchId: largestBatchId,\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\n                }));\n            });\n        });\n    }\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\n            let result = documentMap();\n            if (document.isFoundDocument()) {\n                result = result.insert(document.key, document);\n            }\n            return result;\n        });\n    }\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\n        const collectionId = query.collectionGroup;\n        let results = documentMap();\n        return this.indexManager\n            .getCollectionParents(transaction, collectionId)\n            .next(parents => {\n            // Perform a collection query against each parent that contains the\n            // collectionId and aggregate the results.\n            return PersistencePromise.forEach(parents, (parent) => {\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\n                    r.forEach((key, doc) => {\n                        results = results.insert(key, doc);\n                    });\n                });\n            }).next(() => results);\n        });\n    }\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\n        // Query the remote documents and overlay mutations.\n        let overlays;\n        return this.documentOverlayCache\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\n            .next(result => {\n            overlays = result;\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\n        })\n            .next(remoteDocuments => {\n            // As documents might match the query because of their overlay we need to\n            // include documents for all overlays in the initial document set.\n            overlays.forEach((_, overlay) => {\n                const key = overlay.getKey();\n                if (remoteDocuments.get(key) === null) {\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\n                }\n            });\n            // Apply the overlays and match against the query.\n            let results = documentMap();\n            remoteDocuments.forEach((key, document) => {\n                const overlay = overlays.get(key);\n                if (overlay !== undefined) {\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n                }\n                // Finally, insert the documents that still match the query\n                if (queryMatches(query, document)) {\n                    results = results.insert(key, document);\n                }\n            });\n            return results;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryBundleCache {\n    constructor(serializer) {\n        this.serializer = serializer;\n        this.bundles = new Map();\n        this.namedQueries = new Map();\n    }\n    getBundleMetadata(transaction, bundleId) {\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\n        return PersistencePromise.resolve();\n    }\n    getNamedQuery(transaction, queryName) {\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\n    }\n    saveNamedQuery(transaction, query) {\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of DocumentOverlayCache.\n */\nclass MemoryDocumentOverlayCache {\n    constructor() {\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\n        // for the overlay and the overlay itself.\n        this.overlays = new SortedMap(DocumentKey.comparator);\n        this.overlayByBatchId = new Map();\n    }\n    getOverlay(transaction, key) {\n        return PersistencePromise.resolve(this.overlays.get(key));\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        overlays.forEach((_, mutation) => {\n            this.saveOverlay(transaction, largestBatchId, mutation);\n        });\n        return PersistencePromise.resolve();\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const keys = this.overlayByBatchId.get(batchId);\n        if (keys !== undefined) {\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\n            this.overlayByBatchId.delete(batchId);\n        }\n        return PersistencePromise.resolve();\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const immediateChildrenPathLength = collection.length + 1;\n        const prefix = new DocumentKey(collection.child(''));\n        const iter = this.overlays.getIteratorFrom(prefix);\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (!collection.isPrefixOf(key.path)) {\n                break;\n            }\n            // Documents from sub-collections\n            if (key.path.length !== immediateChildrenPathLength) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                result.set(overlay.getKey(), overlay);\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\n        const iter = this.overlays.getIterator();\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (key.getCollectionGroup() !== collectionGroup) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\n                if (overlaysForBatchId === null) {\n                    overlaysForBatchId = newOverlayMap();\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\n                }\n                overlaysForBatchId.set(overlay.getKey(), overlay);\n            }\n        }\n        const result = newOverlayMap();\n        const batchIter = batchIdToOverlays.getIterator();\n        while (batchIter.hasNext()) {\n            const entry = batchIter.getNext();\n            const overlays = entry.value;\n            overlays.forEach((key, overlay) => result.set(key, overlay));\n            if (result.size() >= count) {\n                break;\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    saveOverlay(transaction, largestBatchId, mutation) {\n        // Remove the association of the overlay to its batch id.\n        const existing = this.overlays.get(mutation.key);\n        if (existing !== null) {\n            const newSet = this.overlayByBatchId\n                .get(existing.largestBatchId)\n                .delete(mutation.key);\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\n        }\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\n        // Create the association of this overlay to the given largestBatchId.\n        let batch = this.overlayByBatchId.get(largestBatchId);\n        if (batch === undefined) {\n            batch = documentKeySet();\n            this.overlayByBatchId.set(largestBatchId, batch);\n        }\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryGlobalsCache {\n    constructor() {\n        this.sessionToken = ByteString.EMPTY_BYTE_STRING;\n    }\n    getSessionToken(transaction) {\n        return PersistencePromise.resolve(this.sessionToken);\n    }\n    setSessionToken(transaction, sessionToken) {\n        this.sessionToken = sessionToken;\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nclass ReferenceSet {\n    constructor() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n    }\n    /** Returns true if the reference set contains no references. */\n    isEmpty() {\n        return this.refsByKey.isEmpty();\n    }\n    /** Adds a reference to the given document key for the given ID. */\n    addReference(key, id) {\n        const ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    }\n    /** Add references to the given document keys for the given ID. */\n    addReferences(keys, id) {\n        keys.forEach(key => this.addReference(key, id));\n    }\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    removeReference(key, id) {\n        this.removeRef(new DocReference(key, id));\n    }\n    removeReferences(keys, id) {\n        keys.forEach(key => this.removeReference(key, id));\n    }\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    removeReferencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        const keys = [];\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            this.removeRef(ref);\n            keys.push(ref.key);\n        });\n        return keys;\n    }\n    removeAllReferences() {\n        this.refsByKey.forEach(ref => this.removeRef(ref));\n    }\n    removeRef(ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n    }\n    referencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        let keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    }\n    containsKey(key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return firstRef !== null && key.isEqual(firstRef.key);\n    }\n}\nclass DocReference {\n    constructor(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    static compareByKey(left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    }\n    /** Compare by ID then by key */\n    static compareByTargetId(left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryMutationQueue {\n    constructor(indexManager, referenceDelegate) {\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    checkEmpty(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            this.mutationQueue[this.mutationQueue.length - 1];\n        }\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key and index collection parents.\n        for (const mutation of mutations) {\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\n        }\n        return PersistencePromise.resolve(batch);\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        const rawIndex = this.indexOfBatchId(nextBatchId);\n        const index = rawIndex < 0 ? 0 : rawIndex;\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\n    }\n    getHighestUnacknowledgedBatchId() {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\n    }\n    getAllMutationBatches(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.slice());\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        const start = new DocReference(documentKey, 0);\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        const result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        documentKeys.forEach(documentKey => {\n            const start = new DocReference(documentKey, 0);\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n            });\n        });\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        const prefix = query.path;\n        const immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        let startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        const start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(ref => {\n            const rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    findMutationBatches(batchIDs) {\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        const result = [];\n        batchIDs.forEach(batchId => {\n            const batch = this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return result;\n    }\n    removeMutationBatch(transaction, batch) {\n        // Find the position of the first batch for removal.\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\n        hardAssert(batchIndex === 0);\n        this.mutationQueue.shift();\n        let references = this.batchesByDocumentKey;\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\n            const ref = new DocReference(mutation.key, batch.batchId);\n            references = references.delete(ref);\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\n        }).next(() => {\n            this.batchesByDocumentKey = references;\n        });\n    }\n    removeCachedMutationKeys(batchId) {\n        // No-op since the memory mutation queue does not maintain a separate cache.\n    }\n    containsKey(txn, key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    }\n    performConsistencyCheck(txn) {\n        if (this.mutationQueue.length === 0) ;\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId - The batchId to search for\n     * @param action - A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    indexOfExistingBatchId(batchId, action) {\n        const index = this.indexOfBatchId(batchId);\n        return index;\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @returns The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been removed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    indexOfBatchId(batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        const firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    }\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficient.\n     */\n    findMutationBatch(batchId) {\n        const index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        const batch = this.mutationQueue[index];\n        return batch;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The smallest value representable by a 64-bit signed integer (long).\n */\nconst MIN_LONG_VALUE = '-9223372036854775808';\nfunction documentEntryMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\n/**\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newMemoryRemoteDocumentCache()`.\n */\nclass MemoryRemoteDocumentCacheImpl {\n    /**\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\n     * expected to just return 0 to avoid unnecessarily doing the work of\n     * calculating the size.\n     */\n    constructor(sizer) {\n        this.sizer = sizer;\n        /** Underlying cache of documents and their read times. */\n        this.docs = documentEntryMap();\n        /** Size of all cached documents. */\n        this.size = 0;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\n     *\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    addEntry(transaction, doc) {\n        const key = doc.key;\n        const entry = this.docs.get(key);\n        const previousSize = entry ? entry.size : 0;\n        const currentSize = this.sizer(doc);\n        this.docs = this.docs.insert(key, {\n            document: doc.mutableCopy(),\n            size: currentSize\n        });\n        this.size += currentSize - previousSize;\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\n    }\n    /**\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\n     *\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    removeEntry(documentKey) {\n        const entry = this.docs.get(documentKey);\n        if (entry) {\n            this.docs = this.docs.remove(documentKey);\n            this.size -= entry.size;\n        }\n    }\n    getEntry(transaction, documentKey) {\n        const entry = this.docs.get(documentKey);\n        return PersistencePromise.resolve(entry\n            ? entry.document.mutableCopy()\n            : MutableDocument.newInvalidDocument(documentKey));\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        documentKeys.forEach(documentKey => {\n            const entry = this.docs.get(documentKey);\n            results = results.insert(documentKey, entry\n                ? entry.document.mutableCopy()\n                : MutableDocument.newInvalidDocument(documentKey));\n        });\n        return PersistencePromise.resolve(results);\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\n        let results = mutableDocumentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        const collectionPath = query.path;\n        // Document keys are ordered first by numeric value (\"__id<Long>__\"),\n        // then lexicographically by string value. Start the iterator at the minimum\n        // possible Document key value.\n        const prefix = new DocumentKey(collectionPath.child('__id' + MIN_LONG_VALUE + '__'));\n        const iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            const { key, value: { document } } = iterator.getNext();\n            if (!collectionPath.isPrefixOf(key.path)) {\n                break;\n            }\n            if (key.path.length > collectionPath.length + 1) {\n                // Exclude entries from subcollections.\n                continue;\n            }\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\n                // The document sorts before the offset.\n                continue;\n            }\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\n                // The document cannot possibly match the query.\n                continue;\n            }\n            results = results.insert(document.key, document.mutableCopy());\n        }\n        return PersistencePromise.resolve(results);\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        // This method should only be called from the IndexBackfiller if persistence\n        // is enabled.\n        fail();\n    }\n    forEachDocumentKey(transaction, f) {\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\n    }\n    newChangeBuffer(options) {\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\n        // a separate changelog and does not need special handling for removals.\n        return new MemoryRemoteDocumentChangeBuffer(this);\n    }\n    getSize(txn) {\n        return PersistencePromise.resolve(this.size);\n    }\n}\n/**\n * Creates a new memory-only RemoteDocumentCache.\n *\n * @param sizer - Used to assess the size of a document. For eager GC, this is\n * expected to just return 0 to avoid unnecessarily doing the work of\n * calculating the size.\n */\nfunction newMemoryRemoteDocumentCache(sizer) {\n    return new MemoryRemoteDocumentCacheImpl(sizer);\n}\n/**\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\n */\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    constructor(documentCache) {\n        super();\n        this.documentCache = documentCache;\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        this.changes.forEach((key, doc) => {\n            if (doc.isValidDocument()) {\n                promises.push(this.documentCache.addEntry(transaction, doc));\n            }\n            else {\n                this.documentCache.removeEntry(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        return this.documentCache.getEntry(transaction, documentKey);\n    }\n    getAllFromCache(transaction, documentKeys) {\n        return this.documentCache.getEntries(transaction, documentKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryTargetCache {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /**\n         * Maps a target to the data about that target\n         */\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /** The highest sequence number encountered. */\n        this.highestSequenceNumber = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n        this.targetCount = 0;\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\n    }\n    forEachTarget(txn, f) {\n        this.targets.forEach((_, targetData) => f(targetData));\n        return PersistencePromise.resolve();\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\n    }\n    getHighestSequenceNumber(transaction) {\n        return PersistencePromise.resolve(this.highestSequenceNumber);\n    }\n    allocateTargetId(transaction) {\n        this.highestTargetId = this.targetIdGenerator.next();\n        return PersistencePromise.resolve(this.highestTargetId);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        if (lastRemoteSnapshotVersion) {\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        }\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = highestListenSequenceNumber;\n        }\n        return PersistencePromise.resolve();\n    }\n    saveTargetData(targetData) {\n        this.targets.set(targetData.target, targetData);\n        const targetId = targetData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\n            this.highestTargetId = targetId;\n        }\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = targetData.sequenceNumber;\n        }\n    }\n    addTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        this.targetCount += 1;\n        return PersistencePromise.resolve();\n    }\n    updateTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        return PersistencePromise.resolve();\n    }\n    removeTargetData(transaction, targetData) {\n        this.targets.delete(targetData.target);\n        this.references.removeReferencesForId(targetData.targetId);\n        this.targetCount -= 1;\n        return PersistencePromise.resolve();\n    }\n    removeTargets(transaction, upperBound, activeTargetIds) {\n        let count = 0;\n        const removals = [];\n        this.targets.forEach((key, targetData) => {\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                this.targets.delete(key);\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\n                count++;\n            }\n        });\n        return PersistencePromise.waitFor(removals).next(() => count);\n    }\n    getTargetCount(transaction) {\n        return PersistencePromise.resolve(this.targetCount);\n    }\n    getTargetData(transaction, target) {\n        const targetData = this.targets.get(target) || null;\n        return PersistencePromise.resolve(targetData);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        const referenceDelegate = this.persistence.referenceDelegate;\n        const promises = [];\n        if (referenceDelegate) {\n            keys.forEach(key => {\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\n            });\n        }\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    }\n    containsKey(txn, key) {\n        return PersistencePromise.resolve(this.references.containsKey(key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$d = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nclass MemoryPersistence {\n    /**\n     * The constructor accepts a factory for creating a reference delegate. This\n     * allows both the delegate and this instance to have strong references to\n     * each other without having nullable fields that would then need to be\n     * checked or asserted on every access.\n     */\n    constructor(referenceDelegateFactory, serializer) {\n        this.mutationQueues = {};\n        this.overlays = {};\n        this.listenSequence = new ListenSequence(0);\n        this._started = false;\n        this._started = true;\n        this.globalsCache = new MemoryGlobalsCache();\n        this.referenceDelegate = referenceDelegateFactory(this);\n        this.targetCache = new MemoryTargetCache(this);\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\n        this.indexManager = new MemoryIndexManager();\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\n        this.serializer = new LocalSerializer(serializer);\n        this.bundleCache = new MemoryBundleCache(this.serializer);\n    }\n    start() {\n        return Promise.resolve();\n    }\n    shutdown() {\n        // No durable state to ensure is closed on shutdown.\n        this._started = false;\n        return Promise.resolve();\n    }\n    get started() {\n        return this._started;\n    }\n    setDatabaseDeletedListener() {\n        // No op.\n    }\n    setNetworkEnabled() {\n        // No op.\n    }\n    getIndexManager(user) {\n        // We do not currently support indices for memory persistence, so we can\n        // return the same shared instance of the memory index manager.\n        return this.indexManager;\n    }\n    getDocumentOverlayCache(user) {\n        let overlay = this.overlays[user.toKey()];\n        if (!overlay) {\n            overlay = new MemoryDocumentOverlayCache();\n            this.overlays[user.toKey()] = overlay;\n        }\n        return overlay;\n    }\n    getMutationQueue(user, indexManager) {\n        let queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\n        const txn = new MemoryTransaction(this.listenSequence.next());\n        this.referenceDelegate.onTransactionStarted();\n        return transactionOperation(txn)\n            .next(result => {\n            return this.referenceDelegate\n                .onTransactionCommitted(txn)\n                .next(() => result);\n        })\n            .toPromise()\n            .then(result => {\n            txn.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    mutationQueuesContainKey(transaction, key) {\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\n    }\n}\n/**\n * Memory persistence is not actually transactional, but future implementations\n * may have transaction-scoped state.\n */\nclass MemoryTransaction extends PersistenceTransaction {\n    constructor(currentSequenceNumber) {\n        super();\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nclass MemoryEagerDelegate {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /** Tracks all documents that are active in Query views. */\n        this.localViewReferences = new ReferenceSet();\n        /** The list of documents that are potentially GCed after each transaction. */\n        this._orphanedDocuments = null;\n    }\n    static factory(persistence) {\n        return new MemoryEagerDelegate(persistence);\n    }\n    get orphanedDocuments() {\n        if (!this._orphanedDocuments) {\n            throw fail();\n        }\n        else {\n            return this._orphanedDocuments;\n        }\n    }\n    addReference(txn, targetId, key) {\n        this.localViewReferences.addReference(key, targetId);\n        this.orphanedDocuments.delete(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.localViewReferences.removeReference(key, targetId);\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\n        const cache = this.persistence.getTargetCache();\n        return cache\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\n            .next(keys => {\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\n        })\n            .next(() => cache.removeTargetData(txn, targetData));\n    }\n    onTransactionStarted() {\n        this._orphanedDocuments = new Set();\n    }\n    onTransactionCommitted(txn) {\n        // Remove newly orphaned documents.\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\n            const key = DocumentKey.fromPath(path);\n            return this.isReferenced(txn, key).next(isReferenced => {\n                if (!isReferenced) {\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        }).next(() => {\n            this._orphanedDocuments = null;\n            return changeBuffer.apply(txn);\n        });\n    }\n    updateLimboDocument(txn, key) {\n        return this.isReferenced(txn, key).next(isReferenced => {\n            if (isReferenced) {\n                this.orphanedDocuments.delete(key.toString());\n            }\n            else {\n                this.orphanedDocuments.add(key.toString());\n            }\n        });\n    }\n    documentSize(doc) {\n        // For eager GC, we don't care about the document size, there are no size thresholds.\n        return 0;\n    }\n    isReferenced(txn, key) {\n        return PersistencePromise.or([\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => this.persistence.mutationQueuesContainKey(txn, key)\n        ]);\n    }\n}\nclass MemoryLruDelegate {\n    constructor(persistence, lruParams) {\n        this.persistence = persistence;\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\n    }\n    static factory(persistence, lruParams) {\n        return new MemoryLruDelegate(persistence, lruParams);\n    }\n    // No-ops, present so memory persistence doesn't have to care which delegate\n    // it has.\n    onTransactionStarted() { }\n    onTransactionCommitted(txn) {\n        return PersistencePromise.resolve();\n    }\n    forEachTarget(txn, f) {\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.persistence\n            .getTargetCache()\n            .getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\n            // being too recent.\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\n                if (!isPinned) {\n                    return f(sequenceNumber);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.persistence\n            .getTargetCache()\n            .removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        let count = 0;\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        const p = cache.forEachDocumentKey(txn, key => {\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\n                if (!isPinned) {\n                    count++;\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        });\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\n    }\n    addReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    updateLimboDocument(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    documentSize(document) {\n        let documentSize = document.key.toString().length;\n        if (document.isFoundDocument()) {\n            documentSize += estimateByteSize(document.data.value);\n        }\n        return documentSize;\n    }\n    isPinned(txn, key, upperBound) {\n        return PersistencePromise.or([\n            () => this.persistence.mutationQueuesContainKey(txn, key),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => {\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\n            }\n        ]);\n    }\n    getCacheSize(txn) {\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Performs database creation and schema upgrades. */\nclass SchemaConverter {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    /**\n     * Performs database creation and schema upgrades.\n     *\n     * Note that in production, this method is only ever used to upgrade the schema\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n     * and local feature development.\n     */\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\n        if (fromVersion < 1 && toVersion >= 1) {\n            createPrimaryClientStore(db);\n            createMutationQueue(db);\n            createQueryCache(db);\n            createLegacyRemoteDocumentCache(db);\n        }\n        // Migration 2 to populate the targetGlobal object no longer needed since\n        // migration 3 unconditionally clears it.\n        let p = PersistencePromise.resolve();\n        if (fromVersion < 3 && toVersion >= 3) {\n            // Brand new clients don't need to drop and recreate--only clients that\n            // potentially have corrupt data.\n            if (fromVersion !== 0) {\n                dropQueryCache(db);\n                createQueryCache(db);\n            }\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\n        }\n        if (fromVersion < 4 && toVersion >= 4) {\n            if (fromVersion !== 0) {\n                // Schema version 3 uses auto-generated keys to generate globally unique\n                // mutation batch IDs (this was previously ensured internally by the\n                // client). To migrate to the new schema, we have to read all mutations\n                // and write them back out. We preserve the existing batch IDs to guarantee\n                // consistency with other object stores. Any further mutation batch IDs will\n                // be auto-generated.\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\n            }\n            p = p.next(() => {\n                createClientMetadataStore(db);\n            });\n        }\n        if (fromVersion < 5 && toVersion >= 5) {\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\n        }\n        if (fromVersion < 6 && toVersion >= 6) {\n            p = p.next(() => {\n                createDocumentGlobalStore(db);\n                return this.addDocumentGlobal(simpleDbTransaction);\n            });\n        }\n        if (fromVersion < 7 && toVersion >= 7) {\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\n        }\n        if (fromVersion < 8 && toVersion >= 8) {\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\n        }\n        if (fromVersion < 9 && toVersion >= 9) {\n            p = p.next(() => {\n                // Multi-Tab used to manage its own changelog, but this has been moved\n                // to the DbRemoteDocument object store itself. Since the previous change\n                // log only contained transient data, we can drop its object store.\n                dropRemoteDocumentChangesStore(db);\n                // Note: Schema version 9 used to create a read time index for the\n                // RemoteDocumentCache. This is now done with schema version 13.\n            });\n        }\n        if (fromVersion < 10 && toVersion >= 10) {\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\n        }\n        if (fromVersion < 11 && toVersion >= 11) {\n            p = p.next(() => {\n                createBundlesStore(db);\n                createNamedQueriesStore(db);\n            });\n        }\n        if (fromVersion < 12 && toVersion >= 12) {\n            p = p.next(() => {\n                createDocumentOverlayStore(db);\n            });\n        }\n        if (fromVersion < 13 && toVersion >= 13) {\n            p = p\n                .next(() => createRemoteDocumentCache(db))\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\n        }\n        if (fromVersion < 14 && toVersion >= 14) {\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\n        }\n        if (fromVersion < 15 && toVersion >= 15) {\n            p = p.next(() => createFieldIndex(db));\n        }\n        if (fromVersion < 16 && toVersion >= 16) {\n            // Clear the object stores to remove possibly corrupted index entries\n            p = p\n                .next(() => {\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\n                indexStateStore.clear();\n            })\n                .next(() => {\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\n                indexEntryStore.clear();\n            });\n        }\n        if (fromVersion < 17 && toVersion >= 17) {\n            p = p.next(() => {\n                createGlobalsStore(db);\n            });\n        }\n        return p;\n    }\n    addDocumentGlobal(txn) {\n        let byteSize = 0;\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate((_, doc) => {\n            byteSize += dbDocumentSize(doc);\n        })\n            .next(() => {\n            const metadata = { byteSize };\n            return txn\n                .store(DbRemoteDocumentGlobalStore)\n                .put(DbRemoteDocumentGlobalKey, metadata);\n        });\n    }\n    removeAcknowledgedMutations(txn) {\n        const queuesStore = txn.store(DbMutationQueueStore);\n        const mutationsStore = txn.store(DbMutationBatchStore);\n        return queuesStore.loadAll().next(queues => {\n            return PersistencePromise.forEach(queues, (queue) => {\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\n                return mutationsStore\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\n                    .next(dbBatches => {\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\n                        hardAssert(dbBatch.userId === queue.userId);\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\n     * with a sequence number. Missing rows are given the most recently used sequence number.\n     */\n    ensureSequenceNumbers(txn) {\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\n            const writeSentinelKey = (path) => {\n                return documentTargetStore.put({\n                    targetId: 0,\n                    path: encodeResourcePath(path),\n                    sequenceNumber: metadata.highestListenSequenceNumber\n                });\n            };\n            const promises = [];\n            return documentsStore\n                .iterate((key, doc) => {\n                const path = new ResourcePath(key);\n                const docSentinelKey = sentinelKey(path);\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\n                    if (!maybeSentinel) {\n                        return writeSentinelKey(path);\n                    }\n                    else {\n                        return PersistencePromise.resolve();\n                    }\n                }));\n            })\n                .next(() => PersistencePromise.waitFor(promises));\n        });\n    }\n    createCollectionParentIndex(db, txn) {\n        // Create the index.\n        db.createObjectStore(DbCollectionParentStore, {\n            keyPath: DbCollectionParentKeyPath\n        });\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\n        // Helper to add an index entry iff we haven't already written it.\n        const cache = new MemoryCollectionParentIndex();\n        const addEntry = (collectionPath) => {\n            if (cache.add(collectionPath)) {\n                const collectionId = collectionPath.lastSegment();\n                const parentPath = collectionPath.popLast();\n                return collectionParentsStore.put({\n                    collectionId,\n                    parent: encodeResourcePath(parentPath)\n                });\n            }\n        };\n        // Index existing remote documents.\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\n            const path = new ResourcePath(pathSegments);\n            return addEntry(path.popLast());\n        })\n            .next(() => {\n            // Index existing mutations.\n            return txn\n                .store(DbDocumentMutationStore)\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\n                const path = decodeResourcePath(encodedPath);\n                return addEntry(path.popLast());\n            });\n        });\n    }\n    rewriteCanonicalIds(txn) {\n        const targetStore = txn.store(DbTargetStore);\n        return targetStore.iterate((key, originalDbTarget) => {\n            const originalTargetData = fromDbTarget(originalDbTarget);\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\n            return targetStore.put(updatedDbTarget);\n        });\n    }\n    rewriteRemoteDocumentCache(db, transaction) {\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\n        const writes = [];\n        return legacyRemoteDocumentStore\n            .iterate((_, legacyDocument) => {\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\n            const path = extractKey(legacyDocument).path.toArray();\n            const dbRemoteDocument = {\n                prefixPath: path.slice(0, path.length - 2),\n                collectionGroup: path[path.length - 2],\n                documentId: path[path.length - 1],\n                readTime: legacyDocument.readTime || [0, 0],\n                unknownDocument: legacyDocument.unknownDocument,\n                noDocument: legacyDocument.noDocument,\n                document: legacyDocument.document,\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\n            };\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\n        })\n            .next(() => PersistencePromise.waitFor(writes));\n    }\n    runOverlayMigration(db, transaction) {\n        const mutationsStore = transaction.store(DbMutationBatchStore);\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\n        return mutationsStore.loadAll().next(dbBatches => {\n            const userToDocumentSet = new Map();\n            dbBatches.forEach(dbBatch => {\n                var _a;\n                let documentSet = (_a = userToDocumentSet.get(dbBatch.userId)) !== null && _a !== void 0 ? _a : documentKeySet();\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\n                userToDocumentSet.set(dbBatch.userId, documentSet);\n            });\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\n                const user = new User(userId);\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n                // NOTE: The index manager and the reference delegate are\n                // irrelevant for the purpose of recalculating and saving\n                // overlays. We can therefore simply use the memory\n                // implementation.\n                const indexManager = memoryPersistence.getIndexManager(user);\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\n                return localDocumentsView\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\n                    .next();\n            });\n        });\n    }\n}\nfunction sentinelKey(path) {\n    return [0, encodeResourcePath(path)];\n}\nfunction createPrimaryClientStore(db) {\n    db.createObjectStore(DbPrimaryClientStore);\n}\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueueStore, {\n        keyPath: DbMutationQueueKeyPath\n    });\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\n        keyPath: DbMutationBatchKeyPath,\n        autoIncrement: true\n    });\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n    db.createObjectStore(DbDocumentMutationStore);\n}\n/**\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\n * and rewrites all data.\n */\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\n    return v1MutationsStore.loadAll().next(existingMutations => {\n        db.deleteObjectStore(DbMutationBatchStore);\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\n            keyPath: DbMutationBatchKeyPath,\n            autoIncrement: true\n        });\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\n        return PersistencePromise.waitFor(writeAll);\n    });\n}\nfunction createLegacyRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocumentStore$1);\n}\nfunction createRemoteDocumentCache(db) {\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\n        keyPath: DbRemoteDocumentKeyPath\n    });\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\n}\nfunction createDocumentGlobalStore(db) {\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\n}\nfunction createQueryCache(db) {\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\n        keyPath: DbTargetDocumentKeyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\n    const targetStore = db.createObjectStore(DbTargetStore, {\n        keyPath: DbTargetKeyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobalStore);\n}\nfunction dropQueryCache(db) {\n    db.deleteObjectStore(DbTargetDocumentStore);\n    db.deleteObjectStore(DbTargetStore);\n    db.deleteObjectStore(DbTargetGlobalStore);\n}\nfunction dropRemoteDocumentChangesStore(db) {\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\n        db.deleteObjectStore('remoteDocumentChanges');\n    }\n}\n/**\n * Creates the target global singleton row.\n *\n * @param txn - The version upgrade transaction for indexeddb\n */\nfunction writeEmptyTargetGlobalEntry(txn) {\n    const globalStore = txn.store(DbTargetGlobalStore);\n    const metadata = {\n        highestTargetId: 0,\n        highestListenSequenceNumber: 0,\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\n        targetCount: 0\n    };\n    return globalStore.put(DbTargetGlobalKey, metadata);\n}\nfunction createClientMetadataStore(db) {\n    db.createObjectStore(DbClientMetadataStore, {\n        keyPath: DbClientMetadataKeyPath\n    });\n}\nfunction createBundlesStore(db) {\n    db.createObjectStore(DbBundleStore, {\n        keyPath: DbBundleKeyPath\n    });\n}\nfunction createNamedQueriesStore(db) {\n    db.createObjectStore(DbNamedQueryStore, {\n        keyPath: DbNamedQueryKeyPath\n    });\n}\nfunction createFieldIndex(db) {\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\n        keyPath: DbIndexConfigurationKeyPath,\n        autoIncrement: true\n    });\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\n        keyPath: DbIndexStateKeyPath\n    });\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\n        keyPath: DbIndexEntryKeyPath\n    });\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\n}\nfunction createDocumentOverlayStore(db) {\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\n        keyPath: DbDocumentOverlayKeyPath\n    });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\n}\nfunction createGlobalsStore(db) {\n    db.createObjectStore(DbGlobalsStore, {\n        keyPath: DbGlobalsKeyPath\n    });\n}\nfunction extractKey(remoteDoc) {\n    if (remoteDoc.document) {\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\n    }\n    else if (remoteDoc.noDocument) {\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\n    }\n    else if (remoteDoc.unknownDocument) {\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$c = 'IndexedDbPersistence';\n/**\n * Oldest acceptable age in milliseconds for client metadata before the client\n * is considered inactive and its associated data is garbage collected.\n */\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\n/**\n * Oldest acceptable metadata age for clients that may participate in the\n * primary lease election. Clients that have not updated their client metadata\n * within 5 seconds are not eligible to receive a primary lease.\n */\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\n/**\n * The interval at which clients will update their metadata, including\n * refreshing their primary lease if held or potentially trying to acquire it if\n * not held.\n *\n * Primary clients may opportunistically refresh their metadata earlier\n * if they're already performing an IndexedDB operation.\n */\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\n/** User-facing error when the primary lease is required but not available. */\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\n    'one tab has persistence enabled at any given time.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\n    'an incomplete implementation. Offline persistence has been disabled.';\n// The format of the LocalStorage key that stores zombied client is:\n//     firestore_zombie_<persistence_prefix>_<instance_key>\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\n/**\n * The name of the main (and currently only) IndexedDB database. This name is\n * appended to the prefix provided to the IndexedDbPersistence constructor.\n */\nconst MAIN_DATABASE = 'main';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * On Web only, the Firestore SDKs support shared access to its persistence\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\n * to synchronize state even without network connectivity. Shared access is\n * currently optional and not enabled unless all clients invoke\n * `enablePersistence()` with `{synchronizeTabs:true}`.\n *\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\n * will designate one client as the “primary client”. An effort is made to pick\n * a visible, network-connected and active client, and this client is\n * responsible for letting other clients know about its presence. The primary\n * client writes a unique client-generated identifier (the client ID) to\n * IndexedDb’s “owner” store every 4 seconds. If the primary client fails to\n * update this entry, another client can acquire the lease and take over as\n * primary.\n *\n * Some persistence operations in the SDK are designated as primary-client only\n * operations. This includes the acknowledgment of mutations and all updates of\n * remote documents. The effects of these operations are written to persistence\n * and then broadcast to other tabs via LocalStorage (see\n * `WebStorageSharedClientState`), which then refresh their state from\n * persistence.\n *\n * Similarly, the primary client listens to notifications sent by secondary\n * clients to discover persistence changes written by secondary clients, such as\n * the addition of new mutations and query targets.\n *\n * If multi-tab is not enabled and another tab already obtained the primary\n * lease, IndexedDbPersistence enters a failed state and all subsequent\n * operations will automatically fail.\n *\n * Additionally, there is an optimization so that when a tab is closed, the\n * primary lease is released immediately (this is especially important to make\n * sure that a refreshed tab is able to immediately re-acquire the primary\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\n * since it is an asynchronous API. So in addition to attempting to give up the\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\n * LocalStorage which acts as an indicator that another tab should go ahead and\n * take the primary lease immediately regardless of the current lease timestamp.\n *\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\n * longer optional.\n */\nclass IndexedDbPersistence {\n    constructor(\n    /**\n     * Whether to synchronize the in-memory state of multiple tabs and share\n     * access to local persistence.\n     */\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \n    /**\n     * If set to true, forcefully obtains database access. Existing tabs will\n     * no longer be able to access IndexedDB.\n     */\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\n        this.allowTabSynchronization = allowTabSynchronization;\n        this.persistenceKey = persistenceKey;\n        this.clientId = clientId;\n        this.queue = queue;\n        this.window = window;\n        this.document = document;\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\n        this.forceOwningTab = forceOwningTab;\n        this.schemaVersion = schemaVersion;\n        this.listenSequence = null;\n        this._started = false;\n        this.isPrimary = false;\n        this.networkEnabled = true;\n        /** Our window.unload handler, if registered. */\n        this.windowUnloadHandler = null;\n        this.inForeground = false;\n        /** Our 'visibilitychange' listener if registered. */\n        this.documentVisibilityHandler = null;\n        /** The client metadata refresh task. */\n        this.clientMetadataRefresher = null;\n        /** The last time we garbage collected the client metadata object store. */\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\n        /** A listener to notify on primary state changes. */\n        this.primaryStateListener = _ => Promise.resolve();\n        if (!IndexedDbPersistence.isAvailable()) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n        }\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\n        this.dbName = persistenceKey + MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\n        this.globalsCache = new IndexedDbGlobalsCache();\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        this.bundleCache = new IndexedDbBundleCache();\n        if (this.window && this.window.localStorage) {\n            this.webStorage = this.window.localStorage;\n        }\n        else {\n            this.webStorage = null;\n            if (forceOwningTab === false) {\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\n                    'reliably. In particular enablePersistence() could fail immediately ' +\n                    'after refreshing the page.');\n            }\n        }\n    }\n    /**\n     * Attempt to start IndexedDb persistence.\n     *\n     * @returns Whether persistence was enabled.\n     */\n    start() {\n        // NOTE: This is expected to fail sometimes (in the case of another tab\n        // already having the persistence lock), so it's the first thing we should\n        // do.\n        return this.updateClientMetadataAndTryBecomePrimary()\n            .then(() => {\n            if (!this.isPrimary && !this.allowTabSynchronization) {\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\n                // obtain the primary lease.\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n            }\n            this.attachVisibilityHandler();\n            this.attachWindowUnloadHook();\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\n        })\n            .then(highestListenSequenceNumber => {\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\n        })\n            .then(() => {\n            this._started = true;\n        })\n            .catch(reason => {\n            this.simpleDb && this.simpleDb.close();\n            return Promise.reject(reason);\n        });\n    }\n    /**\n     * Registers a listener that gets called when the primary state of the\n     * instance changes. Upon registering, this listener is invoked immediately\n     * with the current primary state.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setPrimaryStateListener(primaryStateListener) {\n        this.primaryStateListener = async (primaryState) => {\n            if (this.started) {\n                return primaryStateListener(primaryState);\n            }\n        };\n        return primaryStateListener(this.isPrimary);\n    }\n    /**\n     * Registers a listener that gets called when the database receives a\n     * version change event indicating that it has deleted.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setDatabaseDeletedListener(databaseDeletedListener) {\n        this.simpleDb.setVersionChangeListener(async (event) => {\n            // Check if an attempt is made to delete IndexedDB.\n            if (event.newVersion === null) {\n                await databaseDeletedListener();\n            }\n        });\n    }\n    /**\n     * Adjusts the current network state in the client's metadata, potentially\n     * affecting the primary lease.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setNetworkEnabled(networkEnabled) {\n        if (this.networkEnabled !== networkEnabled) {\n            this.networkEnabled = networkEnabled;\n            // Schedule a primary lease refresh for immediate execution. The eventual\n            // lease update will be propagated via `primaryStateListener`.\n            this.queue.enqueueAndForget(async () => {\n                if (this.started) {\n                    await this.updateClientMetadataAndTryBecomePrimary();\n                }\n            });\n        }\n    }\n    /**\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\n     * extend the primary lease for the local client. Asynchronously notifies the\n     * primary state listener if the client either newly obtained or released its\n     * primary lease.\n     */\n    updateClientMetadataAndTryBecomePrimary() {\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\n            const metadataStore = clientMetadataStore(txn);\n            return metadataStore\n                .put({\n                clientId: this.clientId,\n                updateTimeMs: Date.now(),\n                networkEnabled: this.networkEnabled,\n                inForeground: this.inForeground\n            })\n                .next(() => {\n                if (this.isPrimary) {\n                    return this.verifyPrimaryLease(txn).next(success => {\n                        if (!success) {\n                            this.isPrimary = false;\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        }\n                    });\n                }\n            })\n                .next(() => this.canActAsPrimary(txn))\n                .next(canActAsPrimary => {\n                if (this.isPrimary && !canActAsPrimary) {\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\n                }\n                else if (canActAsPrimary) {\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\n                }\n                else {\n                    return /* canActAsPrimary= */ false;\n                }\n            });\n        })\n            .catch(e => {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\n                // Proceed with the existing state. Any subsequent access to\n                // IndexedDB will verify the lease.\n                return this.isPrimary;\n            }\n            if (!this.allowTabSynchronization) {\n                throw e;\n            }\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\n            return /* isPrimary= */ false;\n        })\n            .then(isPrimary => {\n            if (this.isPrimary !== isPrimary) {\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\n            }\n            this.isPrimary = isPrimary;\n        });\n    }\n    verifyPrimaryLease(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\n        });\n    }\n    removeClientMetadata(txn) {\n        const metadataStore = clientMetadataStore(txn);\n        return metadataStore.delete(this.clientId);\n    }\n    /**\n     * If the garbage collection threshold has passed, prunes the\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\n     * time of all clients.\n     */\n    async maybeGarbageCollectMultiClientState() {\n        if (this.isPrimary &&\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\n            this.lastGarbageCollectionTime = Date.now();\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\n                const metadataStore = getStore(txn, DbClientMetadataStore);\n                return metadataStore.loadAll().next(existingClients => {\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\n                    // Delete metadata for clients that are no longer considered active.\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\n                });\n            }).catch(() => {\n                // Ignore primary lease violations or any other type of error. The next\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\n                // on LocalStore.\n                return [];\n            });\n            // Delete potential leftover entries that may continue to mark the\n            // inactive clients as zombied in LocalStorage.\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\n            // entries first to avoid potentially reviving a zombied client.\n            if (this.webStorage) {\n                for (const inactiveClient of inactiveClients) {\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\n                }\n            }\n        }\n    }\n    /**\n     * Schedules a recurring timer to update the client metadata and to either\n     * extend or acquire the primary lease if the client is eligible.\n     */\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\n            return this.updateClientMetadataAndTryBecomePrimary()\n                .then(() => this.maybeGarbageCollectMultiClientState())\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\n        });\n    }\n    /** Checks whether `client` is the local client. */\n    isLocalClient(client) {\n        return client ? client.ownerId === this.clientId : false;\n    }\n    /**\n     * Evaluate the state of all active clients and determine whether the local\n     * client is or can act as the holder of the primary lease. Returns whether\n     * the client is eligible for the lease, but does not actually acquire it.\n     * May return 'false' even if there is no active leaseholder and another\n     * (foreground) client should become leaseholder instead.\n     */\n    canActAsPrimary(txn) {\n        if (this.forceOwningTab) {\n            return PersistencePromise.resolve(true);\n        }\n        const store = primaryClientStore(txn);\n        return store\n            .get(DbPrimaryClientKey)\n            .next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            // A client is eligible for the primary lease if:\n            // - its network is enabled and the client's tab is in the foreground.\n            // - its network is enabled and no other client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and the client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and no other client's tab is in\n            //   the foreground.\n            // - the `forceOwningTab` setting was passed in.\n            if (currentLeaseIsValid) {\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\n                    return true;\n                }\n                if (!this.isLocalClient(currentPrimary)) {\n                    if (!currentPrimary.allowTabSynchronization) {\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\n                        // not opted into multi-tab synchronization. If this happens at\n                        // client startup, we reject the Promise returned by\n                        // `enablePersistence()` and the user can continue to use Firestore\n                        // with in-memory persistence.\n                        // If this fails during a lease refresh, we will instead block the\n                        // AsyncQueue from executing further operations. Note that this is\n                        // acceptable since mixing & matching different `synchronizeTabs`\n                        // settings is not supported.\n                        //\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\n                        // no longer be turned off.\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                    }\n                    return false;\n                }\n            }\n            if (this.networkEnabled && this.inForeground) {\n                return true;\n            }\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(existingClients => {\n                // Process all existing clients and determine whether at least one of\n                // them is better suited to obtain the primary lease.\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\n                    if (this.clientId !== otherClient.clientId) {\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\n                        if (otherClientHasBetterNetworkState ||\n                            (otherClientHasBetterVisibility &&\n                                otherClientHasSameNetworkState)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return preferredCandidate === undefined;\n            });\n        })\n            .next(canActAsPrimary => {\n            if (this.isPrimary !== canActAsPrimary) {\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\n            }\n            return canActAsPrimary;\n        });\n    }\n    async shutdown() {\n        // The shutdown() operations are idempotent and can be called even when\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\n        this._started = false;\n        this.markClientZombied();\n        if (this.clientMetadataRefresher) {\n            this.clientMetadataRefresher.cancel();\n            this.clientMetadataRefresher = null;\n        }\n        this.detachVisibilityHandler();\n        this.detachWindowUnloadHook();\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\n        // has obtained the primary lease.\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\n        });\n        this.simpleDb.close();\n        // Remove the entry marking the client as zombied from LocalStorage since\n        // we successfully deleted its metadata from IndexedDb.\n        this.removeClientZombiedEntry();\n    }\n    /**\n     * Returns clients that are not zombied and have an updateTime within the\n     * provided threshold.\n     */\n    filterActiveClients(clients, activityThresholdMs) {\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\n            !this.isClientZombied(client.clientId));\n    }\n    /**\n     * Returns the IDs of the clients that are currently active. If multi-tab\n     * is not supported, returns an array that only contains the local client's\n     * ID.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    getActiveClients() {\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\n        });\n    }\n    get started() {\n        return this._started;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getMutationQueue(user, indexManager) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getIndexManager(user) {\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\n    }\n    getDocumentOverlayCache(user) {\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\n        const objectStores = getObjectStores(this.schemaVersion);\n        let persistenceTransaction;\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\n                ? this.listenSequence.next()\n                : ListenSequence.INVALID);\n            if (mode === 'readwrite-primary') {\n                // While we merely verify that we have (or can acquire) the lease\n                // immediately, we wait to extend the primary lease until after\n                // executing transactionOperation(). This ensures that even if the\n                // transactionOperation takes a long time, we'll use a recent\n                // leaseTimestampMs in the extended (or newly acquired) lease.\n                return this.verifyPrimaryLease(persistenceTransaction)\n                    .next(holdsPrimaryLease => {\n                    if (holdsPrimaryLease) {\n                        return /* holdsPrimaryLease= */ true;\n                    }\n                    return this.canActAsPrimary(persistenceTransaction);\n                })\n                    .next(holdsPrimaryLease => {\n                    if (!holdsPrimaryLease) {\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\n                        this.isPrimary = false;\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\n                    }\n                    return transactionOperation(persistenceTransaction);\n                })\n                    .next(result => {\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\n                });\n            }\n            else {\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\n            }\n        })\n            .then(result => {\n            persistenceTransaction.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    /**\n     * Verifies that the current tab is the primary leaseholder or alternatively\n     * that the leaseholder has opted into multi-tab synchronization.\n     */\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\n    // be turned off.\n    verifyAllowTabSynchronization(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\n                if (!this.forceOwningTab &&\n                    (!this.allowTabSynchronization ||\n                        !currentPrimary.allowTabSynchronization)) {\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                }\n            }\n        });\n    }\n    /**\n     * Obtains or extends the new primary lease for the local client. This\n     * method does not verify that the client is eligible for this lease.\n     */\n    acquireOrExtendPrimaryLease(txn) {\n        const newPrimary = {\n            ownerId: this.clientId,\n            allowTabSynchronization: this.allowTabSynchronization,\n            leaseTimestampMs: Date.now()\n        };\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\n    }\n    static isAvailable() {\n        return SimpleDb.isAvailable();\n    }\n    /** Checks the primary lease and removes it if we are the current primary. */\n    releasePrimaryLeaseIfHeld(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            if (this.isLocalClient(primaryClient)) {\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\n                return store.delete(DbPrimaryClientKey);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    }\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\n    isWithinAge(updateTimeMs, maxAgeMs) {\n        const now = Date.now();\n        const minAcceptable = now - maxAgeMs;\n        const maxAcceptable = now;\n        if (updateTimeMs < minAcceptable) {\n            return false;\n        }\n        else if (updateTimeMs > maxAcceptable) {\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\n            return false;\n        }\n        return true;\n    }\n    attachVisibilityHandler() {\n        if (this.document !== null &&\n            typeof this.document.addEventListener === 'function') {\n            this.documentVisibilityHandler = () => {\n                this.queue.enqueueAndForget(() => {\n                    this.inForeground = this.document.visibilityState === 'visible';\n                    return this.updateClientMetadataAndTryBecomePrimary();\n                });\n            };\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.inForeground = this.document.visibilityState === 'visible';\n        }\n    }\n    detachVisibilityHandler() {\n        if (this.documentVisibilityHandler) {\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.documentVisibilityHandler = null;\n        }\n    }\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\n     * by tabs trying to acquire the primary lease to determine that the lease\n     * is no longer valid even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\n     * it is a synchronous API and so can be used reliably from  an unload\n     * handler.\n     */\n    attachWindowUnloadHook() {\n        var _a;\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\n            this.windowUnloadHandler = () => {\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\n                // accesses internal state. We execute this code directly during shutdown\n                // to make sure it gets a chance to run.\n                this.markClientZombied();\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() &&\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\n                    // the next page load.\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\n                }\n                this.queue.enqueueAndForget(() => {\n                    // Attempt graceful shutdown (including releasing our primary lease),\n                    // but there's no guarantee it will complete.\n                    return this.shutdown();\n                });\n            };\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\n        }\n    }\n    detachWindowUnloadHook() {\n        if (this.windowUnloadHandler) {\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    }\n    /**\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\n     * Clients become zombied when their tab closes without running all of the\n     * cleanup logic in `shutdown()`.\n     */\n    isClientZombied(clientId) {\n        var _a;\n        try {\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\n            return isZombied;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't working.\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\n            return false;\n        }\n    }\n    /**\n     * Record client as zombied (a client that had its tab closed). Zombied\n     * clients are ignored during primary tab selection.\n     */\n    markClientZombied() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            logError('Failed to set zombie client id.', e);\n        }\n    }\n    /** Removes the zombied client entry if it exists. */\n    removeClientZombiedEntry() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    zombiedClientLocalStorageKey(clientId) {\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the primary client object store.\n */\nfunction primaryClientStore(txn) {\n    return getStore(txn, DbPrimaryClientStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the client metadata object store.\n */\nfunction clientMetadataStore(txn) {\n    return getStore(txn, DbClientMetadataStore);\n}\n/**\n * Generates a string used as a prefix when storing data in IndexedDB and\n * LocalStorage.\n */\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseId.projectId;\n    if (!databaseId.isDefaultDatabase) {\n        database += '.' + databaseId.database;\n    }\n    return 'firestore/' + persistenceKey + '/' + database + '/';\n}\nasync function indexedDbClearPersistence(persistenceKey) {\n    if (!SimpleDb.isAvailable()) {\n        return Promise.resolve();\n    }\n    const dbName = persistenceKey + MAIN_DATABASE;\n    await SimpleDb.delete(dbName);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two array for equality using comparator. The method computes the\n * intersection and invokes `onAdd` for every element that is in `after` but not\n * `before`. `onRemove` is invoked for every element in `before` but missing\n * from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original array.\n * @param after - The elements to diff against the original array.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\n    before = [...before];\n    after = [...after];\n    before.sort(comparator);\n    after.sort(comparator);\n    const bLen = before.length;\n    const aLen = after.length;\n    let a = 0;\n    let b = 0;\n    while (a < aLen && b < bLen) {\n        const cmp = comparator(before[b], after[a]);\n        if (cmp < 0) {\n            // The element was removed if the next element in our ordered\n            // walkthrough is only in `before`.\n            onRemove(before[b++]);\n        }\n        else if (cmp > 0) {\n            // The element was added if the next element in our ordered walkthrough\n            // is only in `after`.\n            onAdd(after[a++]);\n        }\n        else {\n            a++;\n            b++;\n        }\n    }\n    while (a < aLen) {\n        onAdd(after[a++]);\n    }\n    while (b < bLen) {\n        onRemove(before[b++]);\n    }\n}\n/**\n * Verifies equality for an array of primitives.\n *\n * @private\n * @internal\n * @param left Array of primitives.\n * @param right Array of primitives.\n * @return True if arrays are equal.\n */\nfunction isPrimitiveArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (left[i] !== right[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$b = 'LocalStore';\n/**\n * The maximum time to leave a resume token buffered without writing it out.\n * This value is arbitrary: it's long enough to avoid several writes\n * (possibly indefinitely if updates come more frequently than this) but\n * short enough that restarting after crashing will still have a pretty\n * recent resume token.\n */\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\n/**\n * Implements `LocalStore` interface.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass LocalStoreImpl {\n    constructor(\n    /** Manages our in-memory or durable persistence. */\n    persistence, queryEngine, initialUser, serializer) {\n        this.persistence = persistence;\n        this.queryEngine = queryEngine;\n        this.serializer = serializer;\n        /**\n         * Maps a targetID to data about its target.\n         *\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\n         * of `applyRemoteEvent()` idempotent.\n         */\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\n        /** Maps a target to its targetID. */\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /**\n         * A per collection group index of the last read time processed by\n         * `getNewDocumentChanges()`.\n         *\n         * PORTING NOTE: This is only used for multi-tab synchronization.\n         */\n        this.collectionGroupReadTime = new Map();\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.targetCache = persistence.getTargetCache();\n        this.bundleCache = persistence.getBundleCache();\n        this.initializeUserComponents(initialUser);\n    }\n    initializeUserComponents(user) {\n        // TODO(indexing): Add spec tests that test these components change after a\n        // user change\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\n        this.indexManager = this.persistence.getIndexManager(user);\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\n        this.remoteDocuments.setIndexManager(this.indexManager);\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\n    }\n    collectGarbage(garbageCollector) {\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\n    }\n}\nfunction newLocalStore(\n/** Manages our in-memory or durable persistence. */\npersistence, queryEngine, initialUser, serializer) {\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\n}\n/**\n * Tells the LocalStore that the currently authenticated user has changed.\n *\n * In response the local store switches the mutation queue to the new user and\n * returns any resulting document changes.\n */\n// PORTING NOTE: Android and iOS only return the documents affected by the\n// change.\nasync function localStoreHandleUserChange(localStore, user) {\n    const localStoreImpl = debugCast(localStore);\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\n        // Swap out the mutation queue, grabbing the pending mutation batches\n        // before and after.\n        let oldBatches;\n        return localStoreImpl.mutationQueue\n            .getAllMutationBatches(txn)\n            .next(promisedOldBatches => {\n            oldBatches = promisedOldBatches;\n            localStoreImpl.initializeUserComponents(user);\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\n        })\n            .next(newBatches => {\n            const removedBatchIds = [];\n            const addedBatchIds = [];\n            // Union the old/new changed keys.\n            let changedKeys = documentKeySet();\n            for (const batch of oldBatches) {\n                removedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            for (const batch of newBatches) {\n                addedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            // Return the set of all (potentially) changed documents and the list\n            // of mutation batch IDs that were affected by change.\n            return localStoreImpl.localDocuments\n                .getDocuments(txn, changedKeys)\n                .next(affectedDocuments => {\n                return {\n                    affectedDocuments,\n                    removedBatchIds,\n                    addedBatchIds\n                };\n            });\n        });\n    });\n    return result;\n}\n/* Accepts locally generated Mutations and commit them to storage. */\nfunction localStoreWriteLocally(localStore, mutations) {\n    const localStoreImpl = debugCast(localStore);\n    const localWriteTime = Timestamp.now();\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    let overlayedDocuments;\n    let mutationBatch;\n    return localStoreImpl.persistence\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\n        // Figure out which keys do not have a remote version in the cache, this\n        // is needed to create the right overlay mutation: if no remote version\n        // presents, we do not need to create overlays as patch mutations.\n        // TODO(Overlay): Is there a better way to determine this? Using the\n        //  document version does not work because local mutations set them back\n        //  to 0.\n        let remoteDocs = mutableDocumentMap();\n        let docsWithoutRemoteVersion = documentKeySet();\n        return localStoreImpl.remoteDocuments\n            .getEntries(txn, keys)\n            .next(docs => {\n            remoteDocs = docs;\n            remoteDocs.forEach((key, doc) => {\n                if (!doc.isValidDocument()) {\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\n                }\n            });\n        })\n            .next(() => {\n            // Load and apply all existing mutations. This lets us compute the\n            // current base state for all non-idempotent transforms before applying\n            // any additional user-provided writes.\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\n        })\n            .next((docs) => {\n            overlayedDocuments = docs;\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\n            // we record the base state in a separate patch mutation. This is\n            // later used to guarantee consistent values and prevents flicker\n            // even if the backend sends us an update that already includes our\n            // transform.\n            const baseMutations = [];\n            for (const mutation of mutations) {\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\n                if (baseValue != null) {\n                    // NOTE: The base state should only be applied if there's some\n                    // existing document to override, so use a Precondition of\n                    // exists=true\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\n                }\n            }\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\n        })\n            .next(batch => {\n            mutationBatch = batch;\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\n        });\n    })\n        .then(() => ({\n        batchId: mutationBatch.batchId,\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\n    }));\n}\n/**\n * Acknowledges the given batch.\n *\n * On the happy path when a batch is acknowledged, the local store will\n *\n *  + remove the batch from the mutation queue;\n *  + apply the changes to the remote document cache;\n *  + recalculate the latency compensated view implied by those changes (there\n *    may be mutations in the queue that affect the documents but haven't been\n *    acknowledged yet); and\n *  + give the changed documents back the sync engine\n *\n * @returns The resulting (modified) documents.\n */\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\n        const affected = batchResult.batch.keys();\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\n    });\n}\nfunction getKeysWithTransformResults(batchResult) {\n    let result = documentKeySet();\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\n        const mutationResult = batchResult.mutationResults[i];\n        if (mutationResult.transformResults.length > 0) {\n            result = result.add(batchResult.batch.mutations[i].key);\n        }\n    }\n    return result;\n}\n/**\n * Removes mutations from the MutationQueue for the specified batch;\n * LocalDocuments will be recalculated.\n *\n * @returns The resulting modified documents.\n */\nfunction localStoreRejectBatch(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\n        let affectedKeys;\n        return localStoreImpl.mutationQueue\n            .lookupMutationBatch(txn, batchId)\n            .next((batch) => {\n            hardAssert(batch !== null);\n            affectedKeys = batch.keys();\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\n        })\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\n    });\n}\n/**\n * Returns the largest (latest) batch id in mutation queue that is pending\n * server response.\n *\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\n */\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\n}\n/**\n * Returns the last consistent snapshot processed (used by the RemoteStore to\n * determine whether to buffer incoming snapshots from the backend).\n */\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\n}\n/**\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\n * event reflects any write batches that have been acknowledged or rejected\n * (i.e. we do not re-apply local mutations to updates from this event).\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\n    const localStoreImpl = debugCast(localStore);\n    const remoteVersion = remoteEvent.snapshotVersion;\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n    return localStoreImpl.persistence\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n        const promises = [];\n        remoteEvent.targetChanges.forEach((change, targetId) => {\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\n            if (!oldTargetData) {\n                return;\n            }\n            // Only update the remote keys if the target is still active. This\n            // ensures that we can persist the updated target data along with\n            // the updated assignment.\n            promises.push(localStoreImpl.targetCache\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\n                .next(() => {\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\n            }));\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\n                newTargetData = newTargetData\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\n            }\n            else if (change.resumeToken.approximateByteSize() > 0) {\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\n            }\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\n            // Update the target data if there are target changes (or if\n            // sufficient time has passed since the last update).\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\n            }\n        });\n        let changedDocs = mutableDocumentMap();\n        let existenceChangedKeys = documentKeySet();\n        remoteEvent.documentUpdates.forEach(key => {\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\n            }\n        });\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\n        // the remote documents in advance in a single call.\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\n            changedDocs = result.changedDocuments;\n            existenceChangedKeys = result.existenceChangedKeys;\n        }));\n        // HACK: The only reason we allow a null snapshot version is so that we\n        // can synthesize remote events when we get permission denied errors while\n        // trying to resolve the state of a locally cached document that is in\n        // limbo.\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\n            const updateRemoteVersion = localStoreImpl.targetCache\n                .getLastRemoteSnapshotVersion(txn)\n                .next(lastRemoteSnapshotVersion => {\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\n            });\n            promises.push(updateRemoteVersion);\n        }\n        return PersistencePromise.waitFor(promises)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\n            .next(() => changedDocs);\n    })\n        .then(changedDocs => {\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\n        return changedDocs;\n    });\n}\n/**\n * Populates document change buffer with documents from backend or a bundle.\n * Returns the document changes resulting from applying those documents, and\n * also a set of documents whose existence state are changed as a result.\n *\n * @param txn - Transaction to use to read existing documents from storage.\n * @param documentBuffer - Document buffer to collect the resulted changes to be\n *        applied to storage.\n * @param documents - Documents to be applied.\n */\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\n    let updatedKeys = documentKeySet();\n    let existenceChangedKeys = documentKeySet();\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\n        let changedDocuments = mutableDocumentMap();\n        documents.forEach((key, doc) => {\n            const existingDoc = existingDocs.get(key);\n            // Check if see if there is a existence state change for this document.\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\n                existenceChangedKeys = existenceChangedKeys.add(key);\n            }\n            // Note: The order of the steps below is important, since we want\n            // to ensure that rejected limbo resolutions (which fabricate\n            // NoDocuments with SnapshotVersion.min()) never add documents to\n            // cache.\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\n                // events. We remove these documents from cache since we lost\n                // access.\n                documentBuffer.removeEntry(key, doc.readTime);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else if (!existingDoc.isValidDocument() ||\n                doc.version.compareTo(existingDoc.version) > 0 ||\n                (doc.version.compareTo(existingDoc.version) === 0 &&\n                    existingDoc.hasPendingWrites)) {\n                documentBuffer.addEntry(doc);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else {\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n            }\n        });\n        return { changedDocuments, existenceChangedKeys };\n    });\n}\n/**\n * Returns true if the newTargetData should be persisted during an update of\n * an active target. TargetData should always be persisted when a target is\n * being released and should not call this function.\n *\n * While the target is active, TargetData updates can be omitted when nothing\n * about the target has changed except metadata like the resume token or\n * snapshot version. Occasionally it's worth the extra write to prevent these\n * values from getting too stale after a crash, but this doesn't have to be\n * too frequent.\n */\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\n    // Always persist target data if we don't already have a resume token.\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\n        return true;\n    }\n    // Don't allow resume token changes to be buffered indefinitely. This\n    // allows us to be reasonably up-to-date after a crash and avoids needing\n    // to loop over all active queries on shutdown. Especially in the browser\n    // we may not get time to do anything interesting while the current tab is\n    // closing.\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\n        oldTargetData.snapshotVersion.toMicroseconds();\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\n        return true;\n    }\n    // Otherwise if the only thing that has changed about a target is its resume\n    // token it's not worth persisting. Note that the RemoteStore keeps an\n    // in-memory view of the currently active targets which includes the current\n    // resume token, so stream failure or user changes will still use an\n    // up-to-date resume token regardless of what we do here.\n    const changes = change.addedDocuments.size +\n        change.modifiedDocuments.size +\n        change.removedDocuments.size;\n    return changes > 0;\n}\n/**\n * Notifies local store of the changed views to locally pin documents.\n */\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\n    const localStoreImpl = debugCast(localStore);\n    try {\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\n            });\n        });\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\n            // number for the documents that were included in this transaction.\n            // This might trigger them to be deleted earlier than they otherwise\n            // would have, but it should not invalidate the integrity of the data.\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\n        }\n        else {\n            throw e;\n        }\n    }\n    for (const viewChange of viewChanges) {\n        const targetId = viewChange.targetId;\n        if (!viewChange.fromCache) {\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n            // Advance the last limbo free snapshot version\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\n            // TODO(b/272564316): Apply the optimization done on other platforms.\n            // This is a problem for web because saving the updated targetData from\n            // non-primary client conflicts with what primary client saved.\n        }\n    }\n}\n/**\n * Gets the mutation batch after the passed in batchId in the mutation queue\n * or null if empty.\n * @param afterBatchId - If provided, the batch to search after.\n * @returns The next mutation or null if there wasn't one.\n */\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\n        if (afterBatchId === undefined) {\n            afterBatchId = BATCHID_UNKNOWN;\n        }\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n    });\n}\n/**\n * Reads the current value of a Document with a given key or null if not\n * found - used for testing.\n */\nfunction localStoreReadDocument(localStore, key) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\n}\n/**\n * Assigns the given target an internal ID so that its results can be pinned so\n * they don't get GC'd. A target must be allocated in the local store before\n * the store can be used to manage its view.\n *\n * Allocating an already allocated `Target` will return the existing `TargetData`\n * for that `Target`.\n */\nfunction localStoreAllocateTarget(localStore, target) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence\n        .runTransaction('Allocate target', 'readwrite', txn => {\n        let targetData;\n        return localStoreImpl.targetCache\n            .getTargetData(txn, target)\n            .next((cached) => {\n            if (cached) {\n                // This target has been listened to previously, so reuse the\n                // previous targetID.\n                // TODO(mcg): freshen last accessed date?\n                targetData = cached;\n                return PersistencePromise.resolve(targetData);\n            }\n            else {\n                return localStoreImpl.targetCache\n                    .allocateTargetId(txn)\n                    .next(targetId => {\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\n                    return localStoreImpl.targetCache\n                        .addTargetData(txn, targetData)\n                        .next(() => targetData);\n                });\n            }\n        });\n    })\n        .then(targetData => {\n        // If Multi-Tab is enabled, the existing target data may be newer than\n        // the in-memory data\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\n        if (cachedTargetData === null ||\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\n                0) {\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\n        }\n        return targetData;\n    });\n}\n/**\n * Returns the TargetData as seen by the LocalStore, including updates that may\n * have not yet been persisted to the TargetCache.\n */\n// Visible for testing.\nfunction localStoreGetTargetData(localStore, transaction, target) {\n    const localStoreImpl = debugCast(localStore);\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\n    if (targetId !== undefined) {\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\n    }\n    else {\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\n    }\n}\n/**\n * Unpins all the documents associated with the given target. If\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\n * directly removes the associated target data from the target cache.\n *\n * Releasing a non-existing `Target` is a no-op.\n */\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\n    const localStoreImpl = debugCast(localStore);\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\n    try {\n        if (!keepPersistedTargetData) {\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\n            });\n        }\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // All `releaseTarget` does is record the final metadata state for the\n            // target, but we've been recording this periodically during target\n            // activity. If we lose this write this could cause a very slight\n            // difference in the order of target deletion during GC, but we\n            // don't define exact LRU semantics so this is acceptable.\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\n        }\n        else {\n            throw e;\n        }\n    }\n    localStoreImpl.targetDataByTarget =\n        localStoreImpl.targetDataByTarget.remove(targetId);\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\n}\n/**\n * Runs the specified query against the local store and returns the results,\n * potentially taking advantage of query data from previous executions (such\n * as the set of remote keys).\n *\n * @param usePreviousResults - Whether results from previous executions can\n * be used to optimize this query execution.\n */\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\n    const localStoreImpl = debugCast(localStore);\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\n    let remoteKeys = documentKeySet();\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\n    // Use readwrite instead of readonly so indexes can be created\n    txn => {\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\n            .next(targetData => {\n            if (targetData) {\n                lastLimboFreeSnapshotVersion =\n                    targetData.lastLimboFreeSnapshotVersion;\n                return localStoreImpl.targetCache\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\n                    .next(result => {\n                    remoteKeys = result;\n                });\n            }\n        })\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\n            ? lastLimboFreeSnapshotVersion\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\n            .next(documents => {\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\n            return { documents, remoteKeys };\n        });\n    });\n}\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n        promiseChain = promiseChain\n            .next(() => documentBuffer.getEntry(txn, docKey))\n            .next(doc => {\n            const ackVersion = batchResult.docVersions.get(docKey);\n            hardAssert(ackVersion !== null);\n            if (doc.version.compareTo(ackVersion) < 0) {\n                batch.applyToRemoteDocument(doc, batchResult);\n                if (doc.isValidDocument()) {\n                    // We use the commitVersion as the readTime rather than the\n                    // document's updateTime since the updateTime is not advanced\n                    // for updates that do not modify the underlying document.\n                    doc.setReadTime(batchResult.commitVersion);\n                    documentBuffer.addEntry(doc);\n                }\n            }\n        });\n    });\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\n}\n/** Returns the local view of the documents affected by a mutation batch. */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\n            if (keys) {\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\n            }\n            else {\n                return PersistencePromise.resolve(null);\n            }\n        });\n    });\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetActiveClients(localStore) {\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\n    return persistenceImpl.getActiveClients();\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetCachedTarget(localStore, targetId) {\n    const localStoreImpl = debugCast(localStore);\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\n    if (cachedTargetData) {\n        return Promise.resolve(cachedTargetData.target);\n    }\n    else {\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\n            return targetCacheImpl\n                .getTargetDataForTarget(txn, targetId)\n                .next(targetData => (targetData ? targetData.target : null));\n        });\n    }\n}\n/**\n * Returns the set of documents that have been updated since the last call.\n * If this is the first call, returns the set of changes since client\n * initialization. Further invocations will return document that have changed\n * since the prior call.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\n    const localStoreImpl = debugCast(localStore);\n    // Get the current maximum read time for the collection. This should always\n    // exist, but to reduce the chance for regressions we default to\n    // SnapshotVersion.Min()\n    // TODO(indexing): Consider removing the default value.\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    return localStoreImpl.persistence\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \n    /* limit= */ Number.MAX_SAFE_INTEGER))\n        .then(changedDocs => {\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\n        return changedDocs;\n    });\n}\n/** Sets the collection group's maximum read time from the given documents. */\n// PORTING NOTE: Multi-Tab only.\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    changedDocs.forEach((_, doc) => {\n        if (doc.readTime.compareTo(readTime) > 0) {\n            readTime = doc.readTime;\n        }\n    });\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\n}\n/**\n * Creates a new target using the given bundle name, which will be used to\n * hold the keys of all documents from the bundle in query-document mappings.\n * This ensures that the loaded documents do not get garbage collected\n * right away.\n */\nfunction umbrellaTarget(bundleName) {\n    // It is OK that the path used for the query is not valid, because this will\n    // not be read and queried.\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\n}\n/**\n * Applies the documents from a bundle to the \"ground-state\" (remote)\n * documents.\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\n    const localStoreImpl = debugCast(localStore);\n    let documentKeys = documentKeySet();\n    let documentMap = mutableDocumentMap();\n    for (const bundleDoc of documents) {\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n        if (bundleDoc.document) {\n            documentKeys = documentKeys.add(documentKey);\n        }\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\n        documentMap = documentMap.insert(documentKey, doc);\n    }\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n    });\n    // Allocates a target to hold all document keys from the bundle, such that\n    // they will not get garbage collected right away.\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\n            .next(documentChangeResult => {\n            documentBuffer.apply(txn);\n            return documentChangeResult;\n        })\n            .next(documentChangeResult => {\n            return localStoreImpl.targetCache\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\n                .next(() => documentChangeResult.changedDocuments);\n        });\n    });\n}\n/**\n * Returns a promise of a boolean to indicate if the given bundle has already\n * been loaded and the create time is newer than the current loading bundle.\n */\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\n    return localStoreImpl.persistence\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\n    })\n        .then(cached => {\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\n    });\n}\n/**\n * Saves the given `BundleMetadata` to local persistence.\n */\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\n    });\n}\n/**\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\n * resolves to undefined if no persisted data can be found.\n */\nfunction localStoreGetNamedQuery(localStore, queryName) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\n}\n/**\n * Saves the given `NamedQuery` to local persistence.\n */\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\n    // Allocate a target for the named query such that it can be resumed\n    // from associated read time if users use it to listen.\n    // NOTE: this also means if no corresponding target exists, the new target\n    // will remain active and will not get collected, unless users happen to\n    // unlisten the query somehow.\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\n        const readTime = fromVersion(query.readTime);\n        // Simply save the query itself if it is older than what the SDK already\n        // has.\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\n        }\n        // Update existing target data because the query from the bundle is newer.\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\n        localStoreImpl.targetDataByTarget =\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\n        return localStoreImpl.targetCache\n            .updateTargetData(transaction, newTargetData)\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\n    });\n}\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    const promises = [];\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\n        .getFieldIndexes(transaction)\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\n    }, fieldIndex => {\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\n    }))\n        .next(() => PersistencePromise.waitFor(promises)));\n}\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\n    const localStoreImpl = debugCast(localStore);\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\n}\nfunction localStoreDeleteAllFieldIndexes(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A tracker to keep a record of important details during database local query\n * execution.\n */\nclass QueryContext {\n    constructor() {\n        /**\n         * Counts the number of documents passed through during local query execution.\n         */\n        this._documentReadCount = 0;\n    }\n    get documentReadCount() {\n        return this._documentReadCount;\n    }\n    incrementDocumentReadCount(amount) {\n        this._documentReadCount += amount;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\n/**\n * This cost represents the evaluation result of\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\n * / ([docKey, docContent] per documents in full collection scan) coming from\n * experiment [enter PR experiment URL here].\n */\nfunction getDefaultRelativeIndexReadCostPerDocument() {\n    // These values were derived from an experiment where several members of the\n    // Firestore SDK team ran a performance test in various environments.\n    // Googlers can see b/299284287 for details.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)()) {\n        return 8;\n    }\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) > 0) {\n        return 6;\n    }\n    else {\n        return 4;\n    }\n}\n/**\n * The Firestore query engine.\n *\n * Firestore queries can be executed in three modes. The Query Engine determines\n * what mode to use based on what data is persisted. The mode only determines\n * the runtime complexity of the query - the result set is equivalent across all\n * implementations.\n *\n * The Query engine will use indexed-based execution if a user has configured\n * any index that can be used to execute query (via `setIndexConfiguration()`).\n * Otherwise, the engine will try to optimize the query by re-using a previously\n * persisted query result. If that is not possible, the query will be executed\n * via a full collection scan.\n *\n * Index-based execution is the default when available. The query engine\n * supports partial indexed execution and merges the result from the index\n * lookup with documents that have not yet been indexed. The index evaluation\n * matches the backend's format and as such, the SDK can use indexing for all\n * queries that the backend supports.\n *\n * If no index exists, the query engine tries to take advantage of the target\n * document mapping in the TargetCache. These mappings exists for all queries\n * that have been synced with the backend at least once and allow the query\n * engine to only read documents that previously matched a query plus any\n * documents that were edited after the query was last listened to.\n *\n * There are some cases when this optimization is not guaranteed to produce\n * the same results as full collection scans. In these cases, query\n * processing falls back to full scans. These cases are:\n *\n * - Limit queries where a document that matched the query previously no longer\n *   matches the query.\n *\n * - Limit queries where a document edit may cause the document to sort below\n *   another document that is in the local cache.\n *\n * - Queries that have never been CURRENT or free of limbo documents.\n */\nclass QueryEngine {\n    constructor() {\n        this.initialized = false;\n        this.indexAutoCreationEnabled = false;\n        /**\n         * SDK only decides whether it should create index when collection size is\n         * larger than this.\n         */\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\n    }\n    /** Sets the document view to query against. */\n    initialize(localDocuments, indexManager) {\n        this.localDocumentsView = localDocuments;\n        this.indexManager = indexManager;\n        this.initialized = true;\n    }\n    /** Returns all local documents matching the specified query. */\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\n        // Stores the result from executing the query; using this object is more\n        // convenient than passing the result between steps of the persistence\n        // transaction and improves readability comparatively.\n        const queryResult = { result: null };\n        return this.performQueryUsingIndex(transaction, query)\n            .next(result => {\n            queryResult.result = result;\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\n                queryResult.result = result;\n            });\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            const context = new QueryContext();\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\n                queryResult.result = result;\n                if (this.indexAutoCreationEnabled) {\n                    return this.createCacheIndexes(transaction, query, context, result.size);\n                }\n            });\n        })\n            .next(() => queryResult.result);\n    }\n    createCacheIndexes(transaction, query, context, resultSize) {\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\n            }\n            return PersistencePromise.resolve();\n        }\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\n        }\n        if (context.documentReadCount >\n            this.relativeIndexReadCostPerDocument * resultSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\n            }\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\n        }\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Performs an indexed query that evaluates the query based on a collection's\n     * persisted index values. Returns `null` if an index is not available.\n     */\n    performQueryUsingIndex(transaction, query) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        let target = queryToTarget(query);\n        return this.indexManager\n            .getIndexType(transaction, target)\n            .next(indexType => {\n            if (indexType === 0 /* IndexType.NONE */) {\n                // The target cannot be served from any index.\n                return null;\n            }\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\n                // We cannot apply a limit for targets that are served using a partial\n                // index. If a partial index will be used to serve the target, the\n                // query may return a superset of documents that match the target\n                // (e.g. if the index doesn't include all the target's filters), or\n                // may return the correct set of documents in the wrong order (e.g. if\n                // the index doesn't include a segment for one of the orderBys).\n                // Therefore, a limit should not be applied in such cases.\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\n                target = queryToTarget(query);\n            }\n            return this.indexManager\n                .getDocumentsMatchingTarget(transaction, target)\n                .next(keys => {\n                const sortedKeys = documentKeySet(...keys);\n                return this.localDocumentsView\n                    .getDocuments(transaction, sortedKeys)\n                    .next(indexedDocuments => {\n                    return this.indexManager\n                        .getMinOffset(transaction, target)\n                        .next(offset => {\n                        const previousResults = this.applyQuery(query, indexedDocuments);\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\n                            // A limit query whose boundaries change due to local\n                            // edits can be re-run against the cache by excluding the\n                            // limit. This ensures that all documents that match the\n                            // query's filters are included in the result set. The SDK\n                            // can then apply the limit once all local edits are\n                            // incorporated.\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\n                        }\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Performs a query based on the target's persisted query mapping. Returns\n     * `null` if the mapping is not available or cannot be used.\n     */\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        // Queries that have never seen a snapshot without limbo free documents\n        // should also be run as a full collection scan.\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\n            return PersistencePromise.resolve(null);\n        }\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\n            const previousResults = this.applyQuery(query, documents);\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\n                return PersistencePromise.resolve(null);\n            }\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\n            }\n            // Retrieve all results for documents that were updated since the last\n            // limbo-document free remote snapshot.\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\n        });\n    }\n    /** Applies the query filter and sorting to the provided documents.  */\n    applyQuery(query, documents) {\n        // Sort the documents and re-apply the query filter since previously\n        // matching documents do not necessarily still match the query.\n        let queryResults = new SortedSet(newQueryComparator(query));\n        documents.forEach((_, maybeDoc) => {\n            if (queryMatches(query, maybeDoc)) {\n                queryResults = queryResults.add(maybeDoc);\n            }\n        });\n        return queryResults;\n    }\n    /**\n     * Determines if a limit query needs to be refilled from cache, making it\n     * ineligible for index-free execution.\n     *\n     * @param query - The query.\n     * @param sortedPreviousResults - The documents that matched the query when it\n     * was last synchronized, sorted by the query's comparator.\n     * @param remoteKeys - The document keys that matched the query at the last\n     * snapshot.\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\n     * query was last synchronized.\n     */\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\n        if (query.limit === null) {\n            // Queries without limits do not need to be refilled.\n            return false;\n        }\n        if (remoteKeys.size !== sortedPreviousResults.size) {\n            // The query needs to be refilled if a previously matching document no\n            // longer matches.\n            return true;\n        }\n        // Limit queries are not eligible for index-free query execution if there is\n        // a potential that an older document from cache now sorts before a document\n        // that was previously part of the limit. This, however, can only happen if\n        // the document at the edge of the limit goes out of limit.\n        // If a document that is not the limit boundary sorts differently,\n        // the boundary of the limit itself did not change and documents from cache\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\n        // any modifications that don't affect the last document.\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\n            ? sortedPreviousResults.last()\n            : sortedPreviousResults.first();\n        if (!docAtLimitEdge) {\n            // We don't need to refill the query if there were already no documents.\n            return false;\n        }\n        return (docAtLimitEdge.hasPendingWrites ||\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\n    }\n    executeFullCollectionScan(transaction, query, context) {\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\n        }\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\n    }\n    /**\n     * Combines the results from an indexed execution with the remaining documents\n     * that have not yet been indexed.\n     */\n    appendRemainingResults(transaction, indexedResults, query, offset) {\n        // Retrieve all results for documents that were updated since the offset.\n        return this.localDocumentsView\n            .getDocumentsMatchingQuery(transaction, query, offset)\n            .next(remainingResults => {\n            // Merge with existing results\n            indexedResults.forEach(d => {\n                remainingResults = remainingResults.insert(d.key, d);\n            });\n            return remainingResults;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The format of the LocalStorage key that stores the client state is:\n//     firestore_clients_<persistence_prefix>_<instance_key>\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\n/** Assembles the key for a client state in WebStorage */\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\n}\n// The format of the WebStorage key that stores the mutation state is:\n//     firestore_mutations_<persistence_prefix>_<batch_id>\n//     (for unauthenticated users)\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\n//\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\n// contain.\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\n/** Assembles the key for a mutation batch in WebStorage */\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\n    if (user.isAuthenticated()) {\n        mutationKey += `_${user.uid}`;\n    }\n    return mutationKey;\n}\n// The format of the WebStorage key that stores a query target's metadata is:\n//     firestore_targets_<persistence_prefix>_<target_id>\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\n/** Assembles the key for a query state in WebStorage */\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\n}\n// The WebStorage prefix that stores the primary tab's online state. The\n// format of the key is:\n//     firestore_online_state_<persistence_prefix>\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\n/** Assembles the key for the online state of the primary tab. */\nfunction createWebStorageOnlineStateKey(persistenceKey) {\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage prefix that plays as a event to indicate the remote documents\n// might have changed due to some secondary tabs loading a bundle.\n// format of the key is:\n//     firestore_bundle_loaded_v2_<persistenceKey>\n// The version ending with \"v2\" stores the list of modified collection groups.\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\nfunction createBundleLoadedKey(persistenceKey) {\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\n/** Assembles the key for the current sequence number. */\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$a = 'SharedClientState';\n/**\n * Holds the state of a mutation batch, including its user ID, batch ID and\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\n */\n// Visible for testing\nclass MutationMetadata {\n    constructor(user, batchId, state, error) {\n        this.user = user;\n        this.batchId = batchId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(user, batchId, value) {\n        const mutationBatch = JSON.parse(value);\n        let validData = typeof mutationBatch === 'object' &&\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\n                -1 &&\n            (mutationBatch.error === undefined ||\n                typeof mutationBatch.error === 'object');\n        let firestoreError = undefined;\n        if (validData && mutationBatch.error) {\n            validData =\n                typeof mutationBatch.error.message === 'string' &&\n                    typeof mutationBatch.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\n            }\n        }\n        if (validData) {\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const batchMetadata = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            batchMetadata.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(batchMetadata);\n    }\n}\n/**\n * Holds the state of a query target, including its target ID and whether the\n * target is 'not-current', 'current' or 'rejected'.\n */\n// Visible for testing\nclass QueryTargetMetadata {\n    constructor(targetId, state, error) {\n        this.targetId = targetId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(targetId, value) {\n        const targetState = JSON.parse(value);\n        let validData = typeof targetState === 'object' &&\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\n                -1 &&\n            (targetState.error === undefined ||\n                typeof targetState.error === 'object');\n        let firestoreError = undefined;\n        if (validData && targetState.error) {\n            validData =\n                typeof targetState.error.message === 'string' &&\n                    typeof targetState.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\n            }\n        }\n        if (validData) {\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const targetState = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            targetState.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(targetState);\n    }\n}\n/**\n * This class represents the immutable ClientState for a client read from\n * WebStorage, containing the list of active query targets.\n */\nclass RemoteClientState {\n    constructor(clientId, activeTargetIds) {\n        this.clientId = clientId;\n        this.activeTargetIds = activeTargetIds;\n    }\n    /**\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(clientId, value) {\n        const clientState = JSON.parse(value);\n        let validData = typeof clientState === 'object' &&\n            clientState.activeTargetIds instanceof Array;\n        let activeTargetIdsSet = targetIdSet();\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\n        }\n        if (validData) {\n            return new RemoteClientState(clientId, activeTargetIdsSet);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * This class represents the online state for all clients participating in\n * multi-tab. The online state is only written to by the primary client, and\n * used in secondary clients to update their query views.\n */\nclass SharedOnlineState {\n    constructor(clientId, onlineState) {\n        this.clientId = clientId;\n        this.onlineState = onlineState;\n    }\n    /**\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(value) {\n        const onlineState = JSON.parse(value);\n        const validData = typeof onlineState === 'object' &&\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\n                -1 &&\n            typeof onlineState.clientId === 'string';\n        if (validData) {\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\n * mutable and keeps track of all pending mutations, which allows us to\n * update the range of pending mutation batch IDs as new mutations are added or\n * removed.\n *\n * The data in `LocalClientState` is not read from WebStorage and instead\n * updated via its instance methods. The updated state can be serialized via\n * `toWebStorageJSON()`.\n */\n// Visible for testing.\nclass LocalClientState {\n    constructor() {\n        this.activeTargetIds = targetIdSet();\n    }\n    addQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\n    }\n    removeQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\n    }\n    /**\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\n     * Does not encode `clientId` as it is part of the key in WebStorage.\n     */\n    toWebStorageJSON() {\n        const data = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        return JSON.stringify(data);\n    }\n}\n/**\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\n * backing store for the SharedClientState. It keeps track of all active\n * clients and supports modifications of the local client's data.\n */\nclass WebStorageSharedClientState {\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\n        this.window = window;\n        this.queue = queue;\n        this.persistenceKey = persistenceKey;\n        this.localClientId = localClientId;\n        this.syncEngine = null;\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n        this.storageListener = this.handleWebStorageEvent.bind(this);\n        this.activeClients = new SortedMap(primitiveComparator);\n        this.started = false;\n        /**\n         * Captures WebStorage events that occur before `start()` is called. These\n         * events are replayed once `WebStorageSharedClientState` is started.\n         */\n        this.earlyEvents = [];\n        // Escape the special characters mentioned here:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        this.storage = this.window.localStorage;\n        this.currentUser = initialUser;\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\n        // Rather than adding the storage observer during start(), we add the\n        // storage observer during initialization. This ensures that we collect\n        // events before other components populate their initial state (during their\n        // respective start() calls). Otherwise, we might for example miss a\n        // mutation that is added after LocalStore's start() processed the existing\n        // mutations but before we observe WebStorage events.\n        this.window.addEventListener('storage', this.storageListener);\n    }\n    /** Returns 'true' if WebStorage is available in the current environment. */\n    static isAvailable(window) {\n        return !!(window && window.localStorage);\n    }\n    async start() {\n        // Retrieve the list of existing clients to backfill the data in\n        // SharedClientState.\n        const existingClients = await this.syncEngine.getActiveClients();\n        for (const clientId of existingClients) {\n            if (clientId === this.localClientId) {\n                continue;\n            }\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\n            if (storageItem) {\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\n                if (clientState) {\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\n                }\n            }\n        }\n        this.persistClientState();\n        // Check if there is an existing online state and call the callback handler\n        // if applicable.\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\n        if (onlineStateJSON) {\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\n            if (onlineState) {\n                this.handleOnlineStateEvent(onlineState);\n            }\n        }\n        for (const event of this.earlyEvents) {\n            this.handleWebStorageEvent(event);\n        }\n        this.earlyEvents = [];\n        // Register a window unload hook to remove the client metadata entry from\n        // WebStorage even if `shutdown()` was not called.\n        this.window.addEventListener('pagehide', () => this.shutdown());\n        this.started = true;\n    }\n    writeSequenceNumber(sequenceNumber) {\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\n    }\n    getAllActiveQueryTargets() {\n        return this.extractActiveQueryTargets(this.activeClients);\n    }\n    isActiveQueryTarget(targetId) {\n        let found = false;\n        this.activeClients.forEach((key, value) => {\n            if (value.activeTargetIds.has(targetId)) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    addPendingMutation(batchId) {\n        this.persistMutationState(batchId, 'pending');\n    }\n    updateMutationState(batchId, state, error) {\n        this.persistMutationState(batchId, state, error);\n        // Once a final mutation result is observed by other clients, they no longer\n        // access the mutation's metadata entry. Since WebStorage replays events\n        // in order, it is safe to delete the entry right after updating it.\n        this.removeMutationState(batchId);\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        let queryState = 'not-current';\n        // Lookup an existing query state if the target ID was already registered\n        // by another tab\n        if (this.isActiveQueryTarget(targetId)) {\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n            if (storageItem) {\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\n                if (metadata) {\n                    queryState = metadata.state;\n                }\n            }\n        }\n        // If the query is listening to cache only, the target ID should not be registered with the\n        // local Firestore client as an active watch target.\n        if (addToActiveTargetIds) {\n            this.localClientState.addQueryTarget(targetId);\n        }\n        this.persistClientState();\n        return queryState;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localClientState.removeQueryTarget(targetId);\n        this.persistClientState();\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localClientState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n    }\n    updateQueryState(targetId, state, error) {\n        this.persistQueryTargetState(targetId, state, error);\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        removedBatchIds.forEach(batchId => {\n            this.removeMutationState(batchId);\n        });\n        this.currentUser = user;\n        addedBatchIds.forEach(batchId => {\n            this.addPendingMutation(batchId);\n        });\n    }\n    setOnlineState(onlineState) {\n        this.persistOnlineState(onlineState);\n    }\n    notifyBundleLoaded(collectionGroups) {\n        this.persistBundleLoadedState(collectionGroups);\n    }\n    shutdown() {\n        if (this.started) {\n            this.window.removeEventListener('storage', this.storageListener);\n            this.removeItem(this.localClientStorageKey);\n            this.started = false;\n        }\n    }\n    getItem(key) {\n        const value = this.storage.getItem(key);\n        logDebug(LOG_TAG$a, 'READ', key, value);\n        return value;\n    }\n    setItem(key, value) {\n        logDebug(LOG_TAG$a, 'SET', key, value);\n        this.storage.setItem(key, value);\n    }\n    removeItem(key) {\n        logDebug(LOG_TAG$a, 'REMOVE', key);\n        this.storage.removeItem(key);\n    }\n    handleWebStorageEvent(event) {\n        // Note: The function is typed to take Event to be interface-compatible with\n        // `Window.addEventListener`.\n        const storageEvent = event;\n        if (storageEvent.storageArea === this.storage) {\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\n            if (storageEvent.key === this.localClientStorageKey) {\n                logError('Received WebStorage notification for local change. Another client might have ' +\n                    'garbage-collected our state');\n                return;\n            }\n            this.queue.enqueueRetryable(async () => {\n                if (!this.started) {\n                    this.earlyEvents.push(storageEvent);\n                    return;\n                }\n                if (storageEvent.key === null) {\n                    return;\n                }\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue != null) {\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\n                        if (clientState) {\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\n                        }\n                    }\n                    else {\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\n                        return this.handleClientStateEvent(clientId, null);\n                    }\n                }\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\n                        if (mutationMetadata) {\n                            return this.handleMutationBatchEvent(mutationMetadata);\n                        }\n                    }\n                }\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\n                        if (queryTargetMetadata) {\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.onlineStateKey) {\n                    if (storageEvent.newValue !== null) {\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\n                        if (onlineState) {\n                            return this.handleOnlineStateEvent(onlineState);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.sequenceNumberKey) {\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\n                    if (sequenceNumber !== ListenSequence.INVALID) {\n                        this.sequenceNumberHandler(sequenceNumber);\n                    }\n                }\n                else if (storageEvent.key === this.bundleLoadedKey) {\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\n                }\n            });\n        }\n    }\n    get localClientState() {\n        return this.activeClients.get(this.localClientId);\n    }\n    persistClientState() {\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n    }\n    persistMutationState(batchId, state, error) {\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\n    }\n    removeMutationState(batchId) {\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.removeItem(mutationKey);\n    }\n    persistOnlineState(onlineState) {\n        const entry = {\n            clientId: this.localClientId,\n            onlineState\n        };\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\n    }\n    persistQueryTargetState(targetId, state, error) {\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\n    }\n    persistBundleLoadedState(collectionGroups) {\n        const json = JSON.stringify(Array.from(collectionGroups));\n        this.setItem(this.bundleLoadedKey, json);\n    }\n    /**\n     * Parses a client state key in WebStorage. Returns null if the key does not\n     * match the expected key format.\n     */\n    fromWebStorageClientStateKey(key) {\n        const match = this.clientStateKeyRe.exec(key);\n        return match ? match[1] : null;\n    }\n    /**\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\n     * be parsed.\n     */\n    fromWebStorageClientState(key, value) {\n        const clientId = this.fromWebStorageClientStateKey(key);\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\n    }\n    /**\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageMutationMetadata(key, value) {\n        const match = this.mutationBatchKeyRe.exec(key);\n        const batchId = Number(match[1]);\n        const userId = match[2] !== undefined ? match[2] : null;\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\n    }\n    /**\n     * Parses a query target state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageQueryTargetMetadata(key, value) {\n        const match = this.queryTargetKeyRe.exec(key);\n        const targetId = Number(match[1]);\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\n    }\n    /**\n     * Parses an online state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageOnlineState(value) {\n        return SharedOnlineState.fromWebStorageEntry(value);\n    }\n    fromWebStoreBundleLoadedState(value) {\n        return JSON.parse(value);\n    }\n    async handleMutationBatchEvent(mutationBatch) {\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\n            return;\n        }\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\n    }\n    handleQueryTargetEvent(targetMetadata) {\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\n    }\n    handleClientStateEvent(clientId, clientState) {\n        const updatedClients = clientState\n            ? this.activeClients.insert(clientId, clientState)\n            : this.activeClients.remove(clientId);\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\n        const addedTargets = [];\n        const removedTargets = [];\n        newTargets.forEach(targetId => {\n            if (!existingTargets.has(targetId)) {\n                addedTargets.push(targetId);\n            }\n        });\n        existingTargets.forEach(targetId => {\n            if (!newTargets.has(targetId)) {\n                removedTargets.push(targetId);\n            }\n        });\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\n            this.activeClients = updatedClients;\n        });\n    }\n    handleOnlineStateEvent(onlineState) {\n        // We check whether the client that wrote this online state is still active\n        // by comparing its client ID to the list of clients kept active in\n        // IndexedDb. If a client does not update their IndexedDb client state\n        // within 5 seconds, it is considered inactive and we don't emit an online\n        // state event.\n        if (this.activeClients.get(onlineState.clientId)) {\n            this.onlineStateHandler(onlineState.onlineState);\n        }\n    }\n    extractActiveQueryTargets(clients) {\n        let activeTargets = targetIdSet();\n        clients.forEach((kev, value) => {\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\n        });\n        return activeTargets;\n    }\n}\nfunction fromWebStorageSequenceNumber(seqString) {\n    let sequenceNumber = ListenSequence.INVALID;\n    if (seqString != null) {\n        try {\n            const parsed = JSON.parse(seqString);\n            hardAssert(typeof parsed === 'number');\n            sequenceNumber = parsed;\n        }\n        catch (e) {\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\n        }\n    }\n    return sequenceNumber;\n}\n/**\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\n * clients using memory persistence. The state in this class remains fully\n * isolated and no synchronization is performed.\n */\nclass MemorySharedClientState {\n    constructor() {\n        this.localState = new LocalClientState();\n        this.queryState = {};\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n    }\n    addPendingMutation(batchId) {\n        // No op.\n    }\n    updateMutationState(batchId, state, error) {\n        // No op.\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        if (addToActiveTargetIds) {\n            this.localState.addQueryTarget(targetId);\n        }\n        return this.queryState[targetId] || 'not-current';\n    }\n    updateQueryState(targetId, state, error) {\n        this.queryState[targetId] = state;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localState.removeQueryTarget(targetId);\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        delete this.queryState[targetId];\n    }\n    getAllActiveQueryTargets() {\n        return this.localState.activeTargetIds;\n    }\n    isActiveQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    start() {\n        this.localState = new LocalClientState();\n        return Promise.resolve();\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        // No op.\n    }\n    setOnlineState(onlineState) {\n        // No op.\n    }\n    shutdown() { }\n    writeSequenceNumber(sequenceNumber) { }\n    notifyBundleLoaded(collectionGroups) {\n        // No op.\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass NoopConnectivityMonitor {\n    addCallback(callback) {\n        // No-op.\n    }\n    shutdown() {\n        // No-op.\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nclass StreamBridge {\n    constructor(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    onConnected(callback) {\n        this.wrappedOnConnected = callback;\n    }\n    onOpen(callback) {\n        this.wrappedOnOpen = callback;\n    }\n    onClose(callback) {\n        this.wrappedOnClose = callback;\n    }\n    onMessage(callback) {\n        this.wrappedOnMessage = callback;\n    }\n    close() {\n        this.closeFn();\n    }\n    send(msg) {\n        this.sendFn(msg);\n    }\n    callOnConnected() {\n        this.wrappedOnConnected();\n    }\n    callOnOpen() {\n        this.wrappedOnOpen();\n    }\n    callOnClose(err) {\n        this.wrappedOnClose(err);\n    }\n    callOnMessage(msg) {\n        this.wrappedOnMessage(msg);\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The value returned from the most recent invocation of\n * `generateUniqueDebugId()`, or null if it has never been invoked.\n */\nlet lastUniqueDebugId = null;\n/**\n * Generates and returns an initial value for `lastUniqueDebugId`.\n *\n * The returned value is randomly selected from a range of integers that are\n * represented as 8 hexadecimal digits. This means that (within reason) any\n * numbers generated by incrementing the returned number by 1 will also be\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\n * length when converted to a hexadecimal string, making reading logs containing\n * these IDs easier to follow. And since the return value is randomly selected\n * it will help to differentiate between logs from different executions.\n */\nfunction generateInitialUniqueDebugId() {\n    const minResult = 0x10000000;\n    const maxResult = 0x90000000;\n    const resultRange = maxResult - minResult;\n    const resultOffset = Math.round(resultRange * Math.random());\n    return minResult + resultOffset;\n}\n/**\n * Generates and returns a unique ID as a hexadecimal string.\n *\n * The returned ID is intended to be used in debug logging messages to help\n * correlate log messages that may be spatially separated in the logs, but\n * logically related. For example, a network connection could include the same\n * \"debug ID\" string in all of its log messages to help trace a specific\n * connection over time.\n *\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\n */\nfunction generateUniqueDebugId() {\n    if (lastUniqueDebugId === null) {\n        lastUniqueDebugId = generateInitialUniqueDebugId();\n    }\n    else {\n        lastUniqueDebugId++;\n    }\n    return '0x' + lastUniqueDebugId.toString(16);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\n * details.\n */\n/**\n * Creates a node-style callback that resolves or rejects a new Promise. The\n * callback is passed to the given action which can then use the callback as\n * a parameter to a node-style function.\n *\n * The intent is to directly bridge a node-style function (which takes a\n * callback) into a Promise without manually converting between the node-style\n * callback and the promise at each call.\n *\n * In effect it allows you to convert:\n *\n * @example\n * new Promise((resolve: (value?: fs.Stats) => void,\n *              reject: (error?: any) => void) => {\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\n *     if (error) {\n *       reject(error);\n *     } else {\n *       resolve(stat);\n *     }\n *   });\n * });\n *\n * Into\n * @example\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\n *   fs.stat(path, callback);\n * });\n *\n * @param action - a function that takes a node-style callback as an argument\n *     and then uses that callback to invoke some node-style API.\n * @returns a new Promise which will be rejected if the callback is given the\n *     first Error parameter or will resolve to the value given otherwise.\n */\nfunction nodePromise(action) {\n    return new Promise((resolve, reject) => {\n        action((error, value) => {\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(value);\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO: Fetch runtime version from grpc-js/package.json instead\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\nconst grpcVersion = '1.9.15';\nconst LOG_TAG$9 = 'GrpcConnection';\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\n    hardAssert(authToken === null || authToken.type === 'OAuth');\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.Metadata();\n    if (authToken) {\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appCheckToken) {\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appId) {\n        metadata.set('X-Firebase-GMPID', appId);\n    }\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\n    // These headers are used to improve routing and project isolation by the\n    // backend.\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\n    // 11 from Google3.\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\n    metadata.set('x-goog-request-params', databasePath);\n    return metadata;\n}\n/**\n * A Connection implemented by GRPC-Node.\n */\nclass GrpcConnection {\n    get shouldResourcePathBeIncludedInRequest() {\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\n        // the \"path\" to be part of the given `request`.\n        return true;\n    }\n    constructor(protos, databaseInfo) {\n        this.databaseInfo = databaseInfo;\n        // We cache stubs for the most-recently-used token.\n        this.cachedStub = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.firestore = protos['google']['firestore']['v1'];\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\n    }\n    ensureActiveStub() {\n        if (!this.cachedStub) {\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\n            const credentials = this.databaseInfo.ssl\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createSsl()\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createInsecure();\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\n        }\n        return this.cachedStub;\n    }\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\n        return nodePromise((callback) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\n                if (grpcError) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\n                    callback(undefined, value);\n                }\n            });\n        });\n    }\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\n        const streamId = generateUniqueDebugId();\n        const results = [];\n        const responseDeferred = new Deferred();\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\n        const stream = stub[rpcName](jsonRequest, metadata);\n        let callbackFired = false;\n        stream.on('data', (response) => {\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\n            results.push(response);\n            if (expectedResponseCount !== undefined &&\n                results.length === expectedResponseCount) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\n            if (!callbackFired) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('error', (grpcError) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n            const code = mapCodeFromRpcCode(grpcError.code);\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\n        });\n        return responseDeferred.promise;\n    }\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n    openStream(rpcName, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const grpcStream = stub[rpcName](metadata);\n        let closed = false;\n        const close = (err) => {\n            if (!closed) {\n                closed = true;\n                stream.callOnClose(err);\n                grpcStream.end();\n            }\n        };\n        const stream = new StreamBridge({\n            sendFn: (msg) => {\n                if (!closed) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\n                    try {\n                        grpcStream.write(msg);\n                    }\n                    catch (e) {\n                        // This probably means we didn't conform to the proto.  Make sure to\n                        // log the message we sent.\n                        logError('Failure sending:', msg);\n                        logError('Error:', e);\n                        throw e;\n                    }\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\n                        'not sending because gRPC stream is closed:', msg);\n                }\n            },\n            closeFn: () => {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\n                close();\n            }\n        });\n        let onConnectedSent = false;\n        grpcStream.on('data', (msg) => {\n            if (!closed) {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\n                if (!onConnectedSent) {\n                    stream.callOnConnected();\n                    onConnectedSent = true;\n                }\n                stream.callOnMessage(msg);\n            }\n        });\n        grpcStream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\n            close();\n        });\n        grpcStream.on('error', (grpcError) => {\n            if (!closed) {\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\n                const code = mapCodeFromRpcCode(grpcError.code);\n                close(new FirestoreError(code, grpcError.message));\n            }\n        });\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\n            `to ${this.databaseInfo.host}`);\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n        // simulate an onOpen in the next loop after the stream had it's listeners\n        // registered\n        setTimeout(() => {\n            stream.callOnOpen();\n        }, 0);\n        return stream;\n    }\n    /**\n     * Closes and cleans up any resources associated with the GrpcConnection.\n     * If a gRPC client has been generated for this connection, the gRPC client\n     * is closed. Failure to call terminate on a GrpcConnection can result\n     * in leaked resources of the gRPC client.\n     */\n    terminate() {\n        if (this.cachedStub) {\n            this.cachedStub.close();\n            this.cachedStub = undefined;\n        }\n    }\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used by tests so we can match @grpc/proto-loader behavior. */\nconst protoLoaderOptions = {\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: false\n};\n/**\n * Loads the protocol buffer definitions for Firestore.\n *\n * @returns The GrpcObject representing our protos.\n */\nfunction loadProtos() {\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__.fromJSON(protos$1, protoLoaderOptions);\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.loadPackageDefinition(packageDefinition);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Loads the GRPC stack */\nfunction newConnection(databaseInfo) {\n    const protos = loadProtos();\n    return new GrpcConnection(protos, databaseInfo);\n}\n/** Return the Platform-specific connectivity monitor. */\nfunction newConnectivityMonitor() {\n    return new NoopConnectivityMonitor();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The Platform's 'window' implementation or null if not available. */\nfunction getWindow() {\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\n        // eslint-disable-next-line no-restricted-globals\n        return window;\n    }\n    return null;\n}\n/** The Platform's 'document' implementation or null if not available. */\nfunction getDocument() {\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction newSerializer(databaseId) {\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$8 = 'ExponentialBackoff';\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/** Maximum backoff time in milliseconds */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nclass ExponentialBackoff {\n    constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.currentBaseMs = 0;\n        this.timerPromise = null;\n        /** The last backoff attempt, as epoch milliseconds. */\n        this.lastAttemptTime = Date.now();\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    reset() {\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    backoffAndRun(op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\n        // Guard against lastAttemptTime being in the future due to a clock change.\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n        // Guard against the backoff delay already being past.\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\n        if (remainingDelayMs > 0) {\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms, ` +\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\n                `last attempt: ${delaySoFarMs} ms ago)`);\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\n            this.lastAttemptTime = Date.now();\n            return op();\n        });\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    }\n    skipBackoff() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.skipDelay();\n            this.timerPromise = null;\n        }\n    }\n    cancel() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$7 = 'PersistentStream';\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n/** The time a stream stays open until we consider it healthy. */\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *   - Closing idle streams after 60 seconds of inactivity\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be start()ed before messages can\n * be sent and received. The PersistentStream will call the onOpen() function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a start() fail, PersistentStream will call the registered onClose()\n * listener with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nclass PersistentStream {\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.healthTimerId = healthTimerId;\n        this.connection = connection;\n        this.authCredentialsProvider = authCredentialsProvider;\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\n        this.listener = listener;\n        this.state = 0 /* PersistentStreamState.Initial */;\n        /**\n         * A close count that's incremented every time the stream is closed; used by\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\n         * close.\n         */\n        this.closeCount = 0;\n        this.idleTimer = null;\n        this.healthCheck = null;\n        this.stream = null;\n        /**\n         * Count of response messages received.\n         */\n        this.responseCount = 0;\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\n    }\n    /**\n     * Returns true if start() has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    isStarted() {\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\n            this.isOpen());\n    }\n    /**\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\n     * called) and the stream is ready for outbound requests.\n     */\n    isOpen() {\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\n            this.state === 3 /* PersistentStreamState.Healthy */);\n    }\n    /**\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\n     * ready for outbound requests, at which point isOpen() will return true.\n     *\n     * When start returns, isStarted() will return true.\n     */\n    start() {\n        this.responseCount = 0;\n        if (this.state === 4 /* PersistentStreamState.Error */) {\n            this.performBackoff();\n            return;\n        }\n        this.auth();\n    }\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted() state.\n     *\n     * When stop returns, isStarted() and isOpen() will both return false.\n     */\n    async stop() {\n        if (this.isStarted()) {\n            await this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose() listener. That function can decide to\n     * inhibit backoff if required.\n     */\n    inhibitBackoff() {\n        this.state = 0 /* PersistentStreamState.Initial */;\n        this.backoff.reset();\n    }\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    markIdle() {\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.idleTimer === null) {\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\n        }\n    }\n    /** Sends a message to the underlying stream. */\n    sendRequest(msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    }\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    async handleIdleCloseTimer() {\n        if (this.isOpen()) {\n            // When timing out an idle stream there's no reason to force the stream into backoff when\n            // it restarts so set the stream state to Initial instead of Error.\n            return this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /** Marks the stream as active again. */\n    cancelIdleCheck() {\n        if (this.idleTimer) {\n            this.idleTimer.cancel();\n            this.idleTimer = null;\n        }\n    }\n    /** Cancels the health check delayed operation. */\n    cancelHealthCheck() {\n        if (this.healthCheck) {\n            this.healthCheck.cancel();\n            this.healthCheck = null;\n        }\n    }\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling start().\n     *\n     * @param finalState - the intended state of the stream after closing.\n     * @param error - the error the connection was closed with.\n     */\n    async close(finalState, error) {\n        // Cancel any outstanding timers (they're guaranteed not to execute).\n        this.cancelIdleCheck();\n        this.cancelHealthCheck();\n        this.backoff.cancel();\n        // Invalidates any stream-related callbacks (e.g. from auth or the\n        // underlying stream), guaranteeing they won't execute.\n        this.closeCount++;\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\n            // If this is an intentional close ensure we don't delay our next connection attempt.\n            this.backoff.reset();\n        }\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n            logError(error.toString());\n            logError('Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        else if (error &&\n            error.code === Code.UNAUTHENTICATED &&\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\n            // \"unauthenticated\" error means the token was rejected. This should rarely\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\n            // request a token. If a user manually resets their system clock this can\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\n            // before we received the first message and we need to invalidate the token\n            // to ensure that we fetch a new token.\n            this.authCredentialsProvider.invalidateToken();\n            this.appCheckCredentialsProvider.invalidateToken();\n        }\n        // Clean up the underlying stream because we are no longer interested in events.\n        if (this.stream !== null) {\n            this.tearDown();\n            this.stream.close();\n            this.stream = null;\n        }\n        // This state must be assigned before calling onClose() to allow the callback to\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\n        this.state = finalState;\n        // Notify the listener that the stream closed.\n        await this.listener.onClose(error);\n    }\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    tearDown() { }\n    auth() {\n        this.state = 1 /* PersistentStreamState.Starting */;\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\n        const closeCount = this.closeCount;\n        Promise.all([\n            this.authCredentialsProvider.getToken(),\n            this.appCheckCredentialsProvider.getToken()\n        ]).then(([authToken, appCheckToken]) => {\n            // Stream can be stopped while waiting for authentication.\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\n            // and let this dispatch onto the queue, but that opened a spec test can\n            // of worms that I don't want to deal with in this PR.\n            if (this.closeCount === closeCount) {\n                // Normally we'd have to schedule the callback on the AsyncQueue.\n                // However, the following calls are safe to be called outside the\n                // AsyncQueue since they don't chain asynchronous calls\n                this.startStream(authToken, appCheckToken);\n            }\n        }, (error) => {\n            dispatchIfNotClosed(() => {\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                return this.handleStreamClose(rpcError);\n            });\n        });\n    }\n    startStream(authToken, appCheckToken) {\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        this.stream = this.startRpc(authToken, appCheckToken);\n        this.stream.onConnected(() => {\n            dispatchIfNotClosed(() => this.listener.onConnected());\n        });\n        this.stream.onOpen(() => {\n            dispatchIfNotClosed(() => {\n                this.state = 2 /* PersistentStreamState.Open */;\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\n                    if (this.isOpen()) {\n                        this.state = 3 /* PersistentStreamState.Healthy */;\n                    }\n                    return Promise.resolve();\n                });\n                return this.listener.onOpen();\n            });\n        });\n        this.stream.onClose((error) => {\n            dispatchIfNotClosed(() => {\n                return this.handleStreamClose(error);\n            });\n        });\n        this.stream.onMessage((msg) => {\n            dispatchIfNotClosed(() => {\n                if (++this.responseCount === 1) {\n                    return this.onFirst(msg);\n                }\n                else {\n                    return this.onNext(msg);\n                }\n            });\n        });\n    }\n    performBackoff() {\n        this.state = 5 /* PersistentStreamState.Backoff */;\n        this.backoff.backoffAndRun(async () => {\n            this.state = 0 /* PersistentStreamState.Initial */;\n            this.start();\n        });\n    }\n    // Visible for tests\n    handleStreamClose(error) {\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(4 /* PersistentStreamState.Error */, error);\n    }\n    /**\n     * Returns a \"dispatcher\" function that dispatches operations onto the\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\n     * re-opened, etc.\n     */\n    getCloseGuardedDispatcher(startCloseCount) {\n        return (fn) => {\n            this.queue.enqueueAndForget(() => {\n                if (this.closeCount === startCloseCount) {\n                    return fn();\n                }\n                else {\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\n                    return Promise.resolve();\n                }\n            });\n        };\n    }\n}\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the onOpen() listener, any number of\n * listen() and unlisten() calls can be made to control what changes will be\n * sent from the server for ListenResponses.\n */\nclass PersistentListenStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Listen', authToken, appCheckToken);\n    }\n    onFirst(watchChangeProto) {\n        return this.onNext(watchChangeProto);\n    }\n    onNext(watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\n        const snapshot = versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    }\n    /**\n     * Registers interest in the results of the given target. If the target\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the target will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    watch(targetData) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.addTarget = toTarget(this.serializer, targetData);\n        const labels = toListenRequestLabels(this.serializer, targetData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    }\n    /**\n     * Unregisters interest in the results of the target associated with the\n     * given targetId.\n     */\n    unwatch(targetId) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    }\n}\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nclass PersistentWriteStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get handshakeComplete() {\n        return this.responseCount > 0;\n    }\n    // Override of PersistentStream.start\n    start() {\n        this.lastStreamToken = undefined;\n        super.start();\n    }\n    tearDown() {\n        if (this.handshakeComplete) {\n            this.writeMutations([]);\n        }\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Write', authToken, appCheckToken);\n    }\n    onFirst(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // The first response is always the handshake response\n        hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\n        return this.listener.onHandshakeComplete();\n    }\n    onNext(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // A successful first write response means the stream is healthy,\n        // Note, that we could consider a successful handshake healthy, however,\n        // the write itself might be causing an error we want to back off from.\n        this.backoff.reset();\n        const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\n        const commitVersion = fromVersion(responseProto.commitTime);\n        return this.listener.onMutationResult(commitVersion, results);\n    }\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    writeHandshake() {\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        this.sendRequest(request);\n    }\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    writeMutations(mutations) {\n        const request = {\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\n        };\n        this.sendRequest(request);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\nclass Datastore {\n}\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nclass DatastoreImpl extends Datastore {\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\n        super();\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.connection = connection;\n        this.serializer = serializer;\n        this.terminated = false;\n    }\n    verifyInitialized() {\n        if (this.terminated) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n        }\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    terminate() {\n        this.terminated = true;\n        this.connection.terminate();\n    }\n}\n// TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\n}\nasync function invokeCommitRpc(datastore, mutations) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\n    };\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\n}\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\n    };\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\n    const docs = new Map();\n    response.forEach(proto => {\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\n        docs.set(doc.key.toString(), doc);\n    });\n    const result = [];\n    keys.forEach(key => {\n        const doc = docs.get(key.toString());\n        hardAssert(!!doc);\n        result.push(doc);\n    });\n    return result;\n}\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\n    var _a;\n    const datastoreImpl = debugCast(datastore);\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\n        delete request.parent;\n    }\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \n    /*expectedResponseCount=*/ 1);\n    // Omit RunAggregationQueryResponse that only contain readTimes.\n    const filteredResult = response.filter(proto => !!proto.result);\n    hardAssert(filteredResult.length === 1);\n    // Remap the short-form aliases that were sent to the server\n    // to the client-side aliases. Users will access the results\n    // using the client-side alias.\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\n        return accumulator;\n    }, {});\n    return remappedFields;\n}\nfunction newPersistentWriteStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\nfunction newPersistentWatchStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$6 = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\n// to 1. If that works okay, we could potentially remove this logic entirely.\nconst MAX_WATCH_STREAM_FAILURES = 1;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nclass OnlineStateTracker {\n    constructor(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started (including on each\n     * backoff attempt).\n     *\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\n     * the onlineStateTimer.\n     */\n    handleWatchStreamStart() {\n        if (this.watchStreamFailures === 0) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\n                this.onlineStateTimer = null;\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\n                    `seconds.`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    }\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    handleWatchStreamFailure(error) {\n        if (this.state === \"Online\" /* OnlineState.Online */) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\n                    `times. Most recent error: ${error.toString()}`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n            }\n        }\n    }\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    set(newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === \"Online\" /* OnlineState.Online */) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    }\n    setAndBroadcast(newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    }\n    logClientOfflineWarningIfNecessary(details) {\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\n            `This typically indicates that your device does not have a healthy ` +\n            `Internet connection at the moment. The client will operate in offline ` +\n            `mode until it is able to successfully connect to the backend.`;\n        if (this.shouldWarnClientIsOffline) {\n            logError(message);\n            this.shouldWarnClientIsOffline = false;\n        }\n        else {\n            logDebug(LOG_TAG$6, message);\n        }\n    }\n    clearOnlineStateTimer() {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$5 = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\nclass RemoteStoreImpl {\n    constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound mutations.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.asyncQueue = asyncQueue;\n        this.remoteSyncer = {};\n        /**\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\n         * LocalStore via fillWritePipeline() and have or will send to the write\n         * stream.\n         *\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\n         * restart the write stream. When the stream is established the writes in the\n         * pipeline will be sent in order.\n         *\n         * Writes remain in writePipeline until they are acknowledged by the backend\n         * and thus will automatically be re-sent if the stream is interrupted /\n         * restarted before they're acknowledged.\n         *\n         * Write responses from the backend are linked to their originating request\n         * purely based on order, and so we can just shift() writes from the front of\n         * the writePipeline as we receive responses.\n         */\n        this.writePipeline = [];\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = new Map();\n        /**\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\n         * RemoteStore may start its network connections.\n         */\n        this.offlineCauses = new Set();\n        /**\n         * Event handlers that get called when the network is disabled or enabled.\n         *\n         * PORTING NOTE: These functions are used on the Web client to create the\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\n         * the streams are created during construction of RemoteStore.\n         */\n        this.onNetworkStatusChange = [];\n        this.connectivityMonitor = connectivityMonitor;\n        this.connectivityMonitor.addCallback((_) => {\n            asyncQueue.enqueueAndForget(async () => {\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\n                // network becomes unreachable as we don't have any other way to tear\n                // down our streams.\n                if (canUseNetwork(this)) {\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\n                    await restartNetwork(this);\n                }\n            });\n        });\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n}\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\n}\n/** Re-enables the network. Idempotent. */\nfunction remoteStoreEnableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\n    return enableNetworkInternal(remoteStoreImpl);\n}\nasync function enableNetworkInternal(remoteStoreImpl) {\n    if (canUseNetwork(remoteStoreImpl)) {\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n            await networkStatusHandler(/* enabled= */ true);\n        }\n    }\n}\n/**\n * Temporarily disables the network. The network can be re-enabled using\n * enableNetwork().\n */\nasync function remoteStoreDisableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\n    await disableNetworkInternal(remoteStoreImpl);\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n}\nasync function disableNetworkInternal(remoteStoreImpl) {\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n        await networkStatusHandler(/* enabled= */ false);\n    }\n}\nasync function remoteStoreShutdown(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.connectivityMonitor.shutdown();\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n}\n/**\n * Starts new listen for the given target. Uses resume token if provided. It\n * is a no-op if the target of given `TargetData` is already being listened to.\n */\nfunction remoteStoreListen(remoteStore, targetData) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\n        return;\n    }\n    // Mark this as something the client is currently listening for.\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        // The listen will be sent in onWatchStreamOpen\n        startWatchStream(remoteStoreImpl);\n    }\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    }\n}\n/**\n * Removes the listen from server. It is a no-op if the given target id is\n * not being listened to.\n */\nfunction remoteStoreUnlisten(remoteStore, targetId) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const watchStream = ensureWatchStream(remoteStoreImpl);\n    remoteStoreImpl.listenTargets.delete(targetId);\n    if (watchStream.isOpen()) {\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n    }\n    if (remoteStoreImpl.listenTargets.size === 0) {\n        if (watchStream.isOpen()) {\n            watchStream.markIdle();\n        }\n        else if (canUseNetwork(remoteStoreImpl)) {\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\n            // have no listeners, since without any listens to send we cannot\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n        }\n    }\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the ack to process any messages from this target.\n */\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\n        targetData = targetData.withExpectedCount(expectedCount);\n    }\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the removal on the server before we process any\n * messages from this target.\n */\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\n}\nfunction startWatchStream(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\n    });\n    ensureWatchStream(remoteStoreImpl).start();\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\n}\n/**\n * Returns whether the watch stream should be started because it's necessary\n * and has not yet been started.\n */\nfunction shouldStartWatchStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.listenTargets.size > 0);\n}\nfunction canUseNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    return remoteStoreImpl.offlineCauses.size === 0;\n}\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = undefined;\n}\nasync function onWatchStreamConnected(remoteStoreImpl) {\n    // Mark the client as online since we got a \"connected\" notification.\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n}\nasync function onWatchStreamOpen(remoteStoreImpl) {\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    });\n}\nasync function onWatchStreamClose(remoteStoreImpl, error) {\n    cleanUpWatchStreamState(remoteStoreImpl);\n    // If we still need the watch stream, retry the connection.\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\n        startWatchStream(remoteStoreImpl);\n    }\n    else {\n        // No need to restart watch stream because there are no active targets.\n        // The online state is set to unknown because there is no active attempt\n        // at establishing a connection\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\n    // Mark the client as online since we got a message from the server\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n    if (watchChange instanceof WatchTargetChange &&\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\n        watchChange.cause) {\n        // There was an error on a target, don't wait for a consistent snapshot\n        // to raise events\n        try {\n            await handleTargetError(remoteStoreImpl, watchChange);\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n        return;\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\n    }\n    else if (watchChange instanceof ExistenceFilterChange) {\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\n    }\n    else {\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\n    }\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\n        try {\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\n                // We have received a target change with a global snapshot if the snapshot\n                // version is not equal to SnapshotVersion.min().\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\n            }\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n}\n/**\n * Recovery logic for IndexedDB errors that takes the network offline until\n * `op` succeeds. Retries are scheduled with backoff using\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\n * validated via a generic operation.\n *\n * The returned Promise is resolved once the network is disabled and before\n * any retry attempt.\n */\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\n    if (isIndexedDbTransactionError(e)) {\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\n        // Disable network and raise offline snapshots\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n        if (!op) {\n            // Use a simple read operation to determine if IndexedDB recovered.\n            // Ideally, we would expose a health check directly on SimpleDb, but\n            // RemoteStore only has access to persistence through LocalStore.\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n        }\n        // Probe IndexedDB periodically and re-enable network\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\n            await op();\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\n            await enableNetworkInternal(remoteStoreImpl);\n        });\n    }\n    else {\n        throw e;\n    }\n}\n/**\n * Executes `op`. If `op` fails, takes the network offline until `op`\n * succeeds. Returns after the first attempt.\n */\nfunction executeWithRecovery(remoteStoreImpl, op) {\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\n}\n/**\n * Takes a batch of changes from the Datastore, repackages them as a\n * RemoteEvent, and passes that on to the listener, which is typically the\n * SyncEngine.\n */\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\n    // Update in-memory resume tokens. LocalStore will update the\n    // persistent view of these when applying the completed RemoteEvent.\n    remoteEvent.targetChanges.forEach((change, targetId) => {\n        if (change.resumeToken.approximateByteSize() > 0) {\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\n            // A watched target might have been removed already.\n            if (targetData) {\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\n            }\n        }\n    });\n    // Re-establish listens for the targets that have been invalidated by\n    // existence filter mismatches.\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\n        if (!targetData) {\n            // A watched target might have been removed already.\n            return;\n        }\n        // Clear the resume token for the target, since we're in a known mismatch\n        // state.\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\n        // Cause a hard reset by unwatching and rewatching immediately, but\n        // deliberately don't send a resume token so that we get a full update.\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n        // Mark the target we send as being on behalf of an existence filter\n        // mismatch, but don't actually retain that in listenTargets. This ensures\n        // that we flag the first re-listen this way without impacting future\n        // listens of this target (that might happen e.g. on reconnect).\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\n    });\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\n}\n/** Handles an error on a target */\nasync function handleTargetError(remoteStoreImpl, watchChange) {\n    const error = watchChange.cause;\n    for (const targetId of watchChange.targetIds) {\n        // A watched target might have been removed already.\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\n            remoteStoreImpl.listenTargets.delete(targetId);\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\n        }\n    }\n}\n/**\n * Attempts to fill our write pipeline with writes from the LocalStore.\n *\n * Called internally to bootstrap or refill the write pipeline and by\n * SyncEngine whenever there are new mutations to process.\n *\n * Starts the write stream if necessary.\n */\nasync function fillWritePipeline(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\n            .batchId\n        : BATCHID_UNKNOWN;\n    while (canAddToWritePipeline(remoteStoreImpl)) {\n        try {\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\n            if (batch === null) {\n                if (remoteStoreImpl.writePipeline.length === 0) {\n                    writeStream.markIdle();\n                }\n                break;\n            }\n            else {\n                lastBatchIdRetrieved = batch.batchId;\n                addToWritePipeline(remoteStoreImpl, batch);\n            }\n        }\n        catch (e) {\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\n/**\n * Returns true if we can add to the write pipeline (i.e. the network is\n * enabled and the write pipeline is not full).\n */\nfunction canAddToWritePipeline(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\n}\n/**\n * Queues additional writes to be sent to the write stream, sending them\n * immediately if the write stream is established.\n */\nfunction addToWritePipeline(remoteStoreImpl, batch) {\n    remoteStoreImpl.writePipeline.push(batch);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nfunction shouldStartWriteStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.writePipeline.length > 0);\n}\nfunction startWriteStream(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).start();\n}\nasync function onWriteStreamOpen(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\n}\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    // Send the write pipeline now that the stream is established.\n    for (const batch of remoteStoreImpl.writePipeline) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\n    const batch = remoteStoreImpl.writePipeline.shift();\n    const success = MutationBatchResult.from(batch, commitVersion, results);\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\n    // It's possible that with the completion of this mutation another\n    // slot has freed up.\n    await fillWritePipeline(remoteStoreImpl);\n}\nasync function onWriteStreamClose(remoteStoreImpl, error) {\n    // If the write stream closed after the write handshake completes, a write\n    // operation failed and we fail the pending operation.\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\n        // This error affects the actual write.\n        await handleWriteError(remoteStoreImpl, error);\n    }\n    // The write stream might have been started by refilling the write\n    // pipeline for failed writes\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\nasync function handleWriteError(remoteStoreImpl, error) {\n    // Only handle permanent errors here. If it's transient, just let the retry\n    // logic kick in.\n    if (isPermanentWriteError(error.code)) {\n        // This was a permanent error, the request itself was the problem\n        // so it's not going to succeed if we resend it.\n        const batch = remoteStoreImpl.writePipeline.shift();\n        // In this case it's also unlikely that the server itself is melting\n        // down -- this was just a bad request so inhibit backoff on the next\n        // restart.\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\n        // It's possible that with the completion of this mutation\n        // another slot has freed up.\n        await fillWritePipeline(remoteStoreImpl);\n    }\n}\nasync function restartNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\n    // Tear down and re-create our network streams. This will ensure we get a\n    // fresh auth token for the new user and re-fill the write pipeline with\n    // new mutations from the LocalStore (since mutations are per-user).\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    if (usesNetwork) {\n        // Don't set the network status to Unknown if we are offline.\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\n/**\n * Toggles the network state when the client gains or loses its primary lease.\n */\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (isPrimary) {\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\n        await enableNetworkInternal(remoteStoreImpl);\n    }\n    else if (!isPrimary) {\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\n/**\n * If not yet initialized, registers the WatchStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWatchStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.watchStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.watchStream.inhibitBackoff();\n                if (shouldStartWatchStream(remoteStoreImpl)) {\n                    startWatchStream(remoteStoreImpl);\n                }\n                else {\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n                }\n            }\n            else {\n                await remoteStoreImpl.watchStream.stop();\n                cleanUpWatchStreamState(remoteStoreImpl);\n            }\n        });\n    }\n    return remoteStoreImpl.watchStream;\n}\n/**\n * If not yet initialized, registers the WriteStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWriteStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.writeStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: () => Promise.resolve(),\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.writeStream.inhibitBackoff();\n                // This will start the write stream if necessary.\n                await fillWritePipeline(remoteStoreImpl);\n            }\n            else {\n                await remoteStoreImpl.writeStream.stop();\n                if (remoteStoreImpl.writePipeline.length > 0) {\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\n                    remoteStoreImpl.writePipeline = [];\n                }\n            }\n        });\n    }\n    return remoteStoreImpl.writeStream;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$4 = 'AsyncQueue';\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nclass DelayedOperation {\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(err => { });\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue - The queue to schedule the operation on.\n     * @param id - A Timer ID identifying the type of operation this is.\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\n     * @param op - The operation to run.\n     * @param removalCallback - A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\n        const targetTime = Date.now() + delayMs;\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    }\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    start(delayMs) {\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n    }\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    skipDelay() {\n        return this.handleDelayElapsed();\n    }\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    cancel(reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    }\n    handleDelayElapsed() {\n        this.asyncQueue.enqueueAndForget(() => {\n            if (this.timerHandle !== null) {\n                this.clearTimeout();\n                return this.op().then(result => {\n                    return this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    }\n}\n/**\n * Returns a FirestoreError that can be surfaced to the user if the provided\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\n */\nfunction wrapInUserErrorIfRecoverable(e, msg) {\n    logError(LOG_TAG$4, `${msg}: ${e}`);\n    if (isIndexedDbTransactionError(e)) {\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\n    }\n    else {\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nclass DocumentSet {\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    static emptySet(oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    }\n    /** The default ordering is by key if the comparator is omitted */\n    constructor(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n        }\n        else {\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    has(key) {\n        return this.keyedMap.get(key) != null;\n    }\n    get(key) {\n        return this.keyedMap.get(key);\n    }\n    first() {\n        return this.sortedSet.minKey();\n    }\n    last() {\n        return this.sortedSet.maxKey();\n    }\n    isEmpty() {\n        return this.sortedSet.isEmpty();\n    }\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    indexOf(key) {\n        const doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    }\n    get size() {\n        return this.sortedSet.size;\n    }\n    /** Iterates documents in order defined by \"comparator\" */\n    forEach(cb) {\n        this.sortedSet.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Inserts or updates a document with the same key */\n    add(doc) {\n        // First remove the element if we have it.\n        const set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    }\n    /** Deletes a document with a given key */\n    delete(key) {\n        const doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    }\n    isEqual(other) {\n        if (!(other instanceof DocumentSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.sortedSet.getIterator();\n        const otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            const thisDoc = thisIt.getNext().key;\n            const otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        const docStrings = [];\n        this.forEach(doc => {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    }\n    copy(keyedMap, sortedSet) {\n        const newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nclass DocumentChangeSet {\n    constructor() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    track(change) {\n        const key = change.doc.key;\n        const oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== 0 /* ChangeType.Added */ &&\n            oldChange.type === 3 /* ChangeType.Metadata */) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\n            oldChange.type !== 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 0 /* ChangeType.Added */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 1 /* ChangeType.Removed */,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === 0 /* ChangeType.Added */ &&\n            oldChange.type === 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail();\n        }\n    }\n    getChanges() {\n        const changes = [];\n        this.changeMap.inorderTraversal((key, change) => {\n            changes.push(change);\n        });\n        return changes;\n    }\n}\nclass ViewSnapshot {\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.mutatedKeys = mutatedKeys;\n        this.fromCache = fromCache;\n        this.syncStateChanged = syncStateChanged;\n        this.excludesMetadataChanges = excludesMetadataChanges;\n        this.hasCachedResults = hasCachedResults;\n    }\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\n        const changes = [];\n        documents.forEach(doc => {\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\n        });\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \n        /* syncStateChanged= */ true, \n        /* excludesMetadataChanges= */ false, hasCachedResults);\n    }\n    get hasPendingWrites() {\n        return !this.mutatedKeys.isEmpty();\n    }\n    isEqual(other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasCachedResults !== other.hasCachedResults ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\n            !queryEquals(this.query, other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        const changes = this.docChanges;\n        const otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (let i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n    constructor() {\n        this.viewSnap = undefined;\n        this.listeners = [];\n    }\n    // Helper methods that checks if the query has listeners that listening to remote store\n    hasRemoteListeners() {\n        return this.listeners.some(listener => listener.listensToRemoteStore());\n    }\n}\nfunction newEventManager() {\n    return new EventManagerImpl();\n}\nclass EventManagerImpl {\n    constructor() {\n        this.queries = newQueriesObjectMap();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.snapshotsInSyncListeners = new Set();\n    }\n    terminate() {\n        errorAllTargets(this, new FirestoreError(Code.ABORTED, 'Firestore shutting down'));\n    }\n}\nfunction newQueriesObjectMap() {\n    return new ObjectMap(q => canonifyQuery(q), queryEquals);\n}\nasync function eventManagerListen(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\n    const query = listener.query;\n    let queryInfo = eventManagerImpl.queries.get(query);\n    if (!queryInfo) {\n        queryInfo = new QueryListenersInfo();\n        listenerAction = listener.listensToRemoteStore()\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\n    }\n    else if (!queryInfo.hasRemoteListeners() &&\n        listener.listensToRemoteStore()) {\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\n    }\n    try {\n        switch (listenerAction) {\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ true);\n                break;\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ false);\n                break;\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\n                break;\n            default:\n                break;\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\n        listener.onError(firestoreError);\n        return;\n    }\n    eventManagerImpl.queries.set(query, queryInfo);\n    queryInfo.listeners.push(listener);\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\n    if (queryInfo.viewSnap) {\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\n        if (raisedEvent) {\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\n        }\n    }\n}\nasync function eventManagerUnlisten(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    const query = listener.query;\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        const i = queryInfo.listeners.indexOf(listener);\n        if (i >= 0) {\n            queryInfo.listeners.splice(i, 1);\n            if (queryInfo.listeners.length === 0) {\n                listenerAction = listener.listensToRemoteStore()\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\n            }\n            else if (!queryInfo.hasRemoteListeners() &&\n                listener.listensToRemoteStore()) {\n                // The removed listener is the last one that sourced from watch.\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\n            }\n        }\n    }\n    switch (listenerAction) {\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ true);\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ false);\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\n        default:\n            return;\n    }\n}\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\n    const eventManagerImpl = debugCast(eventManager);\n    let raisedEvent = false;\n    for (const viewSnap of viewSnaps) {\n        const query = viewSnap.query;\n        const queryInfo = eventManagerImpl.queries.get(query);\n        if (queryInfo) {\n            for (const listener of queryInfo.listeners) {\n                if (listener.onViewSnapshot(viewSnap)) {\n                    raisedEvent = true;\n                }\n            }\n            queryInfo.viewSnap = viewSnap;\n        }\n    }\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction eventManagerOnWatchError(eventManager, query, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    }\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    eventManagerImpl.queries.delete(query);\n}\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.onlineState = onlineState;\n    let raisedEvent = false;\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\n            if (listener.applyOnlineStateChange(onlineState)) {\n                raisedEvent = true;\n            }\n        }\n    });\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction addSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\n    // Immediately fire an initial event, indicating all existing listeners\n    // are in-sync.\n    observer.next();\n}\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\n}\nfunction errorAllTargets(eventManager, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queries = eventManagerImpl.queries;\n    // Prevent further access by clearing ObjectMap.\n    eventManagerImpl.queries = newQueriesObjectMap();\n    queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    });\n}\n// Call all global snapshot listeners that have been set.\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\n        observer.next();\n    });\n}\nvar ListenerDataSource;\n(function (ListenerDataSource) {\n    /** Listen to both cache and server changes */\n    ListenerDataSource[\"Default\"] = \"default\";\n    /** Listen to changes in cache only */\n    ListenerDataSource[\"Cache\"] = \"cache\";\n})(ListenerDataSource || (ListenerDataSource = {}));\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nclass QueryListener {\n    constructor(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.snap = null;\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.options = options || {};\n    }\n    /**\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\n     * if applicable (depending on what changed, whether the user has opted into\n     * metadata-only changes, etc.). Returns true if a user-facing event was\n     * indeed raised.\n     */\n    onViewSnapshot(snap) {\n        if (!this.options.includeMetadataChanges) {\n            // Remove the metadata only changes.\n            const docChanges = [];\n            for (const docChange of snap.docChanges) {\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\n        }\n        let raisedEvent = false;\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n                raisedEvent = true;\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n            raisedEvent = true;\n        }\n        this.snap = snap;\n        return raisedEvent;\n    }\n    onError(error) {\n        this.queryObserver.error(error);\n    }\n    /** Returns whether a snapshot was raised. */\n    applyOnlineStateChange(onlineState) {\n        this.onlineState = onlineState;\n        let raisedEvent = false;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n            raisedEvent = true;\n        }\n        return raisedEvent;\n    }\n    shouldRaiseInitialEvent(snap, onlineState) {\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // Always raise event if listening to cache\n        if (!this.listensToRemoteStore()) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            return false;\n        }\n        // Raise data from cache if we have any documents, have cached results before,\n        // or we are offline.\n        return (!snap.docs.isEmpty() ||\n            snap.hasCachedResults ||\n            onlineState === \"Offline\" /* OnlineState.Offline */);\n    }\n    shouldRaiseEvent(snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    }\n    raiseInitialEvent(snap) {\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    }\n    listensToRemoteStore() {\n        return this.options.source !== ListenerDataSource.Cache;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nclass LocalViewChanges {\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\n        this.targetId = targetId;\n        this.fromCache = fromCache;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    static fromSnapshot(targetId, viewSnapshot) {\n        let addedKeys = documentKeySet();\n        let removedKeys = documentKeySet();\n        for (const docChange of viewSnapshot.docChanges) {\n            switch (docChange.type) {\n                case 0 /* ChangeType.Added */:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                // do nothing\n            }\n        }\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper to convert objects from bundles to model objects in the SDK.\n */\nclass BundleConverterImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    toDocumentKey(name) {\n        return fromName(this.serializer, name);\n    }\n    /**\n     * Converts a BundleDocument to a MutableDocument.\n     */\n    toMutableDocument(bundledDoc) {\n        if (bundledDoc.metadata.exists) {\n            return fromDocument(this.serializer, bundledDoc.document, false);\n        }\n        else {\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\n        }\n    }\n    toSnapshotVersion(time) {\n        return fromVersion(time);\n    }\n}\n/**\n * A class to process the elements from a bundle, load them into local\n * storage and provide progress update while loading.\n */\nclass BundleLoader {\n    constructor(bundleMetadata, localStore, serializer) {\n        this.bundleMetadata = bundleMetadata;\n        this.localStore = localStore;\n        this.serializer = serializer;\n        /** Batched queries to be saved into storage */\n        this.queries = [];\n        /** Batched documents to be saved into storage */\n        this.documents = [];\n        /** The collection groups affected by this bundle. */\n        this.collectionGroups = new Set();\n        this.progress = bundleInitialProgress(bundleMetadata);\n    }\n    /**\n     * Adds an element from the bundle to the loader.\n     *\n     * Returns a new progress if adding the element leads to a new progress,\n     * otherwise returns null.\n     */\n    addSizedElement(element) {\n        this.progress.bytesLoaded += element.byteLength;\n        let documentsLoaded = this.progress.documentsLoaded;\n        if (element.payload.namedQuery) {\n            this.queries.push(element.payload.namedQuery);\n        }\n        else if (element.payload.documentMetadata) {\n            this.documents.push({ metadata: element.payload.documentMetadata });\n            if (!element.payload.documentMetadata.exists) {\n                ++documentsLoaded;\n            }\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\n            this.collectionGroups.add(path.get(path.length - 2));\n        }\n        else if (element.payload.document) {\n            this.documents[this.documents.length - 1].document =\n                element.payload.document;\n            ++documentsLoaded;\n        }\n        if (documentsLoaded !== this.progress.documentsLoaded) {\n            this.progress.documentsLoaded = documentsLoaded;\n            return Object.assign({}, this.progress);\n        }\n        return null;\n    }\n    getQueryDocumentMapping(documents) {\n        const queryDocumentMap = new Map();\n        const bundleConverter = new BundleConverterImpl(this.serializer);\n        for (const bundleDoc of documents) {\n            if (bundleDoc.metadata.queries) {\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n                for (const queryName of bundleDoc.metadata.queries) {\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\n                    queryDocumentMap.set(queryName, documentKeys);\n                }\n            }\n        }\n        return queryDocumentMap;\n    }\n    /**\n     * Update the progress to 'Success' and return the updated progress.\n     */\n    async complete() {\n        const changedDocs = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\n        for (const q of this.queries) {\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\n        }\n        this.progress.taskState = 'Success';\n        return {\n            progress: this.progress,\n            changedCollectionGroups: this.collectionGroups,\n            changedDocs\n        };\n    }\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\n * loading a bundle.\n */\nfunction bundleInitialProgress(metadata) {\n    return {\n        taskState: 'Running',\n        documentsLoaded: 0,\n        bytesLoaded: 0,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\n * has succeeded.\n */\nfunction bundleSuccessProgress(metadata) {\n    return {\n        taskState: 'Success',\n        documentsLoaded: metadata.totalDocuments,\n        bytesLoaded: metadata.totalBytes,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AddedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\nclass RemovedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nclass View {\n    constructor(query, \n    /** Documents included in the remote target */\n    _syncedDocuments) {\n        this.query = query;\n        this._syncedDocuments = _syncedDocuments;\n        this.syncState = null;\n        this.hasCachedResults = false;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.docComparator = newQueryComparator(query);\n        this.documentSet = new DocumentSet(this.docComparator);\n    }\n    /**\n     * The set of remote documents that the server has told us belongs to the target associated with\n     * this view.\n     */\n    get syncedDocuments() {\n        return this._syncedDocuments;\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges - The doc changes to apply to this view.\n     * @param previousChanges - If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @returns a new set of docs, changes, and refill flag.\n     */\n    computeDocChanges(docChanges, previousChanges) {\n        const changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        const oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        let newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        let newDocumentSet = oldDocumentSet;\n        let needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.first()\n            : null;\n        docChanges.inorderTraversal((key, entry) => {\n            const oldDoc = oldDocumentSet.get(key);\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\n            const oldDocHadPendingMutations = oldDoc\n                ? this.mutatedKeys.has(oldDoc.key)\n                : false;\n            const newDocHasPendingMutations = newDoc\n                ? newDoc.hasLocalMutations ||\n                    // We only consider committed mutations for documents that were\n                    // mutated during the lifetime of the view.\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\n                : false;\n            let changeApplied = false;\n            // Calculate change\n            if (oldDoc && newDoc) {\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual) {\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\n                        changeSet.track({\n                            type: 2 /* ChangeType.Modified */,\n                            doc: newDoc\n                        });\n                        changeApplied = true;\n                        if ((lastDocInLimit &&\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\n                            (firstDocInLimit &&\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\n                            // This doc moved from inside the limit to outside the limit.\n                            // That means there may be some other doc in the local cache\n                            // that should be included instead.\n                            needsRefill = true;\n                        }\n                    }\n                }\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\n                    changeApplied = true;\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\n                changeApplied = true;\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n                changeApplied = true;\n                if (lastDocInLimit || firstDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n            if (changeApplied) {\n                if (newDoc) {\n                    newDocumentSet = newDocumentSet.add(newDoc);\n                    if (newDocHasPendingMutations) {\n                        newMutatedKeys = newMutatedKeys.add(key);\n                    }\n                    else {\n                        newMutatedKeys = newMutatedKeys.delete(key);\n                    }\n                }\n                else {\n                    newDocumentSet = newDocumentSet.delete(key);\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n        });\n        // Drop documents out to meet limit/limitToLast requirement.\n        if (this.query.limit !== null) {\n            while (newDocumentSet.size > this.query.limit) {\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\n                    ? newDocumentSet.last()\n                    : newDocumentSet.first();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n            }\n        }\n        return {\n            documentSet: newDocumentSet,\n            changeSet,\n            needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    }\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\n        // We suppress the initial change event for documents that were modified as\n        // part of a write acknowledgment (e.g. when the value of a server transform\n        // is applied) as Watch will send us the same document again.\n        // By suppressing the event, we only raise two user visible events (one with\n        // `hasPendingWrites` and the final state of the document) instead of three\n        // (one with `hasPendingWrites`, the modified document with\n        // `hasPendingWrites` and the final state of the document).\n        return (oldDoc.hasLocalMutations &&\n            newDoc.hasCommittedMutations &&\n            !newDoc.hasLocalMutations);\n    }\n    /**\n     * Updates the view with the given ViewDocumentChanges and optionally updates\n     * limbo docs and sync state from the provided target change.\n     * @param docChanges - The set of changes to make to the view's docs.\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\n     *        this change.\n     * @param targetChange - A target change to apply for computing limbo docs and\n     *        sync state.\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\n     *        existence filter mismatch. If not explicitly specified, it is treated\n     *        equivalently to `false`.\n     * @returns A new ViewChange with the given docs, changes, and sync state.\n     */\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\n        const oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        const changes = docChanges.changeSet.getChanges();\n        changes.sort((c1, c2) => {\n            return (compareChangeType(c1.type, c2.type) ||\n                this.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        targetIsPendingReset = targetIsPendingReset !== null && targetIsPendingReset !== void 0 ? targetIsPendingReset : false;\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\n            ? this.updateLimboDocuments()\n            : [];\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\n        const syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges };\n        }\n        else {\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \n            /* excludesMetadataChanges= */ false, targetChange\n                ? targetChange.resumeToken.approximateByteSize() > 0\n                : false);\n            return {\n                snapshot: snap,\n                limboChanges\n            };\n        }\n    }\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    applyOnlineStateChange(onlineState) {\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            }, \n            /* limboResolutionEnabled= */ false);\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    }\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    shouldBeInLimbo(key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this._syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    }\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    applyTargetChange(targetChange) {\n        if (targetChange) {\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\n            targetChange.modifiedDocuments.forEach(key => {\n            });\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\n            this.current = targetChange.current;\n        }\n    }\n    updateLimboDocuments() {\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        const oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(doc => {\n            if (this.shouldBeInLimbo(doc.key)) {\n                this.limboDocuments = this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        const changes = [];\n        oldLimboDocuments.forEach(key => {\n            if (!this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(key => {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    }\n    /**\n     * Update the in-memory state of the current view with the state read from\n     * persistence.\n     *\n     * We update the query view whenever a client's primary status changes:\n     * - When a client transitions from primary to secondary, it can miss\n     *   LocalStorage updates and its query views may temporarily not be\n     *   synchronized with the state on disk.\n     * - For secondary to primary transitions, the client needs to update the list\n     *   of `syncedDocuments` since secondary clients update their query views\n     *   based purely on synthesized RemoteEvents.\n     *\n     * @param queryResult.documents - The documents that match the query according\n     * to the LocalStore.\n     * @param queryResult.remoteKeys - The keys of the documents that match the\n     * query according to the backend.\n     *\n     * @returns The ViewChange that resulted from this synchronization.\n     */\n    // PORTING NOTE: Multi-tab only.\n    synchronizeWithPersistedState(queryResult) {\n        this._syncedDocuments = queryResult.remoteKeys;\n        this.limboDocuments = documentKeySet();\n        const docChanges = this.computeDocChanges(queryResult.documents);\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\n    }\n    /**\n     * Returns a view snapshot as if this query was just listened to. Contains\n     * a document add for every existing document and the `fromCache` and\n     * `hasPendingWrites` status of the already established view.\n     */\n    // PORTING NOTE: Multi-tab only.\n    computeInitialSnapshot() {\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\n    }\n}\nfunction compareChangeType(c1, c2) {\n    const order = (change) => {\n        switch (change) {\n            case 0 /* ChangeType.Added */:\n                return 1;\n            case 2 /* ChangeType.Modified */:\n                return 2;\n            case 3 /* ChangeType.Metadata */:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case 1 /* ChangeType.Removed */:\n                return 0;\n            default:\n                return fail();\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$3 = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n    constructor(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.view = view;\n    }\n}\n/** Tracks a limbo resolution. */\nclass LimboResolution {\n    constructor(key) {\n        this.key = key;\n        /**\n         * Set to true once we've received a document. This is used in\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\n         * decide whether it needs to manufacture a delete event for the target once\n         * the target is CURRENT.\n         */\n        this.receivedDocument = false;\n    }\n}\n/**\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\n *\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\n * registered individually. This is done in `syncEngineWrite()` and\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\n * serve as entry points to RemoteStore's functionality.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass SyncEngineImpl {\n    constructor(localStore, remoteStore, eventManager, \n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.eventManager = eventManager;\n        this.sharedClientState = sharedClientState;\n        this.currentUser = currentUser;\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\n        this.syncEngineListener = {};\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\n        this.queriesByTarget = new Map();\n        /**\n         * The keys of documents that are in limbo for which we haven't yet started a\n         * limbo resolution query. The strings in this set are the result of calling\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\n         *\n         * The `Set` type was chosen because it provides efficient lookup and removal\n         * of arbitrary elements and it also maintains insertion order, providing the\n         * desired queue-like FIFO semantics.\n         */\n        this.enqueuedLimboResolutions = new Set();\n        /**\n         * Keeps track of the target ID for each document that is in limbo with an\n         * active target.\n         */\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        /**\n         * Keeps track of the information about an active limbo resolution for each\n         * active target ID that was started for the purpose of limbo resolution.\n         */\n        this.activeLimboResolutionsByTarget = new Map();\n        this.limboDocumentRefs = new ReferenceSet();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\n        this.pendingWritesCallbacks = new Map();\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        // The primary state is set to `true` or `false` immediately after Firestore\n        // startup. In the interim, a client should only be considered primary if\n        // `isPrimary` is true.\n        this._isPrimaryClient = undefined;\n    }\n    get isPrimaryClient() {\n        return this._isPrimaryClient === true;\n    }\n}\nfunction newSyncEngine(localStore, remoteStore, eventManager, \n// PORTING NOTE: Manages state synchronization in multi-tab environments.\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\n    if (isPrimary) {\n        syncEngine._isPrimaryClient = true;\n    }\n    return syncEngine;\n}\n/**\n * Initiates the new listen, resolves promise when listen enqueued to the\n * server. All the subsequent view snapshots or errors are sent to the\n * subscribed handlers. Returns the initial snapshot.\n */\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    let viewSnapshot;\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    if (queryView) {\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\n        // already exists when EventManager calls us for the first time. This\n        // happens when the primary tab is already listening to this query on\n        // behalf of another tab and the user of the primary also starts listening\n        // to the query. EventManager will not have an assigned target ID in this\n        // case and calls `listen` to obtain this ID.\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\n        viewSnapshot = queryView.view.computeInitialSnapshot();\n    }\n    else {\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \n        /** shouldInitializeView= */ true);\n    }\n    return viewSnapshot;\n}\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\nasync function triggerRemoteStoreListen(syncEngine, query) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \n    /** shouldListenToRemote= */ true, \n    /** shouldInitializeView= */ false);\n}\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\n    const targetId = targetData.targetId;\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\n    // not registering it in shared client state, and directly calculate initial snapshots and\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\n    // as active watch target.\n    const status = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId, \n    /* addToActiveTargetIds= */ shouldListenToRemote);\n    let viewSnapshot;\n    if (shouldInitializeView) {\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\n    }\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    return viewSnapshot;\n}\n/**\n * Registers a view for a previously unknown query and computes its initial\n * snapshot.\n */\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\n    // targets based on view changes. This allows us to only depend on Limbo\n    // changes when user code includes queries.\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \n    /* usePreviousResults= */ true);\n    const view = new View(query, queryResult.remoteKeys);\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\n    const viewChange = view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\n    const data = new QueryView(query, targetId, view);\n    syncEngineImpl.queryViewsByQuery.set(query, data);\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\n    }\n    else {\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\n    }\n    return viewChange.snapshot;\n}\n/** Stops listening to the query. */\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    // Only clean up the query view and target if this is the only query mapped\n    // to the target.\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (queries.length > 1) {\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        return;\n    }\n    // No other queries are mapped to the target, clean up the query and the target.\n    if (syncEngineImpl.isPrimaryClient) {\n        // We need to remove the local query target first to allow us to verify\n        // whether any other client is still interested in this target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\n        if (!targetRemainsActive) {\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n            /*keepPersistedTargetData=*/ false)\n                .then(() => {\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\n                if (shouldUnlistenToRemote) {\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n                }\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n            })\n                .catch(ignoreIfPrimaryLeaseLoss);\n        }\n    }\n    else {\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n        /*keepPersistedTargetData=*/ true);\n    }\n}\n/** Unlistens to the remote store while still listening to the cache. */\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\n        // watch target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n    }\n}\n/**\n * Initiates the write of local mutation batch which involves adding the\n * writes to the mutation queue, notifying the remote store about new\n * mutations and raising events for any changes this write caused.\n *\n * The promise returned by this call is resolved when the above steps\n * have completed, *not* when the write was acked by the backend. The\n * userCallback is resolved once the write was acked/rejected by the\n * backend (or failed locally for any other reason).\n */\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\n    try {\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    catch (e) {\n        // If we can't persist the mutation, we reject the user callback and\n        // don't send the mutation. The user can then retry the write.\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\n        userCallback.reject(error);\n    }\n}\n/**\n * Applies one remote event to the sync engine, notifying any views of the\n * changes, and releasing any pending mutation batches that would become\n * visible because of the snapshot version the remote event contains.\n */\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\n        // Update `receivedDocument` as appropriate for any limbo targets.\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n            if (limboResolution) {\n                // Since this is a limbo resolution lookup, it's for a single document\n                // and it could be added, modified, or removed, but not a combination.\n                hardAssert(targetChange.addedDocuments.size +\n                    targetChange.modifiedDocuments.size +\n                    targetChange.removedDocuments.size <=\n                    1);\n                if (targetChange.addedDocuments.size > 0) {\n                    limboResolution.receivedDocument = true;\n                }\n                else if (targetChange.modifiedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                }\n                else if (targetChange.removedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                    limboResolution.receivedDocument = false;\n                }\n                else {\n                    // This was probably just a CURRENT targetChange or similar.\n                }\n            }\n        });\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Applies an OnlineState change to the sync engine and notifies any views of\n * the change.\n */\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // If we are the secondary client, we explicitly ignore the remote store's\n    // online state (the local client may go offline, even though the primary\n    // tab remains online) and only apply the primary tab's online state from\n    // SharedClientState.\n    if ((syncEngineImpl.isPrimaryClient &&\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\n        (!syncEngineImpl.isPrimaryClient &&\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\n        const newViewSnapshots = [];\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\n        if (newViewSnapshots.length) {\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n        }\n        syncEngineImpl.onlineState = onlineState;\n        if (syncEngineImpl.isPrimaryClient) {\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\n        }\n    }\n}\n/**\n * Rejects the listen for the given targetID. This can be triggered by the\n * backend for any active target.\n *\n * @param syncEngine - The sync engine implementation.\n * @param targetId - The targetID corresponds to one previously initiated by the\n * user as part of TargetData passed to listen() on RemoteStore.\n * @param err - A description of the condition that has forced the rejection.\n * Nearly always this will be an indication that the user is no longer\n * authorized to see the data matching the target.\n */\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // PORTING NOTE: Multi-tab only.\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    const limboKey = limboResolution && limboResolution.key;\n    if (limboKey) {\n        // TODO(klimt): We really only should do the following on permission\n        // denied errors, but we don't have the cause code here.\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\n        // This is kind of a hack. Ideally, we would have a method in the local\n        // store to purge a document. However, it would be tricky to keep all of\n        // the local store's invariants with another method.\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\n        // TODO(b/217189216): This limbo document should ideally have a read time,\n        // so that it is picked up by any read-time based scans. The backend,\n        // however, does not send a read time for target removals.\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\n        const event = new RemoteEvent(SnapshotVersion.min(), \n        /* targetChanges= */ new Map(), \n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\n        // Since this query failed, we won't want to manually unlisten to it.\n        // We only remove it from bookkeeping after we successfully applied the\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\n        // this query when the RemoteStore restarts the Watch stream, which should\n        // re-trigger the target failure.\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n    else {\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const batchId = mutationBatchResult.batch.batchId;\n    try {\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        processUserCallback(syncEngineImpl, batchId, error);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Registers a user callback that resolves when all pending mutations at the moment of calling\n * are acknowledged .\n */\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\n    }\n    try {\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\n        if (highestBatchId === BATCHID_UNKNOWN) {\n            // Trigger the callback right away if there is no pending writes at the moment.\n            callback.resolve();\n            return;\n        }\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\n        callbacks.push(callback);\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\n        callback.reject(firestoreError);\n    }\n}\n/**\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\n * if there are any.\n */\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\n        callback.resolve();\n    });\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\n}\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\n        callbacks.forEach(callback => {\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\n        });\n    });\n    syncEngineImpl.pendingWritesCallbacks.clear();\n}\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    if (!newCallbacks) {\n        newCallbacks = new SortedMap(primitiveComparator);\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n        newCallbacks;\n}\n/**\n * Resolves or rejects the user callback for the given batch and then discards\n * it.\n */\nfunction processUserCallback(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n        const callback = newCallbacks.get(batchId);\n        if (callback) {\n            if (error) {\n                callback.reject(error);\n            }\n            else {\n                callback.resolve();\n            }\n            newCallbacks = newCallbacks.remove(batchId);\n        }\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n            newCallbacks;\n    }\n}\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        if (error) {\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\n        }\n    }\n    syncEngineImpl.queriesByTarget.delete(targetId);\n    if (syncEngineImpl.isPrimaryClient) {\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\n        limboKeys.forEach(limboKey => {\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboKey);\n            }\n        });\n    }\n}\nfunction removeLimboTarget(syncEngineImpl, key) {\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\n    // It's possible that the target already got removed because the query failed. In that case,\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\n    if (limboTargetId === null) {\n        // This target already got removed, because the query failed.\n        return;\n    }\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\n    syncEngineImpl.activeLimboTargetsByKey =\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\n}\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\n    for (const limboChange of limboChanges) {\n        if (limboChange instanceof AddedLimboDocument) {\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\n            trackLimboChange(syncEngineImpl, limboChange);\n        }\n        else if (limboChange instanceof RemovedLimboDocument) {\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboChange.key);\n            }\n        }\n        else {\n            fail();\n        }\n    }\n}\nfunction trackLimboChange(syncEngineImpl, limboChange) {\n    const key = limboChange.key;\n    const keyString = key.path.canonicalString();\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n}\n/**\n * Starts listens for documents in limbo that are enqueued for resolution,\n * subject to a maximum number of concurrent resolutions.\n *\n * Without bounding the number of concurrent resolutions, the server can fail\n * with \"resource exhausted\" errors which can lead to pathological client\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\n */\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\n        syncEngineImpl.activeLimboTargetsByKey.size <\n            syncEngineImpl.maxConcurrentLimboResolutions) {\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\n            .values()\n            .next().value;\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\n    }\n}\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const newSnaps = [];\n    const docChangesInAllViews = [];\n    const queriesProcessed = [];\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\n        // Return early since `onWatchChange()` might not have been assigned yet.\n        return;\n    }\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\n        queriesProcessed.push(syncEngineImpl\n            .applyDocChanges(queryView, changes, remoteEvent)\n            .then(viewSnapshot => {\n            var _a;\n            // If there are changes, or we are handling a global snapshot, notify\n            // secondary clients to update query state.\n            if (viewSnapshot || remoteEvent) {\n                if (syncEngineImpl.isPrimaryClient) {\n                    // Query state is set to `current` if:\n                    // - There is a view change and it is up-to-date, or,\n                    // - There is a global snapshot, the Target is current, and no changes to be resolved\n                    const isCurrent = viewSnapshot\n                        ? !viewSnapshot.fromCache\n                        : (_a = remoteEvent === null || remoteEvent === void 0 ? void 0 : remoteEvent.targetChanges.get(queryView.targetId)) === null || _a === void 0 ? void 0 : _a.current;\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, isCurrent ? 'current' : 'not-current');\n                }\n            }\n            // Update views if there are actual changes.\n            if (!!viewSnapshot) {\n                newSnaps.push(viewSnapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\n                docChangesInAllViews.push(docChanges);\n            }\n        }));\n    });\n    await Promise.all(queriesProcessed);\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\n}\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\n    if (viewDocChanges.needsRefill) {\n        // The query has a limit and some docs were removed, so we need\n        // to re-run the query against the local store to make sure we\n        // didn't lose any good docs that had been past the limit.\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n        /* usePreviousResults= */ false).then(({ documents }) => {\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\n        });\n    }\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\n    return viewChange.snapshot;\n}\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\n    if (userChanged) {\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\n        syncEngineImpl.currentUser = user;\n        // Fails tasks waiting for pending writes requested by previous user.\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\n        // TODO(b/114226417): Consider calling this only in the primary tab.\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\n    }\n}\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    if (limboResolution && limboResolution.receivedDocument) {\n        return documentKeySet().add(limboResolution.key);\n    }\n    else {\n        let keySet = documentKeySet();\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (!queries) {\n            return keySet;\n        }\n        for (const query of queries) {\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\n        }\n        return keySet;\n    }\n}\n/**\n * Reconcile the list of synced documents in an existing view with those\n * from persistence.\n */\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n    /* usePreviousResults= */ true);\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\n    if (syncEngineImpl.isPrimaryClient) {\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\n    }\n    return viewSnapshot;\n}\n/**\n * Retrieves newly changed documents from remote document cache and raises\n * snapshots if needed.\n */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\n}\n/** Applies a mutation state to an existing batch.  */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\n    if (documents === null) {\n        // A throttled tab may not have seen the mutation before it was completed\n        // and removed from the mutation queue, in which case we won't have cached\n        // the affected documents. In this case we can safely ignore the update\n        // since that means we didn't apply the mutation locally at all (if we\n        // had, we would have cached the affected documents), and so we will just\n        // see any resulting document changes via normal remote document updates\n        // as applicable.\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\n        return;\n    }\n    if (batchState === 'pending') {\n        // If we are the primary client, we need to send this write to the\n        // backend. Secondary clients will ignore these writes since their remote\n        // connection is disabled.\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\n        // NOTE: Both these methods are no-ops for batches that originated from\n        // other clients.\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\n    }\n    else {\n        fail();\n    }\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    ensureWatchCallbacks(syncEngineImpl);\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\n        // Secondary tabs only maintain Views for their local listeners and the\n        // Views internal state may not be 100% populated (in particular\n        // secondary tabs don't track syncedDocuments, the set of documents the\n        // server considers to be in the target). So when a secondary becomes\n        // primary, we need to need to make sure that all views for all targets\n        // match the state on disk.\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\n        syncEngineImpl._isPrimaryClient = true;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\n        for (const targetData of activeQueries) {\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n        }\n    }\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\n        const activeTargets = [];\n        let p = Promise.resolve();\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\n                activeTargets.push(targetId);\n            }\n            else {\n                p = p.then(() => {\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                    /*keepPersistedTargetData=*/ true);\n                });\n            }\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n        });\n        await p;\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\n        resetLimboDocuments(syncEngineImpl);\n        syncEngineImpl._isPrimaryClient = false;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\n    }\n}\n// PORTING NOTE: Multi-Tab only.\nfunction resetLimboDocuments(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n    });\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n}\n/**\n * Reconcile the query views of the provided query targets with the state from\n * persistence. Raises snapshots for any changes that affect the local\n * client and returns the updated state of all target's query data.\n *\n * @param syncEngine - The sync engine implementation\n * @param targets - the list of targets with views that need to be recomputed\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\n * tab to a primary tab\n */\n// PORTING NOTE: Multi-Tab only.\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const activeQueries = [];\n    const newViewSnapshots = [];\n    for (const targetId of targets) {\n        let targetData;\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (queries && queries.length !== 0) {\n            // For queries that have a local View, we fetch their current state\n            // from LocalStore (as the resume token and the snapshot version\n            // might have changed) and reconcile their views with the persisted\n            // state (the list of syncedDocuments may have gotten out of sync).\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\n            for (const query of queries) {\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\n                if (viewChange.snapshot) {\n                    newViewSnapshots.push(viewChange.snapshot);\n                }\n            }\n        }\n        else {\n            // For queries that never executed on this client, we need to\n            // allocate the target in LocalStore and initialize a new View.\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \n            /*current=*/ false, targetData.resumeToken);\n        }\n        activeQueries.push(targetData);\n    }\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n    return activeQueries;\n}\n/**\n * Creates a `Query` object from the specified `Target`. There is no way to\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\n * object.\n *\n * The synthesized result might be different from the original `Query`, but\n * since the synthesized `Query` should return the same results as the\n * original one (only the presentation of results might differ), the potential\n * difference will not cause issues.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction synthesizeTargetToQuery(target) {\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\n}\n/** Returns the IDs of the clients that are currently active. */\n// PORTING NOTE: Multi-Tab only.\nfunction syncEngineGetActiveClients(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (syncEngineImpl._isPrimaryClient) {\n        // If we receive a target state notification via WebStorage, we are\n        // either already secondary or another tab has taken the primary lease.\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\n        return;\n    }\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\n    if (query && query.length > 0) {\n        switch (state) {\n            case 'current':\n            case 'not-current': {\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\n                break;\n            }\n            case 'rejected': {\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                /* keepPersistedTargetData */ true);\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\n                break;\n            }\n            default:\n                fail();\n        }\n    }\n}\n/** Adds or removes Watch targets for queries from different tabs. */\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    if (!syncEngineImpl._isPrimaryClient) {\n        return;\n    }\n    for (const targetId of added) {\n        // A target is already listening to remote store if it is already registered to\n        // sharedClientState.\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\n        if (targetAlreadyListeningToRemoteStore) {\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\n            continue;\n        }\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \n        /*current=*/ false, targetData.resumeToken);\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    for (const targetId of removed) {\n        // Check that the target is still active since the target might have been\n        // removed if it has been rejected by the backend.\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\n            continue;\n        }\n        // Release queries that are still active.\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => {\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n            removeAndCleanupTarget(syncEngineImpl, targetId);\n        })\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nfunction ensureWatchCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\n        syncEngineRejectListen.bind(null, syncEngineImpl);\n    syncEngineImpl.syncEngineListener.onWatchChange =\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\n    syncEngineImpl.syncEngineListener.onWatchError =\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\n    return syncEngineImpl;\n}\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\n    return syncEngineImpl;\n}\n/**\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\n * the bundle finished loading.\n *\n * @param syncEngine - SyncEngine to use.\n * @param bundleReader - Bundle to load into the SDK.\n * @param task - LoadBundleTask used to update the loading progress to public API.\n */\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\n    });\n}\n/** Loads a bundle and returns the list of affected collection groups. */\nasync function loadBundleImpl(syncEngine, reader, task) {\n    try {\n        const metadata = await reader.getMetadata();\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\n        if (skip) {\n            await reader.close();\n            task._completeWith(bundleSuccessProgress(metadata));\n            return Promise.resolve(new Set());\n        }\n        task._updateProgress(bundleInitialProgress(metadata));\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\n        let element = await reader.nextElement();\n        while (element) {\n            ;\n            const progress = await loader.addSizedElement(element);\n            if (progress) {\n                task._updateProgress(progress);\n            }\n            element = await reader.nextElement();\n        }\n        const result = await loader.complete();\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \n        /* remoteEvent */ undefined);\n        // Save metadata, so loading the same bundle will skip.\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\n        task._completeWith(result.progress);\n        return Promise.resolve(result.changedCollectionGroups);\n    }\n    catch (e) {\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\n        task._failWith(e);\n        return Promise.resolve(new Set());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides all components needed for Firestore with in-memory persistence.\n * Uses EagerGC garbage collection.\n */\nclass MemoryOfflineComponentProvider {\n    constructor() {\n        this.kind = 'memory';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\n        this.sharedClientState = this.createSharedClientState(cfg);\n        this.persistence = this.createPersistence(cfg);\n        await this.persistence.start();\n        this.localStore = this.createLocalStore(cfg);\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        return null;\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        return null;\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createPersistence(cfg) {\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n    async terminate() {\n        var _a, _b;\n        (_a = this.gcScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n        (_b = this.indexBackfillerScheduler) === null || _b === void 0 ? void 0 : _b.stop();\n        this.sharedClientState.shutdown();\n        await this.persistence.shutdown();\n    }\n}\nMemoryOfflineComponentProvider.provider = {\n    build: () => new MemoryOfflineComponentProvider()\n};\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(cacheSizeBytes) {\n        super();\n        this.cacheSizeBytes = cacheSizeBytes;\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate);\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createPersistence(cfg) {\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\n    }\n}\n/**\n * Provides all components needed for Firestore with IndexedDB persistence.\n */\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\n        super();\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistent';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        await this.onlineComponentProvider.initialize(this, cfg);\n        // Enqueue writes from a previous session\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(() => {\n            if (this.gcScheduler && !this.gcScheduler.started) {\n                this.gcScheduler.start();\n            }\n            if (this.indexBackfillerScheduler &&\n                !this.indexBackfillerScheduler.started) {\n                this.indexBackfillerScheduler.start();\n            }\n            return Promise.resolve();\n        });\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\n    }\n    createPersistence(cfg) {\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n}\n/**\n * Provides all components needed for Firestore with multi-tab IndexedDB\n * persistence.\n *\n * In the legacy client, this provider is used to provide both multi-tab and\n * non-multi-tab persistence since we cannot tell at build time whether\n * `synchronizeTabs` will be enabled.\n */\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes) {\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.synchronizeTabs = true;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        const syncEngine = this.onlineComponentProvider.syncEngine;\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\n            this.sharedClientState.syncEngine = {\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\n            };\n            await this.sharedClientState.start();\n        }\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\n            if (this.gcScheduler) {\n                if (isPrimary && !this.gcScheduler.started) {\n                    this.gcScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.gcScheduler.stop();\n                }\n            }\n            if (this.indexBackfillerScheduler) {\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\n                    this.indexBackfillerScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.indexBackfillerScheduler.stop();\n                }\n            }\n        });\n    }\n    createSharedClientState(cfg) {\n        const window = getWindow();\n        if (!WebStorageSharedClientState.isAvailable(window)) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\n        }\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\n    }\n}\n/**\n * Initializes and wires the components that are needed to interface with the\n * network.\n */\nclass OnlineComponentProvider {\n    async initialize(offlineComponentProvider, cfg) {\n        if (this.localStore) {\n            // OnlineComponentProvider may get initialized multiple times if\n            // multi-tab persistence is used.\n            return;\n        }\n        this.localStore = offlineComponentProvider.localStore;\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\n        this.datastore = this.createDatastore(cfg);\n        this.remoteStore = this.createRemoteStore(cfg);\n        this.eventManager = this.createEventManager(cfg);\n        this.syncEngine = this.createSyncEngine(cfg, \n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\n        this.remoteStore.remoteSyncer.handleCredentialChange =\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\n    }\n    createEventManager(cfg) {\n        return newEventManager();\n    }\n    createDatastore(cfg) {\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\n        const connection = newConnection(cfg.databaseInfo);\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\n    }\n    createRemoteStore(cfg) {\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\n    }\n    createSyncEngine(cfg, startAsPrimary) {\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\n    }\n    async terminate() {\n        var _a, _b;\n        await remoteStoreShutdown(this.remoteStore);\n        (_a = this.datastore) === null || _a === void 0 ? void 0 : _a.terminate();\n        (_b = this.eventManager) === null || _b === void 0 ? void 0 : _b.terminate();\n    }\n}\nOnlineComponentProvider.provider = {\n    build: () => new OnlineComponentProvider()\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * How many bytes to read each time when `ReadableStreamReader.read()` is\n * called. Only applicable for byte streams that we control (e.g. those backed\n * by an UInt8Array).\n */\nconst DEFAULT_BYTES_PER_READ = 10240;\n/**\n * Builds a `ByteStreamReader` from a UInt8Array.\n * @param source - The data source to use.\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\n *        will read.\n */\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\n    let readFrom = 0;\n    // The TypeScript definition for ReadableStreamReader changed. We use\n    // `any` here to allow this code to compile with different versions.\n    // See https://github.com/microsoft/TypeScript/issues/42970\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const reader = {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        async read() {\n            if (readFrom < source.byteLength) {\n                const result = {\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\n                    done: false\n                };\n                readFrom += bytesPerRead;\n                return result;\n            }\n            return { done: true };\n        },\n        async cancel() { },\n        releaseLock() { },\n        closed: Promise.resolve()\n    };\n    return reader;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\n    if (!argument) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\n    }\n}\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\n    if (argument1 === true && argument2 === true) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\n    }\n}\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nfunction validateDocumentPath(path) {\n    if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nfunction validateCollectionPath(path) {\n    if (DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null));\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = `${input.substring(0, 20)}...`;\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            const customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return `a custom ${customObjectName} object`;\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail();\n    }\n}\n/** try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        return input.constructor.name;\n    }\n    return null;\n}\n/**\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n * underlying instance. Throws if  `obj` is not an instance of `T`.\n *\n * This cast is used in the Lite and Full SDK to verify instance types for\n * arguments passed to the public API.\n * @internal\n */\nfunction cast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    if ('_delegate' in obj) {\n        // Unwrap Compat types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj = obj._delegate;\n    }\n    if (!(obj instanceof constructor)) {\n        if (constructor.name === obj.constructor.name) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\n                `reference from a different Firestore SDK?`);\n        }\n        else {\n            const description = valueDescription(obj);\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\n        }\n    }\n    return obj;\n}\nfunction validatePositiveNumber(functionName, n) {\n    if (n <= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * On Node, only supported data source is a `Uint8Array` for now.\n */\nfunction toByteStreamReader(source, bytesPerRead) {\n    if (!(source instanceof Uint8Array)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\n    }\n    return toByteStreamReaderHelper(source, bytesPerRead);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nclass AsyncObserver {\n    constructor(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    next(value) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.next) {\n            this.scheduleEvent(this.observer.next, value);\n        }\n    }\n    error(error) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.error) {\n            this.scheduleEvent(this.observer.error, error);\n        }\n        else {\n            logError('Uncaught Error in snapshot listener:', error.toString());\n        }\n    }\n    mute() {\n        this.muted = true;\n    }\n    scheduleEvent(eventHandler, event) {\n        setTimeout(() => {\n            if (!this.muted) {\n                eventHandler(event);\n            }\n        }, 0);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A complete element in the bundle stream, together with the byte length it\n * occupies in the stream.\n */\nclass SizedBundleElement {\n    constructor(payload, \n    // How many bytes this element takes to store in the bundle.\n    byteLength) {\n        this.payload = payload;\n        this.byteLength = byteLength;\n    }\n    isBundleMetadata() {\n        return 'metadata' in this.payload;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A class representing a bundle.\n *\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\n * elements out of the underlying content.\n */\nclass BundleReaderImpl {\n    constructor(\n    /** The reader to read from underlying binary bundle data source. */\n    reader, serializer) {\n        this.reader = reader;\n        this.serializer = serializer;\n        /** Cached bundle metadata. */\n        this.metadata = new Deferred();\n        /**\n         * Internal buffer to hold bundle content, accumulating incomplete element\n         * content.\n         */\n        this.buffer = new Uint8Array();\n        this.textDecoder = newTextDecoder();\n        // Read the metadata (which is the first element).\n        this.nextElementImpl().then(element => {\n            if (element && element.isBundleMetadata()) {\n                this.metadata.resolve(element.payload.metadata);\n            }\n            else {\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\n            }\n        }, error => this.metadata.reject(error));\n    }\n    close() {\n        return this.reader.cancel();\n    }\n    async getMetadata() {\n        return this.metadata.promise;\n    }\n    async nextElement() {\n        // Makes sure metadata is read before proceeding.\n        await this.getMetadata();\n        return this.nextElementImpl();\n    }\n    /**\n     * Reads from the head of internal buffer, and pulling more data from\n     * underlying stream if a complete element cannot be found, until an\n     * element(including the prefixed length and the JSON string) is found.\n     *\n     * Once a complete element is read, it is dropped from internal buffer.\n     *\n     * Returns either the bundled element, or null if we have reached the end of\n     * the stream.\n     */\n    async nextElementImpl() {\n        const lengthBuffer = await this.readLength();\n        if (lengthBuffer === null) {\n            return null;\n        }\n        const lengthString = this.textDecoder.decode(lengthBuffer);\n        const length = Number(lengthString);\n        if (isNaN(length)) {\n            this.raiseError(`length string (${lengthString}) is not valid number`);\n        }\n        const jsonString = await this.readJsonString(length);\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\n    }\n    /** First index of '{' from the underlying buffer. */\n    indexOfOpenBracket() {\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\n    }\n    /**\n     * Reads from the beginning of the internal buffer, until the first '{', and\n     * return the content.\n     *\n     * If reached end of the stream, returns a null.\n     */\n    async readLength() {\n        while (this.indexOfOpenBracket() < 0) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                break;\n            }\n        }\n        // Broke out of the loop because underlying stream is closed, and there\n        // happens to be no more data to process.\n        if (this.buffer.length === 0) {\n            return null;\n        }\n        const position = this.indexOfOpenBracket();\n        // Broke out of the loop because underlying stream is closed, but still\n        // cannot find an open bracket.\n        if (position < 0) {\n            this.raiseError('Reached the end of bundle when a length string is expected.');\n        }\n        const result = this.buffer.slice(0, position);\n        // Update the internal buffer to drop the read length.\n        this.buffer = this.buffer.slice(position);\n        return result;\n    }\n    /**\n     * Reads from a specified position from the internal buffer, for a specified\n     * number of bytes, pulling more data from the underlying stream if needed.\n     *\n     * Returns a string decoded from the read bytes.\n     */\n    async readJsonString(length) {\n        while (this.buffer.length < length) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                this.raiseError('Reached the end of bundle when more is expected.');\n            }\n        }\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\n        // Update the internal buffer to drop the read json string.\n        this.buffer = this.buffer.slice(length);\n        return result;\n    }\n    raiseError(message) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.reader.cancel();\n        throw new Error(`Invalid bundle format: ${message}`);\n    }\n    /**\n     * Pulls more data from underlying stream to internal buffer.\n     * Returns a boolean indicating whether the stream is finished.\n     */\n    async pullMoreDataToBuffer() {\n        const result = await this.reader.read();\n        if (!result.done) {\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\n            newBuffer.set(this.buffer);\n            newBuffer.set(result.value, this.buffer.length);\n            this.buffer = newBuffer;\n        }\n        return result.done;\n    }\n}\nfunction newBundleReader(reader, serializer) {\n    return new BundleReaderImpl(reader, serializer);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nclass Transaction$2 {\n    constructor(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = new Map();\n        this.mutations = [];\n        this.committed = false;\n        /**\n         * A deferred usage error that occurred previously in this transaction that\n         * will cause the transaction to fail once it actually commits.\n         */\n        this.lastTransactionError = null;\n        /**\n         * Set of documents that have been written in the transaction.\n         *\n         * When there's more than one write to the same key in a transaction, any\n         * writes after the first are handled differently.\n         */\n        this.writtenDocs = new Set();\n    }\n    async lookup(keys) {\n        this.ensureCommitNotCalled();\n        if (this.mutations.length > 0) {\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\n            throw this.lastTransactionError;\n        }\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n        docs.forEach(doc => this.recordVersion(doc));\n        return docs;\n    }\n    set(key, data) {\n        this.write(data.toMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    update(key, data) {\n        try {\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\n        }\n        catch (e) {\n            this.lastTransactionError = e;\n        }\n        this.writtenDocs.add(key.toString());\n    }\n    delete(key) {\n        this.write(new DeleteMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    async commit() {\n        this.ensureCommitNotCalled();\n        if (this.lastTransactionError) {\n            throw this.lastTransactionError;\n        }\n        const unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(mutation => {\n            unwritten.delete(mutation.key.toString());\n        });\n        // For each document that was read but not written to, we want to perform\n        // a `verify` operation.\n        unwritten.forEach((_, path) => {\n            const key = DocumentKey.fromPath(path);\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n        });\n        await invokeCommitRpc(this.datastore, this.mutations);\n        this.committed = true;\n    }\n    recordVersion(doc) {\n        let docVersion;\n        if (doc.isFoundDocument()) {\n            docVersion = doc.version;\n        }\n        else if (doc.isNoDocument()) {\n            // Represent a deleted doc using SnapshotVersion.min().\n            docVersion = SnapshotVersion.min();\n        }\n        else {\n            throw fail();\n        }\n        const existingVersion = this.readVersions.get(doc.key.toString());\n        if (existingVersion) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions.set(doc.key.toString(), docVersion);\n        }\n    }\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    precondition(key) {\n        const version = this.readVersions.get(key.toString());\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                return Precondition.exists(false);\n            }\n            else {\n                return Precondition.updateTime(version);\n            }\n        }\n        else {\n            return Precondition.none();\n        }\n    }\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    preconditionForUpdate(key) {\n        const version = this.readVersions.get(key.toString());\n        // The first time a document is written, we want to take into account the\n        // read time and existence\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                // The document doesn't exist, so fail the transaction.\n                // This has to be validated locally because you can't send a\n                // precondition that a document does not exist without changing the\n                // semantics of the backend write to be an insert. This is the reverse\n                // of what we want, since we want to assert that the document doesn't\n                // exist but then send the update and have it fail. Since we can't\n                // express that to the backend, we have to validate locally.\n                // Note: this can change once we can send separate verify writes in the\n                // transaction.\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n            }\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    }\n    write(mutation) {\n        this.ensureCommitNotCalled();\n        this.mutations.push(mutation);\n    }\n    ensureCommitNotCalled() {\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nclass TransactionRunner {\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\n        this.asyncQueue = asyncQueue;\n        this.datastore = datastore;\n        this.options = options;\n        this.updateFunction = updateFunction;\n        this.deferred = deferred;\n        this.attemptsRemaining = options.maxAttempts;\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\n    }\n    /** Runs the transaction and sets the result on deferred. */\n    run() {\n        this.attemptsRemaining -= 1;\n        this.runWithBackOff();\n    }\n    runWithBackOff() {\n        this.backoff.backoffAndRun(async () => {\n            const transaction = new Transaction$2(this.datastore);\n            const userPromise = this.tryRunUpdateFunction(transaction);\n            if (userPromise) {\n                userPromise\n                    .then(result => {\n                    this.asyncQueue.enqueueAndForget(() => {\n                        return transaction\n                            .commit()\n                            .then(() => {\n                            this.deferred.resolve(result);\n                        })\n                            .catch(commitError => {\n                            this.handleTransactionError(commitError);\n                        });\n                    });\n                })\n                    .catch(userPromiseError => {\n                    this.handleTransactionError(userPromiseError);\n                });\n            }\n        });\n    }\n    tryRunUpdateFunction(transaction) {\n        try {\n            const userPromise = this.updateFunction(transaction);\n            if (isNullOrUndefined(userPromise) ||\n                !userPromise.catch ||\n                !userPromise.then) {\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\n                return null;\n            }\n            return userPromise;\n        }\n        catch (error) {\n            // Do not retry errors thrown by user provided updateFunction.\n            this.deferred.reject(error);\n            return null;\n        }\n    }\n    handleTransactionError(error) {\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\n            this.attemptsRemaining -= 1;\n            this.asyncQueue.enqueueAndForget(() => {\n                this.runWithBackOff();\n                return Promise.resolve();\n            });\n        }\n        else {\n            this.deferred.reject(error);\n        }\n    }\n    isRetryableTransactionError(error) {\n        if (error.name === 'FirebaseError') {\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n            // non-matching document versions with ABORTED. These errors should be retried.\n            const code = error.code;\n            return (code === 'aborted' ||\n                code === 'failed-precondition' ||\n                code === 'already-exists' ||\n                !isPermanentError(code));\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$2 = 'FirestoreClient';\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\n/** DOMException error code constants. */\nconst DOM_EXCEPTION_INVALID_STATE = 11;\nconst DOM_EXCEPTION_ABORTED = 20;\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the //\n * pieces of the client SDK architecture. It is responsible for creating the //\n * async queue that is shared by all of the other components in the system. //\n */\nclass FirestoreClient {\n    constructor(authCredentials, appCheckCredentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue, databaseInfo, componentProvider) {\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.asyncQueue = asyncQueue;\n        this.databaseInfo = databaseInfo;\n        this.user = User.UNAUTHENTICATED;\n        this.clientId = AutoId.newId();\n        this.authCredentialListener = () => Promise.resolve();\n        this.appCheckCredentialListener = () => Promise.resolve();\n        this._uninitializedComponentsProvider = componentProvider;\n        this.authCredentials.start(asyncQueue, async (user) => {\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\n            await this.authCredentialListener(user);\n            this.user = user;\n        });\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\n        });\n    }\n    get configuration() {\n        return {\n            asyncQueue: this.asyncQueue,\n            databaseInfo: this.databaseInfo,\n            clientId: this.clientId,\n            authCredentials: this.authCredentials,\n            appCheckCredentials: this.appCheckCredentials,\n            initialUser: this.user,\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\n        };\n    }\n    setCredentialChangeListener(listener) {\n        this.authCredentialListener = listener;\n    }\n    setAppCheckTokenChangeListener(listener) {\n        this.appCheckCredentialListener = listener;\n    }\n    terminate() {\n        this.asyncQueue.enterRestrictedMode();\n        const deferred = new Deferred();\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\n            try {\n                if (this._onlineComponents) {\n                    await this._onlineComponents.terminate();\n                }\n                if (this._offlineComponents) {\n                    await this._offlineComponents.terminate();\n                }\n                // The credentials provider must be terminated after shutting down the\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\n                // tokens.\n                this.authCredentials.shutdown();\n                this.appCheckCredentials.shutdown();\n                deferred.resolve();\n            }\n            catch (e) {\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\n                deferred.reject(firestoreError);\n            }\n        });\n        return deferred.promise;\n    }\n}\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\n    const configuration = client.configuration;\n    await offlineComponentProvider.initialize(configuration);\n    let currentUser = configuration.initialUser;\n    client.setCredentialChangeListener(async (user) => {\n        if (!currentUser.isEqual(user)) {\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\n            currentUser = user;\n        }\n    });\n    // When a user calls clearPersistence() in one client, all other clients\n    // need to be terminated to allow the delete to succeed.\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\n    client._offlineComponents = offlineComponentProvider;\n}\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    const offlineComponents = await ensureOfflineComponents(client);\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\n    await onlineComponentProvider.initialize(offlineComponents, client.configuration);\n    // The CredentialChangeListener of the online component provider takes\n    // precedence over the offline component provider.\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client._onlineComponents = onlineComponentProvider;\n}\n/**\n * Decides whether the provided error allows us to gracefully disable\n * persistence (as opposed to crashing the client).\n */\nfunction canFallbackFromIndexedDbError(error) {\n    if (error.name === 'FirebaseError') {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    }\n    else if (typeof DOMException !== 'undefined' &&\n        error instanceof DOMException) {\n        // There are a few known circumstances where we can open IndexedDb but\n        // trying to read/write will fail (e.g. quota exceeded). For\n        // well-understood cases, we attempt to detect these and then gracefully\n        // fall back to memory persistence.\n        // NOTE: Rather than continue to add to this list, we could decide to\n        // always fall back, with the risk that we might accidentally hide errors\n        // representing actual SDK bugs.\n        return (\n        // When the browser is out of quota we could get either quota exceeded\n        // or an aborted error depending on whether the error happened during\n        // schema migration.\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\n            error.code === DOM_EXCEPTION_ABORTED ||\n            // Firefox Private Browsing mode disables IndexedDb and returns\n            // INVALID_STATE for any usage.\n            error.code === DOM_EXCEPTION_INVALID_STATE);\n    }\n    return true;\n}\nasync function ensureOfflineComponents(client) {\n    if (!client._offlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\n            try {\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\n            }\n            catch (e) {\n                const error = e;\n                if (!canFallbackFromIndexedDbError(error)) {\n                    throw error;\n                }\n                logWarn('Error using user provided cache. Falling back to ' +\n                    'memory cache: ' +\n                    error);\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\n            }\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\n            await setOfflineComponentProvider(client, new LruGcMemoryOfflineComponentProvider(undefined));\n        }\n    }\n    return client._offlineComponents;\n}\nasync function ensureOnlineComponents(client) {\n    if (!client._onlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\n        }\n    }\n    return client._onlineComponents;\n}\nfunction getPersistence(client) {\n    return ensureOfflineComponents(client).then(c => c.persistence);\n}\nfunction getLocalStore(client) {\n    return ensureOfflineComponents(client).then(c => c.localStore);\n}\nfunction getRemoteStore(client) {\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\n}\nfunction getSyncEngine(client) {\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\n}\nfunction getDatastore(client) {\n    return ensureOnlineComponents(client).then(c => c.datastore);\n}\nasync function getEventManager(client) {\n    const onlineComponentProvider = await ensureOnlineComponents(client);\n    const eventManager = onlineComponentProvider.eventManager;\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    return eventManager;\n}\n/** Enables the network connection and re-enqueues all pending operations. */\nfunction firestoreClientEnableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(true);\n        return remoteStoreEnableNetwork(remoteStore);\n    });\n}\n/** Disables the network connection. Pending operations will not complete. */\nfunction firestoreClientDisableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(false);\n        return remoteStoreDisableNetwork(remoteStore);\n    });\n}\n/**\n * Returns a Promise that resolves when all writes that were pending at the time\n * this method was called received server acknowledgement. An acknowledgement\n * can be either acceptance or rejection.\n */\nfunction firestoreClientWaitForPendingWrites(client) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientListen(client, query, options, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    const listener = new QueryListener(query, wrappedObserver, options);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return eventManagerListen(eventManager, listener);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return eventManagerUnlisten(eventManager, listener);\n        });\n    };\n}\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return readDocumentFromCache(localStore, docKey, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return executeQueryFromCache(localStore, query, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\n        // above\n        try {\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\n            const datastore = await getDatastore(client);\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\nfunction firestoreClientWrite(client, mutations) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineWrite(syncEngine, mutations, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\n        });\n    };\n}\n/**\n * Takes an updateFunction in which a set of reads and writes can be performed\n * atomically. In the updateFunction, the client can read and write values\n * using the supplied transaction object. After the updateFunction, all\n * changes will be committed. If a retryable error occurs (ex: some other\n * client has changed any of the data referenced), then the updateFunction\n * will be called again after a backoff. If the updateFunction still fails\n * after all retries, then the transaction will be rejected.\n *\n * The transaction object passed to the updateFunction contains methods for\n * accessing documents and collections. Unlike other datastore access, data\n * accessed with the transaction will not reflect local changes that have not\n * been committed. For this reason, it is required that all reads are\n * performed before any writes. Transactions must be performed while online.\n */\nfunction firestoreClientTransaction(client, updateFunction, options) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const datastore = await getDatastore(client);\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\n    });\n    return deferred.promise;\n}\nasync function readDocumentFromCache(localStore, docKey, result) {\n    try {\n        const document = await localStoreReadDocument(localStore, docKey);\n        if (document.isFoundDocument()) {\n            result.resolve(document);\n        }\n        else if (document.isNoDocument()) {\n            result.resolve(null);\n        }\n        else {\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\n                \"exist on the server. Run again without setting 'source' in \" +\n                'the GetOptions to attempt to retrieve the document from the ' +\n                'server.)'));\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated document from the backend via a\n * SnapshotListener.\n */\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: (snap) => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            const exists = snap.docs.has(key);\n            if (!exists && snap.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\n            }\n            else if (exists &&\n                snap.fromCache &&\n                options &&\n                options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\n                    'document does exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached document.)'));\n            }\n            else {\n                result.resolve(snap);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nasync function executeQueryFromCache(localStore, query, result) {\n    try {\n        const queryResult = await localStoreExecuteQuery(localStore, query, \n        /* usePreviousResults= */ true);\n        const view = new View(query, queryResult.remoteKeys);\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\n        const viewChange = view.applyChanges(viewDocChanges, \n        /* limboResolutionEnabled= */ false);\n        result.resolve(viewChange.snapshot);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated query snapshot from the backend via a\n * SnapshotListener.\n */\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: snapshot => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            if (snapshot.fromCache && options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\n                    'documents may exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached documents.)'));\n            }\n            else {\n                result.resolve(snapshot);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(query, wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\n    const reader = createBundleReader(data, newSerializer(databaseId));\n    client.asyncQueue.enqueueAndForget(async () => {\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\n    });\n}\nfunction firestoreClientGetNamedQuery(client, queryName) {\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\n}\nfunction createBundleReader(data, serializer) {\n    let content;\n    if (typeof data === 'string') {\n        content = newTextEncoder().encode(data);\n    }\n    else {\n        content = data;\n    }\n    return newBundleReader(toByteStreamReader(content), serializer);\n}\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\n    });\n}\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\n    });\n}\nfunction firestoreClientDeleteAllFieldIndexes(client) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\n    });\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\n */\nfunction longPollingOptionsEqual(options1, options2) {\n    return options1.timeoutSeconds === options2.timeoutSeconds;\n}\n/**\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\n * option values as the given instance.\n */\nfunction cloneLongPollingOptions(options) {\n    const clone = {};\n    if (options.timeoutSeconds !== undefined) {\n        clone.timeoutSeconds = options.timeoutSeconds;\n    }\n    return clone;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$1 = 'ComponentProvider';\n/**\n * An instance map that ensures only one Datastore exists per Firestore\n * instance.\n */\nconst datastoreInstances = new Map();\n/**\n * Removes all components associated with the provided instance. Must be called\n * when the `Firestore` instance is terminated.\n */\nfunction removeComponents(firestore) {\n    const datastore = datastoreInstances.get(firestore);\n    if (datastore) {\n        logDebug(LOG_TAG$1, 'Removing Datastore');\n        datastoreInstances.delete(firestore);\n        datastore.terminate();\n    }\n}\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// settings() defaults:\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n// The minimum long-polling timeout is hardcoded on the server. The value here\n// should be kept in sync with the value used by the server, as the server will\n// silently ignore a value below the minimum and fall back to the default.\n// Googlers see b/266868871 for relevant discussion.\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\n// No maximum long-polling timeout is configured in the server, and defaults to\n// 30 seconds, which is what Watch appears to use.\n// Googlers see b/266868871 for relevant discussion.\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\n// Whether long-polling auto-detected is enabled by default.\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied `FirestoreSettings` object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettingsImpl {\n    constructor(settings) {\n        var _a, _b;\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            this.host = settings.host;\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\n        }\n        this.credentials = settings.credentials;\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\n        this.localCache = settings.localCache;\n        if (settings.cacheSizeBytes === undefined) {\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\n        }\n        else {\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n            }\n            else {\n                this.cacheSizeBytes = settings.cacheSizeBytes;\n            }\n        }\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\n        if (this.experimentalForceLongPolling) {\n            this.experimentalAutoDetectLongPolling = false;\n        }\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\n        }\n        else {\n            // For backwards compatibility, coerce the value to boolean even though\n            // the TypeScript compiler has narrowed the type to boolean already.\n            // noinspection PointlessBooleanExpressionJS\n            this.experimentalAutoDetectLongPolling =\n                !!settings.experimentalAutoDetectLongPolling;\n        }\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\n        this.useFetchStreams = !!settings.useFetchStreams;\n    }\n    isEqual(other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials &&\n            this.cacheSizeBytes === other.cacheSizeBytes &&\n            this.experimentalForceLongPolling ===\n                other.experimentalForceLongPolling &&\n            this.experimentalAutoDetectLongPolling ===\n                other.experimentalAutoDetectLongPolling &&\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\n            this.useFetchStreams === other.useFetchStreams);\n    }\n}\nfunction validateLongPollingOptions(options) {\n    if (options.timeoutSeconds !== undefined) {\n        if (isNaN(options.timeoutSeconds)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\n                `${options.timeoutSeconds} (must not be NaN)`);\n        }\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore$1 {\n    /** @hideconstructor */\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\n        this._authCredentials = _authCredentials;\n        this._appCheckCredentials = _appCheckCredentials;\n        this._databaseId = _databaseId;\n        this._app = _app;\n        /**\n         * Whether it's a Firestore or Firestore Lite instance.\n         */\n        this.type = 'firestore-lite';\n        this._persistenceKey = '(lite)';\n        this._settings = new FirestoreSettingsImpl({});\n        this._settingsFrozen = false;\n        // A task that is assigned when the terminate() is invoked and resolved when\n        // all components have shut down. Otherwise, Firestore is not terminated,\n        // which can mean either the FirestoreClient is in the process of starting,\n        // or restarting.\n        this._terminateTask = 'notTerminated';\n    }\n    /**\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\n     * instance.\n     */\n    get app() {\n        if (!this._app) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                'not available');\n        }\n        return this._app;\n    }\n    get _initialized() {\n        return this._settingsFrozen;\n    }\n    get _terminated() {\n        return this._terminateTask !== 'notTerminated';\n    }\n    _setSettings(settings) {\n        if (this._settingsFrozen) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only modify settings before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._settings = new FirestoreSettingsImpl(settings);\n        if (settings.credentials !== undefined) {\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\n        }\n    }\n    _getSettings() {\n        return this._settings;\n    }\n    _freezeSettings() {\n        this._settingsFrozen = true;\n        return this._settings;\n    }\n    _delete() {\n        // The `_terminateTask` must be assigned future that completes when\n        // terminate is complete. The existence of this future puts SDK in state\n        // that will not accept further API interaction.\n        if (this._terminateTask === 'notTerminated') {\n            this._terminateTask = this._terminate();\n        }\n        return this._terminateTask;\n    }\n    async _restart() {\n        // The `_terminateTask` must equal 'notTerminated' after restart to\n        // signal that client is in a state that accepts API calls.\n        if (this._terminateTask === 'notTerminated') {\n            await this._terminate();\n        }\n        else {\n            this._terminateTask = 'notTerminated';\n        }\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\n    toJSON() {\n        return {\n            app: this._app,\n            databaseId: this._databaseId,\n            settings: this._settings\n        };\n    }\n    /**\n     * Terminates all components used by this client. Subclasses can override\n     * this method to clean up their own dependencies, but must also call this\n     * method.\n     *\n     * Only ever called once.\n     */\n    _terminate() {\n        removeComponents(this);\n        return Promise.resolve();\n    }\n}\n/**\n * Modify this instance to communicate with the Cloud Firestore emulator.\n *\n * Note: This must be called before this instance has been used to do any\n * operations.\n *\n * @param firestore - The `Firestore` instance to configure to connect to the\n * emulator.\n * @param host - the emulator host (ex: localhost).\n * @param port - the emulator port (ex: 9000).\n * @param options.mockUserToken - the mock auth token to use for unit testing\n * Security Rules.\n */\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\n    var _a;\n    firestore = cast(firestore, Firestore$1);\n    const settings = firestore._getSettings();\n    const newHostSetting = `${host}:${port}`;\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\n            'will be used.');\n    }\n    firestore._setSettings(Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: false }));\n    if (options.mockUserToken) {\n        let token;\n        let user;\n        if (typeof options.mockUserToken === 'string') {\n            token = options.mockUserToken;\n            user = User.MOCK_USER;\n        }\n        else {\n            // Let createMockUserToken validate first (catches common mistakes like\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\n            if (!uid) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n            }\n            user = new User(uid);\n        }\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `Query` refers to a query which you can read or listen to. You can also\n * construct refined `Query` objects by adding filters and ordering.\n */\nclass Query {\n    // This is the lite version of the Query class in the main SDK.\n    /** @hideconstructor protected */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _query) {\n        this.converter = converter;\n        this._query = _query;\n        /** The type of this Firestore reference. */\n        this.type = 'query';\n        this.firestore = firestore;\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, converter, this._query);\n    }\n}\n/**\n * A `DocumentReference` refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist.\n */\nclass DocumentReference {\n    /** @hideconstructor */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _key) {\n        this.converter = converter;\n        this._key = _key;\n        /** The type of this Firestore reference. */\n        this.type = 'document';\n        this.firestore = firestore;\n    }\n    get _path() {\n        return this._key.path;\n    }\n    /**\n     * The document's identifier within its collection.\n     */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._key.path.canonicalString();\n    }\n    /**\n     * The collection this `DocumentReference` belongs to.\n     */\n    get parent() {\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, converter, this._key);\n    }\n}\n/**\n * A `CollectionReference` object can be used for adding documents, getting\n * document references, and querying for documents (using {@link (query:1)}).\n */\nclass CollectionReference extends Query {\n    /** @hideconstructor */\n    constructor(firestore, converter, _path) {\n        super(firestore, converter, newQueryForPath(_path));\n        this._path = _path;\n        /** The type of this Firestore reference. */\n        this.type = 'collection';\n    }\n    /** The collection's identifier. */\n    get id() {\n        return this._query.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._query.path.canonicalString();\n    }\n    /**\n     * A reference to the containing `DocumentReference` if this is a\n     * subcollection. If this isn't a subcollection, the reference is null.\n     */\n    get parent() {\n        const parentPath = this._path.popLast();\n        if (parentPath.isEmpty()) {\n            return null;\n        }\n        else {\n            return new DocumentReference(this.firestore, \n            /* converter= */ null, new DocumentKey(parentPath));\n        }\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, converter, this._path);\n    }\n}\nfunction collection(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    validateNonEmptyArgument('collection', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent.firestore, \n        /* converter= */ null, absolutePath);\n    }\n}\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\n * Creates and returns a new `Query` instance that includes all documents in the\n * database that are contained in a collection or subcollection with the\n * given `collectionId`.\n *\n * @param firestore - A reference to the root `Firestore` instance.\n * @param collectionId - Identifies the collections to query over. Every\n * collection or subcollection with this ID as the last segment of its path\n * will be included. Cannot contain a slash.\n * @returns The created `Query`.\n */\nfunction collectionGroup(firestore, collectionId) {\n    firestore = cast(firestore, Firestore$1);\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\n    if (collectionId.indexOf('/') >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\n            `collectionGroup(). Collection IDs must not contain '/'.`);\n    }\n    return new Query(firestore, \n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\n}\nfunction doc(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 1) {\n        path = AutoId.newId();\n    }\n    validateNonEmptyArgument('doc', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent, \n        /* converter= */ null, new DocumentKey(absolutePath));\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\n    }\n}\n/**\n * Returns true if the provided references are equal.\n *\n * @param left - A reference to compare.\n * @param right - A reference to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction refEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if ((left instanceof DocumentReference ||\n        left instanceof CollectionReference) &&\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\n        return (left.firestore === right.firestore &&\n            left.path === right.path &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n/**\n * Returns true if the provided queries point to the same collection and apply\n * the same constraints.\n *\n * @param left - A `Query` to compare.\n * @param right - A `Query` to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction queryEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if (left instanceof Query && right instanceof Query) {\n        return (left.firestore === right.firestore &&\n            queryEquals(left._query, right._query) &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG = 'AsyncQueue';\nclass AsyncQueueImpl {\n    constructor(tail = Promise.resolve()) {\n        // A list of retryable operations. Retryable operations are run in order and\n        // retried with backoff.\n        this.retryableOps = [];\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\n        // be changed again.\n        this._isShuttingDown = false;\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // visible for testing\n        this.failure = null;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n        this.skipNonRestrictedTasks = false;\n        // List of TimerIds to fast-forward delays for.\n        this.timerIdsToSkip = [];\n        // Backoff timer used to schedule retries for retryable operations\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\n        // Visibility handler that triggers an immediate retry of all retryable\n        // operations. Meant to speed up recovery when we regain file system access\n        // after page comes into foreground.\n        this.visibilityHandler = () => {\n            this.backoff.skipBackoff();\n        };\n        this.tail = tail;\n    }\n    get isShuttingDown() {\n        return this._isShuttingDown;\n    }\n    /**\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\n     * we ignore the Promise result).\n     */\n    enqueueAndForget(op) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueue(op);\n    }\n    enqueueAndForgetEvenWhileRestricted(op) {\n        this.verifyNotFailed();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueueInternal(op);\n    }\n    enterRestrictedMode(purgeExistingTasks) {\n        if (!this._isShuttingDown) {\n            this._isShuttingDown = true;\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\n        }\n    }\n    enqueue(op) {\n        this.verifyNotFailed();\n        if (this._isShuttingDown) {\n            // Return a Promise which never resolves.\n            return new Promise(() => { });\n        }\n        // Create a deferred Promise that we can return to the callee. This\n        // allows us to return a \"hanging Promise\" only to the callee and still\n        // advance the queue even when the operation is not run.\n        const task = new Deferred();\n        return this.enqueueInternal(() => {\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\n                // We do not resolve 'task'\n                return Promise.resolve();\n            }\n            op().then(task.resolve, task.reject);\n            return task.promise;\n        }).then(() => task.promise);\n    }\n    enqueueRetryable(op) {\n        this.enqueueAndForget(() => {\n            this.retryableOps.push(op);\n            return this.retryNextOp();\n        });\n    }\n    /**\n     * Runs the next operation from the retryable queue. If the operation fails,\n     * reschedules with backoff.\n     */\n    async retryNextOp() {\n        if (this.retryableOps.length === 0) {\n            return;\n        }\n        try {\n            await this.retryableOps[0]();\n            this.retryableOps.shift();\n            this.backoff.reset();\n        }\n        catch (e) {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\n            }\n            else {\n                throw e; // Failure will be handled by AsyncQueue\n            }\n        }\n        if (this.retryableOps.length > 0) {\n            // If there are additional operations, we re-schedule `retryNextOp()`.\n            // This is necessary to run retryable operations that failed during\n            // their initial attempt since we don't know whether they are already\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n            // call scheduled here.\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\n            // new backoff on every call, there is only ever a single additional\n            // operation in the queue.\n            this.backoff.backoffAndRun(() => this.retryNextOp());\n        }\n    }\n    enqueueInternal(op) {\n        const newTail = this.tail.then(() => {\n            this.operationInProgress = true;\n            return op()\n                .catch((error) => {\n                this.failure = error;\n                this.operationInProgress = false;\n                const message = getMessageOrStack(error);\n                logError('INTERNAL UNHANDLED ERROR: ', message);\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(result => {\n                this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    }\n    enqueueAfterDelay(timerId, delayMs, op) {\n        this.verifyNotFailed();\n        // Fast-forward delays for timerIds that have been overridden.\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n            delayMs = 0;\n        }\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    }\n    verifyNotFailed() {\n        if (this.failure) {\n            fail();\n        }\n    }\n    verifyOperationInProgress() {\n    }\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    async drain() {\n        // Operations in the queue prior to draining may have enqueued additional\n        // operations. Keep draining the queue until the tail is no longer advanced,\n        // which indicates that no more new operations were enqueued and that all\n        // operations were executed.\n        let currentTail;\n        do {\n            currentTail = this.tail;\n            await currentTail;\n        } while (currentTail !== this.tail);\n    }\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    containsDelayedOperation(timerId) {\n        for (const op of this.delayedOperations) {\n            if (op.timerId === timerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId - Delayed operations up to and including this TimerId\n     * will be drained. Pass TimerId.All to run all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    runAllDelayedOperationsUntil(lastTimerId) {\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(() => {\n            // Run ops in the same order they'd run if they ran naturally.\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n            for (const op of this.delayedOperations) {\n                op.skipDelay();\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return this.drain();\n        });\n    }\n    /**\n     * For Tests: Skip all subsequent delays for a timer id.\n     */\n    skipDelaysForTimerId(timerId) {\n        this.timerIdsToSkip.push(timerId);\n    }\n    /** Called once a DelayedOperation is run or canceled. */\n    removeDelayedOperation(op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        const index = this.delayedOperations.indexOf(op);\n        /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n        this.delayedOperations.splice(index, 1);\n    }\n}\n/**\n * Chrome includes Error.message in Error.stack. Other browsers do not.\n * This returns expected output of message + stack when available.\n * @param error - Error or FirestoreError\n */\nfunction getMessageOrStack(error) {\n    let message = error.message || '';\n    if (error.stack) {\n        if (error.stack.includes(error.message)) {\n            message = error.stack;\n        }\n        else {\n            message = error.message + '\\n' + error.stack;\n        }\n    }\n    return message;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\n * loading, as well as task completion and error events.\n *\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\n */\nclass LoadBundleTask {\n    constructor() {\n        this._progressObserver = {};\n        this._taskCompletionResolver = new Deferred();\n        this._lastProgress = {\n            taskState: 'Running',\n            totalBytes: 0,\n            totalDocuments: 0,\n            bytesLoaded: 0,\n            documentsLoaded: 0\n        };\n    }\n    /**\n     * Registers functions to listen to bundle loading progress events.\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\n     *   each time a Firestore document is loaded from the bundle.\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\n     *   error, and there should be no more updates after this.\n     * @param complete - Called when the loading task is complete.\n     */\n    onProgress(next, error, complete) {\n        this._progressObserver = {\n            next,\n            error,\n            complete\n        };\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\n     *\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    catch(onRejected) {\n        return this._taskCompletionResolver.promise.catch(onRejected);\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\n     *\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\n     *   The update will always have its `taskState` set to `\"Success\"`.\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    then(onFulfilled, onRejected) {\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Notifies all observers that bundle loading has completed, with a provided\n     * `LoadBundleTaskProgress` object.\n     *\n     * @private\n     */\n    _completeWith(progress) {\n        this._updateProgress(progress);\n        if (this._progressObserver.complete) {\n            this._progressObserver.complete();\n        }\n        this._taskCompletionResolver.resolve(progress);\n    }\n    /**\n     * Notifies all observers that bundle loading has failed, with a provided\n     * `Error` as the reason.\n     *\n     * @private\n     */\n    _failWith(error) {\n        this._lastProgress.taskState = 'Error';\n        if (this._progressObserver.next) {\n            this._progressObserver.next(this._lastProgress);\n        }\n        if (this._progressObserver.error) {\n            this._progressObserver.error(error);\n        }\n        this._taskCompletionResolver.reject(error);\n    }\n    /**\n     * Notifies a progress update of loading a bundle.\n     * @param progress - The new progress.\n     *\n     * @private\n     */\n    _updateProgress(progress) {\n        this._lastProgress = progress;\n        if (this._progressObserver.next) {\n            this._progressObserver.next(progress);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Constant used to indicate the LRU garbage collection should be disabled.\n * Set this value as the `cacheSizeBytes` on the settings passed to the\n * {@link Firestore} instance.\n */\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore extends Firestore$1 {\n    /** @hideconstructor */\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\n        /**\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\n         */\n        this.type = 'firestore';\n        this._queue = new AsyncQueueImpl();\n        this._persistenceKey = (app === null || app === void 0 ? void 0 : app.name) || '[DEFAULT]';\n    }\n    async _terminate() {\n        if (this._firestoreClient) {\n            const terminate = this._firestoreClient.terminate();\n            this._queue = new AsyncQueueImpl(terminate);\n            this._firestoreClient = undefined;\n            await terminate;\n        }\n    }\n}\n/**\n * Initializes a new instance of {@link Firestore} with the provided settings.\n * Can only be called before any other function, including\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\n * equivalent to calling {@link (getFirestore:1)}.\n *\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\n * be associated.\n * @param settings - A settings object to configure the {@link Firestore} instance.\n * @param databaseId - The name of the database.\n * @returns A newly initialized {@link Firestore} instance.\n */\nfunction initializeFirestore(app, settings, databaseId) {\n    if (!databaseId) {\n        databaseId = DEFAULT_DATABASE_NAME;\n    }\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\n    if (provider.isInitialized(databaseId)) {\n        const existingInstance = provider.getImmediate({\n            identifier: databaseId\n        });\n        const initialSettings = provider.getOptions(databaseId);\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\n            return existingInstance;\n        }\n        else {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\n                'different options. To avoid this error, call initializeFirestore() with the ' +\n                'same options as when it was originally called, or call getFirestore() to return the' +\n                ' already initialized instance.');\n        }\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.localCache !== undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\n            `be deprecated. Instead, specify the cache size in the cache object`);\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n    }\n    return provider.initialize({\n        options: settings,\n        instanceIdentifier: databaseId\n    });\n}\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const databaseId = typeof appOrDatabaseId === 'string'\n        ? appOrDatabaseId\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\n        identifier: databaseId\n    });\n    if (!db._initialized) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)('firestore');\n        if (emulator) {\n            connectFirestoreEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\n * @internal\n */\nfunction ensureFirestoreConfigured(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n    }\n    if (!firestore._firestoreClient) {\n        configureFirestore(firestore);\n    }\n    return firestore._firestoreClient;\n}\nfunction configureFirestore(firestore) {\n    var _a, _b, _c;\n    const settings = firestore._freezeSettings();\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\n    if (!firestore._componentsProvider) {\n        if (((_b = settings.localCache) === null || _b === void 0 ? void 0 : _b._offlineComponentProvider) &&\n            ((_c = settings.localCache) === null || _c === void 0 ? void 0 : _c._onlineComponentProvider)) {\n            firestore._componentsProvider = {\n                _offline: settings.localCache._offlineComponentProvider,\n                _online: settings.localCache._onlineComponentProvider\n            };\n        }\n    }\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo, firestore._componentsProvider &&\n        buildComponentProvider(firestore._componentsProvider));\n}\nfunction buildComponentProvider(componentsProvider) {\n    const online = componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._online.build();\n    return {\n        _offline: componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._offline.build(online),\n        _online: online\n    };\n}\n/**\n * Attempts to enable persistent storage, if possible.\n *\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\n * {@link clearIndexedDbPersistence}.\n *\n * Persistence cannot be used in a Node.js environment.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @param persistenceSettings - Optional settings object to configure\n * persistence.\n * @returns A `Promise` that represents successfully enabling persistent storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership)\n    });\n    return Promise.resolve();\n}\n/**\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\n * across all tabs, all operations share access to local persistence, including\n * shared execution of queries and latency-compensated local document updates\n * across all connected instances.\n *\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab and\n *     multi-tab is not enabled.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @returns A `Promise` that represents successfully enabling persistent\n * storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nasync function enableMultiTabIndexedDbPersistence(firestore) {\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes)\n    });\n}\n/**\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\n * If the operation fails with a recoverable error (see\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\n * but the client remains usable.\n */\nfunction setPersistenceProviders(firestore, onlineComponentProvider, offlineComponentProvider) {\n    firestore = cast(firestore, Firestore);\n    if (firestore._firestoreClient || firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\n            'enabled. You can only enable persistence before calling any other ' +\n            'methods on a Firestore object.');\n    }\n    if (firestore._componentsProvider || firestore._getSettings().localCache) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\n    }\n    firestore._componentsProvider = {\n        _online: onlineComponentProvider,\n        _offline: offlineComponentProvider\n    };\n    configureFirestore(firestore);\n}\n/**\n * Clears the persistent storage. This includes pending writes and cached\n * documents.\n *\n * Must be called while the {@link Firestore} instance is not started (after the app is\n * terminated or when the app is first initialized). On startup, this function\n * must be called before other functions (other than {@link\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\n * instance is still running, the promise will be rejected with the error code\n * of `failed-precondition`.\n *\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\n * dropping existing data but does not attempt to securely overwrite or\n * otherwise make cached data unrecoverable. For applications that are sensitive\n * to the disclosure of cached data in between user sessions, we strongly\n * recommend not enabling persistence at all.\n *\n * @param firestore - The {@link Firestore} instance to clear persistence for.\n * @returns A `Promise` that is resolved when the persistent storage is\n * cleared. Otherwise, the promise is rejected with an error.\n */\nfunction clearIndexedDbPersistence(firestore) {\n    if (firestore._initialized && !firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\n            'initialized or after it is terminated.');\n    }\n    const deferred = new Deferred();\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\n        try {\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\n            deferred.resolve();\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\n/**\n * Waits until all currently pending writes for the active user have been\n * acknowledged by the backend.\n *\n * The returned promise resolves immediately if there are no outstanding writes.\n * Otherwise, the promise waits for all previously issued writes (including\n * those written in a previous app session), but it does not wait for writes\n * that were added after the function is called. If you want to wait for\n * additional writes, call `waitForPendingWrites()` again.\n *\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\n * changes.\n *\n * @returns A `Promise` which resolves when all currently pending writes have been\n * acknowledged by the backend.\n */\nfunction waitForPendingWrites(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWaitForPendingWrites(client);\n}\n/**\n * Re-enables use of the network for this {@link Firestore} instance after a prior\n * call to {@link disableNetwork}.\n *\n * @returns A `Promise` that is resolved once the network has been enabled.\n */\nfunction enableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientEnableNetwork(client);\n}\n/**\n * Disables network usage for this instance. It can be re-enabled via {@link\n * enableNetwork}. While the network is disabled, any snapshot listeners,\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\n * operations will be queued until the network is restored.\n *\n * @returns A `Promise` that is resolved once the network has been disabled.\n */\nfunction disableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientDisableNetwork(client);\n}\n/**\n * Terminates the provided {@link Firestore} instance.\n *\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\n * may be used. Any other function will throw a `FirestoreError`.\n *\n * To restart after termination, create a new instance of FirebaseFirestore with\n * {@link (getFirestore:1)}.\n *\n * Termination does not cancel any pending writes, and any promises that are\n * awaiting a response from the server will not be resolved. If you have\n * persistence enabled, the next time you start this instance, it will resume\n * sending these writes to the server.\n *\n * Note: Under normal circumstances, calling `terminate()` is not required. This\n * function is useful only when you want to force this instance to release all\n * of its resources or in combination with `clearIndexedDbPersistence()` to\n * ensure that all local state is destroyed between test runs.\n *\n * @returns A `Promise` that is resolved when the instance has been successfully\n * terminated.\n */\nfunction terminate(firestore) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\n    return firestore._delete();\n}\n/**\n * Loads a Firestore bundle into the local cache.\n *\n * @param firestore - The {@link Firestore} instance to load bundles for.\n * @param bundleData - An object representing the bundle to be loaded. Valid\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\n *\n * @returns A `LoadBundleTask` object, which notifies callers with progress\n * updates, and completion or error events. It can be used as a\n * `Promise<LoadBundleTaskProgress>`.\n */\nfunction loadBundle(firestore, bundleData) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const resultTask = new LoadBundleTask();\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\n    return resultTask;\n}\n/**\n * Reads a Firestore {@link Query} from local cache, identified by the given\n * name.\n *\n * The named queries are packaged  into bundles on the server side (along\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\n * in local cache, use this method to extract a {@link Query} by name.\n *\n * @param firestore - The {@link Firestore} instance to read the query from.\n * @param name - The name of the query.\n * @returns A `Promise` that is resolved with the Query or `null`.\n */\nfunction namedQuery(firestore, name) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\n        if (!namedQuery) {\n            return null;\n        }\n        return new Query(firestore, null, namedQuery.query);\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerFirestore(variant, useFetchStreams = true) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate();\n        const firestoreInstance = new Firestore(new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(app, container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);\n        settings = Object.assign({ useFetchStreams }, settings);\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n    }, 'PUBLIC').setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass AggregateImpl {\n    constructor(alias, aggregateType, fieldPath) {\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n    /**\n     * Create a new AggregateField<T>\n     * @param aggregateType Specifies the type of aggregation operation to perform.\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\n     * @internal\n     */\n    constructor(aggregateType = 'count', _internalFieldPath) {\n        this._internalFieldPath = _internalFieldPath;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateField';\n        this.aggregateType = aggregateType;\n    }\n}\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n    /** @hideconstructor */\n    constructor(query, _userDataWriter, _data) {\n        this._userDataWriter = _userDataWriter;\n        this._data = _data;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateQuerySnapshot';\n        this.query = query;\n    }\n    /**\n     * Returns the results of the aggregations performed over the underlying\n     * query.\n     *\n     * The keys of the returned object will be the same as those of the\n     * `AggregateSpec` object specified to the aggregation method, and the values\n     * will be the corresponding aggregation result.\n     *\n     * @returns The results of the aggregations performed over the underlying\n     * query.\n     */\n    data() {\n        return this._userDataWriter.convertObjectMap(this._data);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing an array of bytes.\n */\nclass Bytes {\n    /** @hideconstructor */\n    constructor(byteString) {\n        this._byteString = byteString;\n    }\n    /**\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\n     * bytes.\n     *\n     * @param base64 - The Base64 string used to create the `Bytes` object.\n     */\n    static fromBase64String(base64) {\n        try {\n            return new Bytes(ByteString.fromBase64String(base64));\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\n        }\n    }\n    /**\n     * Creates a new `Bytes` object from the given Uint8Array.\n     *\n     * @param array - The Uint8Array used to create the `Bytes` object.\n     */\n    static fromUint8Array(array) {\n        return new Bytes(ByteString.fromUint8Array(array));\n    }\n    /**\n     * Returns the underlying bytes as a Base64-encoded string.\n     *\n     * @returns The Base64-encoded string created from the `Bytes` object.\n     */\n    toBase64() {\n        return this._byteString.toBase64();\n    }\n    /**\n     * Returns the underlying bytes in a new `Uint8Array`.\n     *\n     * @returns The Uint8Array created from the `Bytes` object.\n     */\n    toUint8Array() {\n        return this._byteString.toUint8Array();\n    }\n    /**\n     * Returns a string representation of the `Bytes` object.\n     *\n     * @returns A string representation of the `Bytes` object.\n     */\n    toString() {\n        return 'Bytes(base64: ' + this.toBase64() + ')';\n    }\n    /**\n     * Returns true if this `Bytes` object is equal to the provided one.\n     *\n     * @param other - The `Bytes` object to compare against.\n     * @returns true if this `Bytes` object is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._byteString.isEqual(other._byteString);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `FieldPath` refers to a field in a document. The path may consist of a\n * single field name (referring to a top-level field in the document), or a\n * list of field names (referring to a nested field in the document).\n *\n * Create a `FieldPath` by providing field names. If more than one field\n * name is provided, the path will point to a nested field in a document.\n */\nclass FieldPath {\n    /**\n     * Creates a `FieldPath` from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames - A list of field names.\n     */\n    constructor(...fieldNames) {\n        for (let i = 0; i < fieldNames.length; ++i) {\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new FieldPath$1(fieldNames);\n    }\n    /**\n     * Returns true if this `FieldPath` is equal to the provided one.\n     *\n     * @param other - The `FieldPath` to compare against.\n     * @returns true if this `FieldPath` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._internalPath.isEqual(other._internalPath);\n    }\n}\n/**\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\n * It can be used in queries to sort or filter by the document ID.\n */\nfunction documentId() {\n    return new FieldPath(DOCUMENT_KEY_NAME);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sentinel values that can be used when writing document fields with `set()`\n * or `update()`.\n */\nclass FieldValue {\n    /**\n     * @param _methodName - The public API endpoint that returns this class.\n     * @hideconstructor\n     */\n    constructor(_methodName) {\n        this._methodName = _methodName;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as latitude/longitude pair.\n *\n * Latitude values are in the range of [-90, 90].\n * Longitude values are in the range of [-180, 180].\n */\nclass GeoPoint {\n    /**\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\n     * longitude values.\n     * @param latitude - The latitude as number between -90 and 90.\n     * @param longitude - The longitude as number between -180 and 180.\n     */\n    constructor(latitude, longitude) {\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    /**\n     * The latitude of this `GeoPoint` instance.\n     */\n    get latitude() {\n        return this._lat;\n    }\n    /**\n     * The longitude of this `GeoPoint` instance.\n     */\n    get longitude() {\n        return this._long;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided one.\n     *\n     * @param other - The `GeoPoint` to compare against.\n     * @returns true if this `GeoPoint` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._lat === other._lat && this._long === other._long;\n    }\n    /** Returns a JSON-serializable representation of this GeoPoint. */\n    toJSON() {\n        return { latitude: this._lat, longitude: this._long };\n    }\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    _compareTo(other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a vector type in Firestore documents.\n * Create an instance with {@link FieldValue.vector}.\n *\n * @class VectorValue\n */\nclass VectorValue {\n    /**\n     * @private\n     * @internal\n     */\n    constructor(values) {\n        // Making a copy of the parameter.\n        this._values = (values || []).map(n => n);\n    }\n    /**\n     * Returns a copy of the raw number array form of the vector.\n     */\n    toArray() {\n        return this._values.map(n => n);\n    }\n    /**\n     * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.\n     */\n    isEqual(other) {\n        return isPrimitiveArrayEqual(this._values, other._values);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nclass ParsedSetData {\n    constructor(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        if (this.fieldMask !== null) {\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\n        }\n    }\n}\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nclass ParsedUpdateData {\n    constructor(data, \n    // The fieldMask does not include document transforms.\n    fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n    }\n}\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case 0 /* UserDataSource.Set */: // fall through\n        case 2 /* UserDataSource.MergeSet */: // fall through\n        case 1 /* UserDataSource.Update */:\n            return true;\n        case 3 /* UserDataSource.Argument */:\n        case 4 /* UserDataSource.ArrayArgument */:\n            return false;\n        default:\n            throw fail();\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContextImpl {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param settings - The settings for the parser.\n     * @param databaseId - The database ID of the Firestore instance.\n     * @param serializer - The serializer to use to generate the Value proto.\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\n     * rather than throw.\n     * @param fieldTransforms - A mutable list of field transforms encountered\n     * while parsing the data.\n     * @param fieldMask - A mutable list of field paths encountered while parsing\n     * the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\n        this.settings = settings;\n        this.databaseId = databaseId;\n        this.serializer = serializer;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get dataSource() {\n        return this.settings.dataSource;\n    }\n    /** Returns a new context with the specified settings overwritten. */\n    contextWith(configuration) {\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n    childContextForField(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePathSegment(field);\n        return context;\n    }\n    childContextForFieldPath(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePath();\n        return context;\n    }\n    childContextForArray(index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // undefined.\n        return this.contextWith({ path: undefined, arrayElement: true });\n    }\n    createError(reason) {\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n    contains(fieldPath) {\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\n    }\n    validatePath() {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (!this.path) {\n            return;\n        }\n        for (let i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    }\n    validatePathSegment(segment) {\n        if (segment.length === 0) {\n            throw this.createError('Document fields must not be empty');\n        }\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with \"__\"');\n        }\n    }\n}\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nclass UserDataReader {\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\n        this.databaseId = databaseId;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        this.serializer = serializer || newSerializer(databaseId);\n    }\n    /** Creates a new top-level parse context. */\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\n        return new ParseContextImpl({\n            dataSource,\n            methodName,\n            targetDoc,\n            path: FieldPath$1.emptyPath(),\n            arrayElement: false,\n            hasConverter\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\n    }\n}\nfunction newUserDataReader(firestore) {\n    const settings = firestore._freezeSettings();\n    const serializer = newSerializer(firestore._databaseId);\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\n}\n/** Parse document data from a set() call. */\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\n    const context = userDataReader.createContext(options.merge || options.mergeFields\n        ? 2 /* UserDataSource.MergeSet */\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const updateData = parseObject(input, context);\n    let fieldMask;\n    let fieldTransforms;\n    if (options.merge) {\n        fieldMask = new FieldMask(context.fieldMask);\n        fieldTransforms = context.fieldTransforms;\n    }\n    else if (options.mergeFields) {\n        const validatedFieldPaths = [];\n        for (const stringOrFieldPath of options.mergeFields) {\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\n            if (!context.contains(fieldPath)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\n            }\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n                validatedFieldPaths.push(fieldPath);\n            }\n        }\n        fieldMask = new FieldMask(validatedFieldPaths);\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\n    }\n    else {\n        fieldMask = null;\n        fieldTransforms = context.fieldTransforms;\n    }\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\n}\nclass DeleteFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\n            // No transform to add for a delete, but we need to add it to our\n            // fieldMask so it gets deleted.\n            context.fieldMask.push(context.path);\n        }\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\n                'of your update data');\n        }\n        else {\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\n                '{merge:true}');\n        }\n        return null;\n    }\n    isEqual(other) {\n        return other instanceof DeleteFieldValueImpl;\n    }\n}\n/**\n * Creates a child context for parsing SerializableFieldValues.\n *\n * This is different than calling `ParseContext.contextWith` because it keeps\n * the fieldTransforms and fieldMask separate.\n *\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\n * Although these values are used with writes, any elements in these FieldValues\n * are not considered writes since they cannot contain any FieldValue sentinels,\n * etc.\n *\n * @param fieldValue - The sentinel FieldValue for which to create a child\n *     context.\n * @param context - The parent context.\n * @param arrayElement - Whether or not the FieldValue has an array.\n */\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\n    return new ParseContextImpl({\n        dataSource: 3 /* UserDataSource.Argument */,\n        targetDoc: context.settings.targetDoc,\n        methodName: fieldValue._methodName,\n        arrayElement\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\n}\nclass ServerTimestampFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        return new FieldTransform(context.path, new ServerTimestampTransform());\n    }\n    isEqual(other) {\n        return other instanceof ServerTimestampFieldValueImpl;\n    }\n}\nclass ArrayUnionFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayUnionFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass ArrayRemoveFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayRemoveFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass NumericIncrementFieldValueImpl extends FieldValue {\n    constructor(methodName, _operand) {\n        super(methodName);\n        this._operand = _operand;\n    }\n    _toFieldTransform(context) {\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\n        return new FieldTransform(context.path, numericIncrement);\n    }\n    isEqual(other) {\n        return (other instanceof NumericIncrementFieldValueImpl &&\n            this._operand === other._operand);\n    }\n}\n/** Parse update data from an update() call. */\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    forEach(input, (key, value) => {\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n        const childContext = context.childContextForFieldPath(path);\n        if (value instanceof DeleteFieldValueImpl) {\n            // Add it to the field mask, but don't add anything to updateData.\n            fieldMaskPaths.push(path);\n        }\n        else {\n            const parsedValue = parseData(value, childContext);\n            if (parsedValue != null) {\n                fieldMaskPaths.push(path);\n                updateData.set(path, parsedValue);\n            }\n        }\n    });\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/** Parse update data from a list of field/value arguments. */\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\n    const values = [value];\n    if (moreFieldsAndValues.length % 2 !== 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\n            'of arguments that alternate between field names and values.');\n    }\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\n        values.push(moreFieldsAndValues[i + 1]);\n    }\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for (let i = keys.length - 1; i >= 0; --i) {\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n            const path = keys[i];\n            let value = values[i];\n            // For Compat types, we have to \"extract\" the underlying types before\n            // performing validation.\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n            const childContext = context.childContextForFieldPath(path);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                const parsedValue = parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData.set(path, parsedValue);\n                }\n            }\n        }\n    }\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/**\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n * bound).\n *\n * @param allowArrays - Whether the query value is an array that may directly\n * contain additional arrays (e.g. the operand of an `in` query).\n */\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\n    const parsed = parseData(input, context);\n    return parsed;\n}\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input - Data to be parsed.\n * @param context - A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @returns The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nfunction parseData(input, context) {\n    // Unwrap the API type from the Compat SDK. This will return the API type\n    // from firestore-exp.\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\n    if (looksLikeJsonObject(input)) {\n        validatePlainObject('Unsupported field value:', context, input);\n        return parseObject(input, context);\n    }\n    else if (input instanceof FieldValue) {\n        // FieldValues usually parse into transforms (except deleteField())\n        // in which case we do not want to include this field in our parsed data\n        // (as doing so will overwrite the field directly prior to the transform\n        // trying to transform it). So we don't add this location to\n        // context.fieldMask and we return null as our parsing result.\n        parseSentinelFieldValue(input, context);\n        return null;\n    }\n    else if (input === undefined && context.ignoreUndefinedProperties) {\n        // If the input is undefined it can never participate in the fieldMask, so\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\n        // `parseScalarValue` will reject an undefined value.\n        return null;\n    }\n    else {\n        // If context.path is null we are inside an array and we don't support\n        // field mask paths more granular than the top-level array.\n        if (context.path) {\n            context.fieldMask.push(context.path);\n        }\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            // In the case of IN queries, the parsed data is an array (representing\n            // the set of values to be included for the IN query) that may directly\n            // contain additional arrays (each representing an individual field\n            // value), so we disable this validation.\n            if (context.settings.arrayElement &&\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            return parseArray(input, context);\n        }\n        else {\n            return parseScalarValue(input, context);\n        }\n    }\n}\nfunction parseObject(obj, context) {\n    const fields = {};\n    if (isEmpty(obj)) {\n        // If we encounter an empty object, we explicitly add it to the update\n        // mask to ensure that the server creates a map entry.\n        if (context.path && context.path.length > 0) {\n            context.fieldMask.push(context.path);\n        }\n    }\n    else {\n        forEach(obj, (key, val) => {\n            const parsedValue = parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                fields[key] = parsedValue;\n            }\n        });\n    }\n    return { mapValue: { fields } };\n}\nfunction parseArray(array, context) {\n    const values = [];\n    let entryIndex = 0;\n    for (const entry of array) {\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\n        if (parsedEntry == null) {\n            // Just include nulls in the array for fields being replaced with a\n            // sentinel.\n            parsedEntry = { nullValue: 'NULL_VALUE' };\n        }\n        values.push(parsedEntry);\n        entryIndex++;\n    }\n    return { arrayValue: { values } };\n}\n/**\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n * context.fieldTransforms.\n */\nfunction parseSentinelFieldValue(value, context) {\n    // Sentinels are only supported with writes, and not within arrays.\n    if (!isWrite(context.dataSource)) {\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\n    }\n    if (!context.path) {\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\n    }\n    const fieldTransform = value._toFieldTransform(context);\n    if (fieldTransform) {\n        context.fieldTransforms.push(fieldTransform);\n    }\n}\n/**\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n *\n * @returns The parsed value\n */\nfunction parseScalarValue(value, context) {\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n    if (value === null) {\n        return { nullValue: 'NULL_VALUE' };\n    }\n    else if (typeof value === 'number') {\n        return toNumber(context.serializer, value);\n    }\n    else if (typeof value === 'boolean') {\n        return { booleanValue: value };\n    }\n    else if (typeof value === 'string') {\n        return { stringValue: value };\n    }\n    else if (value instanceof Date) {\n        const timestamp = Timestamp.fromDate(value);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof Timestamp) {\n        // Firestore backend truncates precision down to microseconds. To ensure\n        // offline mode works the same with regards to truncation, perform the\n        // truncation immediately without waiting for the backend to do that.\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof GeoPoint) {\n        return {\n            geoPointValue: {\n                latitude: value.latitude,\n                longitude: value.longitude\n            }\n        };\n    }\n    else if (value instanceof Bytes) {\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\n    }\n    else if (value instanceof DocumentReference) {\n        const thisDb = context.databaseId;\n        const otherDb = value.firestore._databaseId;\n        if (!otherDb.isEqual(thisDb)) {\n            throw context.createError('Document reference is for database ' +\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\n                `for database ${thisDb.projectId}/${thisDb.database}`);\n        }\n        return {\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\n        };\n    }\n    else if (value instanceof VectorValue) {\n        return parseVectorValue(value, context);\n    }\n    else {\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\n    }\n}\n/**\n * Creates a new VectorValue proto value (using the internal format).\n */\nfunction parseVectorValue(value, context) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY]: {\n                stringValue: VECTOR_VALUE_SENTINEL\n            },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {\n                    values: value.toArray().map(value => {\n                        if (typeof value !== 'number') {\n                            throw context.createError('VectorValues must only contain numeric values.');\n                        }\n                        return toDouble(context.serializer, value);\n                    })\n                }\n            }\n        }\n    };\n    return { mapValue };\n}\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof Timestamp) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Bytes) &&\n        !(input instanceof DocumentReference) &&\n        !(input instanceof FieldValue) &&\n        !(input instanceof VectorValue));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        const description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\n    // If required, replace the FieldPath Compat class with the firestore-exp\n    // FieldPath.\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\n    if (path instanceof FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        const message = 'Field path arguments must be of type string or ';\n        throw createError(message, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\n/**\n * Matches any characters in a field path string that are reserved.\n */\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName - The publicly visible method name\n * @param path - The dot-separated string form of a field path which will be\n * split on dots.\n * @param targetDoc - The document against which the field path will be\n * evaluated.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\n    const found = path.search(FIELD_PATH_RESERVED);\n    if (found >= 0) {\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\n            `'~', '*', '/', '[', or ']'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n    try {\n        return new FieldPath(...path.split('.'))._internalPath;\n    }\n    catch (e) {\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\n            `begin with '.', end with '.', or contain '..'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\n    const hasPath = path && !path.isEmpty();\n    const hasDocument = targetDoc !== undefined;\n    let message = `Function ${methodName}() called with invalid data`;\n    if (hasConverter) {\n        message += ' (via `toFirestore()`)';\n    }\n    message += '. ';\n    let description = '';\n    if (hasPath || hasDocument) {\n        description += ' (found';\n        if (hasPath) {\n            description += ` in field ${path}`;\n        }\n        if (hasDocument) {\n            description += ` in document ${targetDoc}`;\n        }\n        description += ')';\n    }\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\n}\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction fieldMaskContains(haystack, needle) {\n    return haystack.some(v => v.isEqual(needle));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot$1 {\n    // Note: This class is stripped down version of the DocumentSnapshot in\n    // the legacy SDK. The changes are:\n    // - No support for SnapshotMetadata.\n    // - No support for SnapshotOptions.\n    /** @hideconstructor protected */\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._key = _key;\n        this._document = _document;\n        this._converter = _converter;\n    }\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n     */\n    get ref() {\n        return new DocumentReference(this._firestore, this._converter, this._key);\n    }\n    /**\n     * Signals whether or not the document at the snapshot's location exists.\n     *\n     * @returns true if the document exists.\n     */\n    exists() {\n        return this._document !== null;\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n    data() {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * @override\n     * @returns An `Object` containing all fields in the document.\n     */\n    data() {\n        return super.data();\n    }\n}\n/**\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, arg) {\n    if (typeof arg === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, arg);\n    }\n    else if (arg instanceof FieldPath) {\n        return arg._internalPath;\n    }\n    else {\n        return arg._delegate._internalPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateHasExplicitOrderByForLimitToLast(query) {\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\n        query.explicitOrderBy.length === 0) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\n    }\n}\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nclass AppliableConstraint {\n}\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nclass QueryConstraint extends AppliableConstraint {\n}\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\n    let queryConstraints = [];\n    if (queryConstraint instanceof AppliableConstraint) {\n        queryConstraints.push(queryConstraint);\n    }\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n    validateQueryConstraintArray(queryConstraints);\n    for (const constraint of queryConstraints) {\n        query = constraint._apply(query);\n    }\n    return query;\n}\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nclass QueryFieldFilterConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _op, _value) {\n        super();\n        this._field = _field;\n        this._op = _op;\n        this._value = _value;\n        /** The type of this query constraint */\n        this.type = 'where';\n    }\n    static _create(_field, _op, _value) {\n        return new QueryFieldFilterConstraint(_field, _op, _value);\n    }\n    _apply(query) {\n        const filter = this._parse(query);\n        validateNewFieldFilter(query._query, filter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\n    }\n    _parse(query) {\n        const reader = newUserDataReader(query.firestore);\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\n        return filter;\n    }\n}\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction where(fieldPath, opStr, value) {\n    const op = opStr;\n    const field = fieldPathFromArgument('where', fieldPath);\n    return QueryFieldFilterConstraint._create(field, op, value);\n}\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _queryConstraints) {\n        super();\n        this.type = type;\n        this._queryConstraints = _queryConstraints;\n    }\n    static _create(type, _queryConstraints) {\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\n    }\n    _parse(query) {\n        const parsedFilters = this._queryConstraints\n            .map(queryConstraint => {\n            return queryConstraint._parse(query);\n        })\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return CompositeFilter.create(parsedFilters, this._getOperator());\n    }\n    _apply(query) {\n        const parsedFilter = this._parse(query);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty\n            // composite filter).\n            return query;\n        }\n        validateNewFilter(query._query, parsedFilter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\n    }\n    _getQueryConstraints() {\n        return this._queryConstraints;\n    }\n    _getOperator() {\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n    }\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction or(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction and(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\n}\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nclass QueryOrderByConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _direction) {\n        super();\n        this._field = _field;\n        this._direction = _direction;\n        /** The type of this query constraint */\n        this.type = 'orderBy';\n    }\n    static _create(_field, _direction) {\n        return new QueryOrderByConstraint(_field, _direction);\n    }\n    _apply(query) {\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\n    }\n}\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction orderBy(fieldPath, directionStr = 'asc') {\n    const direction = directionStr;\n    const path = fieldPathFromArgument('orderBy', fieldPath);\n    return QueryOrderByConstraint._create(path, direction);\n}\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nclass QueryLimitConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _limit, _limitType) {\n        super();\n        this.type = type;\n        this._limit = _limit;\n        this._limitType = _limitType;\n    }\n    static _create(type, _limit, _limitType) {\n        return new QueryLimitConstraint(type, _limit, _limitType);\n    }\n    _apply(query) {\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\n    }\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limit(limit) {\n    validatePositiveNumber('limit', limit);\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limitToLast(limit) {\n    validatePositiveNumber('limitToLast', limit);\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\n}\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nclass QueryStartAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\n    }\n}\nfunction startAt(...docOrFields) {\n    return QueryStartAtConstraint._create('startAt', docOrFields, \n    /*inclusive=*/ true);\n}\nfunction startAfter(...docOrFields) {\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \n    /*inclusive=*/ false);\n}\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nclass QueryEndAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\n    }\n}\nfunction endBefore(...docOrFields) {\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \n    /*inclusive=*/ false);\n}\nfunction endAt(...docOrFields) {\n    return QueryEndAtConstraint._create('endAt', docOrFields, \n    /*inclusive=*/ true);\n}\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\n    }\n    else {\n        const reader = newUserDataReader(query.firestore);\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\n    }\n}\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\n    let fieldValue;\n    if (fieldPath.isKeyField()) {\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\n        }\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n            validateDisjunctiveFilterElements(value, op);\n            const referenceList = [];\n            for (const arrayValue of value) {\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n            }\n            fieldValue = { arrayValue: { values: referenceList } };\n        }\n        else {\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\n        }\n    }\n    else {\n        if (op === \"in\" /* Operator.IN */ ||\n            op === \"not-in\" /* Operator.NOT_IN */ ||\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            validateDisjunctiveFilterElements(value, op);\n        }\n        fieldValue = parseQueryValue(dataReader, methodName, value, \n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\n    }\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\n    return filter;\n}\nfunction newQueryOrderBy(query, fieldPath, direction) {\n    if (query.startAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\n            'calling orderBy().');\n    }\n    if (query.endAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\n            'calling orderBy().');\n    }\n    const orderBy = new OrderBy(fieldPath, direction);\n    return orderBy;\n}\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\n    if (!doc) {\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`);\n    }\n    const components = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        if (orderBy.field.isKeyField()) {\n            components.push(refValue(databaseId, doc.key));\n        }\n        else {\n            const value = doc.data.field(orderBy.field);\n            if (isServerTimestamp(value)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\n                    'document for which the field \"' +\n                    orderBy.field +\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\n                    'this field is unknown, you cannot start/end a query with it.)');\n            }\n            else if (value !== null) {\n                components.push(value);\n            }\n            else {\n                const field = orderBy.field.canonicalString();\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\n                    `document for which the field '${field}' (used as the ` +\n                    `orderBy) does not exist.`);\n            }\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\n            `The number of arguments must be less than or equal to the ` +\n            `number of orderBy() clauses`);\n    }\n    const components = [];\n    for (let i = 0; i < values.length; i++) {\n        const rawValue = values[i];\n        const orderByComponent = orderBy[i];\n        if (orderByComponent.field.isKeyField()) {\n            if (typeof rawValue !== 'string') {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\n                    `${methodName}(), but got a ${typeof rawValue}`);\n            }\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\n                    `'${rawValue}' contains a slash.`);\n            }\n            const path = query.path.child(ResourcePath.fromString(rawValue));\n            if (!DocumentKey.isDocumentKey(path)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\n                    `of segments.`);\n            }\n            const key = new DocumentKey(path);\n            components.push(refValue(databaseId, key));\n        }\n        else {\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n            components.push(wrapped);\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\n    if (typeof documentIdValue === 'string') {\n        if (documentIdValue === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\n                'must provide a valid document ID, but it was an empty string.');\n        }\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\n                `documentId(), you must provide a plain document ID, but ` +\n                `'${documentIdValue}' contains a '/' character.`);\n        }\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\n        if (!DocumentKey.isDocumentKey(path)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\n                `documentId(), the value provided must result in a valid document path, ` +\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\n        }\n        return refValue(databaseId, new DocumentKey(path));\n    }\n    else if (documentIdValue instanceof DocumentReference) {\n        return refValue(databaseId, documentIdValue._key);\n    }\n    else {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\n            `string or a DocumentReference, but it was: ` +\n            `${valueDescription(documentIdValue)}.`);\n    }\n}\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(value, operator) {\n    if (!Array.isArray(value) || value.length === 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\n            `'${operator.toString()}' filters.`);\n    }\n}\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op) {\n    switch (op) {\n        case \"!=\" /* Operator.NOT_EQUAL */:\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n        case \"in\" /* Operator.IN */:\n            return [\"not-in\" /* Operator.NOT_IN */];\n        case \"not-in\" /* Operator.NOT_IN */:\n            return [\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\n                \"in\" /* Operator.IN */,\n                \"not-in\" /* Operator.NOT_IN */,\n                \"!=\" /* Operator.NOT_EQUAL */\n            ];\n        default:\n            return [];\n    }\n}\nfunction validateNewFieldFilter(query, fieldFilter) {\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\n    if (conflictingOp !== null) {\n        // Special case when it's a duplicate op to give a slightly clearer error message.\n        if (conflictingOp === fieldFilter.op) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\n                `'${fieldFilter.op.toString()}' filter.`);\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n                `with '${conflictingOp.toString()}' filters.`);\n        }\n    }\n}\nfunction validateNewFilter(query, filter) {\n    let testQuery = query;\n    const subFilters = filter.getFlattenedFilters();\n    for (const subFilter of subFilters) {\n        validateNewFieldFilter(testQuery, subFilter);\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\n    }\n}\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(filters, operators) {\n    for (const filter of filters) {\n        for (const fieldFilter of filter.getFlattenedFilters()) {\n            if (operators.indexOf(fieldFilter.op) >= 0) {\n                return fieldFilter.op;\n            }\n        }\n    }\n    return null;\n}\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\n    }\n}\nfunction validateQueryConstraintArray(queryConstraint) {\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\n    if (compositeFilterCount > 1 ||\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\n            'more than one filter at the top level. Consider nesting the multiple ' +\n            'filters within an `and(...)` statement. For example: ' +\n            'change `query(query, where(...), or(...))` to ' +\n            '`query(query, and(where(...), or(...)))`.');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts Firestore's internal types to the JavaScript types that we expose\n * to the user.\n *\n * @internal\n */\nclass AbstractUserDataWriter {\n    convertValue(value, serverTimestampBehavior = 'none') {\n        switch (typeOrder(value)) {\n            case 0 /* TypeOrder.NullValue */:\n                return null;\n            case 1 /* TypeOrder.BooleanValue */:\n                return value.booleanValue;\n            case 2 /* TypeOrder.NumberValue */:\n                return normalizeNumber(value.integerValue || value.doubleValue);\n            case 3 /* TypeOrder.TimestampValue */:\n                return this.convertTimestamp(value.timestampValue);\n            case 4 /* TypeOrder.ServerTimestampValue */:\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\n            case 5 /* TypeOrder.StringValue */:\n                return value.stringValue;\n            case 6 /* TypeOrder.BlobValue */:\n                return this.convertBytes(normalizeByteString(value.bytesValue));\n            case 7 /* TypeOrder.RefValue */:\n                return this.convertReference(value.referenceValue);\n            case 8 /* TypeOrder.GeoPointValue */:\n                return this.convertGeoPoint(value.geoPointValue);\n            case 9 /* TypeOrder.ArrayValue */:\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\n            case 11 /* TypeOrder.ObjectValue */:\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\n            case 10 /* TypeOrder.VectorValue */:\n                return this.convertVectorValue(value.mapValue);\n            default:\n                throw fail();\n        }\n    }\n    convertObject(mapValue, serverTimestampBehavior) {\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\n    }\n    /**\n     * @internal\n     */\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\n        const result = {};\n        forEach(fields, (key, value) => {\n            result[key] = this.convertValue(value, serverTimestampBehavior);\n        });\n        return result;\n    }\n    /**\n     * @internal\n     */\n    convertVectorValue(mapValue) {\n        var _a, _b, _c;\n        const values = (_c = (_b = (_a = mapValue.fields) === null || _a === void 0 ? void 0 : _a[VECTOR_MAP_VECTORS_KEY].arrayValue) === null || _b === void 0 ? void 0 : _b.values) === null || _c === void 0 ? void 0 : _c.map(value => {\n            return normalizeNumber(value.doubleValue);\n        });\n        return new VectorValue(values);\n    }\n    convertGeoPoint(value) {\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\n    }\n    convertArray(arrayValue, serverTimestampBehavior) {\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\n    }\n    convertServerTimestamp(value, serverTimestampBehavior) {\n        switch (serverTimestampBehavior) {\n            case 'previous':\n                const previousValue = getPreviousValue(value);\n                if (previousValue == null) {\n                    return null;\n                }\n                return this.convertValue(previousValue, serverTimestampBehavior);\n            case 'estimate':\n                return this.convertTimestamp(getLocalWriteTime(value));\n            default:\n                return null;\n        }\n    }\n    convertTimestamp(value) {\n        const normalizedValue = normalizeTimestamp(value);\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\n    }\n    convertDocumentKey(name, expectedDatabaseId) {\n        const resourcePath = ResourcePath.fromString(name);\n        hardAssert(isValidResourceName(resourcePath));\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n        const key = new DocumentKey(resourcePath.popFirst(5));\n        if (!databaseId.isEqual(expectedDatabaseId)) {\n            // TODO(b/64130202): Somehow support foreign references.\n            logError(`Document ${key} contains a document ` +\n                `reference within a different database (` +\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\n                `supported. It will be treated as a reference in the current ` +\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\n                `instead.`);\n        }\n        return key;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nfunction applyFirestoreDataConverter(converter, value, options) {\n    let convertedValue;\n    if (converter) {\n        if (options && (options.merge || options.mergeFields)) {\n            // Cast to `any` in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue = converter.toFirestore(value, options);\n        }\n        else {\n            convertedValue = converter.toFirestore(value);\n        }\n    }\n    else {\n        convertedValue = value;\n    }\n    return convertedValue;\n}\nclass LiteUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to sum across the result set.\n */\nfunction sum(field) {\n    return new AggregateField('sum', fieldPathFromArgument$1('sum', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to average across the result set.\n */\nfunction average(field) {\n    return new AggregateField('avg', fieldPathFromArgument$1('average', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nfunction count() {\n    return new AggregateField('count');\n}\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left Compare this AggregateField to the `right`.\n * @param right Compare this AggregateField to the `left`.\n */\nfunction aggregateFieldEqual(left, right) {\n    var _a, _b;\n    return (left instanceof AggregateField &&\n        right instanceof AggregateField &&\n        left.aggregateType === right.aggregateType &&\n        ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) ===\n            ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString()));\n}\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction aggregateQuerySnapshotEqual(left, right) {\n    return (queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data()));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    const object = obj;\n    for (const method of methods) {\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nclass SnapshotMetadata {\n    /** @hideconstructor */\n    constructor(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    /**\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\n     *\n     * @param other - The `SnapshotMetadata` to compare against.\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    }\n}\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot extends DocumentSnapshot$1 {\n    /** @hideconstructor protected */\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\n        super(_firestore, userDataWriter, key, document, converter);\n        this._firestore = _firestore;\n        this._firestoreImpl = _firestore;\n        this.metadata = metadata;\n    }\n    /**\n     * Returns whether or not the data exists. True if the document exists.\n     */\n    exists() {\n        return super.exists();\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document or `undefined` if\n     * the document doesn't exist.\n     */\n    data(options = {}) {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot, options);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * By default, a `serverTimestamp()` that has not yet been set to\n     * its final value will be returned as `null`. You can override this by\n     * passing an options object.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @param options - An options object to configure how the field is retrieved\n     * from the snapshot (for example the desired behavior for server timestamps\n     * that have not yet been set to their final value).\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath, options = {}) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @override\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document.\n     */\n    data(options = {}) {\n        return super.data(options);\n    }\n}\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nclass QuerySnapshot {\n    /** @hideconstructor */\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._snapshot = _snapshot;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n        this.query = query;\n    }\n    /** An array of all the documents in the `QuerySnapshot`. */\n    get docs() {\n        const result = [];\n        this.forEach(doc => result.push(doc));\n        return result;\n    }\n    /** The number of documents in the `QuerySnapshot`. */\n    get size() {\n        return this._snapshot.docs.size;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */\n    get empty() {\n        return this.size === 0;\n    }\n    /**\n     * Enumerates all of the documents in the `QuerySnapshot`.\n     *\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n     * each document in the snapshot.\n     * @param thisArg - The `this` binding for the callback.\n     */\n    forEach(callback, thisArg) {\n        this._snapshot.docs.forEach(doc => {\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\n        });\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If this\n     * is the first snapshot, all documents will be in the list as 'added'\n     * changes.\n     *\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n     * snapshot events.\n     */\n    docChanges(options = {}) {\n        const includeMetadataChanges = !!options.includeMetadataChanges;\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\n        }\n        if (!this._cachedChanges ||\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n        }\n        return this._cachedChanges;\n    }\n}\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n        let index = 0;\n        return querySnapshot._snapshot.docChanges.map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            change.doc;\n            return {\n                type: 'added',\n                doc,\n                oldIndex: -1,\n                newIndex: index++\n            };\n        });\n    }\n    else {\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        let indexTracker = querySnapshot._snapshot.oldDocs;\n        return querySnapshot._snapshot.docChanges\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\n            .map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            let oldIndex = -1;\n            let newIndex = -1;\n            if (change.type !== 0 /* ChangeType.Added */) {\n                oldIndex = indexTracker.indexOf(change.doc.key);\n                indexTracker = indexTracker.delete(change.doc.key);\n            }\n            if (change.type !== 1 /* ChangeType.Removed */) {\n                indexTracker = indexTracker.add(change.doc);\n                newIndex = indexTracker.indexOf(change.doc.key);\n            }\n            return {\n                type: resultChangeType(change.type),\n                doc,\n                oldIndex,\n                newIndex\n            };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case 0 /* ChangeType.Added */:\n            return 'added';\n        case 2 /* ChangeType.Modified */:\n        case 3 /* ChangeType.Metadata */:\n            return 'modified';\n        case 1 /* ChangeType.Removed */:\n            return 'removed';\n        default:\n            return fail();\n    }\n}\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction snapshotEqual(left, right) {\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n        return (left._firestore === right._firestore &&\n            left._key.isEqual(right._key) &&\n            (left._document === null\n                ? right._document === null\n                : left._document.isEqual(right._document)) &&\n            left._converter === right._converter);\n    }\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n        return (left._firestore === right._firestore &&\n            queryEqual(left.query, right.query) &&\n            left.metadata.isEqual(right.metadata) &&\n            left._snapshot.isEqual(right._snapshot));\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDoc(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\nclass ExpUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromCache(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \n    /* fromCache= */ true), reference.converter));\n}\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromServer(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\n        source: 'server'\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocs(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    validateHasExplicitOrderByForLimitToLast(query._query);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromCache(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromServer(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\n        source: 'server'\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\nfunction setDoc(reference, data, options) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\n    const dataReader = newUserDataReader(firestore);\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\n    return executeWrite(firestore, [mutation]);\n}\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const dataReader = newUserDataReader(firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n    let parsed;\n    if (typeof fieldOrUpdateData === 'string' ||\n        fieldOrUpdateData instanceof FieldPath) {\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\n    }\n    else {\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\n    }\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\n    return executeWrite(firestore, [mutation]);\n}\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nfunction deleteDoc(reference) {\n    const firestore = cast(reference.firestore, Firestore);\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\n    return executeWrite(firestore, mutations);\n}\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nfunction addDoc(reference, data) {\n    const firestore = cast(reference.firestore, Firestore);\n    const docRef = doc(reference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n    const dataReader = newUserDataReader(reference.firestore);\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\n    return executeWrite(firestore, [mutation]).then(() => docRef);\n}\nfunction onSnapshot(reference, ...args) {\n    var _a, _b, _c;\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\n    let options = {\n        includeMetadataChanges: false,\n        source: 'default'\n    };\n    let currArg = 0;\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n        options = args[currArg];\n        currArg++;\n    }\n    const internalOptions = {\n        includeMetadataChanges: options.includeMetadataChanges,\n        source: options.source\n    };\n    if (isPartialObserver(args[currArg])) {\n        const userObserver = args[currArg];\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\n    }\n    let observer;\n    let firestore;\n    let internalQuery;\n    if (reference instanceof DocumentReference) {\n        firestore = cast(reference.firestore, Firestore);\n        internalQuery = newQueryForPath(reference._key.path);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n    }\n    else {\n        const query = cast(reference, Query);\n        firestore = cast(query.firestore, Firestore);\n        internalQuery = query._query;\n        const userDataWriter = new ExpUserDataWriter(firestore);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n        validateHasExplicitOrderByForLimitToLast(reference._query);\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\n}\nfunction onSnapshotsInSync(firestore, arg) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const observer = isPartialObserver(arg)\n        ? arg\n        : {\n            next: arg\n        };\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\n}\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nfunction executeWrite(firestore, mutations) {\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWrite(client, mutations);\n}\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\n    const doc = snapshot.docs.get(ref._key);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction getCountFromServer(query) {\n    const countQuerySpec = {\n        count: count()\n    };\n    return getAggregateFromServer(query, countQuerySpec);\n}\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set is aggregated over.\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nfunction getAggregateFromServer(query, aggregateSpec) {\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    // Run the aggregation and convert the results\n    return firestoreClientRunAggregateQuery(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\n}\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\n    return querySnapshot;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'memory';\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        if (settings === null || settings === void 0 ? void 0 : settings.garbageCollector) {\n            this._offlineComponentProvider =\n                settings.garbageCollector._offlineComponentProvider;\n        }\n        else {\n            this._offlineComponentProvider = {\n                build: () => new LruGcMemoryOfflineComponentProvider(undefined)\n            };\n        }\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass PersistentLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'persistent';\n        let tabManager;\n        if (settings === null || settings === void 0 ? void 0 : settings.tabManager) {\n            settings.tabManager._initialize(settings);\n            tabManager = settings.tabManager;\n        }\n        else {\n            tabManager = persistentSingleTabManager(undefined);\n            tabManager._initialize(settings);\n        }\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryEagerGarbageCollectorImpl {\n    constructor() {\n        this.kind = 'memoryEager';\n        this._offlineComponentProvider = MemoryOfflineComponentProvider.provider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryLruGarbageCollectorImpl {\n    constructor(cacheSize) {\n        this.kind = 'memoryLru';\n        this._offlineComponentProvider = {\n            build: () => new LruGcMemoryOfflineComponentProvider(cacheSize)\n        };\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nfunction memoryEagerGarbageCollector() {\n    return new MemoryEagerGarbageCollectorImpl();\n}\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nfunction memoryLruGarbageCollector(settings) {\n    return new MemoryLruGarbageCollectorImpl(settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\n}\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nfunction memoryLocalCache(settings) {\n    return new MemoryLocalCacheImpl(settings);\n}\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nfunction persistentLocalCache(settings) {\n    return new PersistentLocalCacheImpl(settings);\n}\nclass SingleTabManagerImpl {\n    constructor(forceOwnership) {\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistentSingleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes, this.forceOwnership)\n        };\n    }\n}\nclass MultiTabManagerImpl {\n    constructor() {\n        this.kind = 'PersistentMultipleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes)\n        };\n    }\n}\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings Configures the created tab manager.\n */\nfunction persistentSingleTabManager(settings) {\n    return new SingleTabManagerImpl(settings === null || settings === void 0 ? void 0 : settings.forceOwnership);\n}\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nfunction persistentMultipleTabManager() {\n    return new MultiTabManagerImpl();\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_TRANSACTION_OPTIONS = {\n    maxAttempts: 5\n};\nfunction validateTransactionOptions(options) {\n    if (options.maxAttempts < 1) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nclass WriteBatch {\n    /** @hideconstructor */\n    constructor(_firestore, _commitHandler) {\n        this._firestore = _firestore;\n        this._commitHandler = _commitHandler;\n        this._mutations = [];\n        this._committed = false;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    set(documentRef, data, options) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\n        }\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    /**\n     * Commits all of the writes in this write batch as a single atomic unit.\n     *\n     * The result of these writes will only be reflected in document reads that\n     * occur after the returned promise resolves. If the client is offline, the\n     * write fails. If you would like to see local modifications or buffer writes\n     * until the client is online, use the full Firestore SDK.\n     *\n     * @returns A `Promise` resolved once all of the writes in the batch have been\n     * successfully written to the backend as an atomic unit (note that it won't\n     * resolve while you're offline).\n     */\n    commit() {\n        this._verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._commitHandler(this._mutations);\n        }\n        return Promise.resolve();\n    }\n    _verifyNotCommitted() {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    }\n}\nfunction validateReference(documentRef, firestore) {\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\n    if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction$1 {\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\n        return this._transaction.lookup([ref._key]).then(docs => {\n            if (!docs || docs.length !== 1) {\n                return fail();\n            }\n            const doc = docs[0];\n            if (doc.isFoundDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\n            }\n            else if (doc.isNoDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\n            }\n            else {\n                throw fail();\n            }\n        });\n    }\n    set(documentRef, value, options) {\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `Transaction` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction extends Transaction$1 {\n    // This class implements the same logic as the Transaction API in the Lite SDK\n    // but is subclassed in order to return its own DocumentSnapshot types.\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        super(_firestore, _transaction);\n        this._firestore = _firestore;\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\n        return super\n            .get(documentRef)\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\n        /* hasPendingWrites= */ false, \n        /* fromCache= */ false), ref.converter));\n    }\n}\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction runTransaction(firestore, updateFunction, options) {\n    firestore = cast(firestore, Firestore);\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\n    validateTransactionOptions(optionsWithDefaults);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\n */\nfunction deleteField() {\n    return new DeleteFieldValueImpl('deleteField');\n}\n/**\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\n * include a server-generated timestamp in the written data.\n */\nfunction serverTimestamp() {\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\n * value that already exists on the server. Each specified element that doesn't\n * already exist in the array will be added to the end. If the field being\n * modified is not already an array it will be overwritten with an array\n * containing exactly the specified elements.\n *\n * @param elements - The elements to union into the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`.\n */\nfunction arrayUnion(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\n}\n/**\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\n * updateDoc:1} that tells the server to remove the given elements from any\n * array value that already exists on the server. All instances of each element\n * specified will be removed from the array. If the field being modified is not\n * already an array it will be overwritten with an empty array.\n *\n * @param elements - The elements to remove from the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction arrayRemove(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\n * the given value.\n *\n * If either the operand or the current field value uses floating point\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\n * integers, values outside of JavaScript's safe number range\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\n * precision loss. Furthermore, once processed by the Firestore backend, all\n * integer operations are capped between -2^63 and 2^63-1.\n *\n * If the current field value is not of type `number`, or if the field does not\n * yet exist, the transformation sets the field to the given value.\n *\n * @param n - The value to increment by.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction increment(n) {\n    return new NumericIncrementFieldValueImpl('increment', n);\n}\n/**\n * Creates a new `VectorValue` constructed with a copy of the given array of numbers.\n *\n * @param values - Create a `VectorValue` instance with a copy of this array of numbers.\n *\n * @returns A new `VectorValue` constructed with a copy of the given array of numbers.\n */\nfunction vector(values) {\n    return new VectorValue(values);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nfunction writeBatch(firestore) {\n    firestore = cast(firestore, Firestore);\n    ensureFirestoreConfigured(firestore);\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    if (!client._uninitializedComponentsProvider ||\n        client._uninitializedComponentsProvider._offline.kind === 'memory') {\n        // PORTING NOTE: We don't return an error if the user has not enabled\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n        logWarn('Cannot enable indexes when persistence is disabled');\n        return Promise.resolve();\n    }\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\n    return firestoreClientSetIndexConfiguration(client, parsedIndexes);\n}\nfunction parseIndexes(jsonOrConfiguration) {\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\n        ? tryParseJson(jsonOrConfiguration)\n        : jsonOrConfiguration;\n    const parsedIndexes = [];\n    if (Array.isArray(indexConfiguration.indexes)) {\n        for (const index of indexConfiguration.indexes) {\n            const collectionGroup = tryGetString(index, 'collectionGroup');\n            const segments = [];\n            if (Array.isArray(index.fields)) {\n                for (const field of index.fields) {\n                    const fieldPathString = tryGetString(field, 'fieldPath');\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\n                    if (field.arrayConfig === 'CONTAINS') {\n                        segments.push(new IndexSegment(fieldPath, 2 /* IndexKind.CONTAINS */));\n                    }\n                    else if (field.order === 'ASCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 0 /* IndexKind.ASCENDING */));\n                    }\n                    else if (field.order === 'DESCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 1 /* IndexKind.DESCENDING */));\n                    }\n                }\n            }\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\n        }\n    }\n    return parsedIndexes;\n}\nfunction tryParseJson(json) {\n    try {\n        return JSON.parse(json);\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON: ' + (e === null || e === void 0 ? void 0 : e.message));\n    }\n}\nfunction tryGetString(data, property) {\n    if (typeof data[property] !== 'string') {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\n    }\n    return data[property];\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nclass PersistentCacheIndexManager {\n    /** @hideconstructor */\n    constructor(_firestore) {\n        this._firestore = _firestore;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'PersistentCacheIndexManager';\n    }\n}\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @return The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nfunction getPersistentCacheIndexManager(firestore) {\n    var _a;\n    firestore = cast(firestore, Firestore);\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n    if (cachedInstance) {\n        return cachedInstance;\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    if (((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offline.kind) !== 'persistent') {\n        return null;\n    }\n    const instance = new PersistentCacheIndexManager(firestore);\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\n    return instance;\n}\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nfunction deleteAllPersistentCacheIndexes(indexManager) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientDeleteAllFieldIndexes(client);\n    promise\n        .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\n        .catch(error => logWarn('deleting all persistent cache indexes failed', error));\n}\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled);\n    promise\n        .then(_ => logDebug(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} succeeded`))\n        .catch(error => logWarn(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} failed`, error));\n}\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns the `QueryTarget` representation of the given query. Returns `null`\n * if the Firestore client associated with the given query has not been\n * initialized or has been terminated.\n *\n * @param query - The Query to convert to proto representation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _internalQueryToProtoQueryTarget(query) {\n    var _a;\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toQueryTarget(serializer, queryToTarget(query._query)).queryTarget;\n}\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns `RunAggregationQueryRequest` which contains the proto representation\n * of the given aggregation query request. Returns null if the Firestore client\n * associated with the given query has not been initialized or has been\n * terminated.\n *\n * @param query - The Query to convert to proto representation.\n * @param aggregateSpec - The set of aggregations and their aliases.\n */\nfunction _internalAggregationQueryToProtoRunAggregationQueryRequest(query, aggregateSpec) {\n    var _a;\n    const aggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toRunAggregationQueryRequest(serializer, queryToAggregateTarget(query._query), aggregates, \n    /* skipAliasing= */ true).request;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nclass TestingHooks {\n    constructor() {\n        throw new Error('instances of this class should not be created');\n    }\n    /**\n     * Registers a callback to be notified when an existence filter mismatch\n     * occurs in the Watch listen stream.\n     *\n     * The relative order in which callbacks are notified is unspecified; do not\n     * rely on any particular ordering. If a given callback is registered multiple\n     * times then it will be notified multiple times, once per registration.\n     *\n     * @param callback the callback to invoke upon existence filter mismatch.\n     *\n     * @return a function that, when called, unregisters the given callback; only\n     * the first invocation of the returned function does anything; all subsequent\n     * invocations do nothing.\n     */\n    static onExistenceFilterMismatch(callback) {\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n    }\n}\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl {\n    constructor() {\n        this.existenceFilterMismatchCallbacksById = new Map();\n    }\n    static get instance() {\n        if (!testingHooksSpiImplInstance) {\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n            setTestingHooksSpi(testingHooksSpiImplInstance);\n        }\n        return testingHooksSpiImplInstance;\n    }\n    notifyOnExistenceFilterMismatch(info) {\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\n    }\n    onExistenceFilterMismatch(callback) {\n        const id = Symbol();\n        const callbacks = this.existenceFilterMismatchCallbacksById;\n        callbacks.set(id, callback);\n        return () => callbacks.delete(id);\n    }\n}\nlet testingHooksSpiImplInstance = null;\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNLO0FBQ3RIO0FBQ0k7QUFDSztBQUNvSDtBQUN2SDtBQUNpQjtBQUNqQztBQUNZOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkNBQU8sVUFBVSxZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHNDQUFzQyxZQUFZLEtBQUssSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0EscUNBQXFDLFlBQVksS0FBSyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxVQUFVLFVBQVUsS0FBSyxhQUFhO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0hBQWdIO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRFQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsS0FBSztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsS0FBSztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBdUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixNQUFNLDJCQUEyQixLQUFLLDhCQUE4QixZQUFZLEdBQUcsT0FBTyxhQUFhO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0EsMENBQTBDLFdBQVcsZ0JBQWdCO0FBQ3JFO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxREFBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVyxZQUFZLE1BQU07QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxREFBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxVQUFVO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEVBQUUsR0FBRyxFQUFFO0FBQ3hDO0FBQ0EsU0FBUztBQUNULGlCQUFpQixFQUFFLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBcUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQStDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsR0FBRywwQkFBMEI7QUFDNUU7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsR0FBRyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxHQUFHLG9DQUFvQztBQUNoRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQixhQUFhLG9CQUFvQixhQUFhLDJCQUEyQjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2Qyx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSxtQ0FBbUMsY0FBYyxtQkFBbUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLElBQUksYUFBYSxJQUFJLGdDQUFnQztBQUMxRixjQUFjLGNBQWMsaUJBQWlCO0FBQzdDLGNBQWMsZ0JBQWdCLG1CQUFtQjtBQUNqRCxjQUFjLGlCQUFpQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUNBQWlDLEdBQUcsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDLEVBQUUsV0FBVyxFQUFFLDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QyxZQUFZLGdCQUFnQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0RUFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0VBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0RUFBTztBQUNoQyx5QkFBeUIsNEVBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEVBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0RUFBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsMEJBQTBCLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEUsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0IsR0FBRyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksMkJBQTJCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkIsYUFBYSx1QkFBdUI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWdFO0FBQ3ZGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhLFdBQVc7QUFDckcsK0NBQStDLHlDQUF5QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2Q0FBNkM7QUFDdEYsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQSw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLHdEQUF3RCwwQkFBMEI7QUFDbEYsdUJBQXVCLHFDQUFxQztBQUM1RCxpQ0FBaUMsZ0JBQWdCO0FBQ2pELHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGtCQUFrQjtBQUNuRCx1QkFBdUIsc0NBQXNDO0FBQzdELHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBZ0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtHQUErRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZHQUE2RyxjQUFjO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUhBQXFILGNBQWM7QUFDbkk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBGQUEwRixjQUFjO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtJQUFrSSxlQUFlO0FBQ2pKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0dBQXdHLGVBQWU7QUFDdkg7QUFDQTtBQUNBLEtBQUs7QUFDTCxrR0FBa0csZUFBZTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSUFBcUksZUFBZTtBQUNwSix1SUFBdUksZUFBZTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEMsbUNBQW1DO0FBQ2pGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0VBQStFLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLElBQUksY0FBYztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxJQUFJLDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVMsSUFBSSxFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEIsR0FBRyxlQUFlLEdBQUcsUUFBUTtBQUNoRjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWUsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QixHQUFHLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkIsR0FBRyxlQUFlO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUSxLQUFLLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsU0FBUyxLQUFLLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUyxLQUFLLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRyxpREFBaUQsMEJBQTBCLEdBQUcsc0JBQXNCO0FBQ3BHLCtDQUErQyx3QkFBd0IsR0FBRyxzQkFBc0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx1QkFBdUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUIsT0FBTyxhQUFhLE9BQU8sWUFBWTtBQUN6RztBQUNBO0FBQ0EseUJBQXlCLG1EQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQyxhQUFhLGlDQUFpQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFnQjtBQUNsQyxrQkFBa0Isc0RBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsSUFBSSxVQUFVO0FBQ3RFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxJQUFJLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxFQUFFLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsV0FBVyxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxXQUFXLFVBQVU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLFdBQVcsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFFBQVEsV0FBVyxVQUFVO0FBQ3pFLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckYsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QyxFQUFFLGNBQWM7QUFDdkcsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkMsRUFBRSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvREFBb0Q7QUFDaEc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQ0FBMkM7QUFDeEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkNBQTJDLEVBQUUsY0FBYztBQUN0RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQTJDLEVBQUUsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBb0I7QUFDbEQsV0FBVyxnRUFBMEI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELHNDQUFzQywwQkFBMEI7QUFDaEUsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEcsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxJQUFJLEVBQUU7QUFDckM7QUFDQSx1REFBdUQsSUFBSSxJQUFJLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiwrQkFBK0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdEQUFnRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBNkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLG9DQUFvQyxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYSxNQUFNLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSixNQUFNLE1BQU0sWUFBWTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLE1BQU0sTUFBTSxZQUFZO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUJBQWlCLGlCQUFpQixZQUFZO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLDZDQUE2QyxFQUFFO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLHlCQUF5QjtBQUN6SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtGQUFrRjtBQUNqRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsT0FBTztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsNkJBQTZCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3QjtBQUNySCw2Q0FBNkMsaUNBQWlDO0FBQzlFO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JILDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUssR0FBRyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWUsa0NBQWtDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGFBQWE7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBLElBQUksdUJBQXVCO0FBQzNCLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSxxQkFBcUIsaUNBQWlDLGdCQUFnQixpQkFBaUI7QUFDdkY7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw2QkFBNkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdFQUF3RSxxREFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLGlGQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQixHQUFHLHdCQUF3QjtBQUNyRSxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBLHNEQUFzRDtBQUN0RCx3QkFBd0IsSUFBSSx1QkFBdUIsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVELFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUVBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBYTtBQUMvQixJQUFJLGlFQUFrQixLQUFLLDBEQUFTLDRCQUE0QixtREFBbUQ7QUFDbkg7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxrQ0FBa0MscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrQjtBQUM5QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQixHQUFHLGtCQUFrQjtBQUMxRCxnQ0FBZ0MsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RSxJQUFJLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRztBQUNsRSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsbUJBQW1CO0FBQ3pFLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLGVBQWU7QUFDeEUsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyxNQUFNLHFDQUFxQztBQUNoRiw4REFBOEQsVUFBVTtBQUN4RSxJQUFJLFdBQVcsMkJBQTJCLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQywwQkFBMEIsWUFBWSxHQUFHLFNBQVMsTUFBTSxVQUFVO0FBQ2xFLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsMEJBQTBCLFlBQVksR0FBRyxTQUFTLE1BQU0sVUFBVTtBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZSwyQkFBMkIsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakUsSUFBSSxtQkFBbUIsMkJBQTJCLGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RSxJQUFJLHNCQUFzQiwyQkFBMkIsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckUsSUFBSSxxQkFBcUIsMkJBQTJCLGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsR0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXLGdCQUFnQixnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyxxREFBcUQsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLDhGQUE4RiwwQkFBMEI7QUFDeEgseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0EsbUJBQW1CLHFCQUFxQixHQUFHLG9CQUFvQjtBQUMvRDtBQUNBLDZCQUE2Qiw2QkFBNkIsR0FBRyw0QkFBNEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5REFBUztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUIsSUFBSSx1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QixJQUFJLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLFNBQVMsdUJBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGLElBQUksMkNBQTJDLE9BQU8sWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQyxJQUFJLDhDQUE4QztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQTJDLElBQUk7QUFDakcsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0IsSUFBSTtBQUN4RSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQ0FBMkMsSUFBSTtBQUNqRywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0c0U7QUFDNXNFIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVtb3ZlU2VydmljZUluc3RhbmNlLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIFNES19WRVJTSU9OIGFzIFNES19WRVJTSU9OJDEgfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgaW5zcGVjdCwgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGRlZXBFcXVhbCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgZ2V0VUEsIGlzU2FmYXJpIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMkMSB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBJbnRlZ2VyLCBNZDUgfSBmcm9tICdAZmlyZWJhc2Uvd2ViY2hhbm5lbC13cmFwcGVyL2Jsb29tLWJsb2InO1xuaW1wb3J0ICogYXMgZ3JwYyBmcm9tICdAZ3JwYy9ncnBjLWpzJztcbmltcG9ydCAqIGFzIHByb3RvTG9hZGVyIGZyb20gJ0BncnBjL3Byb3RvLWxvYWRlcic7XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiNC43LjhcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGEgbnVsbGFibGUgVUlELiBNb3N0bHkgZXhpc3RzIHRvIG1ha2UgY29kZSBtb3JlXG4gKiByZWFkYWJsZS5cbiAqL1xuY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3IodWlkKSB7XG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgIH1cbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxuICAgICAqIGRpY3Rpb25hcnkuXG4gICAgICovXG4gICAgdG9LZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VpZDonICsgdGhpcy51aWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cy11c2VyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyVXNlcikge1xuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XG4gICAgfVxufVxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXG5Vc2VyLlVOQVVUSEVOVElDQVRFRCA9IG5ldyBVc2VyKG51bGwpO1xuLy8gVE9ETyhtaWtlbGVoZW4pOiBMb29rIGludG8gZ2V0dGluZyBhIHByb3BlciB1aWQtZXF1aXZhbGVudCBmb3Jcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxuVXNlci5HT09HTEVfQ1JFREVOVElBTFMgPSBuZXcgVXNlcignZ29vZ2xlLWNyZWRlbnRpYWxzLXVpZCcpO1xuVXNlci5GSVJTVF9QQVJUWSA9IG5ldyBVc2VyKCdmaXJzdC1wYXJ0eS11aWQnKTtcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxMS4zLjFcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBTREtfVkVSU0lPTiA9IHZlcnNpb247XG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBTREtfVkVSU0lPTiA9IHZlcnNpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogRm9ybWF0cyBhbiBvYmplY3QgYXMgYSBKU09OIHN0cmluZywgc3VpdGFibGUgZm9yIGxvZ2dpbmcuICovXG5mdW5jdGlvbiBmb3JtYXRKU09OKHZhbHVlKSB7XG4gICAgLy8gdXRpbC5pbnNwZWN0KCkgcmVzdWx0cyBpbiBtdWNoIG1vcmUgcmVhZGFibGUgb3V0cHV0IHRoYW4gSlNPTi5zdHJpbmdpZnkoKVxuICAgIHJldHVybiBpbnNwZWN0KHZhbHVlLCB7IGRlcHRoOiAxMDAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XG4vLyBIZWxwZXIgbWV0aG9kcyBhcmUgbmVlZGVkIGJlY2F1c2UgdmFyaWFibGVzIGNhbid0IGJlIGV4cG9ydGVkIGFzIHJlYWQvd3JpdGVcbmZ1bmN0aW9uIGdldExvZ0xldmVsKCkge1xuICAgIHJldHVybiBsb2dDbGllbnQubG9nTGV2ZWw7XG59XG4vKipcbiAqIFNldHMgdGhlIHZlcmJvc2l0eSBvZiBDbG91ZCBGaXJlc3RvcmUgbG9ncyAoZGVidWcsIGVycm9yLCBvciBzaWxlbnQpLlxuICpcbiAqIEBwYXJhbSBsb2dMZXZlbCAtIFRoZSB2ZXJib3NpdHkgeW91IHNldCBmb3IgYWN0aXZpdHkgYW5kIGVycm9yIGxvZ2dpbmcuIENhblxuICogICBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICogICA8dWw+XG4gKiAgICAgPGxpPmBkZWJ1Z2AgZm9yIHRoZSBtb3N0IHZlcmJvc2UgbG9nZ2luZyBsZXZlbCwgcHJpbWFyaWx5IGZvclxuICogICAgIGRlYnVnZ2luZy48L2xpPlxuICogICAgIDxsaT5gZXJyb3JgIHRvIGxvZyBlcnJvcnMgb25seS48L2xpPlxuICogICAgIDxsaT48Y29kZT5gc2lsZW50YCB0byB0dXJuIG9mZiBsb2dnaW5nLjwvbGk+XG4gKiAgIDwvdWw+XG4gKi9cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgbG9nQ2xpZW50LnNldExvZ0xldmVsKGxvZ0xldmVsKTtcbn1cbmZ1bmN0aW9uIGxvZ0RlYnVnKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5kZWJ1ZyhgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGxvZ1dhcm4obXNnLCAuLi5vYmopIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xuICAgICAgICBsb2dDbGllbnQud2FybihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBhcmdUb1N0cmluZyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SlNPTihvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0aW5nIHRvIEpTT04gZmFpbGVkLCBqdXN0IGxvZyB0aGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBVbmNvbmRpdGlvbmFsbHkgZmFpbHMsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gKlxuICogUmV0dXJucyBgbmV2ZXJgIGFuZCBjYW4gYmUgdXNlZCBpbiBleHByZXNzaW9uczpcbiAqIEBleGFtcGxlXG4gKiBsZXQgZnV0dXJlVmFyID0gZmFpbCgnbm90IGltcGxlbWVudGVkIHlldCcpO1xuICovXG5mdW5jdGlvbiBmYWlsKGZhaWx1cmUgPSAnVW5leHBlY3RlZCBzdGF0ZScpIHtcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVTVE9SRSAoJHtTREtfVkVSU0lPTn0pIElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xuICAgIGxvZ0Vycm9yKG1lc3NhZ2UpO1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlc3RvcmVFcnJvciBoZXJlIGJlY2F1c2UgdGhlc2UgYXJlIGludGVybmFsIGZhaWx1cmVzXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcbiAgICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gKi9cbmZ1bmN0aW9uIGhhcmRBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgZmFpbCgpO1xuICAgIH1cbn1cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBUaGUgY29kZSBvZiBjYWxsc2l0ZXMgaW52b2tpbmcgdGhpcyBmdW5jdGlvbiBhcmUgc3RyaXBwZWQgb3V0IGluIHByb2R1Y3Rpb25cbiAqIGJ1aWxkcy4gQW55IHNpZGUtZWZmZWN0cyBvZiBjb2RlIHdpdGhpbiB0aGUgZGVidWdBc3NlcnQoKSBpbnZvY2F0aW9uIHdpbGwgbm90XG4gKiBoYXBwZW4gaW4gdGhpcyBjYXNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWJ1Z0Fzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxufVxuLyoqXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAuIEluIG5vbi1wcm9kdWN0aW9uIGJ1aWxkcywgdmVyaWZpZXMgdGhhdCBgb2JqYCBpcyBhblxuICogaW5zdGFuY2Ugb2YgYFRgIGJlZm9yZSBjYXN0aW5nLlxuICovXG5mdW5jdGlvbiBkZWJ1Z0Nhc3Qob2JqLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBDb2RlID0ge1xuICAgIC8vIENhdXNlcyBhcmUgY29waWVkIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcbiAgICAvKiogTm90IGFuIGVycm9yOyByZXR1cm5lZCBvbiBzdWNjZXNzLiAqL1xuICAgIE9LOiAnb2snLFxuICAgIC8qKiBUaGUgb3BlcmF0aW9uIHdhcyBjYW5jZWxsZWQgKHR5cGljYWxseSBieSB0aGUgY2FsbGVyKS4gKi9cbiAgICBDQU5DRUxMRUQ6ICdjYW5jZWxsZWQnLFxuICAgIC8qKiBVbmtub3duIGVycm9yIG9yIGFuIGVycm9yIGZyb20gYSBkaWZmZXJlbnQgZXJyb3IgZG9tYWluLiAqL1xuICAgIFVOS05PV046ICd1bmtub3duJyxcbiAgICAvKipcbiAgICAgKiBDbGllbnQgc3BlY2lmaWVkIGFuIGludmFsaWQgYXJndW1lbnQuIE5vdGUgdGhhdCB0aGlzIGRpZmZlcnMgZnJvbVxuICAgICAqIEZBSUxFRF9QUkVDT05ESVRJT04uIElOVkFMSURfQVJHVU1FTlQgaW5kaWNhdGVzIGFyZ3VtZW50cyB0aGF0IGFyZVxuICAgICAqIHByb2JsZW1hdGljIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0gKGUuZy4sIGEgbWFsZm9ybWVkIGZpbGVcbiAgICAgKiBuYW1lKS5cbiAgICAgKi9cbiAgICBJTlZBTElEX0FSR1VNRU5UOiAnaW52YWxpZC1hcmd1bWVudCcsXG4gICAgLyoqXG4gICAgICogRGVhZGxpbmUgZXhwaXJlZCBiZWZvcmUgb3BlcmF0aW9uIGNvdWxkIGNvbXBsZXRlLiBGb3Igb3BlcmF0aW9ucyB0aGF0XG4gICAgICogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgc3lzdGVtLCB0aGlzIGVycm9yIG1heSBiZSByZXR1cm5lZCBldmVuIGlmIHRoZVxuICAgICAqIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gRm9yIGV4YW1wbGUsIGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxuICAgICAqIGZyb20gYSBzZXJ2ZXIgY291bGQgaGF2ZSBiZWVuIGRlbGF5ZWQgbG9uZyBlbm91Z2ggZm9yIHRoZSBkZWFkbGluZSB0b1xuICAgICAqIGV4cGlyZS5cbiAgICAgKi9cbiAgICBERUFETElORV9FWENFRURFRDogJ2RlYWRsaW5lLWV4Y2VlZGVkJyxcbiAgICAvKiogU29tZSByZXF1ZXN0ZWQgZW50aXR5IChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBOT1RfRk9VTkQ6ICdub3QtZm91bmQnLFxuICAgIC8qKlxuICAgICAqIFNvbWUgZW50aXR5IHRoYXQgd2UgYXR0ZW1wdGVkIHRvIGNyZWF0ZSAoZS5nLiwgZmlsZSBvciBkaXJlY3RvcnkpIGFscmVhZHlcbiAgICAgKiBleGlzdHMuXG4gICAgICovXG4gICAgQUxSRUFEWV9FWElTVFM6ICdhbHJlYWR5LWV4aXN0cycsXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZXhlY3V0ZSB0aGUgc3BlY2lmaWVkIG9wZXJhdGlvbi5cbiAgICAgKiBQRVJNSVNTSU9OX0RFTklFRCBtdXN0IG5vdCBiZSB1c2VkIGZvciByZWplY3Rpb25zIGNhdXNlZCBieSBleGhhdXN0aW5nXG4gICAgICogc29tZSByZXNvdXJjZSAodXNlIFJFU09VUkNFX0VYSEFVU1RFRCBpbnN0ZWFkIGZvciB0aG9zZSBlcnJvcnMpLlxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgaWYgdGhlIGNhbGxlciBjYW5ub3QgYmUgaWRlbnRpZmllZFxuICAgICAqICh1c2UgVU5BVVRIRU5USUNBVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXG4gICAgICovXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgZG9lcyBub3QgaGF2ZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmb3IgdGhlXG4gICAgICogb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIFVOQVVUSEVOVElDQVRFRDogJ3VuYXV0aGVudGljYXRlZCcsXG4gICAgLyoqXG4gICAgICogU29tZSByZXNvdXJjZSBoYXMgYmVlbiBleGhhdXN0ZWQsIHBlcmhhcHMgYSBwZXItdXNlciBxdW90YSwgb3IgcGVyaGFwcyB0aGVcbiAgICAgKiBlbnRpcmUgZmlsZSBzeXN0ZW0gaXMgb3V0IG9mIHNwYWNlLlxuICAgICAqL1xuICAgIFJFU09VUkNFX0VYSEFVU1RFRDogJ3Jlc291cmNlLWV4aGF1c3RlZCcsXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIHdhcyByZWplY3RlZCBiZWNhdXNlIHRoZSBzeXN0ZW0gaXMgbm90IGluIGEgc3RhdGUgcmVxdWlyZWQgZm9yXG4gICAgICogdGhlIG9wZXJhdGlvbidzIGV4ZWN1dGlvbi4gRm9yIGV4YW1wbGUsIGRpcmVjdG9yeSB0byBiZSBkZWxldGVkIG1heSBiZVxuICAgICAqIG5vbi1lbXB0eSwgYW4gcm1kaXIgb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gYSBub24tZGlyZWN0b3J5LCBldGMuXG4gICAgICpcbiAgICAgKiBBIGxpdG11cyB0ZXN0IHRoYXQgbWF5IGhlbHAgYSBzZXJ2aWNlIGltcGxlbWVudG9yIGluIGRlY2lkaW5nXG4gICAgICogYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELCBhbmQgVU5BVkFJTEFCTEU6XG4gICAgICogIChhKSBVc2UgVU5BVkFJTEFCTEUgaWYgdGhlIGNsaWVudCBjYW4gcmV0cnkganVzdCB0aGUgZmFpbGluZyBjYWxsLlxuICAgICAqICAoYikgVXNlIEFCT1JURUQgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkgYXQgYSBoaWdoZXItbGV2ZWxcbiAgICAgKiAgICAgIChlLmcuLCByZXN0YXJ0aW5nIGEgcmVhZC1tb2RpZnktd3JpdGUgc2VxdWVuY2UpLlxuICAgICAqICAoYykgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVudGlsXG4gICAgICogICAgICB0aGUgc3lzdGVtIHN0YXRlIGhhcyBiZWVuIGV4cGxpY2l0bHkgZml4ZWQuIEUuZy4sIGlmIGFuIFwicm1kaXJcIlxuICAgICAqICAgICAgZmFpbHMgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGlzIG5vbi1lbXB0eSwgRkFJTEVEX1BSRUNPTkRJVElPTlxuICAgICAqICAgICAgc2hvdWxkIGJlIHJldHVybmVkIHNpbmNlIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXRyeSB1bmxlc3NcbiAgICAgKiAgICAgIHRoZXkgaGF2ZSBmaXJzdCBmaXhlZCB1cCB0aGUgZGlyZWN0b3J5IGJ5IGRlbGV0aW5nIGZpbGVzIGZyb20gaXQuXG4gICAgICogIChkKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHBlcmZvcm1zIGNvbmRpdGlvbmFsXG4gICAgICogICAgICBSRVNUIEdldC9VcGRhdGUvRGVsZXRlIG9uIGEgcmVzb3VyY2UgYW5kIHRoZSByZXNvdXJjZSBvbiB0aGVcbiAgICAgKiAgICAgIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgY29uZGl0aW9uLiBFLmcuLCBjb25mbGljdGluZ1xuICAgICAqICAgICAgcmVhZC1tb2RpZnktd3JpdGUgb24gdGhlIHNhbWUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgRkFJTEVEX1BSRUNPTkRJVElPTjogJ2ZhaWxlZC1wcmVjb25kaXRpb24nLFxuICAgIC8qKlxuICAgICAqIFRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQsIHR5cGljYWxseSBkdWUgdG8gYSBjb25jdXJyZW5jeSBpc3N1ZSBsaWtlXG4gICAgICogc2VxdWVuY2VyIGNoZWNrIGZhaWx1cmVzLCB0cmFuc2FjdGlvbiBhYm9ydHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cbiAgICAgKi9cbiAgICBBQk9SVEVEOiAnYWJvcnRlZCcsXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIHdhcyBhdHRlbXB0ZWQgcGFzdCB0aGUgdmFsaWQgcmFuZ2UuIEUuZy4sIHNlZWtpbmcgb3IgcmVhZGluZ1xuICAgICAqIHBhc3QgZW5kIG9mIGZpbGUuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgSU5WQUxJRF9BUkdVTUVOVCwgdGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBwcm9ibGVtIHRoYXQgbWF5IGJlIGZpeGVkXG4gICAgICogaWYgdGhlIHN5c3RlbSBzdGF0ZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSAzMi1iaXQgZmlsZSBzeXN0ZW0gd2lsbFxuICAgICAqIGdlbmVyYXRlIElOVkFMSURfQVJHVU1FTlQgaWYgYXNrZWQgdG8gcmVhZCBhdCBhbiBvZmZzZXQgdGhhdCBpcyBub3QgaW4gdGhlXG4gICAgICogcmFuZ2UgWzAsMl4zMi0xXSwgYnV0IGl0IHdpbGwgZ2VuZXJhdGUgT1VUX09GX1JBTkdFIGlmIGFza2VkIHRvIHJlYWQgZnJvbVxuICAgICAqIGFuIG9mZnNldCBwYXN0IHRoZSBjdXJyZW50IGZpbGUgc2l6ZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGEgZmFpciBiaXQgb2Ygb3ZlcmxhcCBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04gYW5kXG4gICAgICogT1VUX09GX1JBTkdFLiBXZSByZWNvbW1lbmQgdXNpbmcgT1VUX09GX1JBTkdFICh0aGUgbW9yZSBzcGVjaWZpYyBlcnJvcilcbiAgICAgKiB3aGVuIGl0IGFwcGxpZXMgc28gdGhhdCBjYWxsZXJzIHdobyBhcmUgaXRlcmF0aW5nIHRocm91Z2ggYSBzcGFjZSBjYW5cbiAgICAgKiBlYXNpbHkgbG9vayBmb3IgYW4gT1VUX09GX1JBTkdFIGVycm9yIHRvIGRldGVjdCB3aGVuIHRoZXkgYXJlIGRvbmUuXG4gICAgICovXG4gICAgT1VUX09GX1JBTkdFOiAnb3V0LW9mLXJhbmdlJyxcbiAgICAvKiogT3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBvciBub3Qgc3VwcG9ydGVkL2VuYWJsZWQgaW4gdGhpcyBzZXJ2aWNlLiAqL1xuICAgIFVOSU1QTEVNRU5URUQ6ICd1bmltcGxlbWVudGVkJyxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvcnMuIE1lYW5zIHNvbWUgaW52YXJpYW50cyBleHBlY3RlZCBieSB1bmRlcmx5aW5nIFN5c3RlbSBoYXNcbiAgICAgKiBiZWVuIGJyb2tlbi4gSWYgeW91IHNlZSBvbmUgb2YgdGhlc2UgZXJyb3JzLCBTb21ldGhpbmcgaXMgdmVyeSBicm9rZW4uXG4gICAgICovXG4gICAgSU5URVJOQUw6ICdpbnRlcm5hbCcsXG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBUaGlzIGlzIGEgbW9zdCBsaWtlbHkgYSB0cmFuc2llbnRcbiAgICAgKiBjb25kaXRpb24gYW5kIG1heSBiZSBjb3JyZWN0ZWQgYnkgcmV0cnlpbmcgd2l0aCBhIGJhY2tvZmYuXG4gICAgICpcbiAgICAgKiBTZWUgbGl0bXVzIHRlc3QgYWJvdmUgZm9yIGRlY2lkaW5nIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCxcbiAgICAgKiBhbmQgVU5BVkFJTEFCTEUuXG4gICAgICovXG4gICAgVU5BVkFJTEFCTEU6ICd1bmF2YWlsYWJsZScsXG4gICAgLyoqIFVucmVjb3ZlcmFibGUgZGF0YSBsb3NzIG9yIGNvcnJ1cHRpb24uICovXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xufTtcbi8qKiBBbiBlcnJvciByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBvcGVyYXRpb24uICovXG5jbGFzcyBGaXJlc3RvcmVFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tlbmQgZXJyb3IgY29kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlcnJvci5cbiAgICAgKi9cbiAgICBjb2RlLCBcbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSBlcnJvciBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAvLyBIQUNLOiBXZSB3cml0ZSBhIHRvU3RyaW5nIHByb3BlcnR5IGRpcmVjdGx5IGJlY2F1c2UgRXJyb3IgaXMgbm90IGEgcmVhbFxuICAgICAgICAvLyBjbGFzcyBhbmQgc28gaW5oZXJpdGFuY2UgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkuIFdlIGNvdWxkIGFsdGVybmF0aXZlbHlcbiAgICAgICAgLy8gZG8gdGhlIHNhbWUgXCJiYWNrLWRvb3IgaW5oZXJpdGFuY2VcIiB0cmljayB0aGF0IEZpcmViYXNlRXJyb3IgZG9lcy5cbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMubmFtZX06IFtjb2RlPSR7dGhpcy5jb2RlfV06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE9BdXRoVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdPQXV0aCc7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt2YWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcihVc2VyLlVOQVVUSEVOVElDQVRFRCkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxufVxuLyoqXG4gKiBBIENyZWRlbnRpYWxzUHJvdmlkZXIgdGhhdCBhbHdheXMgcmV0dXJucyBhIGNvbnN0YW50IHRva2VuLiBVc2VkIGZvclxuICogZW11bGF0b3IgdG9rZW4gbW9ja2luZy5cbiAqL1xuY2xhc3MgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggc2V0Q2hhbmdlTGlzdGVuZXIoKVxuICAgICAgICAgKiBUaGlzIGlzbid0IGFjdHVhbGx5IG5lY2Vzc2FyeSBzaW5jZSB0aGUgVUlEIG5ldmVyIGNoYW5nZXMsIGJ1dCB3ZSB1c2UgdGhpc1xuICAgICAgICAgKiB0byB2ZXJpZnkgdGhlIGxpc3RlbiBjb250cmFjdCBpcyBhZGhlcmVkIHRvIGluIHRlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW4pO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gY2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcih0aGlzLnRva2VuLnVzZXIpKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhQcm92aWRlcikge1xuICAgICAgICB0aGlzLmF1dGhQcm92aWRlciA9IGF1dGhQcm92aWRlcjtcbiAgICAgICAgLyoqIFRyYWNrcyB0aGUgY3VycmVudCBVc2VyLiAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gVXNlci5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudGVyIHVzZWQgdG8gZGV0ZWN0IGlmIHRoZSB0b2tlbiBjaGFuZ2VkIHdoaWxlIGEgZ2V0VG9rZW4gcmVxdWVzdCB3YXNcbiAgICAgICAgICogb3V0c3RhbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy50b2tlbkxpc3RlbmVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgbGFzdFRva2VuSWQgPSB0aGlzLnRva2VuQ291bnRlcjtcbiAgICAgICAgLy8gQSBjaGFuZ2UgbGlzdGVuZXIgdGhhdCBwcmV2ZW50cyBkb3VibGUtZmlyaW5nIGZvciB0aGUgc2FtZSB0b2tlbiBjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lciA9IHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBsYXN0VG9rZW5JZCkge1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbklkID0gdGhpcy50b2tlbkNvdW50ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUxpc3RlbmVyKHVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBBIHByb21pc2UgdGhhdCBjYW4gYmUgd2FpdGVkIG9uIHRvIGJsb2NrIG9uIHRoZSBuZXh0IHRva2VuIGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBwcm9taXNlIGlzIHJlLWNyZWF0ZWQgYWZ0ZXIgZWFjaCBjaGFuZ2UuXG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2tlbkNvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgICAgIG5leHRUb2tlbi5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhd2FpdE5leHRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbkF0dGVtcHQgPSBuZXh0VG9rZW47XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUb2tlbkF0dGVtcHQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCBndWFyZGVkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBdXRoID0gKGF1dGgpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ0F1dGggZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoLmFkZEF1dGhUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIub25Jbml0KGF1dGggPT4gcmVnaXN0ZXJBdXRoKGF1dGgpKTtcbiAgICAgICAgLy8gT3VyIHVzZXJzIGNhbiBpbml0aWFsaXplIEF1dGggcmlnaHQgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrIGJlZm9yZSB3ZVxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0byBzdGFydCB1cCBpbiB1bmF1dGhlbnRpY2F0ZWQgbW9kZS5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGggPSB0aGlzLmF1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckF1dGgoYXV0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aCBgbnVsbGAgdXNlclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdBdXRoIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIC8vIFRha2Ugbm90ZSBvZiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdG9rZW5Db3VudGVyIHNvIHRoYXQgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gY2FuIGZhaWwgKHdpdGggYW4gQUJPUlRFRCBlcnJvcikgaWYgdGhlcmUgaXMgYSB0b2tlbiBjaGFuZ2Ugd2hpbGUgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgaXMgb3V0c3RhbmRpbmcuXG4gICAgICAgIGNvbnN0IGluaXRpYWxUb2tlbkNvdW50ZXIgPSB0aGlzLnRva2VuQ291bnRlcjtcbiAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVJlZnJlc2g7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5hdXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3Qgc2luY2UgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgdGhlIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAvLyBvdXRzdGFuZGluZyBzbyB0aGUgcmVzcG9uc2UgaXMgcG90ZW50aWFsbHkgZm9yIGEgcHJldmlvdXMgdXNlciAod2hpY2hcbiAgICAgICAgICAgIC8vIHVzZXIsIHdlIGNhbid0IGJlIHN1cmUpLlxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBpbml0aWFsVG9rZW5Db3VudGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnZ2V0VG9rZW4gYWJvcnRlZCBkdWUgdG8gdG9rZW4gY2hhbmdlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuRGF0YS5hY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoVG9rZW4odG9rZW5EYXRhLmFjY2Vzc1Rva2VuLCB0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aCAmJiB0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQXV0aC5nZXRVaWQoKSBjYW4gcmV0dXJuIG51bGwgZXZlbiB3aXRoIGEgdXNlciBsb2dnZWQgaW4uIEl0IGlzIGJlY2F1c2VcbiAgICAvLyBnZXRVaWQoKSBpcyBzeW5jaHJvbm91cywgYnV0IHRoZSBhdXRoIGNvZGUgcG9wdWxhdGluZyBVaWQgaXMgYXN5bmNocm9ub3VzLlxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgQXV0aFRva2VuTGlzdGVuZXIgY2FsbGJhY2tcbiAgICAvLyB0byBndWFyYW50ZWUgdG8gZ2V0IHRoZSBhY3R1YWwgdXNlci5cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gdGhpcy5hdXRoICYmIHRoaXMuYXV0aC5nZXRVaWQoKTtcbiAgICAgICAgaGFyZEFzc2VydChjdXJyZW50VWlkID09PSBudWxsIHx8IHR5cGVvZiBjdXJyZW50VWlkID09PSAnc3RyaW5nJyk7XG4gICAgICAgIHJldHVybiBuZXcgVXNlcihjdXJyZW50VWlkKTtcbiAgICB9XG59XG4vKlxuICogRmlyc3RQYXJ0eVRva2VuIHByb3ZpZGVzIGEgZnJlc2ggdG9rZW4gZWFjaCB0aW1lIGl0cyB2YWx1ZVxuICogaXMgcmVxdWVzdGVkLCBiZWNhdXNlIGlmIHRoZSB0b2tlbiBpcyB0b28gb2xkLCByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkLlxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XG4gKiByZWNvdmVyIGZyb20gdW5hdXRoZW50aWNhdGVkIGVycm9ycyAoc2VlIGIvMzMxNDc4MTggZm9yIGNvbnRleHQpLCBidXQgaXQnc1xuICogc2FmZXIgdG8ga2VlcCB0aGUgaW1wbGVtZW50YXRpb24gYXMtaXMuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlUb2tlbiB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSAnRmlyc3RQYXJ0eSc7XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuRklSU1RfUEFSVFk7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgdXNpbmcgYSBwcm92aWRlZCBmYWN0b3J5IGZ1bmN0aW9uLCBvciByZXR1cm5cbiAgICAgKiBudWxsLlxuICAgICAqL1xuICAgIGdldEF1dGhUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFRva2VuRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctQXV0aFVzZXInLCB0aGlzLnNlc3Npb25JbmRleCk7XG4gICAgICAgIC8vIFVzZSBhcnJheSBub3RhdGlvbiB0byBwcmV2ZW50IG1pbmlmaWNhdGlvblxuICAgICAgICBjb25zdCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSA9IHRoaXMuZ2V0QXV0aFRva2VuKCk7XG4gICAgICAgIGlmIChhdXRoSGVhZGVyVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWFtVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCB0aGlzLmlhbVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVycztcbiAgICB9XG59XG4vKlxuICogUHJvdmlkZXMgdXNlciBjcmVkZW50aWFscyByZXF1aXJlZCBmb3IgdGhlIEZpcmVzdG9yZSBKYXZhU2NyaXB0IFNES1xuICogdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCB1c2luZyB0ZWNobmlxdWUgdGhhdCBpcyBvbmx5IGF2YWlsYWJsZVxuICogdG8gYXBwbGljYXRpb25zIGhvc3RlZCBieSBHb29nbGUuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlyc3RQYXJ0eVRva2VuKHRoaXMuc2Vzc2lvbkluZGV4LCB0aGlzLmlhbVRva2VuLCB0aGlzLmF1dGhUb2tlbkZhY3RvcnkpKTtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdWlkLlxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5GSVJTVF9QQVJUWSkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxufVxuY2xhc3MgQXBwQ2hlY2tUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSAnQXBwQ2hlY2snO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCd4LWZpcmViYXNlLWFwcGNoZWNrJywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBhcHBDaGVja1Byb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlciA9IGFwcENoZWNrUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlckFwcEFwcENoZWNrVG9rZW4gPSBudWxsO1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXBwKSAmJiBhcHAuc2V0dGluZ3MuYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBcHBBcHBDaGVja1Rva2VuID0gYXBwLnNldHRpbmdzLmFwcENoZWNrVG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnRva2VuTGlzdGVuZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG9uVG9rZW5DaGFuZ2VkID0gdG9rZW5SZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVzdWx0LmVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgRXJyb3IgZ2V0dGluZyBBcHAgQ2hlY2sgdG9rZW47IHVzaW5nIHBsYWNlaG9sZGVyIHRva2VuIGluc3RlYWQuIEVycm9yOiAke3Rva2VuUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlblVwZGF0ZWQgPSB0b2tlblJlc3VsdC50b2tlbiAhPT0gdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gdG9rZW5SZXN1bHQudG9rZW47XG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgUmVjZWl2ZWQgJHt0b2tlblVwZGF0ZWQgPyAnbmV3JyA6ICdleGlzdGluZyd9IHRva2VuLmApO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuVXBkYXRlZFxuICAgICAgICAgICAgICAgID8gY2hhbmdlTGlzdGVuZXIodG9rZW5SZXN1bHQudG9rZW4pXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKHRva2VuUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gb25Ub2tlbkNoYW5nZWQodG9rZW5SZXN1bHQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBcHBDaGVjayA9IChhcHBDaGVjaykgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2s7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVjay5hZGRUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlci5vbkluaXQoYXBwQ2hlY2sgPT4gcmVnaXN0ZXJBcHBDaGVjayhhcHBDaGVjaykpO1xuICAgICAgICAvLyBPdXIgdXNlcnMgY2FuIGluaXRpYWxpemUgQXBwQ2hlY2sgYWZ0ZXIgRmlyZXN0b3JlLCBzbyB3ZSBnaXZlIGl0XG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5hcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhcHBDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIEFwcENoZWNrIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aG91dCBpdC5cbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQXBwQXBwQ2hlY2tUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXBwQ2hlY2tUb2tlbih0aGlzLnNlcnZlckFwcEFwcENoZWNrVG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlUmVmcmVzaDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwcENoZWNrLmdldFRva2VuKGZvcmNlUmVmcmVzaCkudGhlbih0b2tlblJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiB0b2tlblJlc3VsdC50b2tlbiA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IHRva2VuUmVzdWx0LnRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXBwQ2hlY2tUb2tlbih0b2tlblJlc3VsdC50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2sgJiYgdGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrLnJlbW92ZVRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBBcHBDaGVjayB0b2tlbiBwcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcHBDaGVja1Rva2VuKCcnKSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7IH1cbiAgICBzaHV0ZG93bigpIHsgfVxufVxuLyoqXG4gKiBCdWlsZHMgYSBDcmVkZW50aWFsc1Byb3ZpZGVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZlxuICogdGhlIGNyZWRlbnRpYWxzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzKSB7XG4gICAgaWYgKCFjcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgc3dpdGNoIChjcmVkZW50aWFsc1sndHlwZSddKSB7XG4gICAgICAgIGNhc2UgJ2ZpcnN0UGFydHknOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXJzdFBhcnR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHNbJ3Nlc3Npb25JbmRleCddIHx8ICcwJywgY3JlZGVudGlhbHNbJ2lhbVRva2VuJ10gfHwgbnVsbCwgY3JlZGVudGlhbHNbJ2F1dGhUb2tlbkZhY3RvcnknXSB8fCBudWxsKTtcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWxzWydjbGllbnQnXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgZmFpbGVkIGR1ZSB0byBpbnZhbGlkIGNyZWRlbnRpYWwgdHlwZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGBuQnl0ZXNgIG9mIHJhbmRvbSBieXRlcy5cbiAqXG4gKiBJZiBgbkJ5dGVzIDwgMGAgLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobkJ5dGVzKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzJDEobkJ5dGVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBhbHBoYW51bWVyaWMgSURzIG9mIGEgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEV4cG9ydGVkIGludGVybmFsbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKi9cbmNsYXNzIEF1dG9JZCB7XG4gICAgc3RhdGljIG5ld0lkKCkge1xuICAgICAgICAvLyBBbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gICAgICAgIC8vIFRoZSBsYXJnZXN0IGJ5dGUgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIGBjaGFyLmxlbmd0aGAuXG4gICAgICAgIGNvbnN0IG1heE11bHRpcGxlID0gTWF0aC5mbG9vcigyNTYgLyBjaGFycy5sZW5ndGgpICogY2hhcnMubGVuZ3RoO1xuICAgICAgICBsZXQgYXV0b0lkID0gJyc7XG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IDIwO1xuICAgICAgICB3aGlsZSAoYXV0b0lkLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByYW5kb21CeXRlcyg0MCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhY2NlcHQgdmFsdWVzIHRoYXQgYXJlIFswLCBtYXhNdWx0aXBsZSksIHRoaXMgZW5zdXJlcyB0aGV5IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIGV2ZW5seSBtYXBwZWQgdG8gaW5kaWNlcyBvZiBgY2hhcnNgIHZpYSBhIG1vZHVsbyBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGggJiYgYnl0ZXNbaV0gPCBtYXhNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvSWQgKz0gY2hhcnMuY2hhckF0KGJ5dGVzW2ldICUgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dG9JZDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqIEhlbHBlciB0byBjb21wYXJlIGFycmF5cyB1c2luZyBpc0VxdWFsKCkuICovXG5mdW5jdGlvbiBhcnJheUVxdWFscyhsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xuICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gY29tcGFyYXRvcih2YWx1ZSwgcmlnaHRbaW5kZXhdKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGltbWVkaWF0ZSBsZXhpY29ncmFwaGljYWxseS1mb2xsb3dpbmcgc3RyaW5nLiBUaGlzIGlzIHVzZWZ1bCB0b1xuICogY29uc3RydWN0IGFuIGluY2x1c2l2ZSByYW5nZSBmb3IgaW5kZXhlZGRiIGl0ZXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gaW1tZWRpYXRlU3VjY2Vzc29yKHMpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGlucHV0IHN0cmluZywgd2l0aCBhbiBhZGRpdGlvbmFsIE5VTCBieXRlIGFwcGVuZGVkLlxuICAgIHJldHVybiBzICsgJ1xcMCc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUaGUgZWFybGllc3QgZGF0ZSBzdXBwb3J0ZWQgYnkgRmlyZXN0b3JlIHRpbWVzdGFtcHMgKDAwMDEtMDEtMDFUMDA6MDA6MDBaKS5cbmNvbnN0IE1JTl9TRUNPTkRTID0gLTYyMTM1NTk2ODAwO1xuLy8gTnVtYmVyIG9mIG5hbm9zZWNvbmRzIGluIGEgbWlsbGlzZWNvbmQuXG5jb25zdCBNU19UT19OQU5PUyA9IDFlNjtcbi8qKlxuICogQSBgVGltZXN0YW1wYCByZXByZXNlbnRzIGEgcG9pbnQgaW4gdGltZSBpbmRlcGVuZGVudCBvZiBhbnkgdGltZSB6b25lIG9yXG4gKiBjYWxlbmRhciwgcmVwcmVzZW50ZWQgYXMgc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXQgbmFub3NlY29uZFxuICogcmVzb2x1dGlvbiBpbiBVVEMgRXBvY2ggdGltZS5cbiAqXG4gKiBJdCBpcyBlbmNvZGVkIHVzaW5nIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLiBJdCBpcyBlbmNvZGVkIGFzc3VtaW5nIGFsbCBtaW51dGVzXG4gKiBhcmUgNjAgc2Vjb25kcyBsb25nLCBpLmUuIGxlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwIHNlY29uZFxuICogdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbi4gUmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICogOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLlxuICpcbiAqIEZvciBleGFtcGxlcyBhbmQgZnVydGhlciBzcGVjaWZpY2F0aW9ucywgcmVmZXIgdG8gdGhlXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi9ibG9iL21hc3Rlci9zcmMvZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byB8IFRpbWVzdGFtcCBkZWZpbml0aW9ufS5cbiAqL1xuY2xhc3MgVGltZXN0YW1wIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCB3aXRoIHRoZSBjdXJyZW50IGRhdGUsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBuZXcgdGltZXN0YW1wIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBub3coKSB7XG4gICAgICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbU1pbGxpcyhEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gaW5pdGlhbGl6ZSB0aGUgYFRpbWVzdGFtcGAgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoZGF0ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbGxpc2Vjb25kcyAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgVW5peCBlcG9jaFxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IG5hbm9zID0gTWF0aC5mbG9vcigobWlsbGlzZWNvbmRzIC0gc2Vjb25kcyAqIDEwMDApICogTVNfVE9fTkFOT1MpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChzZWNvbmRzLCBuYW5vcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogICAgIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAgICAgKiBAcGFyYW0gbmFub3NlY29uZHMgLSBUaGUgbm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kXG4gICAgICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gICAgICogICAgIG5vbi1uZWdhdGl2ZSBuYW5vc2Vjb25kcyB2YWx1ZXMgdGhhdCBjb3VudCBmb3J3YXJkIGluIHRpbWUuIE11c3QgYmVcbiAgICAgKiAgICAgZnJvbSAwIHRvIDk5OSw5OTksOTk5IGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKi9cbiAgICBzZWNvbmRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4qXG4gICAgICovXG4gICAgbmFub3NlY29uZHMpIHtcbiAgICAgICAgdGhpcy5zZWNvbmRzID0gc2Vjb25kcztcbiAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzO1xuICAgICAgICBpZiAobmFub3NlY29uZHMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIG5hbm9zZWNvbmRzIG91dCBvZiByYW5nZTogJyArIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFub3NlY29uZHMgPj0gMWU5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIG5hbm9zZWNvbmRzIG91dCBvZiByYW5nZTogJyArIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kcyA8IE1JTl9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJyZWFrIGluIHRoZSB5ZWFyIDEwLDAwMC5cbiAgICAgICAgaWYgKHNlY29uZHMgPj0gMjUzNDAyMzAwODAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdC4gVGhpcyBjb252ZXJzaW9uXG4gICAgICogY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24gc2luY2UgYERhdGVgIG9iamVjdHMgb25seSBzdXBwb3J0IG1pbGxpc2Vjb25kXG4gICAgICogcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzXG4gICAgICogICAgIHRoaXMgYFRpbWVzdGFtcGAsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxuICAgICAqL1xuICAgIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudG9NaWxsaXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBudW1lcmljIHRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgICogZXBvY2gpLiBUaGlzIG9wZXJhdGlvbiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwb2ludCBpbiB0aW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyB0aW1lc3RhbXAsIHJlcHJlc2VudGVkIGFzXG4gICAgICogICAgIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICovXG4gICAgdG9NaWxsaXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKiAxMDAwICsgdGhpcy5uYW5vc2Vjb25kcyAvIE1TX1RPX05BTk9TO1xuICAgIH1cbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMgPT09IG90aGVyLnNlY29uZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMubmFub3NlY29uZHMsIG90aGVyLm5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLnNlY29uZHMsIG90aGVyLnNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgVGltZXN0YW1wYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBUaW1lc3RhbXBgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIuc2Vjb25kcyA9PT0gdGhpcy5zZWNvbmRzICYmIG90aGVyLm5hbm9zZWNvbmRzID09PSB0aGlzLm5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoJ1RpbWVzdGFtcChzZWNvbmRzPScgK1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRzICtcbiAgICAgICAgICAgICcsIG5hbm9zZWNvbmRzPScgK1xuICAgICAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyArXG4gICAgICAgICAgICAnKScpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzZWNvbmRzOiB0aGlzLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aGlzLm5hbm9zZWNvbmRzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgb2JqZWN0IHRvIGEgcHJpbWl0aXZlIHN0cmluZywgd2hpY2ggYWxsb3dzIGBUaW1lc3RhbXBgIG9iamVjdHNcbiAgICAgKiB0byBiZSBjb21wYXJlZCB1c2luZyB0aGUgYD5gLCBgPD1gLCBgPj1gIGFuZCBgPmAgb3BlcmF0b3JzLlxuICAgICAqL1xuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gPHNlY29uZHM+LjxuYW5vc2Vjb25kcz4gd2hlcmVcbiAgICAgICAgLy8gPHNlY29uZHM+IGlzIHRyYW5zbGF0ZWQgdG8gaGF2ZSBhIG5vbi1uZWdhdGl2ZSB2YWx1ZSBhbmQgYm90aCA8c2Vjb25kcz5cbiAgICAgICAgLy8gYW5kIDxuYW5vc2Vjb25kcz4gYXJlIGxlZnQtcGFkZGVkIHdpdGggemVyb2VzIHRvIGJlIGEgY29uc2lzdGVudCBsZW5ndGguXG4gICAgICAgIC8vIFN0cmluZ3Mgd2l0aCB0aGlzIGZvcm1hdCB0aGVuIGhhdmUgYSBsZXhpY29ncmFwaGljYWwgb3JkZXJpbmcgdGhhdCBtYXRjaGVzXG4gICAgICAgIC8vIHRoZSBleHBlY3RlZCBvcmRlcmluZy4gVGhlIDxzZWNvbmRzPiB0cmFuc2xhdGlvbiBpcyBkb25lIHRvIGF2b2lkIGhhdmluZ1xuICAgICAgICAvLyBhIGxlYWRpbmcgbmVnYXRpdmUgc2lnbiAoaS5lLiBhIGxlYWRpbmcgJy0nIGNoYXJhY3RlcikgaW4gaXRzIHN0cmluZ1xuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2hpY2ggd291bGQgYWZmZWN0IGl0cyBsZXhpY29ncmFwaGljYWwgb3JkZXJpbmcuXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2Vjb25kcyA9IHRoaXMuc2Vjb25kcyAtIE1JTl9TRUNPTkRTO1xuICAgICAgICAvLyBOb3RlOiBVcCB0byAxMiBkZWNpbWFsIGRpZ2l0cyBhcmUgcmVxdWlyZWQgdG8gcmVwcmVzZW50IGFsbCB2YWxpZFxuICAgICAgICAvLyAnc2Vjb25kcycgdmFsdWVzLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRTZWNvbmRzID0gU3RyaW5nKGFkanVzdGVkU2Vjb25kcykucGFkU3RhcnQoMTIsICcwJyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE5hbm9zZWNvbmRzID0gU3RyaW5nKHRoaXMubmFub3NlY29uZHMpLnBhZFN0YXJ0KDksICcwJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTZWNvbmRzICsgJy4nICsgZm9ybWF0dGVkTmFub3NlY29uZHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHZlcnNpb25cbiAqIHRpbWVzdGFtcCwgc3VjaCBhcyB1cGRhdGVfdGltZSBvciByZWFkX3RpbWUuXG4gKi9cbmNsYXNzIFNuYXBzaG90VmVyc2lvbiB7XG4gICAgc3RhdGljIGZyb21UaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24odmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgbWluKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbihuZXcgVGltZXN0YW1wKDAsIDApKTtcbiAgICB9XG4gICAgc3RhdGljIG1heCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24obmV3IFRpbWVzdGFtcCgyNTM0MDIzMDA3OTksIDFlOSAtIDEpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLl9jb21wYXJlVG8ob3RoZXIudGltZXN0YW1wKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuaXNFcXVhbChvdGhlci50aW1lc3RhbXApO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVyc2lvbiBmb3IgdXNlIGluIHNwZWMgdGVzdHMuICovXG4gICAgdG9NaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gbWljcm9zZWNvbmRzLlxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuc2Vjb25kcyAqIDFlNiArIHRoaXMudGltZXN0YW1wLm5hbm9zZWNvbmRzIC8gMTAwMDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnU25hcHNob3RWZXJzaW9uKCcgKyB0aGlzLnRpbWVzdGFtcC50b1N0cmluZygpICsgJyknO1xuICAgIH1cbiAgICB0b1RpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERPQ1VNRU5UX0tFWV9OQU1FID0gJ19fbmFtZV9fJztcbi8qKlxuICogUGF0aCByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2Ygc3RyaW5nIHNlZ21lbnRzLlxuICovXG5jbGFzcyBCYXNlUGF0aCB7XG4gICAgY29uc3RydWN0b3Ioc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPiBzZWdtZW50cy5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxlbiA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBCYXNlUGF0aC5jb21wYXJhdG9yKHRoaXMsIG90aGVyKSA9PT0gMDtcbiAgICB9XG4gICAgY2hpbGQobmFtZU9yUGF0aCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XG4gICAgICAgIGlmIChuYW1lT3JQYXRoIGluc3RhbmNlb2YgQmFzZVBhdGgpIHtcbiAgICAgICAgICAgIG5hbWVPclBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5hbWVPclBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdChzZWdtZW50cyk7XG4gICAgfVxuICAgIC8qKiBUaGUgaW5kZXggb2Ygb25lIHBhc3QgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgcGF0aC4gKi9cbiAgICBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvcEZpcnN0KHNpemUpIHtcbiAgICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IDEgOiBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQgKyBzaXplLCB0aGlzLmxlbmd0aCAtIHNpemUpO1xuICAgIH1cbiAgICBwb3BMYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGZpcnN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXRdO1xuICAgIH1cbiAgICBsYXN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLm9mZnNldCArIGluZGV4XTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1ByZWZpeE9mKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBvdGhlci5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzSW1tZWRpYXRlUGFyZW50T2YocG90ZW50aWFsQ2hpbGQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICsgMSAhPT0gcG90ZW50aWFsQ2hpbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IHBvdGVudGlhbENoaWxkLmdldChpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vZmZzZXQsIGVuZCA9IHRoaXMubGltaXQoKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBmbih0aGlzLnNlZ21lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSAyIHBhdGhzIHNlZ21lbnQgYnkgc2VnbWVudCwgcHJpb3JpdGl6aW5nIG51bWVyaWMgSURzXG4gICAgICogKGUuZy4sIFwiX19pZDEyM19fXCIpIGluIG51bWVyaWMgYXNjZW5kaW5nIG9yZGVyLCBmb2xsb3dlZCBieSBzdHJpbmdcbiAgICAgKiBzZWdtZW50cyBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmF0b3IocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHAxLmxlbmd0aCwgcDIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IEJhc2VQYXRoLmNvbXBhcmVTZWdtZW50cyhwMS5nZXQoaSksIHAyLmdldChpKSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24ocDEubGVuZ3RoIC0gcDIubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmVTZWdtZW50cyhsaHMsIHJocykge1xuICAgICAgICBjb25zdCBpc0xoc051bWVyaWMgPSBCYXNlUGF0aC5pc051bWVyaWNJZChsaHMpO1xuICAgICAgICBjb25zdCBpc1Joc051bWVyaWMgPSBCYXNlUGF0aC5pc051bWVyaWNJZChyaHMpO1xuICAgICAgICBpZiAoaXNMaHNOdW1lcmljICYmICFpc1Joc051bWVyaWMpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgbGhzIGlzIG51bWVyaWNcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNMaHNOdW1lcmljICYmIGlzUmhzTnVtZXJpYykge1xuICAgICAgICAgICAgLy8gT25seSByaHMgaXMgbnVtZXJpY1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMaHNOdW1lcmljICYmIGlzUmhzTnVtZXJpYykge1xuICAgICAgICAgICAgLy8gYm90aCBudW1lcmljXG4gICAgICAgICAgICByZXR1cm4gQmFzZVBhdGguZXh0cmFjdE51bWVyaWNJZChsaHMpLmNvbXBhcmUoQmFzZVBhdGguZXh0cmFjdE51bWVyaWNJZChyaHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJvdGggbm9uLW51bWVyaWNcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGhzID4gcmhzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBzZWdtZW50IGlzIGEgbnVtZXJpYyBJRCAoc3RhcnRzIHdpdGggXCJfX2lkXCIgYW5kIGVuZHMgd2l0aCBcIl9fXCIpLlxuICAgIHN0YXRpYyBpc051bWVyaWNJZChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50LnN0YXJ0c1dpdGgoJ19faWQnKSAmJiBzZWdtZW50LmVuZHNXaXRoKCdfXycpO1xuICAgIH1cbiAgICBzdGF0aWMgZXh0cmFjdE51bWVyaWNJZChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21TdHJpbmcoc2VnbWVudC5zdWJzdHJpbmcoNCwgc2VnbWVudC5sZW5ndGggLSAyKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNsYXNoLXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHJlc291cmNlcyAoZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucylcbiAqIHdpdGhpbiBGaXJlc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFJlc291cmNlUGF0aCBleHRlbmRzIEJhc2VQYXRoIHtcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxuICAgICAgICAvLyBzZXF1ZW5jZXMgKGUuZy4gX19pZDEyM19fKSBhbmQganVzdCBwYXNzZXMgdGhlbSB0aHJvdWdoIHJhdyAodGhleSBleGlzdFxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGF0aFxuICAgICAqIHdoZXJlIGVhY2ggcGF0aCBzZWdtZW50IGhhcyBiZWVuIGVuY29kZWQgd2l0aFxuICAgICAqIGBlbmNvZGVVUklDb21wb25lbnRgLlxuICAgICAqL1xuICAgIHRvVXJpRW5jb2RlZFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlc291cmNlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gc2xhc2gtZGVsaW1pdGVkIHN0cmluZy4gSWYgbXVsdGlwbGVcbiAgICAgKiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbGwgY29tcG9uZW50cyBhcmUgY29tYmluZWQuIExlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICogc2xhc2hlcyBmcm9tIGFsbCBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKC4uLnBhdGhDb21wb25lbnRzKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoZSBjbGllbnQgaXMgaWdub3JhbnQgb2YgYW55IHBhdGggc2VnbWVudHMgY29udGFpbmluZyBlc2NhcGVcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcbiAgICAgICAgLy8gZm9yIGxlZ2FjeSByZWFzb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZnJlcXVlbnRseSkuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoQ29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZignLy8nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgc2VnbWVudCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGNvbnRhaW4gLy8gaW4gdGhlbS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZWQuXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKC4uLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoc2VnbWVudCA9PiBzZWdtZW50Lmxlbmd0aCA+IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChzZWdtZW50cyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKFtdKTtcbiAgICB9XG59XG5jb25zdCBpZGVudGlmaWVyUmVnRXhwID0gL15bX2EtekEtWl1bX2EtekEtWjAtOV0qJC87XG4vKipcbiAqIEEgZG90LXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHN1Yi1vYmplY3RzIHdpdGhpbiBhIGRvY3VtZW50LlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEZpZWxkUGF0aCQxIGV4dGVuZHMgQmFzZVBhdGgge1xuICAgIGNvbnN0cnVjdChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb3VsZCBiZSB1c2VkIGFzIGEgc2VnbWVudCBpbiBhIGZpZWxkIHBhdGhcbiAgICAgKiB3aXRob3V0IGVzY2FwaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkSWRlbnRpZmllcihzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyUmVnRXhwLnRlc3Qoc2VnbWVudCk7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9gL2csICdcXFxcYCcpO1xuICAgICAgICAgICAgaWYgKCFGaWVsZFBhdGgkMS5pc1ZhbGlkSWRlbnRpZmllcihzdHIpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ2AnICsgc3RyICsgJ2AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmllbGQgcmVmZXJlbmNlcyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXG4gICAgICovXG4gICAgaXNLZXlGaWVsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMuZ2V0KDApID09PSBET0NVTUVOVF9LRVlfTkFNRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMga2V5RmllbGQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW0RPQ1VNRU5UX0tFWV9OQU1FXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGZpZWxkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXItZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIC0gU3BsaXR0aW5nIHRoZSBlbXB0eSBzdHJpbmcgaXMgbm90IGFsbG93ZWQgKGZvciBub3cgYXQgbGVhc3QpLlxuICAgICAqIC0gRW1wdHkgc2VnbWVudHMgd2l0aGluIHRoZSBzdHJpbmcgKGUuZy4gaWYgdGhlcmUgYXJlIHR3byBjb25zZWN1dGl2ZVxuICAgICAqICAgc2VwYXJhdG9ycykgYXJlIG5vdCBhbGxvd2VkLlxuICAgICAqXG4gICAgICogVE9ETyhiLzM3MjQ0MTU3KTogd2Ugc2hvdWxkIG1ha2UgdGhpcyBtb3JlIHN0cmljdC4gUmlnaHQgbm93LCBpdCBhbGxvd3NcbiAgICAgKiBub24taWRlbnRpZmllciBwYXRoIGNvbXBvbmVudHMsIGV2ZW4gaWYgdGhleSBhcmVuJ3QgZXNjYXBlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlcnZlckZvcm1hdChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgYWRkQ3VycmVudFNlZ21lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2l0aCAnLicsIGVuZCB3aXRoICcuJywgb3IgY29udGFpbiAnLi4nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaW5CYWNrdGlja3MgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUGF0aCBoYXMgdHJhaWxpbmcgZXNjYXBlIGNoYXJhY3RlcjogJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGF0aFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dCA9PT0gJ1xcXFwnIHx8IG5leHQgPT09ICcuJyB8fCBuZXh0ID09PSAnYCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IG5leHQ7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSAhaW5CYWNrdGlja3M7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJy4nICYmICFpbkJhY2t0aWNrcykge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xuICAgICAgICBpZiAoaW5CYWNrdGlja3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdVbnRlcm1pbmF0ZWQgYCBpbiBwYXRoOiAnICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW10pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIERvY3VtZW50S2V5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpLnBvcEZpcnN0KDUpKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSk7XG4gICAgfVxuICAgIGdldCBjb2xsZWN0aW9uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgucG9wTGFzdCgpLmxhc3RTZWdtZW50KCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRvY3VtZW50IGlzIGluIHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvbklkLiAqL1xuICAgIGhhc0NvbGxlY3Rpb25JZChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhdGgubGVuZ3RoID49IDIgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5nZXQodGhpcy5wYXRoLmxlbmd0aCAtIDIpID09PSBjb2xsZWN0aW9uSWQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCAoaS5lLiB0aGUgbmFtZSBvZiB0aGUgcGFyZW50IGNvbGxlY3Rpb24pIGZvciB0aGlzIGtleS4gKi9cbiAgICBnZXRDb2xsZWN0aW9uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBwYXRoIHRvIHRoZSBwYXJlbnQgY29sbGVjdGlvbi4gKi9cbiAgICBnZXRDb2xsZWN0aW9uUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcih0aGlzLnBhdGgsIG90aGVyLnBhdGgpID09PSAwKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmF0b3IoazEsIGsyKSB7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcihrMS5wYXRoLCBrMi5wYXRoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRG9jdW1lbnRLZXkocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggJSAyID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGRvY3VtZW50IGtleSB3aXRoIHRoZSBnaXZlbiBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudEtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLnNsaWNlKCkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBpbml0aWFsIG11dGF0aW9uIGJhdGNoIGlkIGZvciBlYWNoIGluZGV4LiBHZXRzIHVwZGF0ZWQgZHVyaW5nIGluZGV4XG4gKiBiYWNrZmlsbC5cbiAqL1xuY29uc3QgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEID0gLTE7XG4vKipcbiAqIFRoZSBpbml0aWFsIHNlcXVlbmNlIG51bWJlciBmb3IgZWFjaCBpbmRleC4gR2V0cyB1cGRhdGVkIGR1cmluZyBpbmRleFxuICogYmFja2ZpbGwuXG4gKi9cbmNvbnN0IElOSVRJQUxfU0VRVUVOQ0VfTlVNQkVSID0gMDtcbi8qKlxuICogQW4gaW5kZXggZGVmaW5pdGlvbiBmb3IgZmllbGQgaW5kZXhlcyBpbiBGaXJlc3RvcmUuXG4gKlxuICogRXZlcnkgaW5kZXggaXMgYXNzb2NpYXRlZCB3aXRoIGEgY29sbGVjdGlvbi4gVGhlIGRlZmluaXRpb24gY29udGFpbnMgYSBsaXN0XG4gKiBvZiBmaWVsZHMgYW5kIHRoZWlyIGluZGV4IGtpbmQgKHdoaWNoIGNhbiBiZSBgQVNDRU5ESU5HYCwgYERFU0NFTkRJTkdgIG9yXG4gKiBgQ09OVEFJTlNgIGZvciBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnkgcXVlcmllcykuXG4gKlxuICogVW5saWtlIHRoZSBiYWNrZW5kLCB0aGUgU0RLIGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBjb2xsZWN0aW9uIG9yXG4gKiBjb2xsZWN0aW9uIGdyb3VwLXNjb3BlZCBpbmRpY2VzLiBFdmVyeSBpbmRleCBjYW4gYmUgdXNlZCBmb3IgYm90aCBzaW5nbGVcbiAqIGNvbGxlY3Rpb24gYW5kIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcmllcy5cbiAqL1xuY2xhc3MgRmllbGRJbmRleCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IElELiBSZXR1cm5zIC0xIGlmIHRoZSBpbmRleCBJRCBpcyBub3QgYXZhaWxhYmxlIChlLmcuIHRoZSBpbmRleFxuICAgICAqIGhhcyBub3QgeWV0IGJlZW4gcGVyc2lzdGVkKS5cbiAgICAgKi9cbiAgICBpbmRleElkLCBcbiAgICAvKiogVGhlIGNvbGxlY3Rpb24gSUQgdGhpcyBpbmRleCBhcHBsaWVzIHRvLiAqL1xuICAgIGNvbGxlY3Rpb25Hcm91cCwgXG4gICAgLyoqIFRoZSBmaWVsZCBzZWdtZW50cyBmb3IgdGhpcyBpbmRleC4gKi9cbiAgICBmaWVsZHMsIFxuICAgIC8qKiBTaG93cyBob3cgdXAtdG8tZGF0ZSB0aGUgaW5kZXggaXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG4gICAgaW5kZXhTdGF0ZSkge1xuICAgICAgICB0aGlzLmluZGV4SWQgPSBpbmRleElkO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuaW5kZXhTdGF0ZSA9IGluZGV4U3RhdGU7XG4gICAgfVxufVxuLyoqIEFuIElEIGZvciBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gcGVyc2lzdGVuY2UuICAqL1xuRmllbGRJbmRleC5VTktOT1dOX0lEID0gLTE7XG4vKiogUmV0dXJucyB0aGUgQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55IHNlZ21lbnQgZm9yIHRoaXMgaW5kZXguICovXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpIHtcbiAgICByZXR1cm4gZmllbGRJbmRleC5maWVsZHMuZmluZChzID0+IHMua2luZCA9PT0gMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pO1xufVxuLyoqIFJldHVybnMgYWxsIGRpcmVjdGlvbmFsIChhc2NlbmRpbmcvZGVzY2VuZGluZykgc2VnbWVudHMgZm9yIHRoaXMgaW5kZXguICovXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSB7XG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbHRlcihzID0+IHMua2luZCAhPT0gMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmRlciBvZiB0aGUgZG9jdW1lbnQga2V5IGNvbXBvbmVudCBmb3IgdGhlIGdpdmVuIGluZGV4LlxuICpcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIFdlYiBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkSW5kZXhHZXRLZXlPcmRlcihmaWVsZEluZGV4KSB7XG4gICAgY29uc3QgZGlyZWN0aW9uYWxTZWdtZW50cyA9IGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpO1xuICAgIHJldHVybiBkaXJlY3Rpb25hbFNlZ21lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgICA/IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICA6IGRpcmVjdGlvbmFsU2VnbWVudHNbZGlyZWN0aW9uYWxTZWdtZW50cy5sZW5ndGggLSAxXS5raW5kO1xufVxuLyoqXG4gKiBDb21wYXJlcyBpbmRleGVzIGJ5IGNvbGxlY3Rpb24gZ3JvdXAgYW5kIHNlZ21lbnRzLiBJZ25vcmVzIHVwZGF0ZSB0aW1lIGFuZFxuICogaW5kZXggSUQuXG4gKi9cbmZ1bmN0aW9uIGZpZWxkSW5kZXhTZW1hbnRpY0NvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmNvbGxlY3Rpb25Hcm91cCwgcmlnaHQuY29sbGVjdGlvbkdyb3VwKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4obGVmdC5maWVsZHMubGVuZ3RoLCByaWdodC5maWVsZHMubGVuZ3RoKTsgKytpKSB7XG4gICAgICAgIGNtcCA9IGluZGV4U2VnbWVudENvbXBhcmF0b3IobGVmdC5maWVsZHNbaV0sIHJpZ2h0LmZpZWxkc1tpXSk7XG4gICAgICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5maWVsZHMubGVuZ3RoLCByaWdodC5maWVsZHMubGVuZ3RoKTtcbn1cbi8qKiBSZXR1cm5zIGEgZGVidWcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpZWxkIGluZGV4ICovXG5mdW5jdGlvbiBmaWVsZEluZGV4VG9TdHJpbmcoZmllbGRJbmRleCkge1xuICAgIHJldHVybiBgaWQ9JHtmaWVsZEluZGV4LmluZGV4SWR9fGNnPSR7ZmllbGRJbmRleC5jb2xsZWN0aW9uR3JvdXB9fGY9JHtmaWVsZEluZGV4LmZpZWxkcy5tYXAoZiA9PiBgJHtmLmZpZWxkUGF0aH06JHtmLmtpbmR9YCkuam9pbignLCcpfWA7XG59XG4vKiogQW4gaW5kZXggY29tcG9uZW50IGNvbnNpc3Rpbmcgb2YgZmllbGQgcGF0aCBhbmQgaW5kZXggdHlwZS4gICovXG5jbGFzcyBJbmRleFNlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZmllbGQgcGF0aCBvZiB0aGUgY29tcG9uZW50LiAqL1xuICAgIGZpZWxkUGF0aCwgXG4gICAgLyoqIFRoZSBmaWVsZHMgc29ydGluZyBvcmRlci4gKi9cbiAgICBraW5kKSB7XG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gZmllbGRQYXRoO1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZGV4U2VnbWVudENvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjbXAgPSBGaWVsZFBhdGgkMS5jb21wYXJhdG9yKGxlZnQuZmllbGRQYXRoLCByaWdodC5maWVsZFBhdGgpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5raW5kLCByaWdodC5raW5kKTtcbn1cbi8qKlxuICogU3RvcmVzIHRoZSBcImhpZ2ggd2F0ZXIgbWFya1wiIHRoYXQgaW5kaWNhdGVzIGhvdyB1cGRhdGVkIHRoZSBJbmRleCBpcyBmb3IgdGhlXG4gKiBjdXJyZW50IHVzZXIuXG4gKi9cbmNsYXNzIEluZGV4U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGVuIHRoZSBpbmRleCB3YXMgbGFzdCB1cGRhdGVkIChyZWxhdGl2ZSB0byBvdGhlciBpbmRleGVzKS5cbiAgICAgKi9cbiAgICBzZXF1ZW5jZU51bWJlciwgXG4gICAgLyoqIFRoZSB0aGUgbGF0ZXN0IGluZGV4ZWQgcmVhZCB0aW1lLCBkb2N1bWVudCBhbmQgYmF0Y2ggaWQuICovXG4gICAgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBUaGUgc3RhdGUgb2YgYW4gaW5kZXggdGhhdCBoYXMgbm90IHlldCBiZWVuIGJhY2tmaWxsZWQuICovXG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4U3RhdGUoSU5JVElBTF9TRVFVRU5DRV9OVU1CRVIsIEluZGV4T2Zmc2V0Lm1pbigpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2Zmc2V0IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzIHdpdGggYSByZWFkIHRpbWUgaGlnaGVyIHRoYW5cbiAqIGByZWFkVGltZWAuXG4gKi9cbmZ1bmN0aW9uIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKHJlYWRUaW1lLCBsYXJnZXN0QmF0Y2hJZCkge1xuICAgIC8vIFdlIHdhbnQgdG8gY3JlYXRlIGFuIG9mZnNldCB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyB3aXRoIGEgcmVhZCB0aW1lXG4gICAgLy8gZ3JlYXRlciB0aGFuIHRoZSBwcm92aWRlZCByZWFkIHRpbWUuIFRvIGRvIHNvLCB3ZSB0ZWNobmljYWxseSBuZWVkIHRvXG4gICAgLy8gY3JlYXRlIGFuIG9mZnNldCBmb3IgYChyZWFkVGltZSwgTUFYX0RPQ1VNRU5UX0tFWSlgLiBXaGlsZSB3ZSBjb3VsZCB1c2VcbiAgICAvLyBVbmljb2RlIGNvZGVwb2ludHMgdG8gZ2VuZXJhdGUgTUFYX0RPQ1VNRU5UX0tFWSwgaXQgaXMgbXVjaCBlYXNpZXIgdG8gdXNlXG4gICAgLy8gYChyZWFkVGltZSArIDEsIERvY3VtZW50S2V5LmVtcHR5KCkpYCBzaW5jZSBgPiBEb2N1bWVudEtleS5lbXB0eSgpYCBtYXRjaGVzXG4gICAgLy8gYWxsIHZhbGlkIGRvY3VtZW50IElEcy5cbiAgICBjb25zdCBzdWNjZXNzb3JTZWNvbmRzID0gcmVhZFRpbWUudG9UaW1lc3RhbXAoKS5zZWNvbmRzO1xuICAgIGNvbnN0IHN1Y2Nlc3Nvck5hbm9zID0gcmVhZFRpbWUudG9UaW1lc3RhbXAoKS5uYW5vc2Vjb25kcyArIDE7XG4gICAgY29uc3Qgc3VjY2Vzc29yID0gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAoc3VjY2Vzc29yTmFub3MgPT09IDFlOVxuICAgICAgICA/IG5ldyBUaW1lc3RhbXAoc3VjY2Vzc29yU2Vjb25kcyArIDEsIDApXG4gICAgICAgIDogbmV3IFRpbWVzdGFtcChzdWNjZXNzb3JTZWNvbmRzLCBzdWNjZXNzb3JOYW5vcykpO1xuICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoc3VjY2Vzc29yLCBEb2N1bWVudEtleS5lbXB0eSgpLCBsYXJnZXN0QmF0Y2hJZCk7XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBvZmZzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50LiAqL1xuZnVuY3Rpb24gbmV3SW5kZXhPZmZzZXRGcm9tRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KGRvY3VtZW50LnJlYWRUaW1lLCBkb2N1bWVudC5rZXksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XG59XG4vKipcbiAqIFN0b3JlcyB0aGUgbGF0ZXN0IHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIElEIHRoYXQgd2VyZSBwcm9jZXNzZWQgZm9yIGFuXG4gKiBpbmRleC5cbiAqL1xuY2xhc3MgSW5kZXhPZmZzZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRlc3QgcmVhZCB0aW1lIHZlcnNpb24gdGhhdCBoYXMgYmVlbiBpbmRleGVkIGJ5IEZpcmVzdG9yZSBmb3IgdGhpc1xuICAgICAqIGZpZWxkIGluZGV4LlxuICAgICAqL1xuICAgIHJlYWRUaW1lLCBcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IG9mIHRoZSBsYXN0IGRvY3VtZW50IHRoYXQgd2FzIGluZGV4ZWQgZm9yIHRoaXMgcXVlcnkuIFVzZVxuICAgICAqIGBEb2N1bWVudEtleS5lbXB0eSgpYCBpZiBubyBkb2N1bWVudCBoYXMgYmVlbiBpbmRleGVkLlxuICAgICAqL1xuICAgIGRvY3VtZW50S2V5LCBcbiAgICAvKlxuICAgICAqIFRoZSBsYXJnZXN0IG11dGF0aW9uIGJhdGNoIGlkIHRoYXQncyBiZWVuIHByb2Nlc3NlZCBieSBGaXJlc3RvcmUuXG4gICAgICovXG4gICAgbGFyZ2VzdEJhdGNoSWQpIHtcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xuICAgICAgICB0aGlzLmRvY3VtZW50S2V5ID0gZG9jdW1lbnRLZXk7XG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYW4gb2Zmc2V0IHRoYXQgc29ydHMgYmVmb3JlIGFsbCByZWd1bGFyIG9mZnNldHMuICovXG4gICAgc3RhdGljIG1pbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChTbmFwc2hvdFZlcnNpb24ubWluKCksIERvY3VtZW50S2V5LmVtcHR5KCksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFuIG9mZnNldCB0aGF0IHNvcnRzIGFmdGVyIGFsbCByZWd1bGFyIG9mZnNldHMuICovXG4gICAgc3RhdGljIG1heCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChTbmFwc2hvdFZlcnNpb24ubWF4KCksIERvY3VtZW50S2V5LmVtcHR5KCksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5kZXhPZmZzZXRDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGNtcCA9IGxlZnQucmVhZFRpbWUuY29tcGFyZVRvKHJpZ2h0LnJlYWRUaW1lKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5kb2N1bWVudEtleSwgcmlnaHQuZG9jdW1lbnRLZXkpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5sYXJnZXN0QmF0Y2hJZCwgcmlnaHQubGFyZ2VzdEJhdGNoSWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRyA9ICdUaGUgY3VycmVudCB0YWIgaXMgbm90IGluIHRoZSByZXF1aXJlZCBzdGF0ZSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uLiAnICtcbiAgICAnSXQgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIHJlZnJlc2ggdGhlIGJyb3dzZXIgdGFiLic7XG4vKipcbiAqIEEgYmFzZSBjbGFzcyByZXByZXNlbnRpbmcgYSBwZXJzaXN0ZW5jZSB0cmFuc2FjdGlvbiwgZW5jYXBzdWxhdGluZyBib3RoIHRoZVxuICogdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZSBudW1iZXJzIGFzIHdlbGwgYXMgYSBsaXN0IG9mIG9uQ29tbWl0dGVkIGxpc3RlbmVycy5cbiAqXG4gKiBXaGVuIHlvdSBjYWxsIFBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCksIGl0IHdpbGwgY3JlYXRlIGEgdHJhbnNhY3Rpb24gYW5kXG4gKiBwYXNzIGl0IHRvIHlvdXIgY2FsbGJhY2suIFlvdSB0aGVuIHBhc3MgaXQgdG8gYW55IG1ldGhvZCB0aGF0IG9wZXJhdGVzXG4gKiBvbiBwZXJzaXN0ZW5jZS5cbiAqL1xuY2xhc3MgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkT25Db21taXR0ZWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICByYWlzZU9uQ29tbWl0dGVkRXZlbnQoKSB7XG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBlcnJvciB0aHJvd24gYnkgYSBMb2NhbFN0b3JlIG9wZXJhdGlvbi4gSWYgYSBMb2NhbFN0b3JlXG4gKiBvcGVyYXRpb24gZmFpbHMgYmVjYXVzZSB0aGUgcHJpbWFyeSBsZWFzZSBoYXMgYmVlbiB0YWtlbiBieSBhbm90aGVyIGNsaWVudCxcbiAqIHdlIGlnbm9yZSB0aGUgZXJyb3IgKHRoZSBwZXJzaXN0ZW5jZSBsYXllciB3aWxsIGltbWVkaWF0ZWx5IGNhbGxcbiAqIGBhcHBseVByaW1hcnlMZWFzZWAgdG8gcHJvcGFnYXRlIHRoZSBwcmltYXJ5IHN0YXRlIGNoYW5nZSkuIEFsbCBvdGhlciBlcnJvcnNcbiAqIGFyZSByZS10aHJvd24uXG4gKlxuICogQHBhcmFtIGVyciAtIEFuIGVycm9yIHJldHVybmVkIGJ5IGEgTG9jYWxTdG9yZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB3ZSByZWNvdmVyZWQsIG9yIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OICYmXG4gICAgICAgIGVyci5tZXNzYWdlID09PSBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHKSB7XG4gICAgICAgIGxvZ0RlYnVnKCdMb2NhbFN0b3JlJywgJ1VuZXhwZWN0ZWRseSBsb3N0IHByaW1hcnkgbGVhc2UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFBlcnNpc3RlbmNlUHJvbWlzZSBpcyBlc3NlbnRpYWxseSBhIHJlLWltcGxlbWVudGF0aW9uIG9mIFByb21pc2UgZXhjZXB0XG4gKiBpdCBoYXMgYSAubmV4dCgpIG1ldGhvZCBpbnN0ZWFkIG9mIC50aGVuKCkgYW5kIC5uZXh0KCkgYW5kIC5jYXRjaCgpIGNhbGxiYWNrc1xuICogYXJlIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkgd2hlbiBhIFBlcnNpc3RlbmNlUHJvbWlzZSByZXNvbHZlcyByYXRoZXIgdGhhblxuICogYXN5bmNocm9ub3VzbHkgKFByb21pc2UgaW1wbGVtZW50YXRpb25zIHVzZSBzZXRJbW1lZGlhdGUoKSBvciBzaW1pbGFyKS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBpbnRlcm9wZXJhdGUgd2l0aCBJbmRleGVkREIgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBjb21taXQgdHJhbnNhY3Rpb25zIGlmIGNvbnRyb2wgaXMgcmV0dXJuZWQgdG8gdGhlIGV2ZW50IGxvb3Agd2l0aG91dFxuICogc3luY2hyb25vdXNseSBpbml0aWF0aW5nIGFub3RoZXIgb3BlcmF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBOT1RFOiAudGhlbigpIGFuZCAuY2F0Y2goKSBvbmx5IGFsbG93IGEgc2luZ2xlIGNvbnN1bWVyLCB1bmxpa2Ugbm9ybWFsXG4gKiBQcm9taXNlcy5cbiAqL1xuY2xhc3MgUGVyc2lzdGVuY2VQcm9taXNlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICAvLyBOT1RFOiBuZXh0L2NhdGNoQ2FsbGJhY2sgd2lsbCBhbHdheXMgcG9pbnQgdG8gb3VyIG93biB3cmFwcGVyIGZ1bmN0aW9ucyxcbiAgICAgICAgLy8gbm90IHRoZSB1c2VyJ3MgcmF3IG5leHQoKSBvciBjYXRjaCgpIGNhbGxiYWNrcy5cbiAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAvLyBXaGVuIHRoZSBvcGVyYXRpb24gcmVzb2x2ZXMsIHdlJ2xsIHNldCByZXN1bHQgb3IgZXJyb3IgYW5kIG1hcmsgaXNEb25lLlxuICAgICAgICB0aGlzLnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgLy8gU2V0IHRvIHRydWUgd2hlbiAudGhlbigpIG9yIC5jYXRjaCgpIGFyZSBjYWxsZWQgYW5kIHByZXZlbnRzIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gY2hhaW5pbmcuXG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgc2hvdWxkIGJlIGRlZmluZWQgdW5sZXNzIFQgaXMgVm9pZCwgYnV0IHdlIGNhbid0IGV4cHJlc3NcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGluIHRoZSB0eXBlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCh1bmRlZmluZWQsIGZuKTtcbiAgICB9XG4gICAgbmV4dChuZXh0Rm4sIGNhdGNoRm4pIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tBdHRhY2hlZCkge1xuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN1Y2Nlc3MobmV4dEZuLCB0aGlzLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCB0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsYmFjayA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JhcFVzZXJGdW5jdGlvbihmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQZXJzaXN0ZW5jZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5leHRGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFVzZXJGdW5jdGlvbigoKSA9PiBuZXh0Rm4odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbmV4dEZuLCB0aGVuIFIgbXVzdCBiZSB0aGUgc2FtZSBhcyBUXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKSB7XG4gICAgICAgIGlmIChjYXRjaEZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwVXNlckZ1bmN0aW9uKCgpID0+IGNhdGNoRm4oZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHJlamVjdChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHdhaXRGb3IoXG4gICAgLy8gQWNjZXB0IGFsbCBQcm9taXNlIHR5cGVzIGluIHdhaXRGb3IoKS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFsbCkge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgYWxsLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgKytleHBlY3RlZENvdW50O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICsrcmVzb2x2ZWRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgJiYgcmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHJlamVjdChlcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIHByZWRpY2F0ZSBmdW5jdGlvbnMgdGhhdCBhc3luY2hyb25vdXNseSBldmFsdWF0ZSB0byBhXG4gICAgICogYm9vbGVhbiwgaW1wbGVtZW50cyBhIHNob3J0LWNpcmN1aXRpbmcgYG9yYCBiZXR3ZWVuIHRoZSByZXN1bHRzLiBQcmVkaWNhdGVzXG4gICAgICogd2lsbCBiZSBldmFsdWF0ZWQgdW50aWwgb25lIG9mIHRoZW0gcmV0dXJucyBgdHJ1ZWAsIHRoZW4gc3RvcC4gVGhlIGZpbmFsXG4gICAgICogcmVzdWx0IHdpbGwgYmUgd2hldGhlciBhbnkgb2YgdGhlbSByZXR1cm5lZCBgdHJ1ZWAuXG4gICAgICovXG4gICAgc3RhdGljIG9yKHByZWRpY2F0ZXMpIHtcbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIHByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoaXNUcnVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShpc1RydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yRWFjaChjb2xsZWN0aW9uLCBmKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgociwgcykgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmLmNhbGwodGhpcywgciwgcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmN1cnJlbnRseSBtYXAgYWxsIGFycmF5IGVsZW1lbnRzIHRocm91Z2ggYXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYXBBcnJheShhcnJheSwgZikge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShleHBlY3RlZENvdW50KTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGk7XG4gICAgICAgICAgICAgICAgZihhcnJheVtjdXJyZW50XSkubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2N1cnJlbnRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICArK3Jlc29sdmVkQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZENvdW50ID09PSBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHJlamVjdChlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIHJlY3Vyc2l2ZSBQZXJzaXN0ZW5jZVByb21pc2UgY2FsbHMsIHRoYXQgYXZvaWRzXG4gICAgICogcG90ZW50aWFsIG1lbW9yeSBwcm9ibGVtcyBmcm9tIHVuYm91bmRlZCBjaGFpbnMgb2YgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYGFjdGlvbmAgd2lsbCBiZSBjYWxsZWQgcmVwZWF0ZWRseSB3aGlsZSBgY29uZGl0aW9uYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBkb1doaWxlKGNvbmRpdGlvbiwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbigpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbigpLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFJlZmVyZW5jZXMgdG8gYHdpbmRvd2AgYXJlIGd1YXJkZWQgYnkgU2ltcGxlRGIuaXNBdmFpbGFibGUoKVxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5jb25zdCBMT0dfVEFHJGkgPSAnU2ltcGxlRGInO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgZm9yIGFuIEluZGV4ZWREYiB0cmFuc2FjdGlvbiB0aGF0IGZhaWxzXG4gKiB3aXRoIGEgRE9NRXhjZXB0aW9uLlxuICovXG5jb25zdCBUUkFOU0FDVElPTl9SRVRSWV9DT1VOVCA9IDM7XG4vKipcbiAqIFdyYXBzIGFuIElEQlRyYW5zYWN0aW9uIGFuZCBleHBvc2VzIGEgc3RvcmUoKSBtZXRob2QgdG8gZ2V0IGEgaGFuZGxlIHRvIGFcbiAqIHNwZWNpZmljIG9iamVjdCBzdG9yZS5cbiAqL1xuY2xhc3MgU2ltcGxlRGJUcmFuc2FjdGlvbiB7XG4gICAgc3RhdGljIG9wZW4oZGIsIGFjdGlvbiwgbW9kZSwgb2JqZWN0U3RvcmVOYW1lcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKGFjdGlvbiwgZGIudHJhbnNhY3Rpb24ob2JqZWN0U3RvcmVOYW1lcywgbW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFjdGlvbiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgSW5kZXhlZERiIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCB0cmFuc2FjdGlvbi5lcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNvbXBsZXRpb25Qcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgYWJvcnQoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdBYm9ydGluZyB0cmFuc2FjdGlvbjonLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQ2xpZW50LWluaXRpYXRlZCBhYm9ydCcpO1xuICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZUNvbW1pdCgpIHtcbiAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVjMgSW5kZXhlZERCLCB3ZSBpbnZva2UgY29tbWl0KCkgZXhwbGljaXRseSB0b1xuICAgICAgICAvLyBzcGVlZCB1cCBpbmRleCBEQiBwcm9jZXNzaW5nIGlmIHRoZSBldmVudCBsb29wIHJlbWFpbnMgYmxvY2tzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBtYXliZVYzSW5kZXhlZERiID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLmFib3J0ZWQgJiYgdHlwZW9mIG1heWJlVjNJbmRleGVkRGIuY29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVYzSW5kZXhlZERiLmNvbW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTaW1wbGVEYlN0b3JlPEtleVR5cGUsIFZhbHVlVHlwZT4gZm9yIHRoZSBzcGVjaWZpZWQgc3RvcmUuIEFsbFxuICAgICAqIG9wZXJhdGlvbnMgcGVyZm9ybWVkIG9uIHRoZSBTaW1wbGVEYlN0b3JlIGhhcHBlbiB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHRyYW5zYWN0aW9uIGFuZCBpdCBjYW5ub3QgYmUgdXNlZCBhbnltb3JlIG9uY2UgdGhlIHRyYW5zYWN0aW9uIGlzXG4gICAgICogY29tcGxldGVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdlIGNhbid0IGFjdHVhbGx5IGVuZm9yY2UgdGhhdCB0aGUgS2V5VHlwZSBhbmQgVmFsdWVUeXBlIGFyZVxuICAgICAqIGNvcnJlY3QsIGJ1dCB0aGV5IGFsbG93IHR5cGUgc2FmZXR5IHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvbnN1bWluZyBjb2RlLlxuICAgICAqL1xuICAgIHN0b3JlKHN0b3JlTmFtZSkge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXMudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVEYlN0b3JlKHN0b3JlKTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgSW5kZXhlZERiIHdpdGggYSBzaW1wbGlmaWVkIGludGVyZmFjZSB0aGF0IHVzZXNcbiAqIFByb21pc2UtbGlrZSByZXR1cm4gdmFsdWVzIHRvIGNoYWluIG9wZXJhdGlvbnMuIFJlYWwgcHJvbWlzZXMgY2Fubm90IGJlIHVzZWRcbiAqIHNpbmNlIC50aGVuKCkgY29udGludWF0aW9ucyBhcmUgZXhlY3V0ZWQgYXN5bmNocm9ub3VzbHkgKGUuZy4gdmlhXG4gKiAuc2V0SW1tZWRpYXRlKSwgd2hpY2ggd291bGQgY2F1c2UgSW5kZXhlZERCIHRvIGVuZCB0aGUgdHJhbnNhY3Rpb24uXG4gKiBTZWUgUGVyc2lzdGVuY2VQcm9taXNlIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbmNsYXNzIFNpbXBsZURiIHtcbiAgICAvKiogRGVsZXRlcyB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLiAqL1xuICAgIHN0YXRpYyBkZWxldGUobmFtZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdSZW1vdmluZyBkYXRhYmFzZTonLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHdpbmRvdy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSkpLnRvUHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIEluZGV4ZWREQiBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICovXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU2ltcGxlRGIuaXNNb2NrUGVyc2lzdGVuY2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZXh0ZW5zaXZlbHkgdXNlIGluZGV4ZWQgYXJyYXkgdmFsdWVzIGFuZCBjb21wb3VuZCBrZXlzLFxuICAgICAgICAvLyB3aGljaCBJRSBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydC4gSG93ZXZlciwgdGhleSBzdGlsbCBoYXZlIGluZGV4ZWREQlxuICAgICAgICAvLyBkZWZpbmVkIG9uIHRoZSB3aW5kb3csIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoZW0gaGVyZSBhbmQgbWFrZSBzdXJlXG4gICAgICAgIC8vIHRvIHJldHVybiB0aGF0IHBlcnNpc3RlbmNlIGlzIG5vdCBlbmFibGVkIGZvciB0aG9zZSBicm93c2Vycy5cbiAgICAgICAgLy8gRm9yIHRyYWNraW5nIHN1cHBvcnQgb2YgdGhpcyBmZWF0dXJlLCBzZWUgaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9zdGF0dXMvaW5kZXhlZGRiYXJyYXlzYW5kbXVsdGllbnRyeXN1cHBvcnQvXG4gICAgICAgIC8vIENoZWNrIHRoZSBVQSBzdHJpbmcgdG8gZmluZCBvdXQgdGhlIGJyb3dzZXIuXG4gICAgICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcbiAgICAgICAgLy8gSUUgMTBcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBOVCA2LjI7IFRyaWRlbnQvNi4wKSc7XG4gICAgICAgIC8vIElFIDExXG4gICAgICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMzsgVHJpZGVudC83LjA7IHJ2OjExLjApIGxpa2UgR2Vja28nO1xuICAgICAgICAvLyBFZGdlXG4gICAgICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdPVzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLFxuICAgICAgICAvLyBsaWtlIEdlY2tvKSBDaHJvbWUvMzkuMC4yMTcxLjcxIFNhZmFyaS81MzcuMzYgRWRnZS8xMi4wJztcbiAgICAgICAgLy8gaU9TIFNhZmFyaTogRGlzYWJsZSBmb3IgdXNlcnMgcnVubmluZyBpT1MgdmVyc2lvbiA8IDEwLlxuICAgICAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbih1YSk7XG4gICAgICAgIGNvbnN0IGlzVW5zdXBwb3J0ZWRJT1MgPSAwIDwgaU9TVmVyc2lvbiAmJiBpT1NWZXJzaW9uIDwgMTA7XG4gICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcjogRGlzYWJsZSBmb3IgdXNlcnMgcnVubmluZyB2ZXJzaW9uIDwgNC41LlxuICAgICAgICBjb25zdCBhbmRyb2lkVmVyc2lvbiA9IGdldEFuZHJvaWRWZXJzaW9uKHVhKTtcbiAgICAgICAgY29uc3QgaXNVbnN1cHBvcnRlZEFuZHJvaWQgPSAwIDwgYW5kcm9pZFZlcnNpb24gJiYgYW5kcm9pZFZlcnNpb24gPCA0LjU7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdNU0lFICcpID4gMCB8fFxuICAgICAgICAgICAgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+IDAgfHxcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ0VkZ2UvJykgPiAwIHx8XG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkSU9TIHx8XG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkQW5kcm9pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBiYWNraW5nIEluZGV4ZWREQiBzdG9yZSBpcyB0aGUgTm9kZSBJbmRleGVkREJTaGltXG4gICAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhlbWNsaW9uL0luZGV4ZWREQlNoaW0pLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc01vY2tQZXJzaXN0ZW5jZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgKChfYSA9IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuVVNFX01PQ0tfUEVSU0lTVEVOQ0UpID09PSAnWUVTJyk7XG4gICAgfVxuICAgIC8qKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmcm9tIGEgdHJhbnNhY3Rpb24uICovXG4gICAgc3RhdGljIGdldFN0b3JlKHR4biwgc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIHR4bi5zdG9yZShzdG9yZSk7XG4gICAgfVxuICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcbiAgICAvKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgaU9TIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xuICAgIHN0YXRpYyBnZXRJT1NWZXJzaW9uKHVhKSB7XG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb25SZWdleCA9IHVhLm1hdGNoKC9pKD86cGhvbmV8cGFkfHBvZCkgb3MgKFtcXGRfXSspL2kpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaU9TVmVyc2lvblJlZ2V4XG4gICAgICAgICAgICA/IGlPU1ZlcnNpb25SZWdleFsxXS5zcGxpdCgnXycpLnNsaWNlKDAsIDIpLmpvaW4oJy4nKVxuICAgICAgICAgICAgOiAnLTEnO1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2ltcGxlRGIgd3JhcHBlciBmb3IgSW5kZXhlZERiIGRhdGFiYXNlIGBuYW1lYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgdmVyc2lvbmAgbXVzdCBub3QgYmUgYSBkb3duZ3JhZGUuIEluZGV4ZWREQiBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICogZG93bmdyYWRpbmcgdGhlIHNjaGVtYSB2ZXJzaW9uLiBXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQgYW55IHdheSB0byBkb1xuICAgICAqIHZlcnNpb25pbmcgb3V0c2lkZSBvZiBJbmRleGVkREIncyB2ZXJzaW9uaW5nIG1lY2hhbmlzbSwgYXMgb25seVxuICAgICAqIHZlcnNpb24tdXBncmFkZSB0cmFuc2FjdGlvbnMgYXJlIGFsbG93ZWQgdG8gZG8gdGhpbmdzIGxpa2UgY3JlYXRlXG4gICAgICogb2JqZWN0c3RvcmVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHNjaGVtYUNvbnZlcnRlcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlciA9IHNjaGVtYUNvbnZlcnRlcjtcbiAgICAgICAgY29uc3QgaU9TVmVyc2lvbiA9IFNpbXBsZURiLmdldElPU1ZlcnNpb24oZ2V0VUEoKSk7XG4gICAgICAgIC8vIE5PVEU6IEFjY29yZGluZyB0byBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk3MDUwLCB0aGVcbiAgICAgICAgLy8gYnVnIHdlJ3JlIGNoZWNraW5nIGZvciBzaG91bGQgZXhpc3QgaW4gaU9TID49IDEyLjIgYW5kIDwgMTMsIGJ1dCBmb3JcbiAgICAgICAgLy8gd2hhdGV2ZXIgcmVhc29uIGl0J3MgbXVjaCBoYXJkZXIgdG8gaGl0IGFmdGVyIDEyLjIgc28gd2Ugb25seSBwcm9hY3RpdmVseVxuICAgICAgICAvLyBsb2cgb24gMTIuMi5cbiAgICAgICAgaWYgKGlPU1ZlcnNpb24gPT09IDEyLjIpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGaXJlc3RvcmUgcGVyc2lzdGVuY2Ugc3VmZmVycyBmcm9tIGEgYnVnIGluIGlPUyAxMi4yICcgK1xuICAgICAgICAgICAgICAgICdTYWZhcmkgdGhhdCBtYXkgY2F1c2UgeW91ciBhcHAgdG8gc3RvcCB3b3JraW5nLiBTZWUgJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NjQ5NjI5Ni8xMTA5MTUgZm9yIGRldGFpbHMgJyArXG4gICAgICAgICAgICAgICAgJ2FuZCBhIHBvdGVudGlhbCB3b3JrYXJvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UsIGNyZWF0aW5nIG9yIHVwZ3JhZGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgYXN5bmMgZW5zdXJlRGIoYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5kYikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnT3BlbmluZyBkYXRhYmFzZTonLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEludmVzdGlnYXRlIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSS9Vc2luZ19JbmRleGVkREJcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0cyBJRTkgYW5kIG9sZGVyIFdlYktpdCBicm93c2VycyBoYW5kbGUgdXBncmFkZVxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudGx5LiBUaGV5IGV4cGVjdCBzZXRWZXJzaW9uLCBhcyBkZXNjcmliZWQgaGVyZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCVmVyc2lvbkNoYW5nZVJlcXVlc3Qvc2V0VmVyc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLm5hbWUsIHRoaXMudmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCAnQ2Fubm90IHVwZ3JhZGUgSW5kZXhlZERCIHNjaGVtYSB3aGlsZSBhbm90aGVyIHRhYiBpcyBvcGVuLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDbG9zZSBhbGwgdGFicyB0aGF0IGFjY2VzcyBGaXJlc3RvcmUgYW5kIHJlbG9hZCB0aGlzIHBhZ2UgdG8gcHJvY2VlZC4nKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC50YXJnZXQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVmVyc2lvbkVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIG5ld2VyIHZlcnNpb24gb2YgdGhlIEZpcmVzdG9yZSBTREsgd2FzIHByZXZpb3VzbHkgdXNlZCBhbmQgc28gdGhlIHBlcnNpc3RlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB2ZXJzaW9uIG9mIHRoZSBTREsgeW91IGFyZSBub3cgdXNpbmcuIFRoZSBTREsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpbGwgb3BlcmF0ZSB3aXRoIHBlcnNpc3RlbmNlIGRpc2FibGVkLiBJZiB5b3UgbmVlZCBwZXJzaXN0ZW5jZSwgcGxlYXNlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZS11cGdyYWRlIHRvIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgU0RLIG9yIGVsc2UgY2xlYXIgdGhlIHBlcnNpc3RlZCBJbmRleGVkREIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEgZm9yIHlvdXIgYXBwIHRvIHN0YXJ0IGZyZXNoLicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1VuYWJsZSB0byBvcGVuIGFuIEluZGV4ZWREQiBjb25uZWN0aW9uLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBydW5uaW5nIGluIGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUgYnJvd3Npbmcgc2Vzc2lvbiBvbiBhIGJyb3dzZXIgd2hvc2UgcHJpdmF0ZSBicm93c2luZyBzZXNzaW9ucyBkbyBub3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1cHBvcnQgSW5kZXhlZERCOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnRGF0YWJhc2UgXCInICsgdGhpcy5uYW1lICsgJ1wiIHJlcXVpcmVzIHVwZ3JhZGUgZnJvbSB2ZXJzaW9uOicsIGV2ZW50Lm9sZFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29udmVydGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlT3JVcGdyYWRlKGRiLCByZXF1ZXN0LnRyYW5zYWN0aW9uLCBldmVudC5vbGRWZXJzaW9uLCB0aGlzLnZlcnNpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdEYXRhYmFzZSB1cGdyYWRlIHRvIHZlcnNpb24gJyArIHRoaXMudmVyc2lvbiArICcgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kYi5vbnZlcnNpb25jaGFuZ2UgPSBldmVudCA9PiB0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGI7XG4gICAgfVxuICAgIHNldFZlcnNpb25DaGFuZ2VMaXN0ZW5lcih2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIgPSB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIG9iamVjdFN0b3JlcywgdHJhbnNhY3Rpb25Gbikge1xuICAgICAgICBjb25zdCByZWFkb25seSA9IG1vZGUgPT09ICdyZWFkb25seSc7XG4gICAgICAgIGxldCBhdHRlbXB0TnVtYmVyID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICsrYXR0ZW1wdE51bWJlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IHRoaXMuZW5zdXJlRGIoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IFNpbXBsZURiVHJhbnNhY3Rpb24ub3Blbih0aGlzLmRiLCBhY3Rpb24sIHJlYWRvbmx5ID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnLCBvYmplY3RTdG9yZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRm5SZXN1bHQgPSB0cmFuc2FjdGlvbkZuKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5tYXliZUNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFjdHVhbGx5IHJlY292ZXIsIGFuZCBjYWxsaW5nIGBhYm9ydCgpYCB3aWxsIGNhdXNlIHRoZSB0cmFuc2FjdGlvbidzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gcHJvbWlzZSB0byBiZSByZWplY3RlZC4gVGhpcyBpbiB0dXJuIG1lYW5zIHRoYXQgd2Ugd29uJ3QgdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGB0cmFuc2FjdGlvbkZuUmVzdWx0YCBiZWxvdy4gV2UgcmV0dXJuIGEgcmVqZWN0aW9uIGhlcmUgc28gdGhhdCB3ZSBkb24ndCBhZGQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyBgdm9pZGAgdG8gdGhlIHR5cGUgb2YgYHRyYW5zYWN0aW9uRm5SZXN1bHRgLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIC8vIEFzIG5vdGVkIGFib3ZlLCBlcnJvcnMgYXJlIHByb3BhZ2F0ZWQgYnkgYWJvcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBTb1xuICAgICAgICAgICAgICAgIC8vIHdlIHN3YWxsb3cgYW55IGVycm9yIGhlcmUgdG8gYXZvaWQgdGhlIGJyb3dzZXIgbG9nZ2luZyBpdCBhcyB1bmhhbmRsZWQuXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25GblJlc3VsdC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSAoaS5lLiBJbmRleGVkRGIncyBvbnN1Y2Nlc3MgZXZlbnQgdG9cbiAgICAgICAgICAgICAgICAvLyBmaXJlKSwgYnV0IHN0aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgdHJhbnNhY3Rpb25GblJlc3VsdCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxlci5cbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21wbGV0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25GblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oc2NobWlkdC1zZWJhc3RpYW4pOiBXZSBjb3VsZCBwcm9iYWJseSBiZSBzbWFydGVyIGFib3V0IHRoaXMgYW5kXG4gICAgICAgICAgICAgICAgLy8gbm90IHJldHJ5IGV4Y2VwdGlvbnMgdGhhdCBhcmUgbGlrZWx5IHVucmVjb3ZlcmFibGUgKHN1Y2ggYXMgcXVvdGFcbiAgICAgICAgICAgICAgICAvLyBleGNlZWRlZCBlcnJvcnMpLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGNhbm5vdCB1c2UgYW4gaW5zdGFuY2VvZiBjaGVjayBmb3IgRmlyZXN0b3JlRXhjZXB0aW9uLCBzaW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gaXMgd3JhcHBlZCBpbiBhIGdlbmVyaWMgZXJyb3IgYnkgb3VyIGFzeW5jL2F3YWl0IGhhbmRsaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5YWJsZSA9IGVycm9yLm5hbWUgIT09ICdGaXJlYmFzZUVycm9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0TnVtYmVyIDwgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQ7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnVHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggZXJyb3I6JywgZXJyb3IubWVzc2FnZSwgJ1JldHJ5aW5nOicsIHJldHJ5YWJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5kYikge1xuICAgICAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGIgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqIFBhcnNlIFVzZXIgQWdlbnQgdG8gZGV0ZXJtaW5lIEFuZHJvaWQgdmVyc2lvbi4gUmV0dXJucyAtMSBpZiBub3QgZm91bmQuICovXG5mdW5jdGlvbiBnZXRBbmRyb2lkVmVyc2lvbih1YSkge1xuICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvQW5kcm9pZCAoW1xcZC5dKykvaSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGFuZHJvaWRWZXJzaW9uUmVnZXhcbiAgICAgICAgPyBhbmRyb2lkVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCcuJykuc2xpY2UoMCwgMikuam9pbignLicpXG4gICAgICAgIDogJy0xJztcbiAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xufVxuLyoqXG4gKiBBIGNvbnRyb2xsZXIgZm9yIGl0ZXJhdGluZyBvdmVyIGEga2V5IHJhbmdlIG9yIGluZGV4LiBJdCBhbGxvd3MgYW4gaXRlcmF0ZVxuICogY2FsbGJhY2sgdG8gZGVsZXRlIHRoZSBjdXJyZW50bHktcmVmZXJlbmNlZCBvYmplY3QsIG9yIGp1bXAgdG8gYSBuZXcga2V5XG4gKiB3aXRoaW4gdGhlIGtleSByYW5nZSBvciBpbmRleC5cbiAqL1xuY2xhc3MgSXRlcmF0aW9uQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZGJDdXJzb3IpIHtcbiAgICAgICAgdGhpcy5kYkN1cnNvciA9IGRiQ3Vyc29yO1xuICAgICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0S2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbiAgICB9XG4gICAgZ2V0IHNraXBUb0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEtleTtcbiAgICB9XG4gICAgc2V0IGN1cnNvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiQ3Vyc29yID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBzdG9wIGl0ZXJhdGlvbiBhdCBhbnkgcG9pbnQuXG4gICAgICovXG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHNraXAgdG8gdGhhdCBuZXh0IGtleSwgd2hpY2ggY291bGQgYmVcbiAgICAgKiBhbiBpbmRleCBvciBhIHByaW1hcnkga2V5LlxuICAgICAqL1xuICAgIHNraXAoa2V5KSB7XG4gICAgICAgIHRoaXMubmV4dEtleSA9IGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBmcm9tIHRoZSBvYmplY3Qgc3RvcmUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgQ0FOTk9UIGRvIHRoaXMgd2l0aCBhIGtleXNPbmx5IHF1ZXJ5LlxuICAgICAqL1xuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHRoaXMuZGJDdXJzb3IuZGVsZXRlKCkpO1xuICAgIH1cbn1cbi8qKiBBbiBlcnJvciB0aGF0IHdyYXBzIGV4Y2VwdGlvbnMgdGhhdCB0aHJvd24gZHVyaW5nIEluZGV4ZWREQiBleGVjdXRpb24uICovXG5jbGFzcyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRmlyZXN0b3JlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFjdGlvbk5hbWUsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKENvZGUuVU5BVkFJTEFCTEUsIGBJbmRleGVkREIgdHJhbnNhY3Rpb24gJyR7YWN0aW9uTmFtZX0nIGZhaWxlZDogJHtjYXVzZX1gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbi8qKiBWZXJpZmllcyB3aGV0aGVyIGBlYCBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiAqL1xuZnVuY3Rpb24gaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpIHtcbiAgICAvLyBVc2UgbmFtZSBlcXVhbGl0eSwgYXMgaW5zdGFuY2VvZiBjaGVja3Mgb24gZXJyb3JzIGRvbid0IHdvcmsgd2l0aCBlcnJvcnNcbiAgICAvLyB0aGF0IHdyYXAgb3RoZXIgZXJyb3JzLlxuICAgIHJldHVybiBlLm5hbWUgPT09ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcbn1cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBJREJPYmplY3RTdG9yZSBwcm92aWRpbmcgYW4gQVBJIHRoYXQ6XG4gKlxuICogMSkgSGFzIGdlbmVyaWMgS2V5VHlwZSAvIFZhbHVlVHlwZSBwYXJhbWV0ZXJzIHRvIHByb3ZpZGUgc3Ryb25nbHktdHlwZWRcbiAqIG1ldGhvZHMgZm9yIGFjdGluZyBhZ2FpbnN0IHRoZSBvYmplY3Qgc3RvcmUuXG4gKiAyKSBEZWFscyB3aXRoIEluZGV4ZWREQidzIG9uc3VjY2VzcyAvIG9uZXJyb3IgZXZlbnQgY2FsbGJhY2tzLCBtYWtpbmcgZXZlcnlcbiAqIG1ldGhvZCByZXR1cm4gYSBQZXJzaXN0ZW5jZVByb21pc2UgaW5zdGVhZC5cbiAqIDMpIFByb3ZpZGVzIGEgaGlnaGVyLWxldmVsIEFQSSB0byBhdm9pZCBuZWVkaW5nIHRvIGRvIGV4Y2Vzc2l2ZSB3cmFwcGluZyBvZlxuICogaW50ZXJtZWRpYXRlIEluZGV4ZWREQiB0eXBlcyAoSURCQ3Vyc29yV2l0aFZhbHVlLCBldGMuKVxuICovXG5jbGFzcyBTaW1wbGVEYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIHB1dChrZXlPclZhbHVlLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5T3JWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc3RvcmUucHV0KHZhbHVlLCBrZXlPclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwgJzxhdXRvLWtleT4nLCBrZXlPclZhbHVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnN0b3JlLnB1dChrZXlPclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgdmFsdWUgaW50byBhbiBPYmplY3QgU3RvcmUgYW5kIHJldHVybnMgdGhlIG5ldyBrZXkuIFNpbWlsYXIgdG9cbiAgICAgKiBJbmRleGVkRGIncyBgYWRkKClgLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgb24gcHJpbWFyeSBrZXkgY29sbGlzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBvYmplY3QgdG8gd3JpdGUuXG4gICAgICogQHJldHVybnMgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdBREQnLCB0aGlzLnN0b3JlLm5hbWUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmFkZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZnJvbSB0aGUgc3BlY2lmaWVkIHN0b3JlLCBvciBudWxsXG4gICAgICogaWYgbm8gb2JqZWN0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqXG4gICAgICogQGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBvciBudWxsIGlmIG5vIG9iamVjdCBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgLy8gV2UncmUgZG9pbmcgYW4gdW5zYWZlIGNhc3QgdG8gVmFsdWVUeXBlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCkubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5vbmV4aXN0ZW5jZSB0byBudWxsLlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0dFVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnREVMRVRFJywgdGhpcy5zdG9yZS5uYW1lLCBrZXkpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBldmVyIG5lZWQgbW9yZSBvZiB0aGUgY291bnQgdmFyaWFudHMsIHdlIGNhbiBhZGQgb3ZlcmxvYWRzLiBGb3Igbm93LFxuICAgICAqIGFsbCB3ZSBuZWVkIGlzIHRvIGNvdW50IGV2ZXJ5dGhpbmcgaW4gYSBzdG9yZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICBjb3VudCgpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQ09VTlQnLCB0aGlzLnN0b3JlLm5hbWUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5jb3VudCgpO1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIGxvYWRBbGwoaW5kZXhPclJhbmdlLCByYW5nZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRlT3B0aW9ucyA9IHRoaXMub3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKTtcbiAgICAgICAgLy8gVXNlIGBnZXRBbGwoKWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgSW5kZXhlZERCIHYzLCBhcyBpdCBpcyByb3VnaGx5XG4gICAgICAgIC8vIDIwJSBmYXN0ZXIuXG4gICAgICAgIGNvbnN0IHN0b3JlID0gaXRlcmF0ZU9wdGlvbnMuaW5kZXhcbiAgICAgICAgICAgID8gdGhpcy5zdG9yZS5pbmRleChpdGVyYXRlT3B0aW9ucy5pbmRleClcbiAgICAgICAgICAgIDogdGhpcy5zdG9yZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5nZXRBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoaXRlcmF0ZU9wdGlvbnMucmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3IoaXRlcmF0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZUN1cnNvcihjdXJzb3IsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMgZnJvbSB0aGUgcHJvdmlkZWQgaW5kZXggcmFuZ2UuIExvYWRzIGFsbFxuICAgICAqIGVsZW1lbnRzIGlmIG5vIGxpbWl0IGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGxvYWRGaXJzdChyYW5nZSwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0QWxsKHJhbmdlLCBjb3VudCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZUFsbChpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RFTEVURSBBTEwnLCB0aGlzLnN0b3JlLm5hbWUpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xuICAgICAgICBvcHRpb25zLmtleXNPbmx5ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbGxpbmcgZGVsZXRlKCkgb24gYSBjdXJzb3IgaXMgZG9jdW1lbnRlZCBhcyBtb3JlIGVmZmljaWVudCB0aGFuXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGRlbGV0ZSgpIG9uIGFuIG9iamVjdCBzdG9yZSB3aXRoIGEgc2luZ2xlIGtleVxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJPYmplY3RTdG9yZS9kZWxldGUpLFxuICAgICAgICAgICAgLy8gaG93ZXZlciwgdGhpcyByZXF1aXJlcyB1cyAqbm90KiB0byB1c2UgYSBrZXlzT25seSBjdXJzb3JcbiAgICAgICAgICAgIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCQ3Vyc29yL2RlbGV0ZSkuIFdlXG4gICAgICAgICAgICAvLyBtYXkgd2FudCB0byBjb21wYXJlIHRoZSBwZXJmb3JtYW5jZSBvZiBlYWNoIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sLmRlbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0ZShvcHRpb25zT3JDYWxsYmFjaywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3Iob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYSBzdG9yZSwgYnV0IHdhaXRzIGZvciB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gY29tcGxldGUgZm9yXG4gICAgICogZWFjaCBlbnRyeSBiZWZvcmUgaXRlcmF0aW5nIHRoZSBuZXh0IGVudHJ5LiBUaGlzIGFsbG93cyB0aGUgY2FsbGJhY2sgdG8gZG9cbiAgICAgKiBhc3luY2hyb25vdXMgd29yayB0byBkZXRlcm1pbmUgaWYgdGhpcyBpdGVyYXRpb24gc2hvdWxkIGNvbnRpbnVlLlxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYHRydWVgIHRvIGNvbnRpbnVlIGl0ZXJhdGlvbiwgYW5kXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXRlcmF0ZVNlcmlhbChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gdGhpcy5jdXJzb3Ioe30pO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvci52YWx1ZSkubmV4dChzaG91bGRDb250aW51ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpdGVyYXRlQ3Vyc29yKGN1cnNvclJlcXVlc3QsIGZuKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEl0ZXJhdGlvbkNvbnRyb2xsZXIoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmVzdWx0ID0gZm4oY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvci52YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJSZXN1bHQgaW5zdGFuY2VvZiBQZXJzaXN0ZW5jZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB1c2VyUmVzdWx0LmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godXNlclByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250cm9sbGVyLnNraXBUb0tleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjb250cm9sbGVyLnNraXBUb0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihyZXN1bHRzKSk7XG4gICAgfVxuICAgIG9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSkge1xuICAgICAgICBsZXQgaW5kZXhOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaW5kZXhPclJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPclJhbmdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4TmFtZSA9IGluZGV4T3JSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gaW5kZXhPclJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBpbmRleE5hbWUsIHJhbmdlIH07XG4gICAgfVxuICAgIGN1cnNvcihvcHRpb25zKSB7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSAnbmV4dCc7XG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdwcmV2JztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN0b3JlLmluZGV4KG9wdGlvbnMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5c09ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgub3BlbktleUN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlLm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogV3JhcHMgYW4gSURCUmVxdWVzdCBpbiBhIFBlcnNpc3RlbmNlUHJvbWlzZSwgdXNpbmcgdGhlIG9uc3VjY2VzcyAvIG9uZXJyb3JcbiAqIGhhbmRsZXJzIHRvIHJlc29sdmUgLyByZWplY3QgdGhlIFBlcnNpc3RlbmNlUHJvbWlzZSBhcyBhcHByb3ByaWF0ZS5cbiAqL1xuZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8gR3VhcmQgc28gd2Ugb25seSByZXBvcnQgdGhlIGVycm9yIG9uY2UuXG5sZXQgcmVwb3J0ZWRJT1NFcnJvciA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xuICAgIGlmIChpT1NWZXJzaW9uID49IDEyLjIgJiYgaU9TVmVyc2lvbiA8IDEzKSB7XG4gICAgICAgIGNvbnN0IElPU19FUlJPUiA9ICdBbiBpbnRlcm5hbCBlcnJvciB3YXMgZW5jb3VudGVyZWQgaW4gdGhlIEluZGV4ZWQgRGF0YWJhc2Ugc2VydmVyJztcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5kZXhPZihJT1NfRVJST1IpID49IDApIHtcbiAgICAgICAgICAgIC8vIFdyYXAgZXJyb3IgaW4gYSBtb3JlIGRlc2NyaXB0aXZlIG9uZS5cbiAgICAgICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKCdpbnRlcm5hbCcsIGBJT1NfSU5ERVhFRERCX0JVRzE6IEluZGV4ZWREYiBoYXMgdGhyb3duICcke0lPU19FUlJPUn0nLiBUaGlzIGlzIGxpa2VseSBgICtcbiAgICAgICAgICAgICAgICBgZHVlIHRvIGFuIHVuYXZvaWRhYmxlIGJ1ZyBpbiBpT1MuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTY0OTYyOTYvMTEwOTE1IGAgK1xuICAgICAgICAgICAgICAgIGBmb3IgZGV0YWlscyBhbmQgYSBwb3RlbnRpYWwgd29ya2Fyb3VuZC5gKTtcbiAgICAgICAgICAgIGlmICghcmVwb3J0ZWRJT1NFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkSU9TRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGEgZ2xvYmFsIGV4Y2VwdGlvbiBvdXRzaWRlIG9mIHRoaXMgcHJvbWlzZSBjaGFpbiwgZm9yIHRoZSB1c2VyIHRvXG4gICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgY2F0Y2guXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ld0Vycm9yO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cblxuY29uc3QgTE9HX1RBRyRoID0gJ0luZGV4QmFja2ZpbGxlcic7XG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBpbmRleCBiYWNrZmlsbCBhZnRlciBTREsgaW5pdGlhbGl6YXRpb24uICovXG5jb25zdCBJTklUSUFMX0JBQ0tGSUxMX0RFTEFZX01TID0gMTUgKiAxMDAwO1xuLyoqIE1pbmltdW0gYW1vdW50IG9mIHRpbWUgYmV0d2VlbiBiYWNrZmlsbCBjaGVja3MsIGFmdGVyIHRoZSBmaXJzdCBvbmUuICovXG5jb25zdCBSRUdVTEFSX0JBQ0tGSUxMX0RFTEFZX01TID0gNjAgKiAxMDAwO1xuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcHJvY2VzcyBlYWNoIHRpbWUgYmFja2ZpbGwoKSBpcyBjYWxsZWQuICovXG5jb25zdCBNQVhfRE9DVU1FTlRTX1RPX1BST0NFU1MgPSA1MDtcbi8qKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBJbmRleCBCYWNrZmlsbGVyLiAqL1xuY2xhc3MgSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBiYWNrZmlsbGVyKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IGJhY2tmaWxsZXI7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlKElOSVRJQUxfQkFDS0ZJTExfREVMQVlfTVMpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy50YXNrKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrICE9PSBudWxsO1xuICAgIH1cbiAgICBzY2hlZHVsZShkZWxheSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBTY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkoXCJpbmRleF9iYWNrZmlsbFwiIC8qIFRpbWVySWQuSW5kZXhCYWNrZmlsbCAqLywgZGVsYXksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50c1Byb2Nlc3NlZCA9IGF3YWl0IHRoaXMuYmFja2ZpbGxlci5iYWNrZmlsbCgpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYERvY3VtZW50cyB3cml0dGVuOiAke2RvY3VtZW50c1Byb2Nlc3NlZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdJZ25vcmluZyBJbmRleGVkREIgZXJyb3IgZHVyaW5nIGluZGV4IGJhY2tmaWxsOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlKFJFR1VMQVJfQkFDS0ZJTExfREVMQVlfTVMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogSW1wbGVtZW50cyB0aGUgc3RlcHMgZm9yIGJhY2tmaWxsaW5nIGluZGV4ZXMuICovXG5jbGFzcyBJbmRleEJhY2tmaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIExvY2FsU3RvcmUgcHJvdmlkZXMgYWNjZXNzIHRvIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcuXG4gICAgICogVGhlc2UgcHJvcGVydGllcyB3aWxsIHVwZGF0ZSB3aGVuIHRoZSB1c2VyIGNoYW5nZXMuIENvbnNlcXVlbnRseSxcbiAgICAgKiBtYWtpbmcgYSBsb2NhbCBjb3B5IG9mIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcgd2lsbCByZXF1aXJlXG4gICAgICogdXBkYXRlcyBvdmVyIHRpbWUuIFRoZSBzaW1wbGVyIHNvbHV0aW9uIGlzIHRvIHJlbHkgb24gTG9jYWxTdG9yZSB0byBoYXZlXG4gICAgICogYW4gdXAtdG8tZGF0ZSByZWZlcmVuY2VzIHRvIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFN0b3JlLlxuICAgICAqL1xuICAgIGxvY2FsU3RvcmUsIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICB9XG4gICAgYXN5bmMgYmFja2ZpbGwobWF4RG9jdW1lbnRzVG9Qcm9jZXNzID0gTUFYX0RPQ1VNRU5UU19UT19QUk9DRVNTKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdCYWNrZmlsbCBJbmRleGVzJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHRoaXMud3JpdGVJbmRleEVudHJpZXModHhuLCBtYXhEb2N1bWVudHNUb1Byb2Nlc3MpKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyBpbmRleCBlbnRyaWVzIHVudGlsIHRoZSBjYXAgaXMgcmVhY2hlZC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwcm9jZXNzZWQuICovXG4gICAgd3JpdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIG1heERvY3VtZW50c1RvUHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgZG9jdW1lbnRzUmVtYWluaW5nID0gbWF4RG9jdW1lbnRzVG9Qcm9jZXNzO1xuICAgICAgICBsZXQgY29udGludWVMb29wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5kb1doaWxlKCgpID0+IGNvbnRpbnVlTG9vcCA9PT0gdHJ1ZSAmJiBkb2N1bWVudHNSZW1haW5pbmcgPiAwLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgICAgIC5nZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgLm5leHQoKGNvbGxlY3Rpb25Hcm91cCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ29sbGVjdGlvbkdyb3Vwcy5oYXMoY29sbGVjdGlvbkdyb3VwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZUxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFByb2Nlc3NpbmcgY29sbGVjdGlvbjogJHtjb2xsZWN0aW9uR3JvdXB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBkb2N1bWVudHNSZW1haW5pbmcpLm5leHQoZG9jdW1lbnRzUHJvY2Vzc2VkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50c1JlbWFpbmluZyAtPSBkb2N1bWVudHNQcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzLmFkZChjb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiBtYXhEb2N1bWVudHNUb1Byb2Nlc3MgLSBkb2N1bWVudHNSZW1haW5pbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZW50cmllcyBmb3IgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gZ3JvdXAuIFJldHVybnMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIHdyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBkb2N1bWVudHNSZW1haW5pbmdVbmRlckNhcCkge1xuICAgICAgICAvLyBVc2UgdGhlIGVhcmxpZXN0IG9mZnNldCBvZiBhbGwgZmllbGQgaW5kZXhlcyB0byBxdWVyeSB0aGUgbG9jYWwgY2FjaGUuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAuZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKVxuICAgICAgICAgICAgLm5leHQoZXhpc3RpbmdPZmZzZXQgPT4gdGhpcy5sb2NhbFN0b3JlLmxvY2FsRG9jdW1lbnRzXG4gICAgICAgICAgICAuZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBleGlzdGluZ09mZnNldCwgZG9jdW1lbnRzUmVtYWluaW5nVW5kZXJDYXApXG4gICAgICAgICAgICAubmV4dChuZXh0QmF0Y2ggPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jcyA9IG5leHRCYXRjaC5jaGFuZ2VzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAudXBkYXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2NzKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuZ2V0TmV3T2Zmc2V0KGV4aXN0aW5nT2Zmc2V0LCBuZXh0QmF0Y2gpKVxuICAgICAgICAgICAgICAgIC5uZXh0KG5ld09mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgVXBkYXRpbmcgb2Zmc2V0OiAke25ld09mZnNldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlci51cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jcy5zaXplKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgbmV4dCBvZmZzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gKi9cbiAgICBnZXROZXdPZmZzZXQoZXhpc3RpbmdPZmZzZXQsIGxvb2t1cFJlc3VsdCkge1xuICAgICAgICBsZXQgbWF4T2Zmc2V0ID0gZXhpc3RpbmdPZmZzZXQ7XG4gICAgICAgIGxvb2t1cFJlc3VsdC5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3T2Zmc2V0LCBtYXhPZmZzZXQpID4gMCkge1xuICAgICAgICAgICAgICAgIG1heE9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQobWF4T2Zmc2V0LnJlYWRUaW1lLCBtYXhPZmZzZXQuZG9jdW1lbnRLZXksIE1hdGgubWF4KGxvb2t1cFJlc3VsdC5iYXRjaElkLCBleGlzdGluZ09mZnNldC5sYXJnZXN0QmF0Y2hJZCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYExpc3RlblNlcXVlbmNlYCBpcyBhIG1vbm90b25pYyBzZXF1ZW5jZS4gSXQgaXMgaW5pdGlhbGl6ZWQgd2l0aCBhIG1pbmltdW0gdmFsdWUgdG9cbiAqIGV4Y2VlZC4gQWxsIHN1YnNlcXVlbnQgY2FsbHMgdG8gbmV4dCB3aWxsIHJldHVybiBpbmNyZWFzaW5nIHZhbHVlcy4gSWYgcHJvdmlkZWQgd2l0aCBhXG4gKiBgU2VxdWVuY2VOdW1iZXJTeW5jZXJgLCBpdCB3aWxsIGFkZGl0aW9uYWxseSBidW1wIGl0cyBuZXh0IHZhbHVlIHdoZW4gdG9sZCBvZiBhIG5ldyB2YWx1ZSwgYXNcbiAqIHdlbGwgYXMgd3JpdGUgb3V0IHNlcXVlbmNlIG51bWJlcnMgdGhhdCBpdCBwcm9kdWNlcyB2aWEgYG5leHQoKWAuXG4gKi9cbmNsYXNzIExpc3RlblNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91c1ZhbHVlLCBzZXF1ZW5jZU51bWJlclN5bmNlcikge1xuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyU3luY2VyLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IHNlcXVlbmNlTnVtYmVyID0+IHRoaXMuc2V0UHJldmlvdXNWYWx1ZShzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlciA9PiBzZXF1ZW5jZU51bWJlclN5bmNlci53cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQcmV2aW91c1ZhbHVlKGV4dGVybmFsUHJldmlvdXNWYWx1ZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBNYXRoLm1heChleHRlcm5hbFByZXZpb3VzVmFsdWUsIHRoaXMucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9ICsrdGhpcy5wcmV2aW91c1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIobmV4dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgIH1cbn1cbkxpc3RlblNlcXVlbmNlLklOVkFMSUQgPSAtMTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGVzY2FwZUNoYXIgPSAnXFx1MDAwMSc7XG5jb25zdCBlbmNvZGVkU2VwYXJhdG9yQ2hhciA9ICdcXHUwMDAxJztcbmNvbnN0IGVuY29kZWROdWwgPSAnXFx1MDAxMCc7XG5jb25zdCBlbmNvZGVkRXNjYXBlID0gJ1xcdTAwMTEnO1xuLyoqXG4gKiBFbmNvZGVzIGEgcmVzb3VyY2UgcGF0aCBpbnRvIGEgSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVJlc291cmNlUGF0aChwYXRoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGVuY29kZVNlZ21lbnQocGF0aC5nZXQoaSksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KTtcbn1cbi8qKiBFbmNvZGVzIGEgc2luZ2xlIHNlZ21lbnQgb2YgYSByZXNvdXJjZSBwYXRoIGludG8gdGhlIGdpdmVuIHJlc3VsdCAqL1xuZnVuY3Rpb24gZW5jb2RlU2VnbWVudChzZWdtZW50LCByZXN1bHRCdWYpIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0QnVmO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHNlZ21lbnQuY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXIgKyBlbmNvZGVkTnVsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlc2NhcGVDaGFyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyICsgZW5jb2RlZEVzY2FwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBFbmNvZGVzIGEgcGF0aCBzZXBhcmF0b3IgaW50byB0aGUgZ2l2ZW4gcmVzdWx0ICovXG5mdW5jdGlvbiBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUNoYXIgKyBlbmNvZGVkU2VwYXJhdG9yQ2hhcjtcbn1cbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0gb2YgYSByZXNvdXJjZSBwYXRoIGludG9cbiAqIGEgUmVzb3VyY2VQYXRoIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgbm90IHN1aXRhYmxlIGZvciB1c2Ugd2l0aFxuICogZGVjb2RpbmcgcmVzb3VyY2UgbmFtZXMgZnJvbSB0aGUgc2VydmVyOyB0aG9zZSBhcmUgT25lIFBsYXRmb3JtIGZvcm1hdFxuICogc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlUmVzb3VyY2VQYXRoKHBhdGgpIHtcbiAgICAvLyBFdmVudCB0aGUgZW1wdHkgcGF0aCBtdXN0IGVuY29kZSBhcyBhIHBhdGggb2YgYXQgbGVhc3QgbGVuZ3RoIDIuIEEgcGF0aFxuICAgIC8vIHdpdGggZXhhY3RseSAyIG11c3QgYmUgdGhlIGVtcHR5IHBhdGguXG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaGFyZEFzc2VydChsZW5ndGggPj0gMik7XG4gICAgaWYgKGxlbmd0aCA9PT0gMikge1xuICAgICAgICBoYXJkQXNzZXJ0KHBhdGguY2hhckF0KDApID09PSBlc2NhcGVDaGFyICYmIHBhdGguY2hhckF0KDEpID09PSBlbmNvZGVkU2VwYXJhdG9yQ2hhcik7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XG4gICAgfVxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIGNhbm5vdCBleGlzdCBwYXN0IHRoZSBzZWNvbmQtdG8tbGFzdCBwb3NpdGlvbiBpbiB0aGVcbiAgICAvLyBzb3VyY2UgdmFsdWUuXG4gICAgY29uc3QgbGFzdFJlYXNvbmFibGVFc2NhcGVJbmRleCA9IGxlbmd0aCAtIDI7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBsZXQgc2VnbWVudEJ1aWxkZXIgPSAnJztcbiAgICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgbGVuZ3RoOykge1xuICAgICAgICAvLyBUaGUgbGFzdCB0d28gY2hhcmFjdGVycyBvZiBhIHZhbGlkIGVuY29kZWQgcGF0aCBtdXN0IGJlIGEgc2VwYXJhdG9yLCBzb1xuICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIGFuIGVuZCB0byB0aGlzIHNlZ21lbnQuXG4gICAgICAgIGNvbnN0IGVuZCA9IHBhdGguaW5kZXhPZihlc2NhcGVDaGFyLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPCAwIHx8IGVuZCA+IGxhc3RSZWFzb25hYmxlRXNjYXBlSW5kZXgpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gcGF0aC5jaGFyQXQoZW5kICsgMSk7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSBlbmNvZGVkU2VwYXJhdG9yQ2hhcjpcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGllY2UgPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudEJ1aWxkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhIHNlZ21lbnQgdGhhdCBleGNsdWRlcyBcXDBcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIFxcMDAxXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBjdXJyZW50UGllY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBjdXJyZW50UGllY2U7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50QnVpbGRlcjtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZW5jb2RlZE51bDpcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSAnXFwwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZW5jb2RlZEVzY2FwZTpcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXNjYXBlIGNoYXJhY3RlciBjYW4gYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHRvIGVuY29kZSBpdHNlbGYuXG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBlbmQgKyAyO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChzZWdtZW50cyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBEYlJlbW90ZURvY3VtZW50U3RvcmUkMSA9ICdyZW1vdGVEb2N1bWVudHMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgbmFtZSAnb3duZXInIGlzIGNob3NlbiB0byBlbnN1cmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aFxuICogb2xkZXIgY2xpZW50cyB0aGF0IG9ubHkgc3VwcG9ydGVkIHNpbmdsZSBsb2NrZWQgYWNjZXNzIHRvIHRoZSBwZXJzaXN0ZW5jZVxuICogbGF5ZXIuXG4gKi9cbmNvbnN0IERiUHJpbWFyeUNsaWVudFN0b3JlID0gJ293bmVyJztcbi8qKlxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXG4gKiBEYlByaW1hcnlDbGllbnQgc3RvcmUuXG4gKi9cbmNvbnN0IERiUHJpbWFyeUNsaWVudEtleSA9ICdvd25lcic7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXG5jb25zdCBEYk11dGF0aW9uUXVldWVTdG9yZSA9ICdtdXRhdGlvblF1ZXVlcyc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHVzZXJJZCBwcm9wZXJ0eS4gKi9cbmNvbnN0IERiTXV0YXRpb25RdWV1ZUtleVBhdGggPSAndXNlcklkJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cbmNvbnN0IERiTXV0YXRpb25CYXRjaFN0b3JlID0gJ211dGF0aW9ucyc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHVzZXJJZCwgYmF0Y2hJZCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCA9ICdiYXRjaElkJztcbi8qKiBUaGUgaW5kZXggbmFtZSBmb3IgbG9va3VwIG9mIG11dGF0aW9ucyBieSB1c2VyLiAqL1xuY29uc3QgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4ID0gJ3VzZXJNdXRhdGlvbnNJbmRleCc7XG4vKiogVGhlIHVzZXIgbXV0YXRpb25zIGluZGV4IGlzIGtleWVkIGJ5IFt1c2VySWQsIGJhdGNoSWRdIHBhaXJzLiAqL1xuY29uc3QgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0tleVBhdGggPSBbJ3VzZXJJZCcsICdiYXRjaElkJ107XG4vKipcbiAqIENyZWF0ZXMgYSBbdXNlcklkXSBrZXkgZm9yIHVzZSBpbiB0aGUgRGJEb2N1bWVudE11dGF0aW9ucyBpbmRleCB0byBpdGVyYXRlXG4gKiBvdmVyIGFsbCBvZiBhIHVzZXIncyBkb2N1bWVudCBtdXRhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclVzZXIodXNlcklkKSB7XG4gICAgcmV0dXJuIFt1c2VySWRdO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgW3VzZXJJZCwgZW5jb2RlZFBhdGhdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zXG4gKiBpbmRleCB0byBpdGVyYXRlIG92ZXIgYWxsIGF0IGRvY3VtZW50IG11dGF0aW9ucyBmb3IgYSBnaXZlbiBwYXRoIG9yIGxvd2VyLlxuICovXG5mdW5jdGlvbiBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHVzZXJJZCwgcGF0aCkge1xuICAgIHJldHVybiBbdXNlcklkLCBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCldO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZnVsbCBpbmRleCBrZXkgb2YgW3VzZXJJZCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdIGZvciBpbnNlcnRpbmdcbiAqIGFuZCBkZWxldGluZyBpbnRvIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4LlxuICovXG5mdW5jdGlvbiBuZXdEYkRvY3VtZW50TXV0YXRpb25LZXkodXNlcklkLCBwYXRoLCBiYXRjaElkKSB7XG4gICAgcmV0dXJuIFt1c2VySWQsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKSwgYmF0Y2hJZF07XG59XG4vKipcbiAqIEJlY2F1c2Ugd2Ugc3RvcmUgYWxsIHRoZSB1c2VmdWwgaW5mb3JtYXRpb24gZm9yIHRoaXMgc3RvcmUgaW4gdGhlIGtleSxcbiAqIHRoZXJlIGlzIG5vIHVzZWZ1bCBpbmZvcm1hdGlvbiB0byBzdG9yZSBhcyB0aGUgdmFsdWUuIFRoZSByYXcgKHVuZW5jb2RlZClcbiAqIHBhdGggY2Fubm90IGJlIHN0b3JlZCBiZWNhdXNlIEluZGV4ZWREYiBkb2Vzbid0IHN0b3JlIHByb3RvdHlwZVxuICogaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IERiRG9jdW1lbnRNdXRhdGlvblBsYWNlaG9sZGVyID0ge307XG5jb25zdCBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSA9ICdkb2N1bWVudE11dGF0aW9ucyc7XG5jb25zdCBEYlJlbW90ZURvY3VtZW50U3RvcmUgPSAncmVtb3RlRG9jdW1lbnRzVjE0Jztcbi8qKlxuICogVGhlIHByaW1hcnkga2V5IG9mIHRoZSByZW1vdGUgZG9jdW1lbnRzIHN0b3JlLCB3aGljaCBhbGxvd3MgZm9yIGVmZmljaWVudFxuICogYWNjZXNzIGJ5IGNvbGxlY3Rpb24gcGF0aCBhbmQgcmVhZCB0aW1lLlxuICovXG5jb25zdCBEYlJlbW90ZURvY3VtZW50S2V5UGF0aCA9IFtcbiAgICAncHJlZml4UGF0aCcsXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXG4gICAgJ3JlYWRUaW1lJyxcbiAgICAnZG9jdW1lbnRJZCdcbl07XG4vKiogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGJ5IGtleS4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4ID0gJ2RvY3VtZW50S2V5SW5kZXgnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXhQYXRoID0gW1xuICAgICdwcmVmaXhQYXRoJyxcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAnZG9jdW1lbnRJZCdcbl07XG4vKipcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGRvY3VtZW50cyBieSBjb2xsZWN0aW9uIGdyb3VwIGFuZCByZWFkXG4gKiB0aW1lLlxuICpcbiAqIFRoaXMgaW5kZXggaXMgdXNlZCBieSB0aGUgaW5kZXggYmFja2ZpbGxlci5cbiAqL1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4ID0gJ2NvbGxlY3Rpb25Hcm91cEluZGV4JztcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleFBhdGggPSBbXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXG4gICAgJ3JlYWRUaW1lJyxcbiAgICAncHJlZml4UGF0aCcsXG4gICAgJ2RvY3VtZW50SWQnXG5dO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlID0gJ3JlbW90ZURvY3VtZW50R2xvYmFsJztcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkgPSAncmVtb3RlRG9jdW1lbnRHbG9iYWxLZXknO1xuY29uc3QgRGJUYXJnZXRTdG9yZSA9ICd0YXJnZXRzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdGFyZ2V0SWQgcHJvcGVydHkuICovXG5jb25zdCBEYlRhcmdldEtleVBhdGggPSAndGFyZ2V0SWQnO1xuLyoqIFRoZSBuYW1lIG9mIHRoZSBxdWVyeVRhcmdldHMgaW5kZXguICovXG5jb25zdCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0luZGV4TmFtZSA9ICdxdWVyeVRhcmdldHNJbmRleCc7XG4vKipcbiAqIFRoZSBpbmRleCBvZiBhbGwgY2Fub25pY2FsSWRzIHRvIHRoZSB0YXJnZXRzIHRoYXQgdGhleSBtYXRjaC4gVGhpcyBpcyBub3RcbiAqIGEgdW5pcXVlIG1hcHBpbmcgYmVjYXVzZSBjYW5vbmljYWxJZCBkb2VzIG5vdCBwcm9taXNlIGEgdW5pcXVlIG5hbWUgZm9yIGFsbFxuICogcG9zc2libGUgcXVlcmllcywgc28gd2UgYXBwZW5kIHRoZSB0YXJnZXRJZCB0byBtYWtlIHRoZSBtYXBwaW5nIHVuaXF1ZS5cbiAqL1xuY29uc3QgRGJUYXJnZXRRdWVyeVRhcmdldHNLZXlQYXRoID0gWydjYW5vbmljYWxJZCcsICd0YXJnZXRJZCddO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudFN0b3JlID0gJ3RhcmdldERvY3VtZW50cyc7XG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHRhcmdldElkLCBwYXRoIHByb3BlcnRpZXMuICovXG5jb25zdCBEYlRhcmdldERvY3VtZW50S2V5UGF0aCA9IFsndGFyZ2V0SWQnLCAncGF0aCddO1xuLyoqIFRoZSBpbmRleCBuYW1lIGZvciB0aGUgcmV2ZXJzZSBpbmRleC4gKi9cbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCA9ICdkb2N1bWVudFRhcmdldHNJbmRleCc7XG4vKiogV2UgYWxzbyBuZWVkIHRvIGNyZWF0ZSB0aGUgcmV2ZXJzZSBpbmRleCBmb3IgdGhlc2UgcHJvcGVydGllcy4gKi9cbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNLZXlQYXRoID0gWydwYXRoJywgJ3RhcmdldElkJ107XG4vKipcbiAqIFRoZSBrZXkgc3RyaW5nIHVzZWQgZm9yIHRoZSBzaW5nbGUgb2JqZWN0IHRoYXQgZXhpc3RzIGluIHRoZVxuICogRGJUYXJnZXRHbG9iYWwgc3RvcmUuXG4gKi9cbmNvbnN0IERiVGFyZ2V0R2xvYmFsS2V5ID0gJ3RhcmdldEdsb2JhbEtleSc7XG5jb25zdCBEYlRhcmdldEdsb2JhbFN0b3JlID0gJ3RhcmdldEdsb2JhbCc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiQ29sbGVjdGlvblBhcmVudFN0b3JlID0gJ2NvbGxlY3Rpb25QYXJlbnRzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgY29sbGVjdGlvbklkLCBwYXJlbnQgcHJvcGVydGllcy4gKi9cbmNvbnN0IERiQ29sbGVjdGlvblBhcmVudEtleVBhdGggPSBbJ2NvbGxlY3Rpb25JZCcsICdwYXJlbnQnXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJDbGllbnRNZXRhZGF0YVN0b3JlID0gJ2NsaWVudE1ldGFkYXRhJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgY2xpZW50SWQgcHJvcGVydGllcy4gKi9cbmNvbnN0IERiQ2xpZW50TWV0YWRhdGFLZXlQYXRoID0gJ2NsaWVudElkJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJCdW5kbGVTdG9yZSA9ICdidW5kbGVzJztcbmNvbnN0IERiQnVuZGxlS2V5UGF0aCA9ICdidW5kbGVJZCc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiTmFtZWRRdWVyeVN0b3JlID0gJ25hbWVkUXVlcmllcyc7XG5jb25zdCBEYk5hbWVkUXVlcnlLZXlQYXRoID0gJ25hbWUnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlID0gJ2luZGV4Q29uZmlndXJhdGlvbic7XG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGggPSAnaW5kZXhJZCc7XG4vKipcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBpbmRleCBjb25maWd1cmF0aW9ucyBieSBjb2xsZWN0aW9uXG4gKiBncm91cC5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXG4gKiBwZXJzaXN0ZW5jZSB2aWEgbXVsdGktdGFiLlxuICovXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4ID0gJ2NvbGxlY3Rpb25Hcm91cEluZGV4JztcbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoID0gJ2NvbGxlY3Rpb25Hcm91cCc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiSW5kZXhTdGF0ZVN0b3JlID0gJ2luZGV4U3RhdGUnO1xuY29uc3QgRGJJbmRleFN0YXRlS2V5UGF0aCA9IFsnaW5kZXhJZCcsICd1aWQnXTtcbi8qKlxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGluIGEgY29sbGVjdGlvbiBzb3J0ZWQgYnkgbGFzdFxuICogdXBkYXRlIHRpbWUuIFVzZWQgYnkgdGhlIGJhY2tmaWxsZXIuXG4gKlxuICogUE9SVElORyBOT1RFOiBpT1MgYW5kIEFuZHJvaWQgbWFpbnRhaW4gdGhpcyBpbmRleCBpbi1tZW1vcnksIGJ1dCB0aGlzIGlzXG4gKiBub3QgcG9zc2libGUgaGVyZSBhcyB0aGUgV2ViIGNsaWVudCBzdXBwb3J0cyBjb25jdXJyZW50IGFjY2VzcyB0b1xuICogcGVyc2lzdGVuY2UgdmlhIG11bHRpLXRhYi5cbiAqL1xuY29uc3QgRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleCA9ICdzZXF1ZW5jZU51bWJlckluZGV4JztcbmNvbnN0IERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXhQYXRoID0gWyd1aWQnLCAnc2VxdWVuY2VOdW1iZXInXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJJbmRleEVudHJ5U3RvcmUgPSAnaW5kZXhFbnRyaWVzJztcbmNvbnN0IERiSW5kZXhFbnRyeUtleVBhdGggPSBbXG4gICAgJ2luZGV4SWQnLFxuICAgICd1aWQnLFxuICAgICdhcnJheVZhbHVlJyxcbiAgICAnZGlyZWN0aW9uYWxWYWx1ZScsXG4gICAgJ29yZGVyZWREb2N1bWVudEtleScsXG4gICAgJ2RvY3VtZW50S2V5J1xuXTtcbmNvbnN0IERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXggPSAnZG9jdW1lbnRLZXlJbmRleCc7XG5jb25zdCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4UGF0aCA9IFtcbiAgICAnaW5kZXhJZCcsXG4gICAgJ3VpZCcsXG4gICAgJ29yZGVyZWREb2N1bWVudEtleSdcbl07XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5U3RvcmUgPSAnZG9jdW1lbnRPdmVybGF5cyc7XG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGggPSBbXG4gICAgJ3VzZXJJZCcsXG4gICAgJ2NvbGxlY3Rpb25QYXRoJyxcbiAgICAnZG9jdW1lbnRJZCdcbl07XG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4ID0gJ2NvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4JztcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXhQYXRoID0gW1xuICAgICd1c2VySWQnLFxuICAgICdjb2xsZWN0aW9uUGF0aCcsXG4gICAgJ2xhcmdlc3RCYXRjaElkJ1xuXTtcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4ID0gJ2NvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCc7XG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGggPSBbXG4gICAgJ3VzZXJJZCcsXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXG4gICAgJ2xhcmdlc3RCYXRjaElkJ1xuXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJHbG9iYWxzU3RvcmUgPSAnZ2xvYmFscyc7XG5jb25zdCBEYkdsb2JhbHNLZXlQYXRoID0gJ25hbWUnO1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY29uc3QgVjFfU1RPUkVTID0gW1xuICAgIERiTXV0YXRpb25RdWV1ZVN0b3JlLFxuICAgIERiTXV0YXRpb25CYXRjaFN0b3JlLFxuICAgIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlLFxuICAgIERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxLFxuICAgIERiVGFyZ2V0U3RvcmUsXG4gICAgRGJQcmltYXJ5Q2xpZW50U3RvcmUsXG4gICAgRGJUYXJnZXRHbG9iYWxTdG9yZSxcbiAgICBEYlRhcmdldERvY3VtZW50U3RvcmVcbl07XG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jb25zdCBWM19TVE9SRVMgPSBWMV9TVE9SRVM7XG4vLyBOb3RlOiBEYlJlbW90ZURvY3VtZW50Q2hhbmdlcyBpcyBubyBsb25nZXIgdXNlZCBhbmQgZHJvcHBlZCB3aXRoIHY5LlxuY29uc3QgVjRfU1RPUkVTID0gWy4uLlYzX1NUT1JFUywgRGJDbGllbnRNZXRhZGF0YVN0b3JlXTtcbmNvbnN0IFY2X1NUT1JFUyA9IFsuLi5WNF9TVE9SRVMsIERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZV07XG5jb25zdCBWOF9TVE9SRVMgPSBbLi4uVjZfU1RPUkVTLCBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZV07XG5jb25zdCBWMTFfU1RPUkVTID0gWy4uLlY4X1NUT1JFUywgRGJCdW5kbGVTdG9yZSwgRGJOYW1lZFF1ZXJ5U3RvcmVdO1xuY29uc3QgVjEyX1NUT1JFUyA9IFsuLi5WMTFfU1RPUkVTLCBEYkRvY3VtZW50T3ZlcmxheVN0b3JlXTtcbmNvbnN0IFYxM19TVE9SRVMgPSBbXG4gICAgRGJNdXRhdGlvblF1ZXVlU3RvcmUsXG4gICAgRGJNdXRhdGlvbkJhdGNoU3RvcmUsXG4gICAgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUsXG4gICAgRGJSZW1vdGVEb2N1bWVudFN0b3JlLFxuICAgIERiVGFyZ2V0U3RvcmUsXG4gICAgRGJQcmltYXJ5Q2xpZW50U3RvcmUsXG4gICAgRGJUYXJnZXRHbG9iYWxTdG9yZSxcbiAgICBEYlRhcmdldERvY3VtZW50U3RvcmUsXG4gICAgRGJDbGllbnRNZXRhZGF0YVN0b3JlLFxuICAgIERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSxcbiAgICBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSxcbiAgICBEYkJ1bmRsZVN0b3JlLFxuICAgIERiTmFtZWRRdWVyeVN0b3JlLFxuICAgIERiRG9jdW1lbnRPdmVybGF5U3RvcmVcbl07XG5jb25zdCBWMTRfU1RPUkVTID0gVjEzX1NUT1JFUztcbmNvbnN0IFYxNV9TVE9SRVMgPSBbXG4gICAgLi4uVjE0X1NUT1JFUyxcbiAgICBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlLFxuICAgIERiSW5kZXhTdGF0ZVN0b3JlLFxuICAgIERiSW5kZXhFbnRyeVN0b3JlXG5dO1xuY29uc3QgVjE2X1NUT1JFUyA9IFYxNV9TVE9SRVM7XG5jb25zdCBWMTdfU1RPUkVTID0gWy4uLlYxNV9TVE9SRVMsIERiR2xvYmFsc1N0b3JlXTtcbi8qKiBSZXR1cm5zIHRoZSBvYmplY3Qgc3RvcmVzIGZvciB0aGUgcHJvdmlkZWQgc2NoZW1hLiAqL1xuZnVuY3Rpb24gZ2V0T2JqZWN0U3RvcmVzKHNjaGVtYVZlcnNpb24pIHtcbiAgICBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTcpIHtcbiAgICAgICAgcmV0dXJuIFYxN19TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE2KSB7XG4gICAgICAgIHJldHVybiBWMTZfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNSkge1xuICAgICAgICByZXR1cm4gVjE1X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTQpIHtcbiAgICAgICAgcmV0dXJuIFYxNF9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDEzKSB7XG4gICAgICAgIHJldHVybiBWMTNfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMikge1xuICAgICAgICByZXR1cm4gVjEyX1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTEpIHtcbiAgICAgICAgcmV0dXJuIFYxMV9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiVHJhbnNhY3Rpb24gZXh0ZW5kcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzaW1wbGVEYlRyYW5zYWN0aW9uLCBjdXJyZW50U2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaW1wbGVEYlRyYW5zYWN0aW9uID0gc2ltcGxlRGJUcmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2VOdW1iZXIgPSBjdXJyZW50U2VxdWVuY2VOdW1iZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RvcmUodHhuLCBzdG9yZSkge1xuICAgIGNvbnN0IGluZGV4ZWREYlRyYW5zYWN0aW9uID0gZGVidWdDYXN0KHR4bik7XG4gICAgcmV0dXJuIFNpbXBsZURiLmdldFN0b3JlKGluZGV4ZWREYlRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBmbihrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFRvQXJyYXkob2JqLCBmbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4ob2JqW2tleV0sIGtleSwgb2JqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBBbiBpbW11dGFibGUgc29ydGVkIG1hcCBpbXBsZW1lbnRhdGlvbiwgYmFzZWQgb24gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrXG4vLyB0cmVlLlxuY2xhc3MgU29ydGVkTWFwIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yLCByb290KSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QgPyByb290IDogTExSQk5vZGUuRU1QVFk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yLCB0aGlzLnJvb3RcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yKVxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yLCB0aGlzLnJvb3RcbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3IpXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoaXMgc29ydGVkIG1hcCwgb3IgLTEgaWYgaXQgZG9lc24ndFxuICAgIC8vIGV4aXN0LlxuICAgIGluZGV4T2Yoa2V5KSB7XG4gICAgICAgIC8vIE51bWJlciBvZiBub2RlcyB0aGF0IHdlcmUgcHJ1bmVkIHdoZW4gZGVzY2VuZGluZyByaWdodFxuICAgICAgICBsZXQgcHJ1bmVkTm9kZXMgPSAwO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcnVuZWROb2RlcyArIG5vZGUubGVmdC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VudCBhbGwgbm9kZXMgbGVmdCBvZiB0aGUgbm9kZSBwbHVzIHRoZSBub2RlIGl0c2VsZlxuICAgICAgICAgICAgICAgIHBydW5lZE5vZGVzICs9IG5vZGUubGVmdC5zaXplICsgMTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb2RlIG5vdCBmb3VuZFxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaXNFbXB0eSgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaXplO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgIG1pbktleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5taW5LZXkoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICBtYXhLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubWF4S2V5KCk7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAvLyBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xuICAgIH1cbiAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xuICAgICAgICAgICAgZm4oaywgdik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25zLnB1c2goYCR7a306JHt2fWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGB7JHtkZXNjcmlwdGlvbnMuam9pbignLCAnKX19YDtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uXG4gICAgLy8gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpc1xuICAgIC8vIGFib3J0ZWQuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgZmFsc2UpO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvckZyb20oa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgZmFsc2UpO1xuICAgIH1cbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBudWxsLCB0aGlzLmNvbXBhcmF0b3IsIHRydWUpO1xuICAgIH1cbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwga2V5LCB0aGlzLmNvbXBhcmF0b3IsIHRydWUpO1xuICAgIH1cbn0gLy8gZW5kIFNvcnRlZE1hcFxuLy8gQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlKSB7XG4gICAgICAgIHRoaXMuaXNSZXZlcnNlID0gaXNSZXZlcnNlO1xuICAgICAgICB0aGlzLm5vZGVTdGFjayA9IFtdO1xuICAgICAgICBsZXQgY21wID0gMTtcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXG4gICAgICAgICAgICBpZiAoc3RhcnRLZXkgJiYgaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgY21wICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb3VyIHN0YXJ0IGtleS4gUHVzaCBpdCBvbiB0aGUgc3RhY2ssXG4gICAgICAgICAgICAgICAgLy8gYnV0IHN0b3AgaXRlcmF0aW5nO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZ3JlYXRlciB0aGFuIG91ciBzdGFydCBrZXksIGFkZCBpdCB0byB0aGUgc3RhY2sgYW5kIG1vdmVcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHQoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGFzTmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVTdGFja1t0aGlzLm5vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcbiAgICB9XG59IC8vIGVuZCBTb3J0ZWRNYXBJdGVyYXRvclxuLy8gUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrIHRyZWUuXG5jbGFzcyBMTFJCTm9kZSB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvciAhPSBudWxsID8gY29sb3IgOiBMTFJCTm9kZS5SRUQ7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBMTFJCTm9kZS5FTVBUWTtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IExMUkJOb2RlLkVNUFRZO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmxlZnQuc2l6ZSArIDEgKyB0aGlzLnJpZ2h0LnNpemU7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSAhPSBudWxsID8ga2V5IDogdGhpcy5rZXksIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMudmFsdWUsIGNvbG9yICE9IG51bGwgPyBjb2xvciA6IHRoaXMuY29sb3IsIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLmxlZnQsIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgLy8gZm9yIGVhY2ggbm9kZS4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uXG4gICAgLy8gZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIG5vZGUgaW4gdGhlIHRyZWUuXG4gICAgbWluKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Lm1pbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgIG1pbktleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKCkua2V5O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICBtYXhLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihrZXksIG4ua2V5KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XG4gICAgfVxuICAgIHJlbW92ZU1pbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBMTFJCTm9kZS5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IHRoaXM7XG4gICAgICAgIGlmICghbi5sZWZ0LmlzUmVkKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQucmVtb3ZlTWluKCksIG51bGwpO1xuICAgICAgICByZXR1cm4gbi5maXhVcCgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIG5ldyB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbSByZW1vdmVkLlxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IHNtYWxsZXN0O1xuICAgICAgICBsZXQgbiA9IHRoaXM7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuLnJpZ2h0LmlzRW1wdHkoKSAmJiAhbi5yaWdodC5pc1JlZCgpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobi5yaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbigpO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcbiAgICB9XG4gICAgaXNSZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIG5ldyB0cmVlIGFmdGVyIHBlcmZvcm1pbmcgYW55IG5lZWRlZCByb3RhdGlvbnMuXG4gICAgZml4VXAoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgaWYgKG4ucmlnaHQuaXNSZWQoKSAmJiAhbi5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkgJiYgbi5yaWdodC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgbW92ZVJlZExlZnQoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHQoKSk7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0KCk7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgbW92ZVJlZFJpZ2h0KCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwKCk7XG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHJvdGF0ZUxlZnQoKSB7XG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBubCwgbnVsbCk7XG4gICAgfVxuICAgIHJvdGF0ZVJpZ2h0KCkge1xuICAgICAgICBjb25zdCBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XG4gICAgfVxuICAgIGNvbG9yRmxpcCgpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgLy8gRm9yIHRlc3RpbmcuXG4gICAgY2hlY2tNYXhEZXB0aCgpIHtcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2soKTtcbiAgICAgICAgaWYgKE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5zaXplICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW4gYSBiYWxhbmNlZCBSQiB0cmVlLCB0aGUgYmxhY2stZGVwdGggKG51bWJlciBvZiBibGFjayBub2RlcykgZnJvbSByb290IHRvXG4gICAgLy8gbGVhdmVzIGlzIGVxdWFsIG9uIGJvdGggc2lkZXMuICBUaGlzIGZ1bmN0aW9uIHZlcmlmaWVzIHRoYXQgb3IgYXNzZXJ0cy5cbiAgICBjaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWQoKSAmJiB0aGlzLmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrKCk7XG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrKCkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBibGFja0RlcHRoICsgKHRoaXMuaXNSZWQoKSA/IDAgOiAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0gLy8gZW5kIExMUkJOb2RlXG4vLyBFbXB0eSBub2RlIGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBMTFJCIHRyZWVzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbkxMUkJOb2RlLkVNUFRZID0gbnVsbDtcbkxMUkJOb2RlLlJFRCA9IHRydWU7XG5MTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xuLy8gUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxuY2xhc3MgTExSQkVtcHR5Tm9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1pbktleSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1heEtleSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlzUmVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZvciB0ZXN0aW5nLlxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufSAvLyBlbmQgTExSQkVtcHR5Tm9kZVxuTExSQk5vZGUuRU1QVFkgPSBuZXcgTExSQkVtcHR5Tm9kZSgpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTb3J0ZWRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZWxlbWVudHNcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci5cbiAqXG4gKiBOT1RFOiBpZiBwcm92aWRlZCBjb21wYXJhdG9yIHJldHVybnMgMCBmb3IgdHdvIGVsZW1lbnRzLCB3ZSBjb25zaWRlciB0aGVtIHRvXG4gKiBiZSBlcXVhbCFcbiAqL1xuY2xhc3MgU29ydGVkU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgaGFzKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZWxlbSkgIT09IG51bGw7XG4gICAgfVxuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1pbktleSgpO1xuICAgIH1cbiAgICBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1heEtleSgpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zaXplO1xuICAgIH1cbiAgICBpbmRleE9mKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pbmRleE9mKGVsZW0pO1xuICAgIH1cbiAgICAvKiogSXRlcmF0ZXMgZWxlbWVudHMgaW4gb3JkZXIgZGVmaW5lZCBieSBcImNvbXBhcmF0b3JcIiAqL1xuICAgIGZvckVhY2goY2IpIHtcbiAgICAgICAgdGhpcy5kYXRhLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcbiAgICAgICAgICAgIGNiKGspO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHJhbmdlWzBdICZsdDs9IGVsZW0gJmx0OyByYW5nZVsxXS4gKi9cbiAgICBmb3JFYWNoSW5SYW5nZShyYW5nZSwgY2IpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20ocmFuZ2VbMF0pO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3IoZWxlbS5rZXksIHJhbmdlWzFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoZWxlbS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHN0YXJ0ICZsdDs9IGVsZW0gdW50aWwgZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZm9yRWFjaFdoaWxlKGNiLCBzdGFydCkge1xuICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKGVsZW0ua2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBGaW5kcyB0aGUgbGVhc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGVsZW1gLiAqL1xuICAgIGZpcnN0QWZ0ZXJPckVxdWFsKGVsZW0pIHtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oZWxlbSk7XG4gICAgICAgIHJldHVybiBpdGVyLmhhc05leHQoKSA/IGl0ZXIuZ2V0TmV4dCgpLmtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpKTtcbiAgICB9XG4gICAgZ2V0SXRlcmF0b3JGcm9tKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oa2V5KSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCAqL1xuICAgIGFkZChlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKS5pbnNlcnQoZWxlbSwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKiogRGVsZXRlcyBhbiBlbGVtZW50ICovXG4gICAgZGVsZXRlKGVsZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhlbGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VtcHR5KCk7XG4gICAgfVxuICAgIHVuaW9uV2l0aChvdGhlcikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcztcbiAgICAgICAgLy8gTWFrZSBzdXJlIGByZXN1bHRgIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhcmdlciBvbmUgb2YgdGhlIHR3byBzZXRzLlxuICAgICAgICBpZiAocmVzdWx0LnNpemUgPCBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvdGhlcjtcbiAgICAgICAgICAgIG90aGVyID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChlbGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTb3J0ZWRTZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXNJdCA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpO1xuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuZGF0YS5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAodGhpc0l0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0VsZW0gPSB0aGlzSXQuZ2V0TmV4dCgpLmtleTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRWxlbSA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3IodGhpc0VsZW0sIG90aGVyRWxlbSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgcmVzLnB1c2godGFyZ2V0SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZWxlbSA9PiByZXN1bHQucHVzaChlbGVtKSk7XG4gICAgICAgIHJldHVybiAnU29ydGVkU2V0KCcgKyByZXN1bHQudG9TdHJpbmcoKSArICcpJztcbiAgICB9XG4gICAgY29weShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTb3J0ZWRTZXQodGhpcy5jb21wYXJhdG9yKTtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmNsYXNzIFNvcnRlZFNldEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyKSB7XG4gICAgICAgIHRoaXMuaXRlciA9IGl0ZXI7XG4gICAgfVxuICAgIGdldE5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuZ2V0TmV4dCgpLmtleTtcbiAgICB9XG4gICAgaGFzTmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5oYXNOZXh0KCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gc29ydGVkIHNldHMgZm9yIGVxdWFsaXR5IHVzaW5nIHRoZWlyIG5hdHVyYWwgb3JkZXJpbmcuIFRoZVxuICogbWV0aG9kIGNvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gYW5kIGludm9rZXMgYG9uQWRkYCBmb3IgZXZlcnkgZWxlbWVudCB0aGF0XG4gKiBpcyBpbiBgYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuIGBvblJlbW92ZWAgaXMgaW52b2tlZCBmb3IgZXZlcnkgZWxlbWVudCBpblxuICogYGJlZm9yZWAgYnV0IG1pc3NpbmcgZnJvbSBgYWZ0ZXJgLlxuICpcbiAqIFRoZSBtZXRob2QgY3JlYXRlcyBhIGNvcHkgb2YgYm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhbmQgcnVucyBpbiBPKG4gbG9nXG4gKiBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgdHdvIGxpc3RzLlxuICpcbiAqIEBwYXJhbSBiZWZvcmUgLSBUaGUgZWxlbWVudHMgdGhhdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgc2V0LlxuICogQHBhcmFtIGFmdGVyIC0gVGhlIGVsZW1lbnRzIHRvIGRpZmYgYWdhaW5zdCB0aGUgb3JpZ2luYWwgc2V0LlxuICogQHBhcmFtIGNvbXBhcmF0b3IgLSBUaGUgY29tcGFyYXRvciBmb3IgdGhlIGVsZW1lbnRzIGluIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxuICogYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuXG4gKiBAcGFyYW0gb25SZW1vdmUgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2ZcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cbiAqL1xuZnVuY3Rpb24gZGlmZlNvcnRlZFNldHMoYmVmb3JlLCBhZnRlciwgY29tcGFyYXRvciwgb25BZGQsIG9uUmVtb3ZlKSB7XG4gICAgY29uc3QgYmVmb3JlSXQgPSBiZWZvcmUuZ2V0SXRlcmF0b3IoKTtcbiAgICBjb25zdCBhZnRlckl0ID0gYWZ0ZXIuZ2V0SXRlcmF0b3IoKTtcbiAgICBsZXQgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xuICAgIGxldCBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgdHdvIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgdXNpbmcgdGhlIG9yZGVyaW5nIGRlZmluZWQgYnlcbiAgICAvLyBgY29tcGFyYXRvcmAuXG4gICAgd2hpbGUgKGJlZm9yZVZhbHVlIHx8IGFmdGVyVmFsdWUpIHtcbiAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChiZWZvcmVWYWx1ZSAmJiBhZnRlclZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGJlZm9yZVZhbHVlLCBhZnRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZFxuICAgICAgICAgICAgICAgIC8vIHdhbGt0aHJvdWdoIGlzIG9ubHkgaW4gYGJlZm9yZWAuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBpcyBvbmx5IGluIGBhZnRlcmAuXG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgb25BZGQoYWZ0ZXJWYWx1ZSk7XG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIG9uUmVtb3ZlKGJlZm9yZVZhbHVlKTtcbiAgICAgICAgICAgIGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcbiAgICAgICAgICAgIGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBpdGVyYXRvciBvciBgdW5kZWZpbmVkYCBpZiBub25lIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZUl0ZXJhdG9yKGl0KSB7XG4gICAgcmV0dXJuIGl0Lmhhc05leHQoKSA/IGl0LmdldE5leHQoKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXMgYSBzZXQgb2YgZmllbGRzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcGFydGlhbGx5IHBhdGNoIGEgZG9jdW1lbnQuXG4gKiBGaWVsZE1hc2sgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIE9iamVjdFZhbHVlLlxuICogRXhhbXBsZXM6XG4gKiAgIGZvbyAtIE92ZXJ3cml0ZXMgZm9vIGVudGlyZWx5IHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLiBJZiBmb28gaXMgbm90XG4gKiAgICAgICAgIHByZXNlbnQgaW4gdGhlIGNvbXBhbmlvbiBPYmplY3RWYWx1ZSwgdGhlIGZpZWxkIGlzIGRlbGV0ZWQuXG4gKiAgIGZvby5iYXIgLSBPdmVyd3JpdGVzIG9ubHkgdGhlIGZpZWxkIGJhciBvZiB0aGUgb2JqZWN0IGZvby5cbiAqICAgICAgICAgICAgIElmIGZvbyBpcyBub3QgYW4gb2JqZWN0LCBmb28gaXMgcmVwbGFjZWQgd2l0aCBhbiBvYmplY3RcbiAqICAgICAgICAgICAgIGNvbnRhaW5pbmcgZm9vXG4gKi9cbmNsYXNzIEZpZWxkTWFzayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IHZhbGlkYXRpb24gb2YgRmllbGRNYXNrXG4gICAgICAgIC8vIFNvcnQgdGhlIGZpZWxkIG1hc2sgdG8gc3VwcG9ydCBgRmllbGRNYXNrLmlzRXF1YWwoKWAgYW5kIGFzc2VydCBiZWxvdy5cbiAgICAgICAgZmllbGRzLnNvcnQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEZpZWxkTWFzayBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGFkZGluZyBhbGwgdGhlIGdpdmVuXG4gICAgICogZmllbGRzIHBhdGhzIHRvIHRoaXMgZmllbGQgbWFzay5cbiAgICAgKi9cbiAgICB1bmlvbldpdGgoZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgbGV0IG1lcmdlZE1hc2tTZXQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgbWVyZ2VkTWFza1NldCA9IG1lcmdlZE1hc2tTZXQuYWRkKGZpZWxkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIG1lcmdlZE1hc2tTZXQgPSBtZXJnZWRNYXNrU2V0LmFkZChmaWVsZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKG1lcmdlZE1hc2tTZXQudG9BcnJheSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCBgZmllbGRQYXRoYCBpcyBpbmNsdWRlZCBieSBhdCBsZWFzdCBvbmUgZmllbGQgaW4gdGhpcyBmaWVsZFxuICAgICAqIG1hc2suXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIE8obikgb3BlcmF0aW9uLCB3aGVyZSBgbmAgaXMgdGhlIHNpemUgb2YgdGhlIGZpZWxkIG1hc2suXG4gICAgICovXG4gICAgY292ZXJzKGZpZWxkUGF0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTWFza1BhdGggb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZE1hc2tQYXRoLmlzUHJlZml4T2YoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHModGhpcy5maWVsZHMsIG90aGVyLmZpZWxkcywgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIENvbnZlcnRzIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYmluYXJ5IHN0cmluZy4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XG4gICAgLy8gTm90ZTogV2UgdXNlZCB0byB2YWxpZGF0ZSB0aGUgYmFzZTY0IHN0cmluZyBoZXJlIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAvLyBUaGlzIHdhcyByZW1vdmVkIHRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlIG9mIGluZGV4aW5nLlxuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbmNvZGVkLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xufVxuLyoqIENvbnZlcnRzIGEgYmluYXJ5IHN0cmluZyB0byBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZy4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChyYXcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmF3LCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuLyoqIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIEJhc2U2NCBjb252ZXJzaW9uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLiAqL1xuZnVuY3Rpb24gaXNCYXNlNjRBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEltbXV0YWJsZSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBcInByb3RvXCIgYnl0ZSBzdHJpbmcuXG4gKlxuICogUHJvdG8gYnl0ZSBzdHJpbmdzIGNhbiBlaXRoZXIgYmUgQmFzZTY0LWVuY29kZWQgc3RyaW5ncyBvciBVaW50OEFycmF5cyB3aGVuXG4gKiBzZW50IG9uIHRoZSB3aXJlLiBUaGlzIGNsYXNzIGFic3RyYWN0cyBhd2F5IHRoaXMgZGlmZmVyZW50aWF0aW9uIGJ5IGhvbGRpbmdcbiAqIHRoZSBwcm90byBieXRlIHN0cmluZyBpbiBhIGNvbW1vbiBjbGFzcyB0aGF0IG11c3QgYmUgY29udmVydGVkIGludG8gYSBzdHJpbmdcbiAqIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgcHJvdG8uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQnl0ZVN0cmluZyB7XG4gICAgY29uc3RydWN0b3IoYmluYXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpIHtcbiAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gZGVjb2RlQmFzZTY0KGJhc2U2NCk7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk7IFJlbW92ZSB0aGUgY29weSBvZiB0aGUgYnl0ZSBzdHJpbmcgaGVyZSBhcyB0aGlzIG1ldGhvZFxuICAgICAgICAvLyBpcyBmcmVxdWVudGx5IGNhbGxlZCBkdXJpbmcgaW5kZXhpbmcuXG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5KGFycmF5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlU3RyaW5nKGJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmJpbmFyeVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSsrKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0KHRoaXMuYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgdG9VaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheUZyb21CaW5hcnlTdHJpbmcodGhpcy5iaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBhcHByb3hpbWF0ZUJ5dGVTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoICogMjtcbiAgICB9XG4gICAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuYmluYXJ5U3RyaW5nLCBvdGhlci5iaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVN0cmluZyA9PT0gb3RoZXIuYmluYXJ5U3RyaW5nO1xuICAgIH1cbn1cbkJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcgPSBuZXcgQnl0ZVN0cmluZygnJyk7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIFVpbnQ4YXJyYXkgdG8gYSBiaW5hcnkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiaW5hcnlTdHJpbmdGcm9tVWludDhBcnJheShhcnJheSkge1xuICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmFyeVN0cmluZztcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBiaW5hcnkgc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlGcm9tQmluYXJ5U3RyaW5nKGJpbmFyeVN0cmluZykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gQSBSZWdFeHAgbWF0Y2hpbmcgSVNPIDg2MDEgVVRDIHRpbWVzdGFtcHMgd2l0aCBvcHRpb25hbCBmcmFjdGlvbi5cbmNvbnN0IElTT19USU1FU1RBTVBfUkVHX0VYUCA9IG5ldyBSZWdFeHAoL15cXGR7NH0tXFxkXFxkLVxcZFxcZFRcXGRcXGQ6XFxkXFxkOlxcZFxcZCg/OlxcLihcXGQrKSk/WiQvKTtcbi8qKlxuICogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHZhbHVlcyBmb3IgYSB0aW1lc3RhbXAgdmFsdWUgaW50byBhIFwic2Vjb25kcyBhbmRcbiAqIG5hbm9zXCIgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVzdGFtcChkYXRlKSB7XG4gICAgaGFyZEFzc2VydCghIWRhdGUpO1xuICAgIC8vIFRoZSBqc29uIGludGVyZmFjZSAoZm9yIHRoZSBicm93c2VyKSB3aWxsIHJldHVybiBhbiBpc28gdGltZXN0YW1wIHN0cmluZyxcbiAgICAvLyB3aGlsZSB0aGUgcHJvdG8ganMgbGlicmFyeSAoZm9yIG5vZGUpIHdpbGwgcmV0dXJuIGFcbiAgICAvLyBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGluc3RhbmNlLlxuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVGhlIGRhdGUgc3RyaW5nIGNhbiBoYXZlIGhpZ2hlciBwcmVjaXNpb24gKG5hbm9zKSB0aGFuIHRoZSBEYXRlIGNsYXNzXG4gICAgICAgIC8vIChtaWxsaXMpLCBzbyB3ZSBkbyBzb21lIGN1c3RvbSBwYXJzaW5nIGhlcmUuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBuYW5vcyByaWdodCBvdXQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgbGV0IG5hbm9zID0gMDtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSBJU09fVElNRVNUQU1QX1JFR19FWFAuZXhlYyhkYXRlKTtcbiAgICAgICAgaGFyZEFzc2VydCghIWZyYWN0aW9uKTtcbiAgICAgICAgaWYgKGZyYWN0aW9uWzFdKSB7XG4gICAgICAgICAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIG91dCB0byA5IGRpZ2l0cyAobmFub3MpLlxuICAgICAgICAgICAgbGV0IG5hbm9TdHIgPSBmcmFjdGlvblsxXTtcbiAgICAgICAgICAgIG5hbm9TdHIgPSAobmFub1N0ciArICcwMDAwMDAwMDAnKS5zdWJzdHIoMCwgOSk7XG4gICAgICAgICAgICBuYW5vcyA9IE51bWJlcihuYW5vU3RyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSB0aGUgZGF0ZSB0byBnZXQgdGhlIHNlY29uZHMuXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IocGFyc2VkRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE8oYi8zNzI4MjIzNyk6IFVzZSBzdHJpbmdzIGZvciBQcm90bzMgdGltZXN0YW1wc1xuICAgICAgICAvLyBhc3NlcnQoIXRoaXMub3B0aW9ucy51c2VQcm90bzNKc29uLFxuICAgICAgICAvLyAgICdUaGUgdGltZXN0YW1wIGluc3RhbmNlIGZvcm1hdCByZXF1aXJlcyBQcm90byBKUy4nKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLnNlY29uZHMpO1xuICAgICAgICBjb25zdCBuYW5vcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLm5hbm9zKTtcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgbnVtYmVycyBpbnRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBSZXR1cm5zIDAgaWYgdGhlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOdW1iZXIodmFsdWUpIHtcbiAgICAvLyBUT0RPKGJqb3JuaWNrKTogSGFuZGxlIGludDY0IGdyZWF0ZXIgdGhhbiA1MyBiaXRzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbi8qKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIEJsb2JzIGludG8gYSBCeXRlU3RyaW5nLiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQnl0ZVN0cmluZyhibG9iKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJsb2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYmxvYik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbG9jYWxseS1hcHBsaWVkIFNlcnZlclRpbWVzdGFtcC5cbiAqXG4gKiBTZXJ2ZXIgVGltZXN0YW1wcyBhcmUgYmFja2VkIGJ5IE1hcFZhbHVlcyB0aGF0IGNvbnRhaW4gYW4gaW50ZXJuYWwgZmllbGRcbiAqIGBfX3R5cGVfX2Agd2l0aCBhIHZhbHVlIG9mIGBzZXJ2ZXJfdGltZXN0YW1wYC4gVGhlIHByZXZpb3VzIHZhbHVlIGFuZCBsb2NhbFxuICogd3JpdGUgdGltZSBhcmUgc3RvcmVkIGluIGl0cyBgX19wcmV2aW91c192YWx1ZV9fYCBhbmQgYF9fbG9jYWxfd3JpdGVfdGltZV9fYFxuICogZmllbGRzIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gU2VydmVyVGltZXN0YW1wVmFsdWUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGFzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYVxuICogICB0cmFuc2Zvcm0uIFRoZXkgY2FuIG9ubHkgZXhpc3QgaW4gdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gVGhlcmVmb3JlXG4gKiAgIHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgcGFyc2VkIG9yIHNlcmlhbGl6ZWQuXG4gKiAtIFdoZW4gZXZhbHVhdGVkIGxvY2FsbHkgKGUuZy4gZm9yIHNuYXBzaG90LmRhdGEoKSksIHRoZXkgYnkgZGVmYXVsdFxuICogICBldmFsdWF0ZSB0byBgbnVsbGAuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgcGFzc2luZyBjdXN0b21cbiAqICAgRmllbGRWYWx1ZU9wdGlvbnMgdG8gdmFsdWUoKS5cbiAqIC0gV2l0aCByZXNwZWN0IHRvIG90aGVyIFNlcnZlclRpbWVzdGFtcFZhbHVlcywgdGhleSBzb3J0IGJ5IHRoZWlyXG4gKiAgIGxvY2FsV3JpdGVUaW1lLlxuICovXG5jb25zdCBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMID0gJ3NlcnZlcl90aW1lc3RhbXAnO1xuY29uc3QgVFlQRV9LRVkkMSA9ICdfX3R5cGVfXyc7XG5jb25zdCBQUkVWSU9VU19WQUxVRV9LRVkgPSAnX19wcmV2aW91c192YWx1ZV9fJztcbmNvbnN0IExPQ0FMX1dSSVRFX1RJTUVfS0VZID0gJ19fbG9jYWxfd3JpdGVfdGltZV9fJztcbmZ1bmN0aW9uIGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB0eXBlID0gKF9iID0gKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubWFwVmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWVsZHMpIHx8IHt9KVtUWVBFX0tFWSQxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0eXBlID09PSBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNlcnZlclRpbWVzdGFtcCBwcm90byB2YWx1ZSAodXNpbmcgdGhlIGludGVybmFsIGZvcm1hdCkuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCQxKGxvY2FsV3JpdGVUaW1lLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgY29uc3QgbWFwVmFsdWUgPSB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgW1RZUEVfS0VZJDFdOiB7XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWU6IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbTE9DQUxfV1JJVEVfVElNRV9LRVldOiB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kczogbG9jYWxXcml0ZVRpbWUuc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgICAgbmFub3M6IGxvY2FsV3JpdGVUaW1lLm5hbm9zZWNvbmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXZSBzaG91bGQgYXZvaWQgc3RvcmluZyBkZWVwbHkgbmVzdGVkIHNlcnZlciB0aW1lc3RhbXAgbWFwIHZhbHVlc1xuICAgIC8vIGJlY2F1c2Ugd2UgbmV2ZXIgdXNlIHRoZSBpbnRlcm1lZGlhdGUgXCJwcmV2aW91cyB2YWx1ZXNcIi5cbiAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAvLyBwcmV2aW91czogNDJMLCBhZGQ6IHQxLCByZXN1bHQ6IHQxIC0+IDQyTFxuICAgIC8vIHByZXZpb3VzOiB0MSwgIGFkZDogdDIsIHJlc3VsdDogdDIgLT4gNDJMIChOT1QgdDIgLT4gdDEgLT4gNDJMKVxuICAgIC8vIHByZXZpb3VzOiB0MiwgIGFkZDogdDMsIHJlc3VsdDogdDMgLT4gNDJMIChOT1QgdDMgLT4gdDIgLT4gdDEgLT4gNDJMKVxuICAgIC8vIGBnZXRQcmV2aW91c1ZhbHVlYCByZWN1cnNpdmVseSB0cmF2ZXJzZXMgc2VydmVyIHRpbWVzdGFtcHMgdG8gZmluZCB0aGVcbiAgICAvLyBsZWFzdCByZWNlbnQgVmFsdWUuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgaXNTZXJ2ZXJUaW1lc3RhbXAocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgIG1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFwVmFsdWUgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGJlZm9yZSB0aGlzIFNlcnZlclRpbWVzdGFtcCB3YXMgc2V0LlxuICpcbiAqIFByZXNlcnZpbmcgdGhlIHByZXZpb3VzIHZhbHVlcyBhbGxvd3MgdGhlIHVzZXIgdG8gZGlzcGxheSB0aGUgbGFzdCByZXNvbGVkXG4gKiB2YWx1ZSB1bnRpbCB0aGUgYmFja2VuZCByZXNwb25kcyB3aXRoIHRoZSB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIGdldFByZXZpb3VzVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdmFsdWUubWFwVmFsdWUuZmllbGRzW1BSRVZJT1VTX1ZBTFVFX0tFWV07XG4gICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBnZXRQcmV2aW91c1ZhbHVlKHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbG9jYWwgdGltZSBhdCB3aGljaCB0aGlzIHRpbWVzdGFtcCB3YXMgZmlyc3Qgc2V0LlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFdyaXRlVGltZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tMT0NBTF9XUklURV9USU1FX0tFWV0udGltZXN0YW1wVmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGxvY2FsV3JpdGVUaW1lLnNlY29uZHMsIGxvY2FsV3JpdGVUaW1lLm5hbm9zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIERhdGFiYXNlSW5mbyB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIERhdGFiYXNlSW5mbyB1c2luZyB0aGUgcHJvdmlkZWQgaG9zdCwgZGF0YWJhc2VJZCBhbmRcbiAgICAgKiBwZXJzaXN0ZW5jZUtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhYmFzZUlkIC0gVGhlIGRhdGFiYXNlIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gYXBwSWQgLSBUaGUgRmlyZWJhc2UgQXBwIElkLlxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgRmlyZXN0b3JlJ3MgbG9jYWxcbiAgICAgKiBzdG9yYWdlICh1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGRhdGFiYXNlSWQpLlxuICAgICAqIEBwYXJhbSBob3N0IC0gVGhlIEZpcmVzdG9yZSBiYWNrZW5kIGhvc3QgdG8gY29ubmVjdCB0by5cbiAgICAgKiBAcGFyYW0gc3NsIC0gV2hldGhlciB0byB1c2UgU1NMIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gZm9yY2VMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBmb3JjZUxvbmdQb2xsaW5nIG9wdGlvblxuICAgICAqIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGF1dG9EZXRlY3RMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBkZXRlY3RCdWZmZXJpbmdQcm94eVxuICAgICAqIG9wdGlvbiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBsb25nUG9sbGluZ09wdGlvbnMgT3B0aW9ucyB0aGF0IGNvbmZpZ3VyZSBsb25nLXBvbGxpbmcuXG4gICAgICogQHBhcmFtIHVzZUZldGNoU3RyZWFtcyBXaGV0aGVyIHRvIHVzZSB0aGUgRmV0Y2ggQVBJIGluc3RlYWQgb2ZcbiAgICAgKiBYTUxIVFRQUmVxdWVzdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlSWQsIGFwcElkLCBwZXJzaXN0ZW5jZUtleSwgaG9zdCwgc3NsLCBmb3JjZUxvbmdQb2xsaW5nLCBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmcsIGxvbmdQb2xsaW5nT3B0aW9ucywgdXNlRmV0Y2hTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnNzbCA9IHNzbDtcbiAgICAgICAgdGhpcy5mb3JjZUxvbmdQb2xsaW5nID0gZm9yY2VMb25nUG9sbGluZztcbiAgICAgICAgdGhpcy5hdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmc7XG4gICAgICAgIHRoaXMubG9uZ1BvbGxpbmdPcHRpb25zID0gbG9uZ1BvbGxpbmdPcHRpb25zO1xuICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9IHVzZUZldGNoU3RyZWFtcztcbiAgICB9XG59XG4vKiogVGhlIGRlZmF1bHQgZGF0YWJhc2UgbmFtZSBmb3IgYSBwcm9qZWN0LiAqL1xuY29uc3QgREVGQVVMVF9EQVRBQkFTRV9OQU1FID0gJyhkZWZhdWx0KSc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRhdGFiYXNlIElEIGEgRmlyZXN0b3JlIGNsaWVudCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRGF0YWJhc2VJZCB7XG4gICAgY29uc3RydWN0b3IocHJvamVjdElkLCBkYXRhYmFzZSkge1xuICAgICAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgICAgICAgdGhpcy5kYXRhYmFzZSA9IGRhdGFiYXNlID8gZGF0YWJhc2UgOiBERUZBVUxUX0RBVEFCQVNFX05BTUU7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhYmFzZUlkKCcnLCAnJyk7XG4gICAgfVxuICAgIGdldCBpc0RlZmF1bHREYXRhYmFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UgPT09IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgRGF0YWJhc2VJZCAmJlxuICAgICAgICAgICAgb3RoZXIucHJvamVjdElkID09PSB0aGlzLnByb2plY3RJZCAmJlxuICAgICAgICAgICAgb3RoZXIuZGF0YWJhc2UgPT09IHRoaXMuZGF0YWJhc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2UpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYXBwbHkoYXBwLm9wdGlvbnMsIFsncHJvamVjdElkJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdcInByb2plY3RJZFwiIG5vdCBwcm92aWRlZCBpbiBmaXJlYmFzZS5pbml0aWFsaXplQXBwLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSWQoYXBwLm9wdGlvbnMucHJvamVjdElkLCBkYXRhYmFzZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogU2VudGluZWwgdmFsdWUgdGhhdCBzb3J0cyBiZWZvcmUgYW55IE11dGF0aW9uIEJhdGNoIElELiAqL1xuY29uc3QgQkFUQ0hJRF9VTktOT1dOID0gLTE7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHZhbHVlIHJlcHJlc2VudHMgLTAuICovXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkge1xuICAgIC8vIERldGVjdCBpZiB0aGUgdmFsdWUgaXMgLTAuMC4gQmFzZWQgb24gcG9seWZpbGwgZnJvbVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IDEgLyAtMDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZVxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QgZm9yIGJlaW5nIGFuIGludGVnZXIgYW5kIGluIHRoZSBzYWZlIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiZcbiAgICAgICAgIWlzTmVnYXRpdmVaZXJvKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZSA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJlxuICAgICAgICB2YWx1ZSA+PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBUWVBFX0tFWSA9ICdfX3R5cGVfXyc7XG5jb25zdCBNQVhfVkFMVUVfVFlQRSA9ICdfX21heF9fJztcbmNvbnN0IE1BWF9WQUxVRSA9IHtcbiAgICBtYXBWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICdfX3R5cGVfXyc6IHsgc3RyaW5nVmFsdWU6IE1BWF9WQUxVRV9UWVBFIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBWRUNUT1JfVkFMVUVfU0VOVElORUwgPSAnX192ZWN0b3JfXyc7XG5jb25zdCBWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZID0gJ3ZhbHVlJztcbmNvbnN0IE1JTl9WQUxVRSA9IHtcbiAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xufTtcbi8qKiBFeHRyYWN0cyB0aGUgYmFja2VuZCdzIHR5cGUgb3JkZXIgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZS4gKi9cbmZ1bmN0aW9uIHR5cGVPcmRlcih2YWx1ZSkge1xuICAgIGlmICgnbnVsbFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01heFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVmVjdG9yVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbi8qKiBUZXN0cyBgbGVmdGAgYW5kIGByaWdodGAgZm9yIGVxdWFsaXR5IGJhc2VkIG9uIHRoZSBiYWNrZW5kIHNlbWFudGljcy4gKi9cbmZ1bmN0aW9uIHZhbHVlRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VHlwZSA9IHR5cGVPcmRlcihsZWZ0KTtcbiAgICBjb25zdCByaWdodFR5cGUgPSB0eXBlT3JkZXIocmlnaHQpO1xuICAgIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LmJvb2xlYW5WYWx1ZSA9PT0gcmlnaHQuYm9vbGVhblZhbHVlO1xuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGdldExvY2FsV3JpdGVUaW1lKGxlZnQpLmlzRXF1YWwoZ2V0TG9jYWxXcml0ZVRpbWUocmlnaHQpKTtcbiAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQuc3RyaW5nVmFsdWUgPT09IHJpZ2h0LnN0cmluZ1ZhbHVlO1xuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnJlZmVyZW5jZVZhbHVlID09PSByaWdodC5yZWZlcmVuY2VWYWx1ZTtcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGdlb1BvaW50RXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSwgcmlnaHQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHZhbHVlRXF1YWxzKTtcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi86XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBsZWZ0LnRpbWVzdGFtcFZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgcmlnaHQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGxlZnQudGltZXN0YW1wVmFsdWUubGVuZ3RoID09PSByaWdodC50aW1lc3RhbXBWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIHN0cmluZyBlcXVhbGl0eSBmb3IgSVNPIDg2MDEgdGltZXN0YW1wc1xuICAgICAgICByZXR1cm4gbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gcmlnaHQudGltZXN0YW1wVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAobGVmdC50aW1lc3RhbXBWYWx1ZSk7XG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQudGltZXN0YW1wVmFsdWUpO1xuICAgIHJldHVybiAobGVmdFRpbWVzdGFtcC5zZWNvbmRzID09PSByaWdodFRpbWVzdGFtcC5zZWNvbmRzICYmXG4gICAgICAgIGxlZnRUaW1lc3RhbXAubmFub3MgPT09IHJpZ2h0VGltZXN0YW1wLm5hbm9zKTtcbn1cbmZ1bmN0aW9uIGdlb1BvaW50RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIChub3JtYWxpemVOdW1iZXIobGVmdC5nZW9Qb2ludFZhbHVlLmxhdGl0dWRlKSA9PT1cbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpICYmXG4gICAgICAgIG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSA9PT1cbiAgICAgICAgICAgIG5vcm1hbGl6ZU51bWJlcihyaWdodC5nZW9Qb2ludFZhbHVlLmxvbmdpdHVkZSkpO1xufVxuZnVuY3Rpb24gYmxvYkVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBub3JtYWxpemVCeXRlU3RyaW5nKGxlZnQuYnl0ZXNWYWx1ZSkuaXNFcXVhbChub3JtYWxpemVCeXRlU3RyaW5nKHJpZ2h0LmJ5dGVzVmFsdWUpKTtcbn1cbmZ1bmN0aW9uIG51bWJlckVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICgnaW50ZWdlclZhbHVlJyBpbiBsZWZ0ICYmICdpbnRlZ2VyVmFsdWUnIGluIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuaW50ZWdlclZhbHVlKSA9PT0gbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmludGVnZXJWYWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZG91YmxlVmFsdWUnIGluIGxlZnQgJiYgJ2RvdWJsZVZhbHVlJyBpbiByaWdodCkge1xuICAgICAgICBjb25zdCBuMSA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmRvdWJsZVZhbHVlKTtcbiAgICAgICAgY29uc3QgbjIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuZG91YmxlVmFsdWUpO1xuICAgICAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZVplcm8objEpID09PSBpc05lZ2F0aXZlWmVybyhuMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4objEpICYmIGlzTmFOKG4yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvYmplY3RFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5tYXBWYWx1ZS5maWVsZHMgfHwge307XG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5tYXBWYWx1ZS5maWVsZHMgfHwge307XG4gICAgaWYgKG9iamVjdFNpemUobGVmdE1hcCkgIT09IG9iamVjdFNpemUocmlnaHRNYXApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbGVmdE1hcCkge1xuICAgICAgICBpZiAobGVmdE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRNYXBba2V5XSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgIXZhbHVlRXF1YWxzKGxlZnRNYXBba2V5XSwgcmlnaHRNYXBba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBBcnJheVZhbHVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGFycmF5VmFsdWVDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgcmV0dXJuICgoaGF5c3RhY2sudmFsdWVzIHx8IFtdKS5maW5kKHYgPT4gdmFsdWVFcXVhbHModiwgbmVlZGxlKSkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiB2YWx1ZUNvbXBhcmUobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRUeXBlID0gdHlwZU9yZGVyKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHR5cGVPcmRlcihyaWdodCk7XG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFR5cGUsIHJpZ2h0VHlwZSk7XG4gICAgfVxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmJvb2xlYW5WYWx1ZSwgcmlnaHQuYm9vbGVhblZhbHVlKTtcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTnVtYmVycyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMobGVmdC50aW1lc3RhbXBWYWx1ZSwgcmlnaHQudGltZXN0YW1wVmFsdWUpO1xuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVUaW1lc3RhbXBzKGdldExvY2FsV3JpdGVUaW1lKGxlZnQpLCBnZXRMb2NhbFdyaXRlVGltZShyaWdodCkpO1xuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5zdHJpbmdWYWx1ZSwgcmlnaHQuc3RyaW5nVmFsdWUpO1xuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQmxvYnMobGVmdC5ieXRlc1ZhbHVlLCByaWdodC5ieXRlc1ZhbHVlKTtcbiAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlUmVmZXJlbmNlcyhsZWZ0LnJlZmVyZW5jZVZhbHVlLCByaWdodC5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlR2VvUG9pbnRzKGxlZnQuZ2VvUG9pbnRWYWx1ZSwgcmlnaHQuZ2VvUG9pbnRWYWx1ZSk7XG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnQuYXJyYXlWYWx1ZSwgcmlnaHQuYXJyYXlWYWx1ZSk7XG4gICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZWN0b3JzKGxlZnQubWFwVmFsdWUsIHJpZ2h0Lm1hcFZhbHVlKTtcbiAgICAgICAgY2FzZSAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZU1hcHMobGVmdC5tYXBWYWx1ZSwgcmlnaHQubWFwVmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSB8fCBsZWZ0LmRvdWJsZVZhbHVlKTtcbiAgICBjb25zdCByaWdodE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUgfHwgcmlnaHQuZG91YmxlVmFsdWUpO1xuICAgIGlmIChsZWZ0TnVtYmVyIDwgcmlnaHROdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID4gcmlnaHROdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnROdW1iZXIgPT09IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb25lIG9yIGJvdGggYXJlIE5hTi5cbiAgICAgICAgaWYgKGlzTmFOKGxlZnROdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4ocmlnaHROdW1iZXIpID8gMCA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBsZWZ0Lmxlbmd0aCA9PT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0KTtcbiAgICBjb25zdCByaWdodFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChyaWdodCk7XG4gICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5zZWNvbmRzLCByaWdodFRpbWVzdGFtcC5zZWNvbmRzKTtcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5uYW5vcywgcmlnaHRUaW1lc3RhbXAubmFub3MpO1xufVxuZnVuY3Rpb24gY29tcGFyZVJlZmVyZW5jZXMobGVmdFBhdGgsIHJpZ2h0UGF0aCkge1xuICAgIGNvbnN0IGxlZnRTZWdtZW50cyA9IGxlZnRQYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgcmlnaHRTZWdtZW50cyA9IHJpZ2h0UGF0aC5zcGxpdCgnLycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdFNlZ21lbnRzLmxlbmd0aCAmJiBpIDwgcmlnaHRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0U2VnbWVudHNbaV0sIHJpZ2h0U2VnbWVudHNbaV0pO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzLmxlbmd0aCwgcmlnaHRTZWdtZW50cy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gY29tcGFyZUdlb1BvaW50cyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxhdGl0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxhdGl0dWRlKSk7XG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxvbmdpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sb25naXR1ZGUpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCbG9icyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdCk7XG4gICAgY29uc3QgcmlnaHRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQpO1xuICAgIHJldHVybiBsZWZ0Qnl0ZXMuY29tcGFyZVRvKHJpZ2h0Qnl0ZXMpO1xufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRBcnJheSA9IGxlZnQudmFsdWVzIHx8IFtdO1xuICAgIGNvbnN0IHJpZ2h0QXJyYXkgPSByaWdodC52YWx1ZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXJyYXkubGVuZ3RoICYmIGkgPCByaWdodEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdEFycmF5W2ldLCByaWdodEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRBcnJheS5sZW5ndGgsIHJpZ2h0QXJyYXkubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVWZWN0b3JzKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0LmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCByaWdodE1hcCA9IHJpZ2h0LmZpZWxkcyB8fCB7fTtcbiAgICAvLyBUaGUgdmVjdG9yIGlzIGEgbWFwLCBidXQgb25seSB2ZWN0b3IgdmFsdWUgaXMgY29tcGFyZWQuXG4gICAgY29uc3QgbGVmdEFycmF5VmFsdWUgPSAoX2EgPSBsZWZ0TWFwW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXJyYXlWYWx1ZTtcbiAgICBjb25zdCByaWdodEFycmF5VmFsdWUgPSAoX2IgPSByaWdodE1hcFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFycmF5VmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoQ29tcGFyZSA9IHByaW1pdGl2ZUNvbXBhcmF0b3IoKChfYyA9IGxlZnRBcnJheVZhbHVlID09PSBudWxsIHx8IGxlZnRBcnJheVZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWZ0QXJyYXlWYWx1ZS52YWx1ZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHx8IDAsICgoX2QgPSByaWdodEFycmF5VmFsdWUgPT09IG51bGwgfHwgcmlnaHRBcnJheVZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdodEFycmF5VmFsdWUudmFsdWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSB8fCAwKTtcbiAgICBpZiAobGVuZ3RoQ29tcGFyZSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoQ29tcGFyZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVBcnJheXMobGVmdEFycmF5VmFsdWUsIHJpZ2h0QXJyYXlWYWx1ZSk7XG59XG5mdW5jdGlvbiBjb21wYXJlTWFwcyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUgJiYgcmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaWdodCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdE1hcCk7XG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5maWVsZHMgfHwge307XG4gICAgY29uc3QgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHRNYXApO1xuICAgIC8vIEV2ZW4gdGhvdWdoIE1hcFZhbHVlcyBhcmUgbGlrZWx5IHNvcnRlZCBjb3JyZWN0bHkgYmFzZWQgb24gdGhlaXIgaW5zZXJ0aW9uXG4gICAgLy8gb3JkZXIgKGUuZy4gd2hlbiByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kKSwgbG9jYWwgbW9kaWZpY2F0aW9ucyBjYW4gYnJpbmdcbiAgICAvLyBlbGVtZW50cyBvdXQgb2Ygb3JkZXIuIFdlIG5lZWQgdG8gcmUtc29ydCB0aGUgZWxlbWVudHMgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBjYW5vbmljYWwgSURzIGFyZSBpbmRlcGVuZGVudCBvZiBpbnNlcnRpb24gb3JkZXIuXG4gICAgbGVmdEtleXMuc29ydCgpO1xuICAgIHJpZ2h0S2V5cy5zb3J0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0S2V5cy5sZW5ndGggJiYgaSA8IHJpZ2h0S2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXlDb21wYXJlID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcbiAgICAgICAgaWYgKGtleUNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlDb21wYXJlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdE1hcFtsZWZ0S2V5c1tpXV0sIHJpZ2h0TWFwW3JpZ2h0S2V5c1tpXV0pO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXMubGVuZ3RoLCByaWdodEtleXMubGVuZ3RoKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZSBwcm92aWRlZCBmaWVsZCB2YWx1ZSAoYXMgdXNlZCBpbiBUYXJnZXRcbiAqIHNlcmlhbGl6YXRpb24pLlxuICovXG5mdW5jdGlvbiBjYW5vbmljYWxJZCh2YWx1ZSkge1xuICAgIHJldHVybiBjYW5vbmlmeVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuYm9vbGVhblZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZS5pbnRlZ2VyVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuZG91YmxlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeVJlZmVyZW5jZSh2YWx1ZS5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeUFycmF5KHZhbHVlLmFycmF5VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeU1hcCh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5Qnl0ZVN0cmluZyhieXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykudG9CYXNlNjQoKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VGltZXN0YW1wKHRpbWVzdGFtcCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICByZXR1cm4gYHRpbWUoJHtub3JtYWxpemVkVGltZXN0YW1wLnNlY29uZHN9LCR7bm9ybWFsaXplZFRpbWVzdGFtcC5uYW5vc30pYDtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5R2VvUG9pbnQoZ2VvUG9pbnQpIHtcbiAgICByZXR1cm4gYGdlbygke2dlb1BvaW50LmxhdGl0dWRlfSwke2dlb1BvaW50LmxvbmdpdHVkZX0pYDtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5UmVmZXJlbmNlKHJlZmVyZW5jZVZhbHVlKSB7XG4gICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHJlZmVyZW5jZVZhbHVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2Fub25pZnlNYXAobWFwVmFsdWUpIHtcbiAgICAvLyBJdGVyYXRpb24gb3JkZXIgaW4gSmF2YVNjcmlwdCBpcyBub3QgZ3VhcmFudGVlZC4gVG8gZW5zdXJlIHRoYXQgd2UgZ2VuZXJhdGVcbiAgICAvLyBtYXRjaGluZyBjYW5vbmljYWwgSURzIGZvciBpZGVudGljYWwgbWFwcywgd2UgbmVlZCB0byBzb3J0IHRoZSBrZXlzLlxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhtYXBWYWx1ZS5maWVsZHMgfHwge30pLnNvcnQoKTtcbiAgICBsZXQgcmVzdWx0ID0gJ3snO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7a2V5fToke2Nhbm9uaWZ5VmFsdWUobWFwVmFsdWUuZmllbGRzW2tleV0pfWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG59XG5mdW5jdGlvbiBjYW5vbmlmeUFycmF5KGFycmF5VmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gJ1snO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2Fub25pZnlWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgKGFuZCB3aWxkbHkgaW5hY2N1cmF0ZSkgaW4tbWVtb3J5IHNpemUgZm9yIHRoZSBmaWVsZFxuICogdmFsdWUuXG4gKlxuICogVGhlIG1lbW9yeSBzaXplIHRha2VzIGludG8gYWNjb3VudCBvbmx5IHRoZSBhY3R1YWwgdXNlciBkYXRhIGFzIGl0IHJlc2lkZXNcbiAqIGluIG1lbW9yeSBhbmQgaWdub3JlcyBvYmplY3Qgb3ZlcmhlYWQuXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZVNpemUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgLy8gVGltZXN0YW1wcyBhcmUgbWFkZSB1cCBvZiB0d28gZGlzdGluY3QgbnVtYmVycyAoc2Vjb25kcyArIG5hbm9zZWNvbmRzKVxuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgPyAxNiArIGVzdGltYXRlQnl0ZVNpemUocHJldmlvdXNWYWx1ZSkgOiAxNjtcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0RhdGFfc3RydWN0dXJlczpcbiAgICAgICAgICAgIC8vIFwiSmF2YVNjcmlwdCdzIFN0cmluZyB0eXBlIGlzIFsuLi5dIGEgc2V0IG9mIGVsZW1lbnRzIG9mIDE2LWJpdCB1bnNpZ25lZFxuICAgICAgICAgICAgLy8gaW50ZWdlciB2YWx1ZXNcIlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlLmxlbmd0aCAqIDI7XG4gICAgICAgIGNhc2UgNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcodmFsdWUuYnl0ZXNWYWx1ZSkuYXBwcm94aW1hdGVCeXRlU2l6ZSgpO1xuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlZmVyZW5jZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxuICAgICAgICAgICAgLy8gR2VvUG9pbnRzIGFyZSBtYWRlIHVwIG9mIHR3byBkaXN0aW5jdCBudW1iZXJzIChsYXRpdHVkZSArIGxvbmdpdHVkZSlcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGVzdGltYXRlQXJyYXlCeXRlU2l6ZSh2YWx1ZS5hcnJheVZhbHVlKTtcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi86XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGVzdGltYXRlTWFwQnl0ZVNpemUodmFsdWUubWFwVmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzdGltYXRlTWFwQnl0ZVNpemUobWFwVmFsdWUpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgZm9yRWFjaChtYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbCkgPT4ge1xuICAgICAgICBzaXplICs9IGtleS5sZW5ndGggKyBlc3RpbWF0ZUJ5dGVTaXplKHZhbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZUFycmF5Qnl0ZVNpemUoYXJyYXlWYWx1ZSkge1xuICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLnJlZHVjZSgocHJldmlvdXNTaXplLCB2YWx1ZSkgPT4gcHJldmlvdXNTaXplICsgZXN0aW1hdGVCeXRlU2l6ZSh2YWx1ZSksIDApO1xufVxuLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBkYXRhYmFzZSBhbmQga2V5LiAqL1xuZnVuY3Rpb24gcmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmZXJlbmNlVmFsdWU6IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfS9kYXRhYmFzZXMvJHtkYXRhYmFzZUlkLmRhdGFiYXNlfS9kb2N1bWVudHMvJHtrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKX1gXG4gICAgfTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBJbnRlZ2VyVmFsdWUgLiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBEb3VibGVWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzRG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBlaXRoZXIgYW4gSW50ZWdlclZhbHVlIG9yIGEgRG91YmxlVmFsdWUuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IGlzRG91YmxlKHZhbHVlKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBBcnJheVZhbHVlLiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdhcnJheVZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE51bGxWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ251bGxWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgTmFOLiAqL1xuZnVuY3Rpb24gaXNOYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWUgJiYgaXNOYU4oTnVtYmVyKHZhbHVlLmRvdWJsZVZhbHVlKSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBNYXBWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzTWFwVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnbWFwVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgVmV0b3JWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzVmVjdG9yVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHR5cGUgPSAoX2IgPSAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tYXBWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwge30pW1RZUEVfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0eXBlID09PSBWRUNUT1JfVkFMVUVfU0VOVElORUw7XG59XG4vKiogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBgc291cmNlYC4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmdlb1BvaW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLmdlb1BvaW50VmFsdWUpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZS50aW1lc3RhbXBWYWx1ZSAmJlxuICAgICAgICB0eXBlb2Ygc291cmNlLnRpbWVzdGFtcFZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnRpbWVzdGFtcFZhbHVlKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UubWFwVmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcbiAgICAgICAgZm9yRWFjaChzb3VyY2UubWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+ICh0YXJnZXQubWFwVmFsdWUuZmllbGRzW2tleV0gPSBkZWVwQ2xvbmUodmFsKSkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UuYXJyYXlWYWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiBbXSB9IH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5hcnJheVZhbHVlLnZhbHVlc1tpXSA9IGRlZXBDbG9uZShzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBWYWx1ZSByZXByZXNlbnRzIHRoZSBjYW5vbmljYWwge0BsaW5rICNNQVhfVkFMVUV9IC4gKi9cbmZ1bmN0aW9uIGlzTWF4VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKCgoKHZhbHVlLm1hcFZhbHVlIHx8IHt9KS5maWVsZHMgfHwge30pWydfX3R5cGVfXyddIHx8IHt9KS5zdHJpbmdWYWx1ZSA9PT1cbiAgICAgICAgTUFYX1ZBTFVFX1RZUEUpO1xufVxuY29uc3QgTUlOX1ZFQ1RPUl9WQUxVRSA9IHtcbiAgICBtYXBWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHsgc3RyaW5nVmFsdWU6IFZFQ1RPUl9WQUxVRV9TRU5USU5FTCB9LFxuICAgICAgICAgICAgW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldOiB7XG4gICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiogUmV0dXJucyB0aGUgbG93ZXN0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgdHlwZSAoaW5jbHVzaXZlKS4gKi9cbmZ1bmN0aW9uIHZhbHVlc0dldExvd2VyQm91bmQodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiBmYWxzZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBOYU4gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogeyBzZWNvbmRzOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShEYXRhYmFzZUlkLmVtcHR5KCksIERvY3VtZW50S2V5LmVtcHR5KCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNWZWN0b3JWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkVDVE9SX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcFZhbHVlOiB7fSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGV4Y2x1c2l2ZSkuICovXG5mdW5jdGlvbiB2YWx1ZXNHZXRVcHBlckJvdW5kKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IE5hTiB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiB7IHNlY29uZHM6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKERhdGFiYXNlSWQuZW1wdHkoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNSU5fVkVDVE9SX1ZBTFVFO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1ZlY3RvclZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWFwVmFsdWU6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG93ZXJCb3VuZENvbXBhcmUobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjbXAgPSB2YWx1ZUNvbXBhcmUobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICYmICFyaWdodC5pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGVmdC5pbmNsdXNpdmUgJiYgcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHVwcGVyQm91bmRDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY21wID0gdmFsdWVDb21wYXJlKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAmJiAhcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGVmdC5pbmNsdXNpdmUgJiYgcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIE9iamVjdFZhbHVlIHJlcHJlc2VudHMgYSBNYXBWYWx1ZSBpbiB0aGUgRmlyZXN0b3JlIFByb3RvIGFuZCBvZmZlcnMgdGhlXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIGZpZWxkcyAodmlhIHRoZSBPYmplY3RWYWx1ZUJ1aWxkZXIpLlxuICovXG5jbGFzcyBPYmplY3RWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZToge30gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBvciBudWxsIGlmIHRoZSBwYXRoIGlzIG5vdCBzZXQuXG4gICAgICovXG4gICAgZmllbGQocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gKGN1cnJlbnRMZXZlbC5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3BhdGguZ2V0KGkpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwVmFsdWUoY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5sYXN0U2VnbWVudCgpXTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWwgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWVsZCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXRoLnBvcExhc3QoKSk7XG4gICAgICAgIGZpZWxkc01hcFtwYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvdmlkZWQgZmllbGRzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEEgbWFwIG9mIGZpZWxkcyB0byB2YWx1ZXMgKG9yIG51bGwgZm9yIGRlbGV0ZXMpLlxuICAgICAqL1xuICAgIHNldEFsbChkYXRhKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKTtcbiAgICAgICAgbGV0IHVwc2VydHMgPSB7fTtcbiAgICAgICAgbGV0IGRlbGV0ZXMgPSBbXTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKCh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNJbW1lZGlhdGVQYXJlbnRPZihwYXRoKSkge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgYWNjdW11bGF0ZWQgY2hhbmdlcyBhdCB0aGlzIHBhcmVudCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcbiAgICAgICAgICAgICAgICB1cHNlcnRzID0ge307XG4gICAgICAgICAgICAgICAgZGVsZXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdXBzZXJ0c1twYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaChwYXRoLmxhc3RTZWdtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcbiAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZmllbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBubyBmaWVsZCBhdCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcGF0aCwgbm90aGluZyBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZmllbGQgcGF0aCB0byByZW1vdmUuXG4gICAgICovXG4gICAgZGVsZXRlKHBhdGgpIHtcbiAgICAgICAgY29uc3QgbmVzdGVkVmFsdWUgPSB0aGlzLmZpZWxkKHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgaWYgKGlzTWFwVmFsdWUobmVzdGVkVmFsdWUpICYmIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkcykge1xuICAgICAgICAgICAgZGVsZXRlIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkc1twYXRoLmxhc3RTZWdtZW50KCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlRXF1YWxzKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwIHRoYXQgY29udGFpbnMgdGhlIGxlYWYgZWxlbWVudCBvZiBgcGF0aGAuIElmIHRoZSBwYXJlbnRcbiAgICAgKiBlbnRyeSBkb2VzIG5vdCB5ZXQgZXhpc3QsIG9yIGlmIGl0IGlzIG5vdCBhIG1hcCwgYSBuZXcgbWFwIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBnZXRGaWVsZHNNYXAocGF0aCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICghY3VycmVudC5tYXBWYWx1ZS5maWVsZHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUgPSB7IGZpZWxkczoge30gfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldO1xuICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKG5leHQpIHx8ICFuZXh0Lm1hcFZhbHVlLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzW3BhdGguZ2V0KGkpXSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC5tYXBWYWx1ZS5maWVsZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGBmaWVsZHNNYXBgIGJ5IGFkZGluZywgcmVwbGFjaW5nIG9yIGRlbGV0aW5nIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqL1xuICAgIGFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIGluc2VydHMsIGRlbGV0ZXMpIHtcbiAgICAgICAgZm9yRWFjaChpbnNlcnRzLCAoa2V5LCB2YWwpID0+IChmaWVsZHNNYXBba2V5XSA9IHZhbCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGRlbGV0ZXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNNYXBbZmllbGRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKGRlZXBDbG9uZSh0aGlzLnZhbHVlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgRmllbGRNYXNrIGJ1aWx0IGZyb20gYWxsIGZpZWxkcyBpbiBhIE1hcFZhbHVlLlxuICovXG5mdW5jdGlvbiBleHRyYWN0RmllbGRNYXNrKHZhbHVlKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yRWFjaCh2YWx1ZS5maWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gbmV3IEZpZWxkUGF0aCQxKFtrZXldKTtcbiAgICAgICAgaWYgKGlzTWFwVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRNYXNrID0gZXh0cmFjdEZpZWxkTWFzayh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBuZXN0ZWRNYXNrLmZpZWxkcztcbiAgICAgICAgICAgIGlmIChuZXN0ZWRGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIGVtcHR5IG1hcCBieSBhZGRpbmcgaXQgdG8gdGhlIEZpZWxkTWFzay5cbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFmIG5vZGVzLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkUGF0aCBvZiBuZXN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGguY2hpbGQobmVzdGVkUGF0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBuZXN0ZWQgYW5kIG5vbi1lbXB0eSBPYmplY3RWYWx1ZXMsIGFkZCB0aGUgRmllbGRQYXRoIG9mIHRoZSBsZWFmXG4gICAgICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmllbGRNYXNrKGZpZWxkcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUgd2l0aCBhIGtleSwgdmVyc2lvbiwgZGF0YSBhbmQgd2hldGhlciBpdFxuICogaGFzIGxvY2FsIG11dGF0aW9ucyBhcHBsaWVkIHRvIGl0LlxuICpcbiAqIERvY3VtZW50cyBjYW4gdHJhbnNpdGlvbiBiZXR3ZWVuIHN0YXRlcyB2aWEgYGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoKWAsXG4gKiBgY29udmVydFRvTm9Eb2N1bWVudCgpYCBhbmQgYGNvbnZlcnRUb1Vua25vd25Eb2N1bWVudCgpYC4gSWYgYSBkb2N1bWVudCBkb2VzXG4gKiBub3QgdHJhbnNpdGlvbiB0byBvbmUgb2YgdGhlc2Ugc3RhdGVzIGV2ZW4gYWZ0ZXIgYWxsIG11dGF0aW9ucyBoYXZlIGJlZW5cbiAqIGFwcGxpZWQsIGBpc1ZhbGlkRG9jdW1lbnQoKWAgcmV0dXJucyBmYWxzZSBhbmQgdGhlIGRvY3VtZW50IHNob3VsZCBiZSByZW1vdmVkXG4gKiBmcm9tIGFsbCB2aWV3cy5cbiAqL1xuY2xhc3MgTXV0YWJsZURvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRvY3VtZW50VHlwZSwgdmVyc2lvbiwgcmVhZFRpbWUsIGNyZWF0ZVRpbWUsIGRhdGEsIGRvY3VtZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gZG9jdW1lbnRUeXBlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG4gICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IGNyZWF0ZVRpbWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IGRvY3VtZW50U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkb2N1bWVudCB3aXRoIG5vIGtub3duIHZlcnNpb24gb3IgZGF0YSwgYnV0IHdoaWNoIGNhbiBzZXJ2ZSBhc1xuICAgICAqIGJhc2UgZG9jdW1lbnQgZm9yIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxuICAgICAqIGdpdmVuIHZlcnNpb24uXG4gICAgICovXG4gICAgc3RhdGljIG5ld0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gY3JlYXRlVGltZSwgdmFsdWUsIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbi4gKi9cbiAgICBzdGF0aWMgbmV3Tm9Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8sIFxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbiBidXRcbiAgICAgKiB3aG9zZSBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXG4gICAgICogYmFzZSBkb2N1bWVudCkuXG4gICAgICovXG4gICAgc3RhdGljIG5ld1Vua25vd25Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGFuZCB0aGF0IGl0cyB2ZXJzaW9uXG4gICAgICogYW5kIGRhdGEgYXJlIGtub3duLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQodmVyc2lvbiwgdmFsdWUpIHtcbiAgICAgICAgLy8gSWYgYSBkb2N1bWVudCBpcyBzd2l0Y2hpbmcgc3RhdGUgZnJvbSBiZWluZyBhbiBpbnZhbGlkIG9yIGRlbGV0ZWRcbiAgICAgICAgLy8gZG9jdW1lbnQgdG8gYSB2YWxpZCAoRk9VTkRfRE9DVU1FTlQpIGRvY3VtZW50LCBlaXRoZXIgZHVlIHRvIHJlY2VpdmluZyBhblxuICAgICAgICAvLyB1cGRhdGUgZnJvbSBXYXRjaCBvciBkdWUgdG8gYXBwbHlpbmcgYSBsb2NhbCBzZXQgbXV0YXRpb24gb24gdG9wXG4gICAgICAgIC8vIG9mIGEgZGVsZXRlZCBkb2N1bWVudCwgb3VyIGJlc3QgZ3Vlc3MgYWJvdXQgaXRzIGNyZWF0ZVRpbWUgd291bGQgYmUgdGhlXG4gICAgICAgIC8vIHZlcnNpb24gYXQgd2hpY2ggdGhlIGRvY3VtZW50IHRyYW5zaXRpb25lZCB0byBhIEZPVU5EX0RPQ1VNRU5ULlxuICAgICAgICBpZiAodGhpcy5jcmVhdGVUaW1lLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSAmJlxuICAgICAgICAgICAgKHRoaXMuZG9jdW1lbnRUeXBlID09PSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaW1lID0gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovO1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0IGV4aXN0IGF0IHRoZSBnaXZlblxuICAgICAqIHZlcnNpb24uXG4gICAgICovXG4gICAgY29udmVydFRvTm9Eb2N1bWVudCh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGF0IGEgZ2l2ZW4gdmVyc2lvbiBidXRcbiAgICAgKiB0aGF0IGl0cyBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXG4gICAgICogYmFzZSBkb2N1bWVudCkuXG4gICAgICovXG4gICAgY29udmVydFRvVW5rbm93bkRvY3VtZW50KHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEhhc0xvY2FsTXV0YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAxIC8qIERvY3VtZW50U3RhdGUuSEFTX0xPQ0FMX01VVEFUSU9OUyAqLztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UmVhZFRpbWUocmVhZFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGhhc0xvY2FsTXV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAxIC8qIERvY3VtZW50U3RhdGUuSEFTX0xPQ0FMX01VVEFUSU9OUyAqLztcbiAgICB9XG4gICAgZ2V0IGhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xuICAgIH1cbiAgICBnZXQgaGFzUGVuZGluZ1dyaXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTG9jYWxNdXRhdGlvbnMgfHwgdGhpcy5oYXNDb21taXR0ZWRNdXRhdGlvbnM7XG4gICAgfVxuICAgIGlzVmFsaWREb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlICE9PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovO1xuICAgIH1cbiAgICBpc0ZvdW5kRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi87XG4gICAgfVxuICAgIGlzTm9Eb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLztcbiAgICB9XG4gICAgaXNVbmtub3duRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLztcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTXV0YWJsZURvY3VtZW50ICYmXG4gICAgICAgICAgICB0aGlzLmtleS5pc0VxdWFsKG90aGVyLmtleSkgJiZcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5pc0VxdWFsKG90aGVyLnZlcnNpb24pICYmXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9PT0gb3RoZXIuZG9jdW1lbnRUeXBlICYmXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPT09IG90aGVyLmRvY3VtZW50U3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pc0VxdWFsKG90aGVyLmRhdGEpKTtcbiAgICB9XG4gICAgbXV0YWJsZUNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmNyZWF0ZVRpbWUsIHRoaXMuZGF0YS5jbG9uZSgpLCB0aGlzLmRvY3VtZW50U3RhdGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgRG9jdW1lbnQoJHt0aGlzLmtleX0sICR7dGhpcy52ZXJzaW9ufSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEudmFsdWUpfSwgYCArXG4gICAgICAgICAgICBge2NyZWF0ZVRpbWU6ICR7dGhpcy5jcmVhdGVUaW1lfX0pLCBgICtcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRUeXBlOiAke3RoaXMuZG9jdW1lbnRUeXBlfX0pLCBgICtcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRTdGF0ZTogJHt0aGlzLmRvY3VtZW50U3RhdGV9fSlgKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBhcmVzIHRoZSB2YWx1ZSBmb3IgZmllbGQgYGZpZWxkYCBpbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzLiBUaHJvd3MgaWZcbiAqIHRoZSBmaWVsZCBkb2VzIG5vdCBleGlzdCBpbiBib3RoIGRvY3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZURvY3VtZW50c0J5RmllbGQoZmllbGQsIGQxLCBkMikge1xuICAgIGNvbnN0IHYxID0gZDEuZGF0YS5maWVsZChmaWVsZCk7XG4gICAgY29uc3QgdjIgPSBkMi5kYXRhLmZpZWxkKGZpZWxkKTtcbiAgICBpZiAodjEgIT09IG51bGwgJiYgdjIgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQ29tcGFyZSh2MSwgdjIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBib3VuZCBvZiBhIHF1ZXJ5LlxuICpcbiAqIFRoZSBib3VuZCBpcyBzcGVjaWZpZWQgd2l0aCB0aGUgZ2l2ZW4gY29tcG9uZW50cyByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBhbmRcbiAqIHdoZXRoZXIgaXQncyBqdXN0IGJlZm9yZSBvciBqdXN0IGFmdGVyIHRoZSBwb3NpdGlvbiAocmVsYXRpdmUgdG8gd2hhdGV2ZXIgdGhlXG4gKiBxdWVyeSBvcmRlciBpcykuXG4gKlxuICogVGhlIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsb2dpY2FsIGluZGV4IHBvc2l0aW9uIGZvciBhIHF1ZXJ5LiBJdCdzIGEgcHJlZml4XG4gKiBvZiB2YWx1ZXMgZm9yIHRoZSAocG90ZW50aWFsbHkgaW1wbGljaXQpIG9yZGVyIGJ5IGNsYXVzZXMgb2YgYSBxdWVyeS5cbiAqXG4gKiBCb3VuZCBwcm92aWRlcyBhIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZG9jdW1lbnQgY29tZXMgYmVmb3JlIG9yXG4gKiBhZnRlciBhIGJvdW5kLiBUaGlzIGlzIGluZmx1ZW5jZWQgYnkgd2hldGhlciB0aGUgcG9zaXRpb24gaXMganVzdCBiZWZvcmUgb3JcbiAqIGp1c3QgYWZ0ZXIgdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqL1xuY2xhc3MgQm91bmQge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmluY2x1c2l2ZSA9IGluY2x1c2l2ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBsZXQgY29tcGFyaXNvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoRG9jdW1lbnRLZXkuZnJvbU5hbWUoY29tcG9uZW50LnJlZmVyZW5jZVZhbHVlKSwgZG9jLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkb2NWYWx1ZSA9IGRvYy5kYXRhLmZpZWxkKG9yZGVyQnlDb21wb25lbnQuZmllbGQpO1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IHZhbHVlQ29tcGFyZShjb21wb25lbnQsIGRvY1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5kaXIgPT09IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovKSB7XG4gICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyaXNvbiAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcGFyaXNvbjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYWZ0ZXIgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxuICogb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGJvdW5kU29ydHNBZnRlckRvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcbiAgICByZXR1cm4gYm91bmQuaW5jbHVzaXZlID8gY29tcGFyaXNvbiA+PSAwIDogY29tcGFyaXNvbiA+IDA7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGRvY3VtZW50IHNvcnRzIGJlZm9yZSBhIGJvdW5kIHVzaW5nIHRoZSBwcm92aWRlZCBzb3J0XG4gKiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gYm91bmRTb3J0c0JlZm9yZURvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcbiAgICByZXR1cm4gYm91bmQuaW5jbHVzaXZlID8gY29tcGFyaXNvbiA8PSAwIDogY29tcGFyaXNvbiA8IDA7XG59XG5mdW5jdGlvbiBib3VuZEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaWdodCA9PT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgIT09IHJpZ2h0LmluY2x1c2l2ZSB8fFxuICAgICAgICBsZWZ0LnBvc2l0aW9uLmxlbmd0aCAhPT0gcmlnaHQucG9zaXRpb24ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0LnBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlZnRQb3NpdGlvbiA9IGxlZnQucG9zaXRpb25baV07XG4gICAgICAgIGNvbnN0IHJpZ2h0UG9zaXRpb24gPSByaWdodC5wb3NpdGlvbltpXTtcbiAgICAgICAgaWYgKCF2YWx1ZUVxdWFscyhsZWZ0UG9zaXRpb24sIHJpZ2h0UG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIG9yZGVyaW5nIG9uIGEgZmllbGQsIGluIHNvbWUgRGlyZWN0aW9uLiBEaXJlY3Rpb24gZGVmYXVsdHMgdG8gQVNDRU5ESU5HLlxuICovXG5jbGFzcyBPcmRlckJ5IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZGlyID0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgfVxufVxuZnVuY3Rpb24gY2Fub25pZnlPcmRlckJ5KG9yZGVyQnkpIHtcbiAgICAvLyBUT0RPKGIvMjkxODMxNjUpOiBNYWtlIHRoaXMgY29sbGlzaW9uIHJvYnVzdC5cbiAgICByZXR1cm4gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSArIG9yZGVyQnkuZGlyO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T3JkZXJCeShvcmRlckJ5KSB7XG4gICAgcmV0dXJuIGAke29yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICgke29yZGVyQnkuZGlyfSlgO1xufVxuZnVuY3Rpb24gb3JkZXJCeUVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LmRpciA9PT0gcmlnaHQuZGlyICYmIGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGaWx0ZXIge1xufVxuY2xhc3MgRmllbGRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNGaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNBbnlGaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqL1xuICAgICAgICAgICAgPyBuZXcgS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgdmFsdWUpXG4gICAgICAgICAgICA6IG5ldyBLZXlGaWVsZE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIC8vIFR5cGVzIGRvIG5vdCBoYXZlIHRvIG1hdGNoIGluIE5PVF9FUVVBTCBmaWx0ZXJzLlxuICAgICAgICBpZiAodGhpcy5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgY29tcGFyZSB0eXBlcyB3aXRoIG1hdGNoaW5nIGJhY2tlbmQgb3JkZXIgKHN1Y2ggYXMgZG91YmxlIGFuZCBpbnQpLlxuICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlT3JkZXIodGhpcy52YWx1ZSkgPT09IHR5cGVPcmRlcihvdGhlcikgJiZcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xuICAgIH1cbiAgICBtYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPCAwO1xuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDw9IDA7XG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiAhPT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+PSAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5lcXVhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi8sXG4gICAgICAgICAgICBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovLFxuICAgICAgICAgICAgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovLFxuICAgICAgICAgICAgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLyxcbiAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sXG4gICAgICAgICAgICBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL1xuICAgICAgICBdLmluZGV4T2YodGhpcy5vcCkgPj0gMCk7XG4gICAgfVxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzLCBvcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZmlsdGVycywgb3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVGaWx0ZXIoZmlsdGVycywgb3ApO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbih0aGlzKSkge1xuICAgICAgICAgICAgLy8gRm9yIGNvbmp1bmN0aW9ucywgYWxsIGZpbHRlcnMgbXVzdCBtYXRjaCwgc28gcmV0dXJuIGZhbHNlIGlmIGFueSBmaWx0ZXIgZG9lc24ndCBtYXRjaC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gIWZpbHRlci5tYXRjaGVzKGRvYykpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgZGlzanVuY3Rpb25zLCBhdCBsZWFzdCBvbmUgZmlsdGVyIHNob3VsZCBtYXRjaC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gZmlsdGVyLm1hdGNoZXMoZG9jKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycyA9IHRoaXMuZmlsdGVycy5yZWR1Y2UoKHJlc3VsdCwgc3ViZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChzdWJmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBtdXRhYmxlIGNvcHkgb2YgYHRoaXMuZmlsdGVyc2BcbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXIub3AgPT09IFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xufVxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyLm9wID09PSBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpbHRlciBpcyBhIGNvbmp1bmN0aW9uIG9mIGZpZWxkIGZpbHRlcnMgb25seS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIHJldHVybiAoY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmlsdGVyIGRvZXMgbm90IGNvbnRhaW4gYW55IGNvbXBvc2l0ZSBmaWx0ZXJzLiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAvLyBUT0RPKGIvMjkxODMxNjUpOiBUZWNobmljYWxseSwgdGhpcyB3b24ndCBiZSB1bmlxdWUgaWYgdHdvIHZhbHVlcyBoYXZlXG4gICAgICAgIC8vIHRoZSBzYW1lIGRlc2NyaXB0aW9uLCBzdWNoIGFzIHRoZSBpbnQgMyBhbmQgdGhlIHN0cmluZyBcIjNcIi4gU28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGFkZCB0aGUgdHlwZXMgaW4gaGVyZSBzb21laG93LCB0b28uXG4gICAgICAgIHJldHVybiAoZmlsdGVyLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpICtcbiAgICAgICAgICAgIGZpbHRlci5vcC50b1N0cmluZygpICtcbiAgICAgICAgICAgIGNhbm9uaWNhbElkKGZpbHRlci52YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgICAgIC8vIE9sZGVyIFNESyB2ZXJzaW9ucyB1c2UgYW4gaW1wbGljaXQgQU5EIG9wZXJhdGlvbiBiZXR3ZWVuIHRoZWlyIGZpbHRlcnMuXG4gICAgICAgIC8vIEluIHRoZSBuZXcgU0RLIHZlcnNpb25zLCB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgYW4gZXhwbGljaXQgQU5EIGZpbHRlci5cbiAgICAgICAgLy8gVG8gc3RheSBjb25zaXN0ZW50IHdpdGggdGhlIG9sZCB1c2FnZXMsIHdlIGFkZCBhIHNwZWNpYWwgY2FzZSB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGNhbm9uaWNhbCBJRCBmb3IgdGhlc2UgdHdvIGFyZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBjb2wud2hlcmVFcXVhbHMoXCJhXCIsIDEpLndoZXJlRXF1YWxzKFwiYlwiLCAyKWAgc2hvdWxkIGhhdmUgdGhlIHNhbWVcbiAgICAgICAgLy8gY2Fub25pY2FsIElEIGFzIGBjb2wud2hlcmUoYW5kKGVxdWFscyhcImFcIiwxKSwgZXF1YWxzKFwiYlwiLDIpKSlgLlxuICAgICAgICByZXR1cm4gZmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXJcbiAgICAgICAgY29uc3QgY2Fub25pY2FsSWRzU3RyaW5nID0gZmlsdGVyLmZpbHRlcnNcbiAgICAgICAgICAgIC5tYXAoZmlsdGVyID0+IGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikpXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gYCR7ZmlsdGVyLm9wfSgke2Nhbm9uaWNhbElkc1N0cmluZ30pYDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XG4gICAgaWYgKGYxIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYxIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWVsZEZpbHRlckVxdWFscyhmMSwgZjIpIHtcbiAgICByZXR1cm4gKGYyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXG4gICAgICAgIGYxLmZpZWxkLmlzRXF1YWwoZjIuZmllbGQpICYmXG4gICAgICAgIHZhbHVlRXF1YWxzKGYxLnZhbHVlLCBmMi52YWx1ZSkpO1xufVxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVyRXF1YWxzKGYxLCBmMikge1xuICAgIGlmIChmMiBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciAmJlxuICAgICAgICBmMS5vcCA9PT0gZjIub3AgJiZcbiAgICAgICAgZjEuZmlsdGVycy5sZW5ndGggPT09IGYyLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnNNYXRjaCA9IGYxLmZpbHRlcnMucmVkdWNlKChyZXN1bHQsIGYxRmlsdGVyLCBpbmRleCkgPT4gcmVzdWx0ICYmIGZpbHRlckVxdWFscyhmMUZpbHRlciwgZjIuZmlsdGVyc1tpbmRleF0pLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN1YkZpbHRlcnNNYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdCBjb250YWlucyBhbGwgZmlsdGVyIGZyb21cbiAqIGBjb21wb3NpdGVGaWx0ZXJgIHBsdXMgYWxsIHRoZSBnaXZlbiBmaWx0ZXJzIGluIGBvdGhlckZpbHRlcnNgLlxuICovXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJXaXRoQWRkZWRGaWx0ZXJzKGNvbXBvc2l0ZUZpbHRlciwgb3RoZXJGaWx0ZXJzKSB7XG4gICAgY29uc3QgbWVyZ2VkRmlsdGVycyA9IGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLmNvbmNhdChvdGhlckZpbHRlcnMpO1xuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG1lcmdlZEZpbHRlcnMsIGNvbXBvc2l0ZUZpbHRlci5vcCk7XG59XG4vKiogUmV0dXJucyBhIGRlYnVnIGRlc2NyaXB0aW9uIGZvciBgZmlsdGVyYC4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0ZpbHRlcic7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiAoZmlsdGVyLm9wLnRvU3RyaW5nKCkgK1xuICAgICAgICBgIHtgICtcbiAgICAgICAgZmlsdGVyLmdldEZpbHRlcnMoKS5tYXAoc3RyaW5naWZ5RmlsdGVyKS5qb2luKCcgLCcpICtcbiAgICAgICAgJ30nKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBgJHtmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICR7ZmlsdGVyLm9wfSAke2Nhbm9uaWNhbElkKGZpbHRlci52YWx1ZSl9YDtcbn1cbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgKGkuZS4gJ19fbmFtZV9fJykuICovXG5jbGFzcyBLZXlGaWVsZEZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3AsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmtleSA9IERvY3VtZW50S2V5LmZyb21OYW1lKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZG9jLmtleSwgdGhpcy5rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKTtcbiAgICB9XG59XG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIHdpdGhpbiBhbiBhcnJheS4gKi9cbmNsYXNzIEtleUZpZWxkSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5rZXlzID0gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLnNvbWUoa2V5ID0+IGtleS5pc0VxdWFsKGRvYy5rZXkpKTtcbiAgICB9XG59XG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIG5vdCBwcmVzZW50IHdpdGhpbiBhbiBhcnJheS4gKi9cbmNsYXNzIEtleUZpZWxkTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLywgdmFsdWUpO1xuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShvcCwgdmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoKF9hID0gdmFsdWUuYXJyYXlWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcykgfHwgW10pLm1hcCh2ID0+IHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHYucmVmZXJlbmNlVmFsdWUpO1xuICAgIH0pO1xufVxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMgb3BlcmF0b3IuICovXG5jbGFzcyBBcnJheUNvbnRhaW5zRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIHJldHVybiBpc0FycmF5KG90aGVyKSAmJiBhcnJheVZhbHVlQ29udGFpbnMob3RoZXIuYXJyYXlWYWx1ZSwgdGhpcy52YWx1ZSk7XG4gICAgfVxufVxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgSU4gb3BlcmF0b3IuICovXG5jbGFzcyBJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgb3RoZXIpO1xuICAgIH1cbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIG5vdC1pbiBvcGVyYXRvci4gKi9cbmNsYXNzIE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgaWYgKGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgIWFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcbiAgICB9XG59XG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucy1hbnkgb3BlcmF0b3IuICovXG5jbGFzcyBBcnJheUNvbnRhaW5zQW55RmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgaWYgKCFpc0FycmF5KG90aGVyKSB8fCAhb3RoZXIuYXJyYXlWYWx1ZS52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3RoZXIuYXJyYXlWYWx1ZS52YWx1ZXMuc29tZSh2YWwgPT4gYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgdmFsKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgVGFyZ2V0SW1wbCB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgdGhpcy5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRDYW5vbmljYWxJZCA9IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIFRhcmdldCB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cbiAqIFBhdGggbXVzdCBjdXJyZW50bHkgYmUgZW1wdHkgaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkuXG4gKlxuICogTk9URTogeW91IHNob3VsZCBhbHdheXMgY29uc3RydWN0IGBUYXJnZXRgIGZyb20gYFF1ZXJ5LnRvVGFyZ2V0YCBpbnN0ZWFkIG9mXG4gKiB1c2luZyB0aGlzIGZhY3RvcnkgbWV0aG9kLCBiZWNhdXNlIGBRdWVyeWAgcHJvdmlkZXMgYW4gaW1wbGljaXQgYG9yZGVyQnlgXG4gKiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gbmV3VGFyZ2V0KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIG9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFRhcmdldEltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgc3RhcnRBdCwgZW5kQXQpO1xufVxuZnVuY3Rpb24gY2Fub25pZnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0SW1wbCA9IGRlYnVnQ2FzdCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IHN0ciA9IHRhcmdldEltcGwucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRhcmdldEltcGwuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3xjZzonICsgdGFyZ2V0SW1wbC5jb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICd8ZjonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5maWx0ZXJzLm1hcChmID0+IGNhbm9uaWZ5RmlsdGVyKGYpKS5qb2luKCcsJyk7XG4gICAgICAgIHN0ciArPSAnfG9iOic7XG4gICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLm9yZGVyQnkubWFwKG8gPT4gY2Fub25pZnlPcmRlckJ5KG8pKS5qb2luKCcsJyk7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0SW1wbC5saW1pdCkpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfGw6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRJbXBsLnN0YXJ0QXQpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfGxiOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5zdGFydEF0LmluY2x1c2l2ZSA/ICdiOicgOiAnYTonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuc3RhcnRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRJbXBsLmVuZEF0KSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3x1YjonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZW5kQXQuaW5jbHVzaXZlID8gJ2E6JyA6ICdiOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5lbmRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZCA9IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVRhcmdldCh0YXJnZXQpIHtcbiAgICBsZXQgc3RyID0gdGFyZ2V0LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgc3RyICs9ICcgY29sbGVjdGlvbkdyb3VwPScgKyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHIgKz0gYCwgZmlsdGVyczogWyR7dGFyZ2V0LmZpbHRlcnNcbiAgICAgICAgICAgIC5tYXAoZiA9PiBzdHJpbmdpZnlGaWx0ZXIoZikpXG4gICAgICAgICAgICAuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0YXJnZXQubGltaXQpKSB7XG4gICAgICAgIHN0ciArPSAnLCBsaW1pdDogJyArIHRhcmdldC5saW1pdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5vcmRlckJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyICs9IGAsIG9yZGVyQnk6IFske3RhcmdldC5vcmRlckJ5XG4gICAgICAgICAgICAubWFwKG8gPT4gc3RyaW5naWZ5T3JkZXJCeShvKSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpfV1gO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnN0YXJ0QXQpIHtcbiAgICAgICAgc3RyICs9ICcsIHN0YXJ0QXQ6ICc7XG4gICAgICAgIHN0ciArPSB0YXJnZXQuc3RhcnRBdC5pbmNsdXNpdmUgPyAnYjonIDogJ2E6JztcbiAgICAgICAgc3RyICs9IHRhcmdldC5zdGFydEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuZW5kQXQpIHtcbiAgICAgICAgc3RyICs9ICcsIGVuZEF0OiAnO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LmluY2x1c2l2ZSA/ICdhOicgOiAnYjonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIHJldHVybiBgVGFyZ2V0KCR7c3RyfSlgO1xufVxuZnVuY3Rpb24gdGFyZ2V0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQubGltaXQgIT09IHJpZ2h0LmxpbWl0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQub3JkZXJCeS5sZW5ndGggIT09IHJpZ2h0Lm9yZGVyQnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lm9yZGVyQnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvcmRlckJ5RXF1YWxzKGxlZnQub3JkZXJCeVtpXSwgcmlnaHQub3JkZXJCeVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdC5maWx0ZXJzLmxlbmd0aCAhPT0gcmlnaHQuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWZpbHRlckVxdWFscyhsZWZ0LmZpbHRlcnNbaV0sIHJpZ2h0LmZpbHRlcnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQuY29sbGVjdGlvbkdyb3VwICE9PSByaWdodC5jb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWxlZnQucGF0aC5pc0VxdWFsKHJpZ2h0LnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFib3VuZEVxdWFscyhsZWZ0LnN0YXJ0QXQsIHJpZ2h0LnN0YXJ0QXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kRXF1YWxzKGxlZnQuZW5kQXQsIHJpZ2h0LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHRhcmdldC5wYXRoKSAmJlxuICAgICAgICB0YXJnZXQuY29sbGVjdGlvbkdyb3VwID09PSBudWxsICYmXG4gICAgICAgIHRhcmdldC5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XG59XG4vKiogUmV0dXJucyB0aGUgZmllbGQgZmlsdGVycyB0aGF0IHRhcmdldCB0aGUgZ2l2ZW4gZmllbGQgcGF0aC4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBwYXRoKSB7XG4gICAgcmV0dXJuIHRhcmdldC5maWx0ZXJzLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJiBmLmZpZWxkLmlzRXF1YWwocGF0aCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZXMgdGhhdCBhcmUgdXNlZCBpbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTllcbiAqIGZpbHRlcnMuIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBzdWNoIGZpbHRlcnMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEFycmF5VmFsdWVzKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpO1xuICAgIGlmIChzZWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSkge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZEZpbHRlci52YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBbZmllbGRGaWx0ZXIudmFsdWVdO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgYXJlIG5vdCBhcnJheSBmaWx0ZXJzLlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluICE9IG9yIE5PVF9JTiBmaWx0ZXJzLiBSZXR1cm5zXG4gKiBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggZmlsdGVycy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0Tm90SW5WYWx1ZXModGFyZ2V0LCBmaWVsZEluZGV4KSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIGVxdWFsaXR5IHByZWZpeCwgd2hpY2ggaXMgZW5jb2RlZCBpbiB0aGUgaW5kZXggdmFsdWUgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbmVxdWFsaXR5IChlLmcuIGBhID09ICdhJyAmJiBiICE9ICdiJ2AgaXMgZW5jb2RlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBgdmFsdWUgIT0gJ2FiJ2ApLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KHNlZ21lbnQuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBmaWVsZEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RJbi9Ob3RFcXVhbCBpcyBhbHdheXMgYSBzdWZmaXguIFRoZXJlIGNhbm5vdCBiZSBhbnkgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnRzIGFuZCBoZW5jZSB3ZSBjYW4gcmV0dXJuIGVhcmx5IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zZXQoc2VnbWVudC5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCksIGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWVzLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBjYW5ub3QgYmUgdXNlZCBhcyBub3RJbiBib3VuZHMuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgYSBsb3dlciBib3VuZCBvZiBmaWVsZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN0YXJ0aW5nIHBvaW50IHRvXG4gKiBzY2FuIHRoZSBpbmRleCBkZWZpbmVkIGJ5IGBmaWVsZEluZGV4YC4gUmV0dXJucyBgTUlOX1ZBTFVFYCBpZiBubyBsb3dlciBib3VuZFxuICogZXhpc3RzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRMb3dlckJvdW5kKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQsIHJldHJpZXZlIGEgbG93ZXIgYm91bmQgaWYgdGhlcmUgaXMgYSBzdWl0YWJsZSBmaWx0ZXIgb3JcbiAgICAvLyBzdGFydEF0LlxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICBjb25zdCBzZWdtZW50Qm91bmQgPSBzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgPyB0YXJnZXRHZXRBc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuc3RhcnRBdClcbiAgICAgICAgICAgIDogdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5zdGFydEF0KTtcbiAgICAgICAgdmFsdWVzLnB1c2goc2VnbWVudEJvdW5kLnZhbHVlKTtcbiAgICAgICAgaW5jbHVzaXZlICYmIChpbmNsdXNpdmUgPSBzZWdtZW50Qm91bmQuaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3VuZCh2YWx1ZXMsIGluY2x1c2l2ZSk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXIgYm91bmQgb2YgZmllbGQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kaW5nIHBvaW50XG4gKiB3aGVuIHNjYW5uaW5nIHRoZSBpbmRleCBkZWZpbmVkIGJ5IGBmaWVsZEluZGV4YC4gUmV0dXJucyBgTUFYX1ZBTFVFYCBpZiBub1xuICogdXBwZXIgYm91bmQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRVcHBlckJvdW5kKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQsIHJldHJpZXZlIGFuIHVwcGVyIGJvdW5kIGlmIHRoZXJlIGlzIGEgc3VpdGFibGUgZmlsdGVyIG9yXG4gICAgLy8gZW5kQXQuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRCb3VuZCA9IHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXG4gICAgICAgICAgICA/IHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuZW5kQXQpXG4gICAgICAgICAgICA6IHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5lbmRBdCk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHNlZ21lbnRCb3VuZC52YWx1ZSk7XG4gICAgICAgIGluY2x1c2l2ZSAmJiAoaW5jbHVzaXZlID0gc2VnbWVudEJvdW5kLmluY2x1c2l2ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQodmFsdWVzLCBpbmNsdXNpdmUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIGxvd2VyIGJvdW5kIGZvciBhc2NlbmRpbmcgaW5kZXggc2VnbWVudCBhdFxuICogdGhlIHByb3ZpZGVkIGBmaWVsZFBhdGhgIChvciB0aGUgdXBwZXIgYm91bmQgZm9yIGFuIGRlc2NlbmRpbmcgc2VnbWVudCkuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgZmllbGRQYXRoLCBib3VuZCkge1xuICAgIGxldCB2YWx1ZSA9IE1JTl9WQUxVRTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBQcm9jZXNzIGFsbCBmaWx0ZXJzIHRvIGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZmllbGQgc2VnbWVudFxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIGZpZWxkUGF0aCkpIHtcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xuICAgICAgICBsZXQgZmlsdGVySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSB2YWx1ZXNHZXRMb3dlckJvdW5kKGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgbG93ZXIgYm91bmRzLlxuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogZmlsdGVyVmFsdWUsIGluY2x1c2l2ZTogZmlsdGVySW5jbHVzaXZlIH0pIDwgMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcbiAgICAvLyByYW5nZSB0byBzZWUgaWYgd2UgY2FuIG5hcnJvdyB0aGUgc2NvcGUuXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB0YXJnZXQub3JkZXJCeVtpXTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgICAgICAgICAgaWYgKGxvd2VyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBjdXJzb3JWYWx1ZSwgaW5jbHVzaXZlOiBib3VuZC5pbmNsdXNpdmUgfSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIHVwcGVyIGJvdW5kIGZvciBhc2NlbmRpbmcgaW5kZXggc2VnbWVudCBhdFxuICogdGhlIHByb3ZpZGVkIGBmaWVsZFBhdGhgIChvciB0aGUgbG93ZXIgYm91bmQgZm9yIGEgZGVzY2VuZGluZyBzZWdtZW50KS5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgZmllbGRQYXRoLCBib3VuZCkge1xuICAgIGxldCB2YWx1ZSA9IE1BWF9WQUxVRTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBQcm9jZXNzIGFsbCBmaWx0ZXJzIHRvIGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZmllbGQgc2VnbWVudFxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIGZpZWxkUGF0aCkpIHtcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgZmlsdGVySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSB2YWx1ZXNHZXRVcHBlckJvdW5kKGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgdXBwZXIgYm91bmRzLlxuICAgICAgICB9XG4gICAgICAgIGlmICh1cHBlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogZmlsdGVyVmFsdWUsIGluY2x1c2l2ZTogZmlsdGVySW5jbHVzaXZlIH0pID4gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcbiAgICAvLyByYW5nZSB0byBzZWUgaWYgd2UgY2FuIG5hcnJvdyB0aGUgc2NvcGUuXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB0YXJnZXQub3JkZXJCeVtpXTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBjdXJzb3JWYWx1ZSwgaW5jbHVzaXZlOiBib3VuZC5pbmNsdXNpdmUgfSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xufVxuLyoqIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cyBvZiBhIHBlcmZlY3QgaW5kZXggZm9yIHRoaXMgdGFyZ2V0LiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0U2VnbWVudENvdW50KHRhcmdldCkge1xuICAgIGxldCBmaWVsZHMgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIGxldCBoYXNBcnJheVNlZ21lbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0YXJnZXQuZmlsdGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YkZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XG4gICAgICAgICAgICAvLyBfX25hbWVfXyBpcyBub3QgYW4gZXhwbGljaXQgc2VnbWVudCBvZiBhbnkgaW5kZXgsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNvdW50IGl0LlxuICAgICAgICAgICAgaWYgKHN1YkZpbHRlci5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFSUkFZX0NPTlRBSU5TIG9yIEFSUkFZX0NPTlRBSU5TX0FOWSBmaWx0ZXJzIG11c3QgYmUgY291bnRlZCBzZXBhcmF0ZWx5LlxuICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGFuIGluZGV4IGZvciBcImEgQVJSQVkgYSBBU0NcIi4gRXZlblxuICAgICAgICAgICAgLy8gdGhvdWdoIHRoZXNlIGFyZSBvbiB0aGUgc2FtZSBmaWVsZCwgdGhleSBzaG91bGQgYmUgY291bnRlZCBhcyB0d29cbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIHNlZ21lbnRzIGluIGFuIGluZGV4LlxuICAgICAgICAgICAgaWYgKHN1YkZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XG4gICAgICAgICAgICAgICAgc3ViRmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgICAgIGhhc0FycmF5U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMuYWRkKHN1YkZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRhcmdldC5vcmRlckJ5KSB7XG4gICAgICAgIC8vIF9fbmFtZV9fIGlzIG5vdCBhbiBleHBsaWNpdCBzZWdtZW50IG9mIGFueSBpbmRleCwgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyBjb3VudCBpdC5cbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzLmFkZChvcmRlckJ5LmZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLnNpemUgKyAoaGFzQXJyYXlTZWdtZW50ID8gMSA6IDApO1xufVxuZnVuY3Rpb24gdGFyZ2V0SGFzTGltaXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5saW1pdCAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUXVlcnkgZW5jYXBzdWxhdGVzIGFsbCB0aGUgcXVlcnkgYXR0cmlidXRlcyB3ZSBzdXBwb3J0IGluIHRoZSBTREsuIEl0IGNhblxuICogYmUgcnVuIGFnYWluc3QgdGhlIExvY2FsU3RvcmUsIGFzIHdlbGwgYXMgYmUgY29udmVydGVkIHRvIGEgYFRhcmdldGAgdG9cbiAqIHF1ZXJ5IHRoZSBSZW1vdGVTdG9yZSByZXN1bHRzLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmNsYXNzIFF1ZXJ5SW1wbCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBRdWVyeSB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cbiAgICAgKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIGV4cGxpY2l0T3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgbGltaXRUeXBlID0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB0aGlzLmV4cGxpY2l0T3JkZXJCeSA9IGV4cGxpY2l0T3JkZXJCeTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmxpbWl0VHlwZSA9IGxpbWl0VHlwZTtcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcbiAgICAgICAgdGhpcy5lbmRBdCA9IGVuZEF0O1xuICAgICAgICB0aGlzLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBudWxsO1xuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxuICAgICAgICAvLyBub24tYWdncmVnYXRlIHF1ZXJpZXMuXG4gICAgICAgIHRoaXMubWVtb2l6ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxuICAgICAgICAvLyBhZ2dyZWdhdGUgcXVlcmllcy4gVW5saWtlIHRhcmdldHMgZm9yIG5vbi1hZ2dyZWdhdGUgcXVlcmllcyxcbiAgICAgICAgLy8gYWdncmVnYXRlIHF1ZXJ5IHRhcmdldHMgZG8gbm90IGNvbnRhaW4gbm9ybWFsaXplZCBvcmRlci1ieXMsIHRoZXkgb25seVxuICAgICAgICAvLyBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cbiAgICAgICAgdGhpcy5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QXQpIDtcbiAgICAgICAgaWYgKHRoaXMuZW5kQXQpIDtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBpbnN0YW5jZSB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkLiAqL1xuZnVuY3Rpb24gbmV3UXVlcnkocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBleHBsaWNpdE9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBsaW1pdFR5cGUsIHN0YXJ0QXQsIGVuZEF0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBleHBsaWNpdE9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBsaW1pdFR5cGUsIHN0YXJ0QXQsIGVuZEF0KTtcbn1cbi8qKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIHF1ZXJ5IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzIGF0IGBwYXRoYCAqL1xuZnVuY3Rpb24gbmV3UXVlcnlGb3JQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IGludG8gYSBjb2xsZWN0aW9uIHF1ZXJ5IGF0IGFcbiAqIHNwZWNpZmljIHBhdGguIFRoaXMgaXMgdXNlZCB3aGVuIGV4ZWN1dGluZyBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJpZXMsIHNpbmNlXG4gKiB3ZSBoYXZlIHRvIHNwbGl0IHRoZSBxdWVyeSBpbnRvIGEgc2V0IG9mIGNvbGxlY3Rpb24gcXVlcmllcyBhdCBtdWx0aXBsZVxuICogcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgXG4gICAgLypjb2xsZWN0aW9uR3JvdXA9Ki8gbnVsbCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBxdWVyeSBkb2VzIG5vdCBzcGVjaWZ5IGFueSBxdWVyeSBjb25zdHJhaW50cyB0aGF0XG4gKiBjb3VsZCByZW1vdmUgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChxdWVyeS5maWx0ZXJzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICBxdWVyeS5saW1pdCA9PT0gbnVsbCAmJlxuICAgICAgICBxdWVyeS5zdGFydEF0ID09IG51bGwgJiZcbiAgICAgICAgcXVlcnkuZW5kQXQgPT0gbnVsbCAmJlxuICAgICAgICAocXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICBxdWVyeS5leHBsaWNpdE9yZGVyQnlbMF0uZmllbGQuaXNLZXlGaWVsZCgpKSkpO1xufVxuLy8gUmV0dXJucyB0aGUgc29ydGVkIHNldCBvZiBpbmVxdWFsaXR5IGZpbHRlciBmaWVsZHMgdXNlZCBpbiB0aGlzIHF1ZXJ5LlxuZnVuY3Rpb24gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeSkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIHF1ZXJ5LmZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xuICAgICAgICBzdWJGaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzXG4gKiB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgY29sbGVjdGlvbklkKTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGEgc2luZ2xlIGRvY3VtZW50IGJ5IHBhdGggKHJhdGhlciB0aGFuIGFcbiAqIGNvbGxlY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkge1xuICAgIHJldHVybiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShxdWVyeS5wYXRoKSAmJlxuICAgICAgICBxdWVyeS5jb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgJiZcbiAgICAgICAgcXVlcnkuZmlsdGVycy5sZW5ndGggPT09IDApO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBjb2xsZWN0aW9uIGdyb3VwIHJhdGhlciB0aGFuIGEgc3BlY2lmaWNcbiAqIGNvbGxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG9yZGVyLWJ5IGNvbnN0cmFpbnQgdGhhdCBpcyB1c2VkIHRvIGV4ZWN1dGUgdGhlIFF1ZXJ5LFxuICogd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmRlci1ieSBjb25zdHJhaW50cyB0aGUgdXNlciBwcm92aWRlZCAoZS5nLlxuICogdGhlIFNESyBhbmQgYmFja2VuZCBhbHdheXMgb3JkZXJzIGJ5IGBfX25hbWVfX2ApLiBUaGUgbm9ybWFsaXplZCBvcmRlci1ieVxuICogaW5jbHVkZXMgaW1wbGljaXQgb3JkZXItYnlzIGluIGFkZGl0aW9uIHRvIHRoZSBleHBsaWNpdCB1c2VyIHByb3ZpZGVkXG4gKiBvcmRlci1ieXMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xuICAgIGlmIChxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9PT0gbnVsbCkge1xuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9IFtdO1xuICAgICAgICBjb25zdCBmaWVsZHNOb3JtYWxpemVkID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBBbnkgZXhwbGljaXQgb3JkZXIgYnkgZmllbGRzIHNob3VsZCBiZSBhZGRlZCBhcyBpcy5cbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gob3JkZXJCeSk7XG4gICAgICAgICAgICBmaWVsZHNOb3JtYWxpemVkLmFkZChvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGltcGxpY2l0IG9yZGVyaW5nIGFsd2F5cyBtYXRjaGVzIHRoZSBsYXN0IGV4cGxpY2l0IG9yZGVyIGJ5LlxuICAgICAgICBjb25zdCBsYXN0RGlyZWN0aW9uID0gcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnlbcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggLSAxXS5kaXJcbiAgICAgICAgICAgIDogXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xuICAgICAgICAvLyBBbnkgaW5lcXVhbGl0eSBmaWVsZHMgbm90IGV4cGxpY2l0bHkgb3JkZXJlZCBzaG91bGQgYmUgaW1wbGljaXRseSBvcmRlcmVkIGluIGEgbGV4aWNvZ3JhcGhpY2FsXG4gICAgICAgIC8vIG9yZGVyLiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpbmVxdWFsaXR5IGZpbHRlcnMgb24gdGhlIHNhbWUgZmllbGQsIHRoZSBmaWVsZCBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgLy8gb25seSBvbmNlLlxuICAgICAgICAvLyBOb3RlOiBgU29ydGVkU2V0PEZpZWxkUGF0aD5gIHNvcnRzIHRoZSBrZXkgZmllbGQgYmVmb3JlIG90aGVyIGZpZWxkcy4gSG93ZXZlciwgd2Ugd2FudCB0aGUga2V5XG4gICAgICAgIC8vIGZpZWxkIHRvIGJlIHNvcnRlZCBsYXN0LlxuICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmllbGRzID0gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeUltcGwpO1xuICAgICAgICBpbmVxdWFsaXR5RmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhmaWVsZC5jYW5vbmljYWxTdHJpbmcoKSkgJiZcbiAgICAgICAgICAgICAgICAhZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShmaWVsZCwgbGFzdERpcmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBkb2N1bWVudCBrZXkgZmllbGQgdG8gdGhlIGxhc3QgaWYgaXQgaXMgbm90IGV4cGxpY2l0bHkgb3JkZXJlZC5cbiAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLmNhbm9uaWNhbFN0cmluZygpKSkge1xuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLCBsYXN0RGlyZWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5O1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5VG9UYXJnZXQocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0KSB7XG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCA9IF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24sXG4gKiBmb3IgdXNlIHdpdGhpbiBhbiBhZ2dyZWdhdGUgcXVlcnkuIFVubGlrZSB0YXJnZXRzIGZvciBub24tYWdncmVnYXRlIHF1ZXJpZXMsXG4gKiBhZ2dyZWdhdGUgcXVlcnkgdGFyZ2V0cyBkbyBub3QgY29udGFpbiBub3JtYWxpemVkIG9yZGVyLWJ5cywgdGhleSBvbmx5XG4gKiBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgaW1wbGljaXQgb3JkZXItYnlzIGZvciBhZ2dyZWdhdGUgcXVlcmllcy5cbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0ID0gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0O1xufVxuZnVuY3Rpb24gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBvcmRlckJ5cykge1xuICAgIGlmIChxdWVyeUltcGwubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeXMsIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHF1ZXJ5SW1wbC5zdGFydEF0LCBxdWVyeUltcGwuZW5kQXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRmxpcCB0aGUgb3JkZXJCeSBkaXJlY3Rpb25zIHNpbmNlIHdlIHdhbnQgdGhlIGxhc3QgcmVzdWx0c1xuICAgICAgICBvcmRlckJ5cyA9IG9yZGVyQnlzLm1hcChvcmRlckJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgID8gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXG4gICAgICAgICAgICAgICAgOiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3JkZXJCeShvcmRlckJ5LmZpZWxkLCBkaXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzd2FwIHRoZSBjdXJzb3JzIHRvIG1hdGNoIHRoZSBub3ctZmxpcHBlZCBxdWVyeSBvcmRlcmluZy5cbiAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHF1ZXJ5SW1wbC5lbmRBdFxuICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLmVuZEF0LnBvc2l0aW9uLCBxdWVyeUltcGwuZW5kQXQuaW5jbHVzaXZlKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBlbmRBdCA9IHF1ZXJ5SW1wbC5zdGFydEF0XG4gICAgICAgICAgICA/IG5ldyBCb3VuZChxdWVyeUltcGwuc3RhcnRBdC5wb3NpdGlvbiwgcXVlcnlJbXBsLnN0YXJ0QXQuaW5jbHVzaXZlKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvLyBOb3cgcmV0dXJuIGFzIGEgTGltaXRUeXBlLkZpcnN0IHF1ZXJ5LlxuICAgICAgICByZXR1cm4gbmV3VGFyZ2V0KHF1ZXJ5SW1wbC5wYXRoLCBxdWVyeUltcGwuY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5cywgcXVlcnlJbXBsLmZpbHRlcnMsIHF1ZXJ5SW1wbC5saW1pdCwgc3RhcnRBdCwgZW5kQXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBuZXdGaWx0ZXJzID0gcXVlcnkuZmlsdGVycy5jb25jYXQoW2ZpbHRlcl0pO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIG5ld0ZpbHRlcnMsIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeSwgb3JkZXJCeSkge1xuICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGUgdGhhdCBvcmRlckJ5IGRvZXMgbm90IGxpc3QgdGhlIHNhbWUga2V5IHR3aWNlLlxuICAgIGNvbnN0IG5ld09yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnkuY29uY2F0KFtvcmRlckJ5XSk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBuZXdPcmRlckJ5LCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBsaW1pdCwgbGltaXRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBsaW1pdCwgbGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhTdGFydEF0KHF1ZXJ5LCBib3VuZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgYm91bmQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEVuZEF0KHF1ZXJ5LCBib3VuZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgYm91bmQpO1xufVxuZnVuY3Rpb24gcXVlcnlFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKHRhcmdldEVxdWFscyhxdWVyeVRvVGFyZ2V0KGxlZnQpLCBxdWVyeVRvVGFyZ2V0KHJpZ2h0KSkgJiZcbiAgICAgICAgbGVmdC5saW1pdFR5cGUgPT09IHJpZ2h0LmxpbWl0VHlwZSk7XG59XG4vLyBUT0RPKGIvMjkxODMxNjUpOiBUaGlzIGlzIHVzZWQgdG8gZ2V0IGEgdW5pcXVlIHN0cmluZyBmcm9tIGEgcXVlcnkgdG8sIGZvclxuLy8gZXhhbXBsZSwgdXNlIGFzIGEgZGljdGlvbmFyeSBrZXksIGJ1dCB0aGUgaW1wbGVtZW50YXRpb24gaXMgc3ViamVjdCB0b1xuLy8gY29sbGlzaW9ucy4gTWFrZSBpdCBjb2xsaXNpb24tZnJlZS5cbmZ1bmN0aW9uIGNhbm9uaWZ5UXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gYCR7Y2Fub25pZnlUYXJnZXQocXVlcnlUb1RhcmdldChxdWVyeSkpfXxsdDoke3F1ZXJ5LmxpbWl0VHlwZX1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gYFF1ZXJ5KHRhcmdldD0ke3N0cmluZ2lmeVRhcmdldChxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSl9OyBsaW1pdFR5cGU9JHtxdWVyeS5saW1pdFR5cGV9KWA7XG59XG4vKiogUmV0dXJucyB3aGV0aGVyIGBkb2NgIG1hdGNoZXMgdGhlIGNvbnN0cmFpbnRzIG9mIGBxdWVyeWAuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXMocXVlcnksIGRvYykge1xuICAgIHJldHVybiAoZG9jLmlzRm91bmREb2N1bWVudCgpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc1BhdGhBbmRDb2xsZWN0aW9uR3JvdXAocXVlcnksIGRvYykgJiZcbiAgICAgICAgcXVlcnlNYXRjaGVzT3JkZXJCeShxdWVyeSwgZG9jKSAmJlxuICAgICAgICBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc0JvdW5kcyhxdWVyeSwgZG9jKSk7XG59XG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNQYXRoQW5kQ29sbGVjdGlvbkdyb3VwKHF1ZXJ5LCBkb2MpIHtcbiAgICBjb25zdCBkb2NQYXRoID0gZG9jLmtleS5wYXRoO1xuICAgIGlmIChxdWVyeS5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcy5wYXRoIGlzIGN1cnJlbnRseSBhbHdheXMgZW1wdHkgc2luY2Ugd2UgZG9uJ3QgZXhwb3NlIENvbGxlY3Rpb25cbiAgICAgICAgLy8gR3JvdXAgcXVlcmllcyByb290ZWQgYXQgYSBkb2N1bWVudCBwYXRoIHlldC5cbiAgICAgICAgcmV0dXJuIChkb2Mua2V5Lmhhc0NvbGxlY3Rpb25JZChxdWVyeS5jb2xsZWN0aW9uR3JvdXApICYmXG4gICAgICAgICAgICBxdWVyeS5wYXRoLmlzUHJlZml4T2YoZG9jUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHF1ZXJ5LnBhdGgpKSB7XG4gICAgICAgIC8vIGV4YWN0IG1hdGNoIGZvciBkb2N1bWVudCBxdWVyaWVzXG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLmlzRXF1YWwoZG9jUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzaGFsbG93IGFuY2VzdG9yIHF1ZXJpZXMgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gcXVlcnkucGF0aC5pc0ltbWVkaWF0ZVBhcmVudE9mKGRvY1BhdGgpO1xuICAgIH1cbn1cbi8qKlxuICogQSBkb2N1bWVudCBtdXN0IGhhdmUgYSB2YWx1ZSBmb3IgZXZlcnkgb3JkZXJpbmcgY2xhdXNlIGluIG9yZGVyIHRvIHNob3cgdXBcbiAqIGluIHRoZSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNPcmRlckJ5KHF1ZXJ5LCBkb2MpIHtcbiAgICAvLyBXZSBtdXN0IHVzZSBgcXVlcnlOb3JtYWxpemVkT3JkZXJCeSgpYCB0byBnZXQgdGhlIGxpc3Qgb2YgYWxsIG9yZGVyQnlzIChib3RoIGltcGxpY2l0IGFuZCBleHBsaWNpdCkuXG4gICAgLy8gTm90ZSB0aGF0IGZvciBPUiBxdWVyaWVzLCBvcmRlckJ5IGFwcGxpZXMgdG8gYWxsIGRpc2p1bmN0aW9uIHRlcm1zIGFuZCBpbXBsaWNpdCBvcmRlckJ5cyBtdXN0XG4gICAgLy8gYmUgdGFrZW4gaW50byBhY2NvdW50LiBGb3IgZXhhbXBsZSwgdGhlIHF1ZXJ5IFwiYSA+IDEgfHwgYj09MVwiIGhhcyBhbiBpbXBsaWNpdCBcIm9yZGVyQnkgYVwiIGR1ZVxuICAgIC8vIHRvIHRoZSBpbmVxdWFsaXR5LCBhbmQgaXMgZXZhbHVhdGVkIGFzIFwiYSA+IDEgb3JkZXJCeSBhIHx8IGI9PTEgb3JkZXJCeSBhXCIuXG4gICAgLy8gQSBkb2N1bWVudCB3aXRoIGNvbnRlbnQgb2Yge2I6MX0gbWF0Y2hlcyB0aGUgZmlsdGVycywgYnV0IGRvZXMgbm90IG1hdGNoIHRoZSBvcmRlckJ5IGJlY2F1c2VcbiAgICAvLyBpdCdzIG1pc3NpbmcgdGhlIGZpZWxkICdhJy5cbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcbiAgICAgICAgLy8gb3JkZXItYnkga2V5IGFsd2F5cyBtYXRjaGVzXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkgJiYgZG9jLmRhdGEuZmllbGQob3JkZXJCeS5maWVsZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0ZpbHRlcnMocXVlcnksIGRvYykge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHF1ZXJ5LmZpbHRlcnMpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIubWF0Y2hlcyhkb2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKiogTWFrZXMgc3VyZSBhIGRvY3VtZW50IGlzIHdpdGhpbiB0aGUgYm91bmRzLCBpZiBwcm92aWRlZC4gKi9cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0JvdW5kcyhxdWVyeSwgZG9jKSB7XG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgJiZcbiAgICAgICAgIWJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChxdWVyeS5zdGFydEF0LCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSwgZG9jKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lbmRBdCAmJlxuICAgICAgICAhYm91bmRTb3J0c0FmdGVyRG9jdW1lbnQocXVlcnkuZW5kQXQsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpLCBkb2MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAgdGhhdCB0aGlzIHF1ZXJ5IHRhcmdldHMuXG4gKlxuICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgV2ViIFNESyB0byBmYWNpbGl0YXRlIG11bHRpLXRhYlxuICogc3luY2hyb25pemF0aW9uIGZvciBxdWVyeSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkuY29sbGVjdGlvbkdyb3VwIHx8XG4gICAgICAgIChxdWVyeS5wYXRoLmxlbmd0aCAlIDIgPT09IDFcbiAgICAgICAgICAgID8gcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpXG4gICAgICAgICAgICA6IHF1ZXJ5LnBhdGguZ2V0KHF1ZXJ5LnBhdGgubGVuZ3RoIC0gMikpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcGFyZSB0d28gZG9jdW1lbnRzXG4gKiBiYXNlZCBvbiB0aGUgUXVlcnkncyBvcmRlcmluZyBjb25zdHJhaW50LlxuICovXG5mdW5jdGlvbiBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpIHtcbiAgICByZXR1cm4gKGQxLCBkMikgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZWRPbktleUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVEb2NzKG9yZGVyQnksIGQxLCBkMik7XG4gICAgICAgICAgICBpZiAoY29tcCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGFyZWRPbktleUZpZWxkID0gY29tcGFyZWRPbktleUZpZWxkIHx8IG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59XG5mdW5jdGlvbiBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKClcbiAgICAgICAgPyBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KVxuICAgICAgICA6IGNvbXBhcmVEb2N1bWVudHNCeUZpZWxkKG9yZGVyQnkuZmllbGQsIGQxLCBkMik7XG4gICAgc3dpdGNoIChvcmRlckJ5LmRpcikge1xuICAgICAgICBjYXNlIFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICBjYXNlIFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovOlxuICAgICAgICAgICAgcmV0dXJuIC0xICogY29tcGFyaXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIG1hcCBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgb2JqZWN0cyBhcyBrZXlzLiBPYmplY3RzIG11c3QgaGF2ZSBhblxuICogYXNzb2NpYXRlZCBlcXVhbHMgZnVuY3Rpb24gYW5kIG11c3QgYmUgaW1tdXRhYmxlLiBFbnRyaWVzIGluIHRoZSBtYXAgYXJlXG4gKiBzdG9yZWQgdG9nZXRoZXIgd2l0aCB0aGUga2V5IGJlaW5nIHByb2R1Y2VkIGZyb20gdGhlIG1hcEtleUZuLiBUaGlzIG1hcFxuICogYXV0b21hdGljYWxseSBoYW5kbGVzIGNvbGxpc2lvbnMgb2Yga2V5cy5cbiAqL1xuY2xhc3MgT2JqZWN0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXBLZXlGbiwgZXF1YWxzRm4pIHtcbiAgICAgICAgdGhpcy5tYXBLZXlGbiA9IG1hcEtleUZuO1xuICAgICAgICB0aGlzLmVxdWFsc0ZuID0gZXF1YWxzRm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5uZXIgbWFwIGZvciBhIGtleS92YWx1ZSBwYWlyLiBEdWUgdG8gdGhlIHBvc3NpYmlsaXR5IG9mIGNvbGxpc2lvbnMgd2VcbiAgICAgICAgICoga2VlcCBhIGxpc3Qgb2YgZW50cmllcyB0aGF0IHdlIGRvIGEgbGluZWFyIHNlYXJjaCB0aHJvdWdoIHRvIGZpbmQgYW4gYWN0dWFsXG4gICAgICAgICAqIG1hdGNoLiBOb3RlIHRoYXQgY29sbGlzaW9ucyBzaG91bGQgYmUgcmFyZSwgc28gd2Ugc3RpbGwgZXhwZWN0IG5lYXJcbiAgICAgICAgICogY29uc3RhbnQgdGltZSBsb29rdXBzIGluIHByYWN0aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbm5lciA9IHt9O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbnRyaWVzIHN0b3JlZCBpbiB0aGUgbWFwICovXG4gICAgICAgIHRoaXMuaW5uZXJTaXplID0gMDtcbiAgICB9XG4gICAgLyoqIEdldCBhIHZhbHVlIGZvciB0aGlzIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LiAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtvdGhlcktleSwgdmFsdWVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG90aGVyS2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIFB1dCB0aGlzIGtleSBhbmQgdmFsdWUgaW4gdGhlIG1hcC4gKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyW2lkXSA9IFtba2V5LCB2YWx1ZV1dO1xuICAgICAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGVudHJ5IGFuZCBkb2VzIG5vdCBpbmNyZWFzZSBgaW5uZXJTaXplYC5cbiAgICAgICAgICAgICAgICBtYXRjaGVzW2ldID0gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMga2V5IGZyb20gdGhlIG1hcC4gUmV0dXJucyBhIGJvb2xlYW4gaWYgYW55dGhpbmcgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyU2l6ZS0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICBmb3JFYWNoKHRoaXMuaW5uZXIsIChfLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZm4oaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmlubmVyKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJTaXplO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIG11dGFibGVEb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTVVUQUJMRV9ET0NVTUVOVF9NQVA7XG59XG5jb25zdCBFTVBUWV9ET0NVTUVOVF9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRNYXAoLi4uZG9jcykge1xuICAgIGxldCBtYXAgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICBtYXAgPSBtYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5ZWREb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAoY29sbGVjdGlvbikge1xuICAgIGxldCBkb2N1bWVudHMgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKChrLCB2KSA9PiAoZG9jdW1lbnRzID0gZG9jdW1lbnRzLmluc2VydChrLCB2Lm92ZXJsYXllZERvY3VtZW50KSkpO1xuICAgIHJldHVybiBkb2N1bWVudHM7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5TWFwKCkge1xuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xufVxuZnVuY3Rpb24gbmV3TXV0YXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XG59XG5mdW5jdGlvbiBuZXdEb2N1bWVudEtleU1hcCgpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xufVxuY29uc3QgRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRWZXJzaW9uTWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9ET0NVTUVOVF9WRVJTSU9OX01BUDtcbn1cbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX0tFWV9TRVQgPSBuZXcgU29ydGVkU2V0KERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cykge1xuICAgIGxldCBzZXQgPSBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgc2V0ID0gc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuY29uc3QgRU1QVFlfVEFSR0VUX0lEX1NFVCA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG5mdW5jdGlvbiB0YXJnZXRJZFNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfVEFSR0VUX0lEX1NFVDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBEb3VibGVWYWx1ZSBmb3IgYHZhbHVlYCB0aGF0IGlzIGVuY29kZWQgYmFzZWQgdGhlIHNlcmlhbGl6ZXInc1xuICogYHVzZVByb3RvM0pzb25gIHNldHRpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ05hTicgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICctSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IGlzTmVnYXRpdmVaZXJvKHZhbHVlKSA/ICctMCcgOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIEludGVnZXJWYWx1ZSBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHsgaW50ZWdlclZhbHVlOiAnJyArIHZhbHVlIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXG4gKiBvdGhlcndpc2UgYSBEb3VibGVWYWx1ZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIoc2VyaWFsaXplciwgdmFsdWUpIHtcbiAgICByZXR1cm4gaXNTYWZlSW50ZWdlcih2YWx1ZSkgPyB0b0ludGVnZXIodmFsdWUpIDogdG9Eb3VibGUoc2VyaWFsaXplciwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovXG5jbGFzcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc3RydWN0dXJhbCB0eXBlIG9mIGBUcmFuc2Zvcm1PcGVyYXRpb25gIGlzIHVuaXF1ZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTQ1MVxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHJlc3VsdCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgcHJldmlvdXNWYWx1ZWAsXG4gKiBvcHRpb25hbGx5IHVzaW5nIHRoZSBwcm92aWRlZCBsb2NhbFdyaXRlVGltZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcHBseU51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBmaW5hbCB0cmFuc2Zvcm0gcmVzdWx0IGFmdGVyIHRoZSB0cmFuc2Zvcm0gaGFzIGJlZW4gYWNrbm93bGVkZ2VkXG4gKiBieSB0aGUgc2VydmVyLCBwb3RlbnRpYWxseSB1c2luZyB0aGUgc2VydmVyLXByb3ZpZGVkIHRyYW5zZm9ybVJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgdHJhbnNmb3JtUmVzdWx0KSB7XG4gICAgLy8gVGhlIHNlcnZlciBqdXN0IHNlbmRzIG51bGwgYXMgdGhlIHRyYW5zZm9ybSByZXN1bHQgZm9yIGFycmF5IG9wZXJhdGlvbnMsXG4gICAgLy8gc28gd2UgaGF2ZSB0byBjYWxjdWxhdGUgYSByZXN1bHQgdGhlIHNhbWUgYXMgd2UgZG8gZm9yIGxvY2FsXG4gICAgLy8gYXBwbGljYXRpb25zLlxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcbn1cbi8qKlxuICogSWYgdGhpcyB0cmFuc2Zvcm0gb3BlcmF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvXG4gKiBwZXJzaXN0IGZvciB0aGlzIHRyYW5zZm9ybS4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgdHJhbnNmb3JtXG4gKiBvcGVyYXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhpcyBiYXNlIHZhbHVlLCBldmVuIGlmIGRvY3VtZW50IGhhc1xuICogYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogQmFzZSB2YWx1ZXMgcHJvdmlkZSBjb25zaXN0ZW50IGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZFxuICogYWxsb3cgdXMgdG8gcmV0dXJuIHRoZSBzYW1lIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZFxuICogaGFzIGFscmVhZHkgYXBwbGllZCB0aGUgdHJhbnNmb3JtIG9wZXJhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3JcbiAqIGlkZW1wb3RlbnQgdHJhbnNmb3JtcywgYXMgdGhleSBjYW4gYmUgcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzXG4gKiBhbHJlYWR5IGFwcGxpZWQgdGhlbS5cbiAqXG4gKiBAcmV0dXJucyBhIGJhc2UgdmFsdWUgdG8gc3RvcmUgYWxvbmcgd2l0aCB0aGUgbXV0YXRpb24sIG9yIG51bGwgZm9yXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHByZXZpb3VzVmFsdWUpID8gcHJldmlvdXNWYWx1ZSA6IHsgaW50ZWdlclZhbHVlOiAwIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5lbGVtZW50cywgcmlnaHQuZWxlbWVudHMsIHZhbHVlRXF1YWxzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHMobGVmdC5vcGVyYW5kLCByaWdodC5vcGVyYW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKTtcbn1cbi8qKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wLiAqL1xuY2xhc3MgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbn1cbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHVuaW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XG4gICAgZm9yIChjb25zdCB0b1VuaW9uIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICBpZiAoIXZhbHVlcy5zb21lKGVsZW1lbnQgPT4gdmFsdWVFcXVhbHMoZWxlbWVudCwgdG9VbmlvbikpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0b1VuaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSByZW1vdmUgb3BlcmF0aW9uLiAqL1xuY2xhc3MgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGxldCB2YWx1ZXMgPSBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheShwcmV2aW91c1ZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHRvUmVtb3ZlIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKGVsZW1lbnQgPT4gIXZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvUmVtb3ZlKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcbn1cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgYmFja2VuZCBzZW1hbnRpY3MgZm9yIGxvY2FsbHkgY29tcHV0ZWQgTlVNRVJJQ19BREQgKGluY3JlbWVudClcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcbiAqIGJhY2tlbmQgZG9lcyBub3QgY2FwIGludGVnZXIgdmFsdWVzIGF0IDJeNjMuIEluc3RlYWQsIEphdmFTY3JpcHQgbnVtYmVyXG4gKiBhcml0aG1ldGljIGlzIHVzZWQgYW5kIHByZWNpc2lvbiBsb3NzIGNhbiBvY2N1ciBmb3IgdmFsdWVzIGdyZWF0ZXIgdGhhbiAyXjUzLlxuICovXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCBvcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgLy8gUE9SVElORyBOT1RFOiBTaW5jZSBKYXZhU2NyaXB0J3MgaW50ZWdlciBhcml0aG1ldGljIGlzIGxpbWl0ZWQgdG8gNTMgYml0XG4gICAgLy8gcHJlY2lzaW9uIGFuZCByZXNvbHZlcyBvdmVyZmxvd3MgYnkgcmVkdWNpbmcgcHJlY2lzaW9uLCB3ZSBkbyBub3RcbiAgICAvLyBtYW51YWxseSBjYXAgb3ZlcmZsb3dzIGF0IDJeNjMuXG4gICAgY29uc3QgYmFzZVZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZSh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIGNvbnN0IHN1bSA9IGFzTnVtYmVyKGJhc2VWYWx1ZSkgKyBhc051bWJlcih0cmFuc2Zvcm0ub3BlcmFuZCk7XG4gICAgaWYgKGlzSW50ZWdlcihiYXNlVmFsdWUpICYmIGlzSW50ZWdlcih0cmFuc2Zvcm0ub3BlcmFuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50ZWdlcihzdW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRvRG91YmxlKHRyYW5zZm9ybS5zZXJpYWxpemVyLCBzdW0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xufVxuZnVuY3Rpb24gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXNcbiAgICAgICAgPyB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcy5zbGljZSgpXG4gICAgICAgIDogW107XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBmaWVsZCBwYXRoIGFuZCB0aGUgVHJhbnNmb3JtT3BlcmF0aW9uIHRvIHBlcmZvcm0gdXBvbiBpdC4gKi9cbmNsYXNzIEZpZWxkVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxufVxuZnVuY3Rpb24gZmllbGRUcmFuc2Zvcm1FcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCkgJiZcbiAgICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQudHJhbnNmb3JtLCByaWdodC50cmFuc2Zvcm0pKTtcbn1cbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIChsLCByKSA9PiBmaWVsZFRyYW5zZm9ybUVxdWFscyhsLCByKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKiBUaGUgcmVzdWx0IG9mIHN1Y2Nlc3NmdWxseSBhcHBseWluZyBhIG11dGF0aW9uIHRvIHRoZSBiYWNrZW5kLiAqL1xuY2xhc3MgTXV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBtdXRhdGlvbiB3YXMgY29tbWl0dGVkOlxuICAgICAqXG4gICAgICogLSBGb3IgbW9zdCBvcGVyYXRpb25zLCB0aGlzIGlzIHRoZSB1cGRhdGVUaW1lIGluIHRoZSBXcml0ZVJlc3VsdC5cbiAgICAgKiAtIEZvciBkZWxldGVzLCB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSAoYmVjYXVzZSBkZWxldGVzIGFyZVxuICAgICAqICAgbm90IHN0b3JlZCBhbmQgaGF2ZSBubyB1cGRhdGVUaW1lKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGVzZSB2ZXJzaW9ucyBjYW4gYmUgZGlmZmVyZW50OiBOby1vcCB3cml0ZXMgd2lsbCBub3QgY2hhbmdlXG4gICAgICogdGhlIHVwZGF0ZVRpbWUgZXZlbiB0aG91Z2ggdGhlIGNvbW1pdFRpbWUgYWR2YW5jZXMuXG4gICAgICovXG4gICAgdmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBmaWVsZHMgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZCBhZnRlciBhIG11dGF0aW9uXG4gICAgICogY29udGFpbmluZyBmaWVsZCB0cmFuc2Zvcm1zIGhhcyBiZWVuIGNvbW1pdHRlZC4gQ29udGFpbnMgb25lIEZpZWxkVmFsdWVcbiAgICAgKiBmb3IgZWFjaCBGaWVsZFRyYW5zZm9ybSB0aGF0IHdhcyBpbiB0aGUgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBXaWxsIGJlIGVtcHR5IGlmIHRoZSBtdXRhdGlvbiBkaWQgbm90IGNvbnRhaW4gYW55IGZpZWxkIHRyYW5zZm9ybXMuXG4gICAgICovXG4gICAgdHJhbnNmb3JtUmVzdWx0cykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdHMgPSB0cmFuc2Zvcm1SZXN1bHRzO1xuICAgIH1cbn1cbi8qKlxuICogRW5jb2RlcyBhIHByZWNvbmRpdGlvbiBmb3IgYSBtdXRhdGlvbi4gVGhpcyBmb2xsb3dzIHRoZSBtb2RlbCB0aGF0IHRoZVxuICogYmFja2VuZCBhY2NlcHRzIHdpdGggdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBleHBsaWNpdCBcImVtcHR5XCIgcHJlY29uZGl0aW9uXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxuICovXG5jbGFzcyBQcmVjb25kaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZVRpbWUsIGV4aXN0cykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSB1cGRhdGVUaW1lO1xuICAgICAgICB0aGlzLmV4aXN0cyA9IGV4aXN0cztcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZW1wdHkgUHJlY29uZGl0aW9uLiAqL1xuICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbigpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gd2l0aCBhbiBleGlzdHMgZmxhZy4gKi9cbiAgICBzdGF0aWMgZXhpc3RzKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih1bmRlZmluZWQsIGV4aXN0cyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovXG4gICAgc3RhdGljIHVwZGF0ZVRpbWUodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih2ZXJzaW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGlzIFByZWNvbmRpdGlvbiBpcyBlbXB0eS4gKi9cbiAgICBnZXQgaXNOb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGlzdHMgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXhpc3RzID09PSBvdGhlci5leGlzdHMgJiZcbiAgICAgICAgICAgICh0aGlzLnVwZGF0ZVRpbWVcbiAgICAgICAgICAgICAgICA/ICEhb3RoZXIudXBkYXRlVGltZSAmJiB0aGlzLnVwZGF0ZVRpbWUuaXNFcXVhbChvdGhlci51cGRhdGVUaW1lKVxuICAgICAgICAgICAgICAgIDogIW90aGVyLnVwZGF0ZVRpbWUpKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwcmVjb25kaXRpb25zIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG5mdW5jdGlvbiBwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQocHJlY29uZGl0aW9uLCBkb2N1bWVudCkge1xuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LnZlcnNpb24uaXNFcXVhbChwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWNvbmRpdGlvbi5leGlzdHMgPT09IGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIG11dGF0aW9uIGRlc2NyaWJlcyBhIHNlbGYtY29udGFpbmVkIGNoYW5nZSB0byBhIGRvY3VtZW50LiBNdXRhdGlvbnMgY2FuXG4gKiBjcmVhdGUsIHJlcGxhY2UsIGRlbGV0ZSwgYW5kIHVwZGF0ZSBzdWJzZXRzIG9mIGRvY3VtZW50cy5cbiAqXG4gKiBNdXRhdGlvbnMgbm90IG9ubHkgYWN0IG9uIHRoZSB2YWx1ZSBvZiB0aGUgZG9jdW1lbnQgYnV0IGFsc28gaXRzIHZlcnNpb24uXG4gKlxuICogRm9yIGxvY2FsIG11dGF0aW9ucyAobXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGNvbW1pdHRlZCB5ZXQpLCB3ZSBwcmVzZXJ2ZVxuICogdGhlIGV4aXN0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBGb3IgRGVsZXRlIG11dGF0aW9ucywgd2VcbiAqIHJlc2V0IHRoZSB2ZXJzaW9uIHRvIDAuXG4gKlxuICogSGVyZSdzIHRoZSBleHBlY3RlZCB0cmFuc2l0aW9uIHRhYmxlLlxuICpcbiAqIE1VVEFUSU9OICAgICAgICAgICBBUFBMSUVEIFRPICAgICAgICAgICAgUkVTVUxUUyBJTlxuICpcbiAqIFNldE11dGF0aW9uICAgICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIERvY3VtZW50KHYwKVxuICogU2V0TXV0YXRpb24gICAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBEb2N1bWVudCh2MClcbiAqIFBhdGNoTXV0YXRpb24gICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIFVua25vd25Eb2N1bWVudCh2MylcbiAqIERlbGV0ZU11dGF0aW9uICAgICBEb2N1bWVudCh2MykgICAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgTm9Eb2N1bWVudCh2MClcbiAqXG4gKiBGb3IgYWNrbm93bGVkZ2VkIG11dGF0aW9ucywgd2UgdXNlIHRoZSB1cGRhdGVUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGFzXG4gKiB0aGUgcmVzdWx0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBBcyBkZWxldGVzIGhhdmUgbm9cbiAqIGV4cGxpY2l0IHVwZGF0ZSB0aW1lLCB3ZSB1c2UgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgZm9yXG4gKiBEZWxldGUgbXV0YXRpb25zLlxuICpcbiAqIElmIGEgbXV0YXRpb24gaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kIGJ1dCBmYWlscyB0aGUgcHJlY29uZGl0aW9uIGNoZWNrXG4gKiBsb2NhbGx5LCB3ZSB0cmFuc2l0aW9uIHRvIGFuIGBVbmtub3duRG9jdW1lbnRgIGFuZCByZWx5IG9uIFdhdGNoIHRvIHNlbmQgdXNcbiAqIHRoZSB1cGRhdGVkIHZlcnNpb24uXG4gKlxuICogRmllbGQgdHJhbnNmb3JtcyBhcmUgdXNlZCBvbmx5IHdpdGggUGF0Y2ggYW5kIFNldCBNdXRhdGlvbnMuIFdlIHVzZSB0aGVcbiAqIGB1cGRhdGVUcmFuc2Zvcm1zYCBtZXNzYWdlIHRvIHN0b3JlIHRyYW5zZm9ybXMsIHJhdGhlciB0aGFuIHRoZSBgdHJhbnNmb3Jtc2BzXG4gKiBtZXNzYWdlcy5cbiAqXG4gKiAjIyBTdWJjbGFzc2luZyBOb3Rlc1xuICpcbiAqIEV2ZXJ5IHR5cGUgb2YgbXV0YXRpb24gbmVlZHMgdG8gaW1wbGVtZW50IGl0cyBvd24gYXBwbHlUb1JlbW90ZURvY3VtZW50KCkgYW5kXG4gKiBhcHBseVRvTG9jYWxWaWV3KCkgdG8gaW1wbGVtZW50IHRoZSBhY3R1YWwgYmVoYXZpb3Igb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uXG4gKiB0byBzb21lIHNvdXJjZSBkb2N1bWVudCAoc2VlIGBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudCgpYCBmb3IgYW5cbiAqIGV4YW1wbGUpLlxuICovXG5jbGFzcyBNdXRhdGlvbiB7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2QgdG8gY2FsY3VsYXRlIGEgYE11dGF0aW9uYCByZXByZXNlbnRpbmcgdGhlIG92ZXJsYXkgZnJvbSB0aGVcbiAqIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgYW5kIGEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIHRoZSBmaWVsZHMgdGhhdFxuICogYXJlIG11dGF0ZWQgYnkgdGhlIGxvY2FsIG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKGRvYywgbWFzaykge1xuICAgIGlmICghZG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8IChtYXNrICYmIG1hc2suZmllbGRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1hc2sgaXMgbnVsbCB3aGVuIHNldHMgb3IgZGVsZXRlcyBhcmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICBpZiAobWFzayA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGRvYy5rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihkb2Mua2V5LCBkb2MuZGF0YSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhdGNoVmFsdWUgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICBsZXQgbWFza1NldCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgbWFzay5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICghbWFza1NldC5oYXMocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkb2NWYWx1ZS5maWVsZChwYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZGVsZXRpbmcgYSBuZXN0ZWQgZmllbGQsIHdlIHRha2UgdGhlIGltbWVkaWF0ZSBwYXJlbnQgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzayB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEp1c3RpZmljYXRpb246IE5lc3RlZCBmaWVsZHMgY2FuIGNyZWF0ZSBwYXJlbnQgZmllbGRzIGltcGxpY2l0bHkuIElmXG4gICAgICAgICAgICAgICAgLy8gb25seSBhIGxlYWYgZW50cnkgaXMgZGVsZXRlZCBpbiBsYXRlciBtdXRhdGlvbnMsIHRoZSBwYXJlbnQgZmllbGRcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3RpbGwgcmVtYWluLCBidXQgd2UgbWF5IGhhdmUgbG9zdCB0aGlzIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIG11dGF0aW9uIChmb28uYmFyIDEpLCB0aGVuIG11dGF0aW9uIChmb28uYmFyIGRlbGV0ZSgpKS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxlYXZlcyB0aGUgZmluYWwgcmVzdWx0IChmb28sIHt9KS4gRGVzcGl0ZSB0aGUgZmFjdCB0aGF0IGBkb2NgXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRoZSBjb3JyZWN0IHJlc3VsdCwgYGZvb2AgaXMgbm90IGluIGBtYXNrYCwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBtdXRhdGlvbiB3b3VsZCBtaXNzIGBmb29gLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRvY1ZhbHVlLmZpZWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWYWx1ZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaFZhbHVlLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tTZXQgPSBtYXNrU2V0LmFkZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oZG9jLmtleSwgcGF0Y2hWYWx1ZSwgbmV3IEZpZWxkTWFzayhtYXNrU2V0LnRvQXJyYXkoKSksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyB0aGlzIG11dGF0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbXB1dGluZyBhXG4gKiBuZXcgcmVtb3RlIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgc3RhdGVcbiAqIChlLmcuIGl0IGlzIGludmFsaWQgb3Igb3V0ZGF0ZWQpLCB0aGUgZG9jdW1lbnQgdHlwZSBtYXkgdHJhbnNpdGlvbiB0b1xuICogdW5rbm93bi5cbiAqXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSBtdXRhdGlvblJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uIGZyb20gdGhlIGJhY2tlbmQuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xuICAgICAgICBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmdcbiAqIHRoZSBuZXcgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGVcbiAqIGV4cGVjdGVkIHN0YXRlLCB0aGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSBtdXRhdGlvbiAtIFRoZSBtdXRhdGlvbiB0byBhcHBseS5cbiAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBtdXRhdGUuIFRoZSBpbnB1dCBkb2N1bWVudCBjYW4gYmUgYW5cbiAqICAgICBpbnZhbGlkIGRvY3VtZW50IGlmIHRoZSBjbGllbnQgaGFzIG5vIGtub3dsZWRnZSBvZiB0aGUgcHJlLW11dGF0aW9uIHN0YXRlXG4gKiAgICAgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHByZXZpb3VzTWFzayAtIFRoZSBmaWVsZHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBiZWZvcmUgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIEEgdGltZXN0YW1wIGluZGljYXRpbmcgdGhlIGxvY2FsIHdyaXRlIHRpbWUgb2YgdGhlXG4gKiAgICAgYmF0Y2ggdGhpcyBtdXRhdGlvbiBpcyBhIHBhcnQgb2YuXG4gKiBAcmV0dXJucyBBIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyB0aGUgZmllbGRzIHRoYXQgYXJlIGNoYW5nZWQgYnkgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzayk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiB0aGlzIG11dGF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvIHBlcnNpc3Qgd2l0aFxuICogdGhpcyBtdXRhdGlvbi4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgbXV0YXRpb24gaXMgYWx3YXlzIGFwcGxpZWRcbiAqIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGJhc2UgdmFsdWUgaXMgYSBzcGFyc2Ugb2JqZWN0IHRoYXQgY29uc2lzdHMgb2Ygb25seSB0aGUgZG9jdW1lbnRcbiAqIGZpZWxkcyBmb3Igd2hpY2ggdGhpcyBtdXRhdGlvbiBjb250YWlucyBhIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybWF0aW9uXG4gKiAoZS5nLiBhIG51bWVyaWMgaW5jcmVtZW50KS4gVGhlIHByb3ZpZGVkIHZhbHVlIGd1YXJhbnRlZXMgY29uc2lzdGVudFxuICogYmVoYXZpb3IgZm9yIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYW5kIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZVxuICogbGF0ZW5jeS1jb21wZW5zYXRlZCB2YWx1ZSBldmVuIGlmIHRoZSBiYWNrZW5kIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlXG4gKiBtdXRhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3IgaWRlbXBvdGVudCBtdXRhdGlvbnMsIGFzIHRoZXkgY2FuIGJlXG4gKiByZS1wbGF5ZWQgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZW0uXG4gKlxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxuICogaWRlbXBvdGVudCBtdXRhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgZG9jdW1lbnQpIHtcbiAgICBsZXQgYmFzZU9iamVjdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGRvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybSwgZXhpc3RpbmdWYWx1ZSB8fCBudWxsKTtcbiAgICAgICAgaWYgKGNvZXJjZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYmFzZU9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJhc2VPYmplY3QgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZU9iamVjdC5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGNvZXJjZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmplY3QgPyBiYXNlT2JqZWN0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbGVmdC5rZXkuaXNFcXVhbChyaWdodC5rZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0LnByZWNvbmRpdGlvbi5pc0VxdWFsKHJpZ2h0LnByZWNvbmRpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQuZmllbGRUcmFuc2Zvcm1zLCByaWdodC5maWVsZFRyYW5zZm9ybXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMCAvKiBNdXRhdGlvblR5cGUuU2V0ICovKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlLmlzRXF1YWwocmlnaHQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSAxIC8qIE11dGF0aW9uVHlwZS5QYXRjaCAqLykge1xuICAgICAgICByZXR1cm4gKGxlZnQuZGF0YS5pc0VxdWFsKHJpZ2h0LmRhdGEpICYmXG4gICAgICAgICAgICBsZWZ0LmZpZWxkTWFzay5pc0VxdWFsKHJpZ2h0LmZpZWxkTWFzaykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IGNyZWF0ZXMgb3IgcmVwbGFjZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcbiAqIG9iamVjdCB2YWx1ZSBjb250ZW50cy5cbiAqL1xuY2xhc3MgU2V0TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgLy8gVW5saWtlIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldywgaWYgd2UncmUgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byBhXG4gICAgLy8gcmVtb3RlIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uXG4gICAgLy8gbXVzdCBoYXZlIGhlbGQuXG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFRoZSBtdXRhdGlvbiBmYWlsZWQgdG8gYXBwbHkgKGUuZy4gYSBkb2N1bWVudCBJRCBjcmVhdGVkIHdpdGggYWRkKClcbiAgICAgICAgLy8gY2F1c2VkIGEgbmFtZSBjb2xsaXNpb24pLlxuICAgICAgICByZXR1cm4gcHJldmlvdXNNYXNrO1xuICAgIH1cbiAgICBjb25zdCBuZXdEYXRhID0gbXV0YXRpb24udmFsdWUuY2xvbmUoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIGRvY3VtZW50KTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICByZXR1cm4gbnVsbDsgLy8gU2V0TXV0YXRpb24gb3ZlcndyaXRlcyBhbGwgZmllbGRzLlxufVxuLyoqXG4gKiBBIG11dGF0aW9uIHRoYXQgbW9kaWZpZXMgZmllbGRzIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXG4gKiBnaXZlbiB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIGFwcGxpZWQgdGhyb3VnaCBhIGZpZWxkIG1hc2s6XG4gKlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIGJvdGggdGhlIG1hc2sgYW5kIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXG4gKiAgICBpcyB1cGRhdGVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIG5laXRoZXIgdGhlIG1hc2sgbm9yIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICBmaWVsZCBpcyB1bm1vZGlmaWVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIHRoZSBtYXNrIGJ1dCBub3QgaW4gdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcbiAqICAgIGlzIGRlbGV0ZWQuXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgbm90IGluIHRoZSBtYXNrIGJ1dCBpcyBpbiB0aGUgdmFsdWVzLCB0aGUgdmFsdWVzIG1hcCBpc1xuICogICAgaWdub3JlZC5cbiAqL1xuY2xhc3MgUGF0Y2hNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRhdGEsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNdXRhdGlvblR5cGUuUGF0Y2ggKi87XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRNYXNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBtdXRhdGlvbiB3YXMgbm90IHJlamVjdGVkLCB3ZSBrbm93IHRoYXQgdGhlIHByZWNvbmRpdGlvblxuICAgICAgICAvLyBtYXRjaGVkIG9uIHRoZSBiYWNrZW5kLiBXZSB0aGVyZWZvcmUgbXVzdCBub3QgaGF2ZSB0aGUgZXhwZWN0ZWQgdmVyc2lvblxuICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgaW4gb3VyIGNhY2hlIGFuZCBjb252ZXJ0IHRvIGFuIFVua25vd25Eb2N1bWVudCB3aXRoIGFcbiAgICAgICAgLy8ga25vd24gdXBkYXRlVGltZS5cbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvVW5rbm93bkRvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xuICAgIG5ld0RhdGEuc2V0QWxsKGdldFBhdGNoKG11dGF0aW9uKSk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gcGF0Y2hNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKCFwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBkb2N1bWVudCk7XG4gICAgY29uc3QgbmV3RGF0YSA9IGRvY3VtZW50LmRhdGE7XG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICBpZiAocHJldmlvdXNNYXNrID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNNYXNrXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcylcbiAgICAgICAgLnVuaW9uV2l0aChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiB0cmFuc2Zvcm0uZmllbGQpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIEZpZWxkUGF0aC9WYWx1ZSBtYXAgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgUGF0Y2hNdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0Y2gobXV0YXRpb24pIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgbXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XG4gICAgICAgIGlmICghZmllbGRQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtdXRhdGlvbi5kYXRhLmZpZWxkKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGZpZWxkUGF0aCwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2UgYWZ0ZXIgYSBtdXRhdGlvblxuICogY29udGFpbmluZyB0cmFuc2Zvcm1zIGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxuICogQHBhcmFtIG11dGFibGVEb2N1bWVudCAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhcHBseWluZyBhbGxcbiAqIHByZXZpb3VzIG11dGF0aW9ucy5cbiAqIEBwYXJhbSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzIC0gVGhlIHRyYW5zZm9ybSByZXN1bHRzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cbiAqL1xuZnVuY3Rpb24gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIG11dGFibGVEb2N1bWVudCwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cykge1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgaGFyZEFzc2VydChmaWVsZFRyYW5zZm9ybXMubGVuZ3RoID09PSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm1zW2ldO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdHMuc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvUmVtb3RlRG9jdW1lbnQodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbGlzdCBvZiBcInRyYW5zZm9ybSByZXN1bHRzXCIgKGEgdHJhbnNmb3JtIHJlc3VsdCBpcyBhIGZpZWxkIHZhbHVlXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhIHRyYW5zZm9ybSkgZm9yIHVzZSB3aGVuIGFwcGx5aW5nIGFcbiAqIHRyYW5zZm9ybSBsb2NhbGx5LlxuICpcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxuICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIGxvY2FsIHRpbWUgb2YgdGhlIG11dGF0aW9uICh1c2VkIHRvXG4gKiAgICAgZ2VuZXJhdGUgU2VydmVyVGltZXN0YW1wVmFsdWVzKS5cbiAqIEBwYXJhbSBtdXRhYmxlRG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgdHJhbnNmb3JtcyBvbi5cbiAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyBsaXN0LlxuICovXG5mdW5jdGlvbiBsb2NhbFRyYW5zZm9ybVJlc3VsdHMoZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgbXV0YWJsZURvY3VtZW50KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVHJhbnNmb3JtIG9mIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdHMuc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgbG9jYWxXcml0ZVRpbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdHM7XG59XG4vKiogQSBtdXRhdGlvbiB0aGF0IGRlbGV0ZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkuICovXG5jbGFzcyBEZWxldGVNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTXV0YXRpb25UeXBlLkRlbGV0ZSAqLztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBbXTtcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgLy8gVW5saWtlIGFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYSByZW1vdGVcbiAgICAvLyBkb2N1bWVudCB0aGUgc2VydmVyIGhhcyBhY2NlcHRlZCB0aGUgbXV0YXRpb24gc28gdGhlIHByZWNvbmRpdGlvbiBtdXN0XG4gICAgLy8gaGF2ZSBoZWxkLlxuICAgIGRvY3VtZW50XG4gICAgICAgIC5jb252ZXJ0VG9Ob0RvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24pXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaykge1xuICAgIGlmIChwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChkb2N1bWVudC52ZXJzaW9uKS5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IHZlcmlmaWVzIHRoZSBleGlzdGVuY2Ugb2YgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aFxuICogdGhlIHByb3ZpZGVkIHByZWNvbmRpdGlvbi5cbiAqXG4gKiBUaGUgYHZlcmlmeWAgb3BlcmF0aW9uIGlzIG9ubHkgdXNlZCBpbiBUcmFuc2FjdGlvbnMsIGFuZCB0aGlzIGNsYXNzIHNlcnZlc1xuICogcHJpbWFyaWx5IHRvIGZhY2lsaXRhdGUgc2VyaWFsaXphdGlvbiBpbnRvIHByb3Rvcy5cbiAqL1xuY2xhc3MgVmVyaWZ5TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAzIC8qIE11dGF0aW9uVHlwZS5WZXJpZnkgKi87XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGJhdGNoIG9mIG11dGF0aW9ucyB0aGF0IHdpbGwgYmUgc2VudCBhcyBvbmUgdW5pdCB0byB0aGUgYmFja2VuZC5cbiAqL1xuY2xhc3MgTXV0YXRpb25CYXRjaCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgdW5pcXVlIElEIG9mIHRoaXMgbXV0YXRpb24gYmF0Y2guXG4gICAgICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIG9yaWdpbmFsIHdyaXRlIHRpbWUgb2YgdGhpcyBtdXRhdGlvbi5cbiAgICAgKiBAcGFyYW0gYmFzZU11dGF0aW9ucyAtIE11dGF0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBiYXNlXG4gICAgICogdmFsdWVzIHdoZW4gdGhpcyBtdXRhdGlvbiBpcyBhcHBsaWVkIGxvY2FsbHkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9jYWxseVxuICAgICAqIG92ZXJ3cml0ZSB2YWx1ZXMgdGhhdCBhcmUgcGVyc2lzdGVkIGluIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuIEJhc2VcbiAgICAgKiBtdXRhdGlvbnMgYXJlIG5ldmVyIHNlbnQgdG8gdGhlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIG11dGF0aW9ucyAtIFRoZSB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucyBpbiB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIFVzZXItcHJvdmlkZWQgbXV0YXRpb25zIGFyZSBhcHBsaWVkIGJvdGggbG9jYWxseSBhbmQgcmVtb3RlbHkgb24gdGhlXG4gICAgICogYmFja2VuZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gICAgICAgIHRoaXMubG9jYWxXcml0ZVRpbWUgPSBsb2NhbFdyaXRlVGltZTtcbiAgICAgICAgdGhpcy5iYXNlTXV0YXRpb25zID0gYmFzZU11dGF0aW9ucztcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpcyBNdXRhdGlvbkJhdGNoIHRvIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnRcbiAgICAgKiB0byBjb21wdXRlIHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSBiYXRjaFJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIE11dGF0aW9uQmF0Y2ggdG8gdGhlXG4gICAgICogYmFja2VuZC5cbiAgICAgKi9cbiAgICBhcHBseVRvUmVtb3RlRG9jdW1lbnQoZG9jdW1lbnQsIGJhdGNoUmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0cyA9IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbXV0YXRpb24gPSB0aGlzLm11dGF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHQgPSBtdXRhdGlvblJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudCBnaXZlbiBhbGwgdGhlIG11dGF0aW9ucyBpbiB0aGlzXG4gICAgICogYmF0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSBtdXRhdGVkRmllbGRzIC0gRmllbGRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlIGFwcGx5aW5nIHRoaXMgbXV0YXRpb24gYmF0Y2guXG4gICAgICogQHJldHVybnMgQSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgYWxsIHRoZSBmaWVsZHMgdGhhdCBhcmUgbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvTG9jYWxWaWV3KGRvY3VtZW50LCBtdXRhdGVkRmllbGRzKSB7XG4gICAgICAgIC8vIEZpcnN0LCBhcHBseSB0aGUgYmFzZSBzdGF0ZS4gVGhpcyBhbGxvd3MgdXMgdG8gYXBwbHkgbm9uLWlkZW1wb3RlbnRcbiAgICAgICAgLy8gdHJhbnNmb3JtIGFnYWluc3QgYSBjb25zaXN0ZW50IHNldCBvZiB2YWx1ZXMuXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5iYXNlTXV0YXRpb25zKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGVkRmllbGRzLCB0aGlzLmxvY2FsV3JpdGVUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZWNvbmQsIGFwcGx5IGFsbCB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiB0aGlzLm11dGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRlZEZpZWxkcywgdGhpcy5sb2NhbFdyaXRlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11dGF0ZWRGaWVsZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IGZvciBhbGwgcHJvdmlkZWQgZG9jdW1lbnRzIGdpdmVuIHRoZSBtdXRhdGlvbnMgaW5cbiAgICAgKiB0aGlzIGJhdGNoLiBSZXR1cm5zIGEgYERvY3VtZW50S2V5YCB0byBgTXV0YXRpb25gIG1hcCB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICAgICAqIHJlcGxhY2UgYWxsIHRoZSBtdXRhdGlvbiBhcHBsaWNhdGlvbnMuXG4gICAgICovXG4gICAgYXBwbHlUb0xvY2FsRG9jdW1lbnRTZXQoZG9jdW1lbnRNYXAsIGRvY3VtZW50c1dpdGhvdXRSZW1vdGVWZXJzaW9uKSB7XG4gICAgICAgIC8vIFRPRE8obXJzY2htaWR0KTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBPKG5eMikuIElmIHdlIGFwcGx5IHRoZSBtdXRhdGlvbnNcbiAgICAgICAgLy8gZGlyZWN0bHkgKGFzIGRvbmUgaW4gYGFwcGx5VG9Mb2NhbFZpZXcoKWApLCB3ZSBjYW4gcmVkdWNlIHRoZSBjb21wbGV4aXR5XG4gICAgICAgIC8vIHRvIE8obikuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXllZERvY3VtZW50ID0gZG9jdW1lbnRNYXAuZ2V0KG0ua2V5KTtcbiAgICAgICAgICAgIC8vIFRPRE8obXV0YWJsZWRvY3VtZW50cyk6IFRoaXMgbWV0aG9kIHNob3VsZCB0YWtlIGEgTXV0YWJsZURvY3VtZW50TWFwXG4gICAgICAgICAgICAvLyBhbmQgd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGNhc3QuXG4gICAgICAgICAgICBjb25zdCBtdXRhYmxlRG9jdW1lbnQgPSBvdmVybGF5ZWREb2N1bWVudC5vdmVybGF5ZWREb2N1bWVudDtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkRmllbGRzID0gdGhpcy5hcHBseVRvTG9jYWxWaWV3KG11dGFibGVEb2N1bWVudCwgb3ZlcmxheWVkRG9jdW1lbnQubXV0YXRlZEZpZWxkcyk7XG4gICAgICAgICAgICAvLyBTZXQgbXV0YXRlZEZpZWxkcyB0byBudWxsIGlmIHRoZSBkb2N1bWVudCBpcyBvbmx5IGZyb20gbG9jYWwgbXV0YXRpb25zLlxuICAgICAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgU2V0IG9yIERlbGV0ZSBtdXRhdGlvbiwgaW5zdGVhZCBvZiB0cnlpbmcgdG8gY3JlYXRlIGFcbiAgICAgICAgICAgIC8vIHBhdGNoIG11dGF0aW9uIGFzIHRoZSBvdmVybGF5LlxuICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IGRvY3VtZW50c1dpdGhvdXRSZW1vdGVWZXJzaW9uLmhhcyhtLmtleSlcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IG11dGF0ZWRGaWVsZHM7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKG11dGFibGVEb2N1bWVudCwgbXV0YXRlZEZpZWxkcyk7XG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzLnNldChtLmtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW11dGFibGVEb2N1bWVudC5pc1ZhbGlkRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIG11dGFibGVEb2N1bWVudC5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoSWQgPT09IG90aGVyLmJhdGNoSWQgJiZcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKHRoaXMubXV0YXRpb25zLCBvdGhlci5tdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkgJiZcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKHRoaXMuYmFzZU11dGF0aW9ucywgb3RoZXIuYmFzZU11dGF0aW9ucywgKGwsIHIpID0+IG11dGF0aW9uRXF1YWxzKGwsIHIpKSk7XG4gICAgfVxufVxuLyoqIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSBtdXRhdGlvbiBiYXRjaCB0byB0aGUgYmFja2VuZC4gKi9cbmNsYXNzIE11dGF0aW9uQmF0Y2hSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGJhdGNoLCBjb21taXRWZXJzaW9uLCBtdXRhdGlvblJlc3VsdHMsIFxuICAgIC8qKlxuICAgICAqIEEgcHJlLWNvbXB1dGVkIG1hcHBpbmcgZnJvbSBlYWNoIG11dGF0ZWQgZG9jdW1lbnQgdG8gdGhlIHJlc3VsdGluZ1xuICAgICAqIHZlcnNpb24uXG4gICAgICovXG4gICAgZG9jVmVyc2lvbnMpIHtcbiAgICAgICAgdGhpcy5iYXRjaCA9IGJhdGNoO1xuICAgICAgICB0aGlzLmNvbW1pdFZlcnNpb24gPSBjb21taXRWZXJzaW9uO1xuICAgICAgICB0aGlzLm11dGF0aW9uUmVzdWx0cyA9IG11dGF0aW9uUmVzdWx0cztcbiAgICAgICAgdGhpcy5kb2NWZXJzaW9ucyA9IGRvY1ZlcnNpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQgZm9yIHRoZSBnaXZlbiBiYXRjaCBhbmQgcmVzdWx0cy4gVGhlcmVcbiAgICAgKiBtdXN0IGJlIG9uZSByZXN1bHQgZm9yIGVhY2ggbXV0YXRpb24gaW4gdGhlIGJhdGNoLiBUaGlzIHN0YXRpYyBmYWN0b3J5XG4gICAgICogY2FjaGVzIGEgZG9jdW1lbnQ9Jmd0O3ZlcnNpb24gbWFwcGluZyAoZG9jVmVyc2lvbnMpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKSB7XG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2gubXV0YXRpb25zLmxlbmd0aCA9PT0gcmVzdWx0cy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmVyc2lvbk1hcCA9IGRvY3VtZW50VmVyc2lvbk1hcCgpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJzaW9uTWFwID0gdmVyc2lvbk1hcC5pbnNlcnQobXV0YXRpb25zW2ldLmtleSwgcmVzdWx0c1tpXS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMsIHZlcnNpb25NYXApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYW4gb3ZlcmxheSBjb21wdXRlZCBieSBGaXJlc3RvcmUuXG4gKlxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXRhdGlvbiBhbmQgdGhlIGxhcmdlc3QgYmF0Y2ggaWQgaW4gRmlyZXN0b3JlIHdoZW5cbiAqIHRoZSBtdXRhdGlvbiB3YXMgY3JlYXRlZC5cbiAqL1xuY2xhc3MgT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSB7XG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9uLmtleTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdGhpcy5tdXRhdGlvbiA9PT0gb3RoZXIubXV0YXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYE92ZXJsYXl7XG4gICAgICBsYXJnZXN0QmF0Y2hJZDogJHt0aGlzLmxhcmdlc3RCYXRjaElkfSxcbiAgICAgIG11dGF0aW9uOiAke3RoaXMubXV0YXRpb24udG9TdHJpbmcoKX1cbiAgICB9YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50LCB1bmNoYW5nZWROYW1lcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMudW5jaGFuZ2VkTmFtZXMgPSB1bmNoYW5nZWROYW1lcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEVycm9yIENvZGVzIGRlc2NyaWJpbmcgdGhlIGRpZmZlcmVudCB3YXlzIEdSUEMgY2FuIGZhaWwuIFRoZXNlIGFyZSBjb3BpZWRcbiAqIGRpcmVjdGx5IGZyb20gR1JQQydzIHNvdXJjZXMgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxuICpcbiAqIEltcG9ydGFudCEgVGhlIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG1hdHRlciBiZWNhdXNlIHRoZSBzdHJpbmcgZm9ybXNcbiAqIGFyZSB1c2VkIGZvciByZXZlcnNlIGxvb2t1cHMgZnJvbSB0aGUgd2ViY2hhbm5lbCBzdHJlYW0uIERvIE5PVCBjaGFuZ2UgdGhlXG4gKiBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBvciBjaGFuZ2UgdGhpcyBpbnRvIGEgY29uc3QgZW51bS5cbiAqL1xudmFyIFJwY0NvZGU7XG4oZnVuY3Rpb24gKFJwY0NvZGUpIHtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG59KShScGNDb2RlIHx8IChScGNDb2RlID0ge30pKTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXG4gKlxuICogU2VlIGlzUGVybWFuZW50V3JpdGVFcnJvciBmb3IgY2xhc3NpZnlpbmcgd3JpdGUgZXJyb3JzLlxuICovXG5mdW5jdGlvbiBpc1Blcm1hbmVudEVycm9yKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBDb2RlLk9LOlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICAgICAgY2FzZSBDb2RlLkNBTkNFTExFRDpcbiAgICAgICAgY2FzZSBDb2RlLlVOS05PV046XG4gICAgICAgIGNhc2UgQ29kZS5ERUFETElORV9FWENFRURFRDpcbiAgICAgICAgY2FzZSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcbiAgICAgICAgY2FzZSBDb2RlLklOVEVSTkFMOlxuICAgICAgICBjYXNlIENvZGUuVU5BVkFJTEFCTEU6XG4gICAgICAgIC8vIFVuYXV0aGVudGljYXRlZCBtZWFucyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIG91ciB0b2tlbiBhbmQgd2UgbmVlZFxuICAgICAgICAvLyB0byByZXRyeSB3aXRoIG5ldyBjcmVkZW50aWFscyB3aGljaCB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICBjYXNlIENvZGUuVU5BVVRIRU5USUNBVEVEOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIENvZGUuSU5WQUxJRF9BUkdVTUVOVDpcbiAgICAgICAgY2FzZSBDb2RlLk5PVF9GT1VORDpcbiAgICAgICAgY2FzZSBDb2RlLkFMUkVBRFlfRVhJU1RTOlxuICAgICAgICBjYXNlIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgIGNhc2UgQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OOlxuICAgICAgICAvLyBBYm9ydGVkIG1pZ2h0IGJlIHJldHJpZWQgaW4gc29tZSBzY2VuYXJpb3MsIGJ1dCB0aGF0IGlzIGRlcGVuZGVudCBvblxuICAgICAgICAvLyB0aGUgY29udGV4dCBhbmQgc2hvdWxkIGhhbmRsZWQgaW5kaXZpZHVhbGx5IGJ5IHRoZSBjYWxsaW5nIGNvZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxuICAgICAgICBjYXNlIENvZGUuQUJPUlRFRDpcbiAgICAgICAgY2FzZSBDb2RlLk9VVF9PRl9SQU5HRTpcbiAgICAgICAgY2FzZSBDb2RlLlVOSU1QTEVNRU5URUQ6XG4gICAgICAgIGNhc2UgQ29kZS5EQVRBX0xPU1M6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXJyb3IgY29kZSByZXByZXNlbnRzIGEgcGVybWFuZW50IGVycm9yIHdoZW4gcmVjZWl2ZWRcbiAqIGluIHJlc3BvbnNlIHRvIGEgd3JpdGUgb3BlcmF0aW9uLlxuICpcbiAqIFdyaXRlIG9wZXJhdGlvbnMgbXVzdCBiZSBoYW5kbGVkIHNwZWNpYWxseSBiZWNhdXNlIGFzIG9mIGIvMTE5NDM3NzY0LCBBQk9SVEVEXG4gKiBlcnJvcnMgb24gdGhlIHdyaXRlIHN0cmVhbSBzaG91bGQgYmUgcmV0cmllZCB0b28gKGV2ZW4gdGhvdWdoIEFCT1JURUQgZXJyb3JzXG4gKiBhcmUgbm90IGdlbmVyYWxseSByZXRyeWFibGUpLlxuICpcbiAqIE5vdGUgdGhhdCBkdXJpbmcgdGhlIGluaXRpYWwgaGFuZHNoYWtlIG9uIHRoZSB3cml0ZSBzdHJlYW0gYW4gQUJPUlRFRCBlcnJvclxuICogc2lnbmFscyB0aGF0IHdlIHNob3VsZCBkaXNjYXJkIG91ciBzdHJlYW0gdG9rZW4gKGkuZS4gaXQgaXMgcGVybWFuZW50KS4gVGhpc1xuICogbWVhbnMgYSBoYW5kc2hha2UgZXJyb3Igc2hvdWxkIGJlIGNsYXNzaWZpZWQgd2l0aCBpc1Blcm1hbmVudEVycm9yLCBhYm92ZS5cbiAqL1xuZnVuY3Rpb24gaXNQZXJtYW5lbnRXcml0ZUVycm9yKGNvZGUpIHtcbiAgICByZXR1cm4gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSAmJiBjb2RlICE9PSBDb2RlLkFCT1JURUQ7XG59XG4vKipcbiAqIE1hcHMgYW4gZXJyb3IgQ29kZSBmcm9tIEdSUEMgc3RhdHVzIGNvZGUgbnVtYmVyLCBsaWtlIDAsIDEsIG9yIDE0LiBUaGVzZVxuICogYXJlIG5vdCB0aGUgc2FtZSBhcyBIVFRQIHN0YXR1cyBjb2Rlcy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgQ29kZSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBHUlBDIHN0YXR1cyBjb2RlLiBGYWlscyBpZiB0aGVyZVxuICogICAgIGlzIG5vIG1hdGNoLlxuICovXG5mdW5jdGlvbiBtYXBDb2RlRnJvbVJwY0NvZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3Qgbm9ybWFsbHkgaGFwcGVuLCBidXQgaW4gY2VydGFpbiBlcnJvciBjYXNlcyAobGlrZSB0cnlpbmdcbiAgICAgICAgLy8gdG8gc2VuZCBpbnZhbGlkIHByb3RvIG1lc3NhZ2VzKSB3ZSBtYXkgZ2V0IGFuIGVycm9yIHdpdGggbm8gR1JQQyBjb2RlLlxuICAgICAgICBsb2dFcnJvcignR1JQQyBlcnJvciBoYXMgbm8gLmNvZGUnKTtcbiAgICAgICAgcmV0dXJuIENvZGUuVU5LTk9XTjtcbiAgICB9XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5PSzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9LO1xuICAgICAgICBjYXNlIFJwY0NvZGUuQ0FOQ0VMTEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQ0FOQ0VMTEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XG4gICAgICAgIGNhc2UgUnBjQ29kZS5ERUFETElORV9FWENFRURFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRFQURMSU5FX0VYQ0VFREVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuSU5URVJOQUw6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JTlRFUk5BTDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOQVZBSUxBQkxFOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVkFJTEFCTEU7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFVVEhFTlRJQ0FURUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5JTlZBTElEX0FSR1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSU5WQUxJRF9BUkdVTUVOVDtcbiAgICAgICAgY2FzZSBScGNDb2RlLk5PVF9GT1VORDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk5PVF9GT1VORDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkFMUkVBRFlfRVhJU1RTOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQUxSRUFEWV9FWElTVFM7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5QRVJNSVNTSU9OX0RFTklFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuRkFJTEVEX1BSRUNPTkRJVElPTjpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT047XG4gICAgICAgIGNhc2UgUnBjQ29kZS5BQk9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQUJPUlRFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLk9VVF9PRl9SQU5HRTpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9VVF9PRl9SQU5HRTtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOSU1QTEVNRU5URUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTklNUExFTUVOVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuREFUQV9MT1NTOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuREFUQV9MT1NTO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIGRlY29kaW5nIGJhc2U2NCBzdHJpbmcuXG4gKi9cbmNsYXNzIEJhc2U2NERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZTY0RGVjb2RlRXJyb3InO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGdsb2JhbCwgc2luZ2xldG9uIGluc3RhbmNlIG9mIFRlc3RpbmdIb29rc1NwaS5cbiAqXG4gKiBUaGlzIHZhcmlhYmxlIHdpbGwgYmUgYG51bGxgIGluIGFsbCBjYXNlcyBfZXhjZXB0XyB3aGVuIHJ1bm5pbmcgZnJvbVxuICogaW50ZWdyYXRpb24gdGVzdHMgdGhhdCBoYXZlIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHRvIGJlIG5vdGlmaWVkIG9mIGV2ZW50c1xuICogdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSB0ZXN0IGV4ZWN1dGlvbi5cbiAqL1xubGV0IHRlc3RpbmdIb29rc1NwaSA9IG51bGw7XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgdGVzdGluZ0hvb2tzU3BpYCBvYmplY3QuXG4gKiBAcGFyYW0gaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0VGVzdGluZ0hvb2tzU3BpKGluc3RhbmNlKSB7XG4gICAgaWYgKHRlc3RpbmdIb29rc1NwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgVGVzdGluZ0hvb2tzU3BpIGluc3RhbmNlIGlzIGFscmVhZHkgc2V0Jyk7XG4gICAgfVxuICAgIHRlc3RpbmdIb29rc1NwaSA9IGluc3RhbmNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dEVuY29kZXInIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXdUZXh0RW5jb2RlcigpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCk7XG59XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBQbGF0Zm9ybSdzICdUZXh0RGVjb2RlcicgaW1wbGVtZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5ld1RleHREZWNvZGVyKCkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIgPSBuZXcgSW50ZWdlcihbMHhmZmZmZmZmZiwgMHhmZmZmZmZmZl0sIDApO1xuLy8gSGFzaCBhIHN0cmluZyB1c2luZyBtZDUgaGFzaGluZyBhbGdvcml0aG0uXG5mdW5jdGlvbiBnZXRNZDVIYXNoVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSBuZXdUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgY29uc3QgbWQ1ID0gbmV3IE1kNSgpO1xuICAgIG1kNS51cGRhdGUoZW5jb2RlZFZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWQ1LmRpZ2VzdCgpKTtcbn1cbi8vIEludGVycHJldCB0aGUgMTYgYnl0ZXMgYXJyYXkgYXMgdHdvIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VycywgZW5jb2RlZCB1c2luZ1xuLy8gMuKAmXMgY29tcGxlbWVudCB1c2luZyBsaXR0bGUgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0NjRCaXRVaW50cyhCeXRlcykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KEJ5dGVzLmJ1ZmZlcik7XG4gICAgY29uc3QgY2h1bmsxID0gZGF0YVZpZXcuZ2V0VWludDMyKDAsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XG4gICAgY29uc3QgY2h1bmsyID0gZGF0YVZpZXcuZ2V0VWludDMyKDQsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XG4gICAgY29uc3QgY2h1bmszID0gZGF0YVZpZXcuZ2V0VWludDMyKDgsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XG4gICAgY29uc3QgY2h1bms0ID0gZGF0YVZpZXcuZ2V0VWludDMyKDEyLCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGludGVnZXIxID0gbmV3IEludGVnZXIoW2NodW5rMSwgY2h1bmsyXSwgMCk7XG4gICAgY29uc3QgaW50ZWdlcjIgPSBuZXcgSW50ZWdlcihbY2h1bmszLCBjaHVuazRdLCAwKTtcbiAgICByZXR1cm4gW2ludGVnZXIxLCBpbnRlZ2VyMl07XG59XG5jbGFzcyBCbG9vbUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpIHtcbiAgICAgICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHRoaXMuaGFzaENvdW50ID0gaGFzaENvdW50O1xuICAgICAgICBpZiAocGFkZGluZyA8IDAgfHwgcGFkZGluZyA+PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nOiAke3BhZGRpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc2hDb3VudCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIGhhc2ggY291bnQ6ICR7aGFzaENvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRtYXAubGVuZ3RoID4gMCAmJiB0aGlzLmhhc2hDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gT25seSBlbXB0eSBibG9vbSBmaWx0ZXIgY2FuIGhhdmUgMCBoYXNoIGNvdW50LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgaGFzaCBjb3VudDogJHtoYXNoQ291bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdG1hcC5sZW5ndGggPT09IDAgJiYgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICAgICAgLy8gRW1wdHkgYmxvb20gZmlsdGVyIHNob3VsZCBoYXZlIDAgcGFkZGluZy5cbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIHBhZGRpbmcgd2hlbiBiaXRtYXAgbGVuZ3RoIGlzIDA6ICR7cGFkZGluZ31gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpdENvdW50ID0gYml0bWFwLmxlbmd0aCAqIDggLSBwYWRkaW5nO1xuICAgICAgICAvLyBTZXQgdGhlIGJpdCBjb3VudCBpbiBJbnRlZ2VyIHRvIGF2b2lkIHJlcGV0aXRpb24gaW4gbWlnaHRDb250YWluKCkuXG4gICAgICAgIHRoaXMuYml0Q291bnRJbkludGVnZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIodGhpcy5iaXRDb3VudCk7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaXRoIGhhc2ggdmFsdWUgYmFzZWQgb24gdGhlIGhhc2hlZCA2NGJpdCBpbnRlZ2VycyxcbiAgICAvLyBhbmQgY2FsY3VsYXRlIGl0cyBjb3JyZXNwb25kaW5nIGJpdCBpbmRleCBpbiB0aGUgYml0bWFwIHRvIGJlIGNoZWNrZWQuXG4gICAgZ2V0Qml0SW5kZXgobnVtMSwgbnVtMiwgaGFzaEluZGV4KSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBoYXNoZWQgdmFsdWUgaChpKSA9IGgxICsgKGkgKiBoMikuXG4gICAgICAgIGxldCBoYXNoVmFsdWUgPSBudW0xLmFkZChudW0yLm11bHRpcGx5KEludGVnZXIuZnJvbU51bWJlcihoYXNoSW5kZXgpKSk7XG4gICAgICAgIC8vIFdyYXAgaWYgaGFzaCB2YWx1ZSBvdmVyZmxvdyA2NGJpdC5cbiAgICAgICAgaWYgKGhhc2hWYWx1ZS5jb21wYXJlKE1BWF82NF9CSVRfVU5TSUdORURfSU5URUdFUikgPT09IDEpIHtcbiAgICAgICAgICAgIGhhc2hWYWx1ZSA9IG5ldyBJbnRlZ2VyKFtoYXNoVmFsdWUuZ2V0Qml0cygwKSwgaGFzaFZhbHVlLmdldEJpdHMoMSldLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaFZhbHVlLm1vZHVsbyh0aGlzLmJpdENvdW50SW5JbnRlZ2VyKS50b051bWJlcigpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gd2hldGhlciB0aGUgYml0IG9uIHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgYml0bWFwIGlzIHNldCB0byAxLlxuICAgIGlzQml0U2V0KGluZGV4KSB7XG4gICAgICAgIC8vIFRvIHJldHJpZXZlIGJpdCBuLCBjYWxjdWxhdGU6IChiaXRtYXBbbiAvIDhdICYgKDB4MDEgPDwgKG4gJSA4KSkpLlxuICAgICAgICBjb25zdCBieXRlID0gdGhpcy5iaXRtYXBbTWF0aC5mbG9vcihpbmRleCAvIDgpXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggJSA4O1xuICAgICAgICByZXR1cm4gKGJ5dGUgJiAoMHgwMSA8PCBvZmZzZXQpKSAhPT0gMDtcbiAgICB9XG4gICAgbWlnaHRDb250YWluKHZhbHVlKSB7XG4gICAgICAgIC8vIEVtcHR5IGJpdG1hcCBzaG91bGQgYWx3YXlzIHJldHVybiBmYWxzZSBvbiBtZW1iZXJzaGlwIGNoZWNrLlxuICAgICAgICBpZiAodGhpcy5iaXRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1kNUhhc2hlZFZhbHVlID0gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgW2hhc2gxLCBoYXNoMl0gPSBnZXQ2NEJpdFVpbnRzKG1kNUhhc2hlZFZhbHVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0Qml0SW5kZXgoaGFzaDEsIGhhc2gyLCBpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0JpdFNldChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgYmxvb20gZmlsdGVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuICovXG4gICAgc3RhdGljIGNyZWF0ZShiaXRDb3VudCwgaGFzaENvdW50LCBjb250YWlucykge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gYml0Q291bnQgJSA4ID09PSAwID8gMCA6IDggLSAoYml0Q291bnQgJSA4KTtcbiAgICAgICAgY29uc3QgYml0bWFwID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGJpdENvdW50IC8gOCkpO1xuICAgICAgICBjb25zdCBibG9vbUZpbHRlciA9IG5ldyBCbG9vbUZpbHRlcihiaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCk7XG4gICAgICAgIGNvbnRhaW5zLmZvckVhY2goaXRlbSA9PiBibG9vbUZpbHRlci5pbnNlcnQoaXRlbSkpO1xuICAgICAgICByZXR1cm4gYmxvb21GaWx0ZXI7XG4gICAgfVxuICAgIGluc2VydCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5iaXRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1kNUhhc2hlZFZhbHVlID0gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgW2hhc2gxLCBoYXNoMl0gPSBnZXQ2NEJpdFVpbnRzKG1kNUhhc2hlZFZhbHVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0Qml0SW5kZXgoaGFzaDEsIGhhc2gyLCBpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qml0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRCaXQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXhPZkJ5dGUgPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICUgODtcbiAgICAgICAgdGhpcy5iaXRtYXBbaW5kZXhPZkJ5dGVdIHw9IDB4MDEgPDwgb2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIEJsb29tRmlsdGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdCbG9vbUZpbHRlckVycm9yJztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGV2ZW50IGZyb20gdGhlIFJlbW90ZVN0b3JlLiBJdCBpcyBzcGxpdCBpbnRvIHRhcmdldENoYW5nZXMgKGNoYW5nZXMgdG8gdGhlXG4gKiBzdGF0ZSBvciB0aGUgc2V0IG9mIGRvY3VtZW50cyBpbiBvdXIgd2F0Y2hlZCB0YXJnZXRzKSBhbmQgZG9jdW1lbnRVcGRhdGVzXG4gKiAoY2hhbmdlcyB0byB0aGUgYWN0dWFsIGRvY3VtZW50cykuXG4gKi9cbmNsYXNzIFJlbW90ZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgc25hcHNob3QgdmVyc2lvbiB0aGlzIGV2ZW50IGJyaW5ncyB1cyB1cCB0bywgb3IgTUlOIGlmIG5vdCBzZXQuXG4gICAgICovXG4gICAgc25hcHNob3RWZXJzaW9uLCBcbiAgICAvKipcbiAgICAgKiBBIG1hcCBmcm9tIHRhcmdldCB0byBjaGFuZ2VzIHRvIHRoZSB0YXJnZXQuIFNlZSBUYXJnZXRDaGFuZ2UuXG4gICAgICovXG4gICAgdGFyZ2V0Q2hhbmdlcywgXG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgdGFyZ2V0cyB0aGF0IGlzIGtub3duIHRvIGJlIGluY29uc2lzdGVudCwgYW5kIHRoZSBwdXJwb3NlIGZvclxuICAgICAqIHJlLWxpc3RlbmluZy4gTGlzdGVucyBmb3IgdGhlc2UgdGFyZ2V0cyBzaG91bGQgYmUgcmUtZXN0YWJsaXNoZWQgd2l0aG91dFxuICAgICAqIHJlc3VtZSB0b2tlbnMuXG4gICAgICovXG4gICAgdGFyZ2V0TWlzbWF0Y2hlcywgXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2Ygd2hpY2ggZG9jdW1lbnRzIGhhdmUgY2hhbmdlZCBvciBiZWVuIGRlbGV0ZWQsIGFsb25nIHdpdGggdGhlXG4gICAgICogZG9jJ3MgbmV3IHZhbHVlcyAoaWYgbm90IGRlbGV0ZWQpLlxuICAgICAqL1xuICAgIGRvY3VtZW50VXBkYXRlcywgXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2Ygd2hpY2ggZG9jdW1lbnQgdXBkYXRlcyBhcmUgZHVlIG9ubHkgdG8gbGltYm8gcmVzb2x1dGlvbiB0YXJnZXRzLlxuICAgICAqL1xuICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMpIHtcbiAgICAgICAgdGhpcy5zbmFwc2hvdFZlcnNpb24gPSBzbmFwc2hvdFZlcnNpb247XG4gICAgICAgIHRoaXMudGFyZ2V0Q2hhbmdlcyA9IHRhcmdldENoYW5nZXM7XG4gICAgICAgIHRoaXMudGFyZ2V0TWlzbWF0Y2hlcyA9IHRhcmdldE1pc21hdGNoZXM7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRVcGRhdGVzID0gZG9jdW1lbnRVcGRhdGVzO1xuICAgICAgICB0aGlzLnJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIQUNLOiBWaWV3cyByZXF1aXJlIFJlbW90ZUV2ZW50cyBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgdmlldyBpc1xuICAgICAqIENVUlJFTlQsIGJ1dCBzZWNvbmRhcnkgdGFicyBkb24ndCByZWNlaXZlIHJlbW90ZSBldmVudHMuIFNvIHRoaXMgbWV0aG9kIGlzXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBSZW1vdGVFdmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IGFcbiAgICAgKiBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3LCBmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudCB0YWIuXG4gICAgICovXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seVxuICAgIHN0YXRpYyBjcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCwgcmVzdW1lVG9rZW4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGFyZ2V0Q2hhbmdlcy5zZXQodGFyZ2V0SWQsIFRhcmdldENoYW5nZS5jcmVhdGVTeW50aGVzaXplZFRhcmdldENoYW5nZUZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCB0YXJnZXRDaGFuZ2VzLCBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpLCBtdXRhYmxlRG9jdW1lbnRNYXAoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFRhcmdldENoYW5nZSBzcGVjaWZpZXMgdGhlIHNldCBvZiBjaGFuZ2VzIGZvciBhIHNwZWNpZmljIHRhcmdldCBhcyBwYXJ0IG9mXG4gKiBhIFJlbW90ZUV2ZW50LiBUaGVzZSBjaGFuZ2VzIHRyYWNrIHdoaWNoIGRvY3VtZW50cyBhcmUgYWRkZWQsIG1vZGlmaWVkIG9yXG4gKiByZW1vdmVkLCBhcyB3ZWxsIGFzIHRoZSB0YXJnZXQncyByZXN1bWUgdG9rZW4gYW5kIHdoZXRoZXIgdGhlIHRhcmdldCBpc1xuICogbWFya2VkIENVUlJFTlQuXG4gKiBUaGUgYWN0dWFsIGNoYW5nZXMgKnRvKiBkb2N1bWVudHMgYXJlIG5vdCBwYXJ0IG9mIHRoZSBUYXJnZXRDaGFuZ2Ugc2luY2VcbiAqIGRvY3VtZW50cyBtYXkgYmUgcGFydCBvZiBtdWx0aXBsZSB0YXJnZXRzLlxuICovXG5jbGFzcyBUYXJnZXRDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgcXVlcnkgdG8gYmUgcmVzdW1lZFxuICAgICAqIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAqIHF1ZXJ5LiBUaGUgcmVzdW1lIHRva2VuIGVzc2VudGlhbGx5IGlkZW50aWZpZXMgYSBwb2ludCBpbiB0aW1lIGZyb20gd2hpY2hcbiAgICAgKiB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxuICAgICAqL1xuICAgIHJlc3VtZVRva2VuLCBcbiAgICAvKipcbiAgICAgKiBUaGUgXCJjdXJyZW50XCIgKHN5bmNlZCkgc3RhdHVzIG9mIHRoaXMgdGFyZ2V0LiBOb3RlIHRoYXQgXCJjdXJyZW50XCJcbiAgICAgKiBoYXMgc3BlY2lhbCBtZWFuaW5nIGluIHRoZSBSUEMgcHJvdG9jb2wgdGhhdCBpbXBsaWVzIHRoYXQgYSB0YXJnZXQgaXNcbiAgICAgKiBib3RoIHVwLXRvLWRhdGUgYW5kIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2ggc3RyZWFtLlxuICAgICAqL1xuICAgIGN1cnJlbnQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBuZXdseSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBhcyBwYXJ0IG9mXG4gICAgICogdGhpcyByZW1vdGUgZXZlbnQuXG4gICAgICovXG4gICAgYWRkZWREb2N1bWVudHMsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBhbHJlYWR5IGFzc2lnbmVkIHRvIHRoaXMgdGFyZ2V0IGJ1dCByZWNlaXZlZFxuICAgICAqIGFuIHVwZGF0ZSBkdXJpbmcgdGhpcyByZW1vdGUgZXZlbnQuXG4gICAgICovXG4gICAgbW9kaWZpZWREb2N1bWVudHMsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSByZW1vdmVkIGZyb20gdGhpcyB0YXJnZXQgYXMgcGFydCBvZiB0aGlzXG4gICAgICogcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIHJlbW92ZWREb2N1bWVudHMpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLmFkZGVkRG9jdW1lbnRzID0gYWRkZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMubW9kaWZpZWREb2N1bWVudHMgPSBtb2RpZmllZERvY3VtZW50cztcbiAgICAgICAgdGhpcy5yZW1vdmVkRG9jdW1lbnRzID0gcmVtb3ZlZERvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBUYXJnZXRDaGFuZ2VzIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBhcHBseSBhIENVUlJFTlQgc3RhdHVzIGNoYW5nZSB0byBhIFZpZXcgKGZvciBxdWVyaWVzIGV4ZWN1dGVkIGluIGEgZGlmZmVyZW50XG4gICAgICogdGFiKSBvciBmb3IgbmV3IHF1ZXJpZXMgKHRvIHJhaXNlIHNuYXBzaG90cyB3aXRoIGNvcnJlY3QgQ1VSUkVOVCBzdGF0dXMpLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTeW50aGVzaXplZFRhcmdldENoYW5nZUZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0Q2hhbmdlKHJlc3VtZVRva2VuLCBjdXJyZW50LCBkb2N1bWVudEtleVNldCgpLCBkb2N1bWVudEtleVNldCgpLCBkb2N1bWVudEtleVNldCgpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGFuZ2VkIGRvY3VtZW50IGFuZCBhIGxpc3Qgb2YgdGFyZ2V0IGlkcyB0byB3aGljaCB0aGlzIGNoYW5nZVxuICogYXBwbGllcy5cbiAqXG4gKiBJZiBkb2N1bWVudCBoYXMgYmVlbiBkZWxldGVkIE5vRG9jdW1lbnQgd2lsbCBiZSBwcm92aWRlZC5cbiAqL1xuY2xhc3MgRG9jdW1lbnRXYXRjaENoYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgYXBwbGllcyB0byBhbGwgb2YgdGhlc2UgdGFyZ2V0cy4gKi9cbiAgICB1cGRhdGVkVGFyZ2V0SWRzLCBcbiAgICAvKiogVGhlIG5ldyBkb2N1bWVudCBpcyByZW1vdmVkIGZyb20gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXG4gICAgcmVtb3ZlZFRhcmdldElkcywgXG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGRvY3VtZW50IGZvciB0aGlzIGNoYW5nZS4gKi9cbiAgICBrZXksIFxuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgZG9jdW1lbnQgb3IgTm9Eb2N1bWVudCBpZiBpdCB3YXMgZGVsZXRlZC4gSXMgbnVsbCBpZiB0aGVcbiAgICAgKiBkb2N1bWVudCB3ZW50IG91dCBvZiB2aWV3IHdpdGhvdXQgdGhlIHNlcnZlciBzZW5kaW5nIGEgbmV3IGRvY3VtZW50LlxuICAgICAqL1xuICAgIG5ld0RvYykge1xuICAgICAgICB0aGlzLnVwZGF0ZWRUYXJnZXRJZHMgPSB1cGRhdGVkVGFyZ2V0SWRzO1xuICAgICAgICB0aGlzLnJlbW92ZWRUYXJnZXRJZHMgPSByZW1vdmVkVGFyZ2V0SWRzO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5uZXdEb2MgPSBuZXdEb2M7XG4gICAgfVxufVxuY2xhc3MgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXIgPSBleGlzdGVuY2VGaWx0ZXI7XG4gICAgfVxufVxuY2xhc3MgV2F0Y2hUYXJnZXRDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBXaGF0IGtpbmQgb2YgY2hhbmdlIG9jY3VycmVkIHRvIHRoZSB3YXRjaCB0YXJnZXQuICovXG4gICAgc3RhdGUsIFxuICAgIC8qKiBUaGUgdGFyZ2V0IElEcyB0aGF0IHdlcmUgYWRkZWQvcmVtb3ZlZC9zZXQuICovXG4gICAgdGFyZ2V0SWRzLCBcbiAgICAvKipcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHRhcmdldCB0byBiZVxuICAgICAqIHJlc3VtZWQgYWZ0ZXIgZGlzY29ubmVjdGluZyB3aXRob3V0IHJldHJhbnNtaXR0aW5nIGFsbCB0aGUgZGF0YSB0aGF0XG4gICAgICogbWF0Y2hlcyB0aGUgdGFyZ2V0LiBUaGUgcmVzdW1lIHRva2VuIGVzc2VudGlhbGx5IGlkZW50aWZpZXMgYSBwb2ludCBpblxuICAgICAqIHRpbWUgZnJvbSB3aGljaCB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxuICAgICAqL1xuICAgIHJlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORywgXG4gICAgLyoqIEFuIFJQQyBlcnJvciBpbmRpY2F0aW5nIHdoeSB0aGUgd2F0Y2ggZmFpbGVkLiAqL1xuICAgIGNhdXNlID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xuICAgICAgICB0aGlzLnJlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG59XG4vKiogVHJhY2tzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhIFdhdGNoIHRhcmdldC4gKi9cbmNsYXNzIFRhcmdldFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcGVuZGluZyByZXNwb25zZXMgKGFkZHMgb3IgcmVtb3ZlcykgdGhhdCB3ZSBhcmUgd2FpdGluZyBvbi5cbiAgICAgICAgICogV2Ugb25seSBjb25zaWRlciB0YXJnZXRzIGFjdGl2ZSB0aGF0IGhhdmUgbm8gcGVuZGluZyByZXNwb25zZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGRvY3VtZW50IGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgcmFpc2VkIHNuYXBzaG90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVzZSBjaGFuZ2VzIGFyZSBjb250aW51b3VzbHkgdXBkYXRlZCBhcyB3ZSByZWNlaXZlIGRvY3VtZW50IHVwZGF0ZXMgYW5kXG4gICAgICAgICAqIGFsd2F5cyByZWZsZWN0IHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzIGFnYWluc3QgdGhlIGxhc3QgaXNzdWVkIHNuYXBzaG90LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSBzbmFwc2hvdENoYW5nZXNNYXAoKTtcbiAgICAgICAgLyoqIFNlZSBwdWJsaWMgZ2V0dGVycyBmb3IgZXhwbGFuYXRpb25zIG9mIHRoZXNlIGZpZWxkcy4gKi9cbiAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IHN0YXRlIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgbmV4dCBzbmFwc2hvdC4gV2VcbiAgICAgICAgICogaW5pdGlhbGl6ZSB0byB0cnVlIHNvIHRoYXQgbmV3bHktYWRkZWQgdGFyZ2V0cyBhcmUgaW5jbHVkZWQgaW4gdGhlIG5leHRcbiAgICAgICAgICogUmVtb3RlRXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyB0YXJnZXQgaGFzIGJlZW4gbWFya2VkICdjdXJyZW50Jy5cbiAgICAgKlxuICAgICAqICdDdXJyZW50JyBoYXMgc3BlY2lhbCBtZWFuaW5nIGluIHRoZSBSUEMgcHJvdG9jb2w6IEl0IGltcGxpZXMgdGhhdCB0aGVcbiAgICAgKiBXYXRjaCBiYWNrZW5kIGhhcyBzZW50IHVzIGFsbCBjaGFuZ2VzIHVwIHRvIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgdGFyZ2V0XG4gICAgICogd2FzIGFkZGVkIGFuZCB0aGF0IHRoZSB0YXJnZXQgaXMgY29uc2lzdGVudCB3aXRoIHRoZSByZXN0IG9mIHRoZSB3YXRjaFxuICAgICAqIHN0cmVhbS5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgfVxuICAgIC8qKiBUaGUgbGFzdCByZXN1bWUgdG9rZW4gc2VudCB0byB1cyBmb3IgdGhpcyB0YXJnZXQuICovXG4gICAgZ2V0IHJlc3VtZVRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdW1lVG9rZW47XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBwZW5kaW5nIHRhcmdldCBhZGRzIG9yIHRhcmdldCByZW1vdmVzLiAqL1xuICAgIGdldCBpc1BlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXNwb25zZXMgIT09IDA7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHdlIGhhdmUgbW9kaWZpZWQgYW55IHN0YXRlIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSBzbmFwc2hvdC4gKi9cbiAgICBnZXQgaGFzUGVuZGluZ0NoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgcmVzdW1lIHRva2VuIHRvIHRoZSBUYXJnZXRDaGFuZ2UsIGJ1dCBvbmx5IHdoZW4gaXQgaGFzIGEgbmV3XG4gICAgICogdmFsdWUuIEVtcHR5IHJlc3VtZVRva2VucyBhcmUgZGlzY2FyZGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVJlc3VtZVRva2VuKHJlc3VtZVRva2VuKSB7XG4gICAgICAgIGlmIChyZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0YXJnZXQgY2hhbmdlIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUbyByZXNldCB0aGUgZG9jdW1lbnQgY2hhbmdlcyBhZnRlciByYWlzaW5nIHRoaXMgc25hcHNob3QsIGNhbGxcbiAgICAgKiBgY2xlYXJQZW5kaW5nQ2hhbmdlcygpYC5cbiAgICAgKi9cbiAgICB0b1RhcmdldENoYW5nZSgpIHtcbiAgICAgICAgbGV0IGFkZGVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgbGV0IG1vZGlmaWVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgbGV0IHJlbW92ZWREb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChrZXksIGNoYW5nZVR5cGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovOlxuICAgICAgICAgICAgICAgICAgICBhZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWREb2N1bWVudHMgPSBtb2RpZmllZERvY3VtZW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZERvY3VtZW50cyA9IHJlbW92ZWREb2N1bWVudHMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0Q2hhbmdlKHRoaXMuX3Jlc3VtZVRva2VuLCB0aGlzLl9jdXJyZW50LCBhZGRlZERvY3VtZW50cywgbW9kaWZpZWREb2N1bWVudHMsIHJlbW92ZWREb2N1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGRvY3VtZW50IGNoYW5nZXMgYW5kIHNldHMgYGhhc1BlbmRpbmdDaGFuZ2VzYCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBjbGVhclBlbmRpbmdDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHNuYXBzaG90Q2hhbmdlc01hcCgpO1xuICAgIH1cbiAgICBhZGREb2N1bWVudENoYW5nZShrZXksIGNoYW5nZVR5cGUpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHRoaXMuZG9jdW1lbnRDaGFuZ2VzLmluc2VydChrZXksIGNoYW5nZVR5cGUpO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudENoYW5nZShrZXkpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHRoaXMuZG9jdW1lbnRDaGFuZ2VzLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICByZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzICs9IDE7XG4gICAgfVxuICAgIHJlY29yZFRhcmdldFJlc3BvbnNlKCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgLT0gMTtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnBlbmRpbmdSZXNwb25zZXMgPj0gMCk7XG4gICAgfVxuICAgIG1hcmtDdXJyZW50KCkge1xuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0cnVlO1xuICAgIH1cbn1cbmNvbnN0IExPR19UQUckZyA9ICdXYXRjaENoYW5nZUFnZ3JlZ2F0b3InO1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0byBhY2N1bXVsYXRlIHdhdGNoIGNoYW5nZXMgaW50byBhIFJlbW90ZUV2ZW50LlxuICovXG5jbGFzcyBXYXRjaENoYW5nZUFnZ3JlZ2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVByb3ZpZGVyID0gbWV0YWRhdGFQcm92aWRlcjtcbiAgICAgICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbGwgdHJhY2tlZCB0YXJnZXRzLiAqL1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudHMgdG8gdXBkYXRlIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgLyoqIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXlzIHRvIHRoZWlyIHNldCBvZiB0YXJnZXQgSURzLiAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPSBkb2N1bWVudFRhcmdldE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgdGFyZ2V0cyB3aXRoIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hlcy4gVGhlc2UgdGFyZ2V0cyBhcmVcbiAgICAgICAgICoga25vd24gdG8gYmUgaW5jb25zaXN0ZW50IGFuZCB0aGVpciBsaXN0ZW5zIG5lZWRzIHRvIGJlIHJlLWVzdGFibGlzaGVkIGJ5XG4gICAgICAgICAqIFJlbW90ZVN0b3JlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGFuZCBhZGRzIHRoZSBEb2N1bWVudFdhdGNoQ2hhbmdlIHRvIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZURvY3VtZW50Q2hhbmdlKGRvY0NoYW5nZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGRvY0NoYW5nZS51cGRhdGVkVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICBpZiAoZG9jQ2hhbmdlLm5ld0RvYyAmJiBkb2NDaGFuZ2UubmV3RG9jLmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2UubmV3RG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2Uua2V5LCBkb2NDaGFuZ2UubmV3RG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGRvY0NoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFByb2Nlc3NlcyBhbmQgYWRkcyB0aGUgV2F0Y2hUYXJnZXRDaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuICovXG4gICAgaGFuZGxlVGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSkge1xuICAgICAgICB0aGlzLmZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICAgICAgc3dpdGNoICh0YXJnZXRDaGFuZ2Uuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5Ob0NoYW5nZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkFkZGVkICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlY3JlbWVudCB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYWNrcyBuZWVkZWQgZnJvbSB3YXRjaFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhpcyB0YXJnZXRJZC5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVjb3JkVGFyZ2V0UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBmcmVzaGx5IGFkZGVkIHRhcmdldCwgc28gd2UgbmVlZCB0byByZXNldCBhbnkgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd2UgaGFkIHByZXZpb3VzbHkuIFRoaXMgY2FuIGhhcHBlbiBlLmcuIHdoZW4gcmVtb3ZlIGFuZCBhZGRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2sgYSB0YXJnZXQgZm9yIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLmNsZWFyUGVuZGluZ0NoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgcmVtb3ZlZCB0YXJnZXRzIHRvIHdlIGNhbiBwb3N0LWZpbHRlciBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSB0YXJnZXQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFja3MgbmVlZGVkIGZyb20gd2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0U3RhdGUuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQ3VycmVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5tYXJrQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZXNldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFyZ2V0IGFuZCBzeW50aGVzaXplcyByZW1vdmVzIGZvciBhbGwgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cy4gVGhlIGJhY2tlbmQgd2lsbCByZS1hZGQgYW55IGRvY3VtZW50cyB0aGF0IHN0aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGUgdGFyZ2V0IGJlZm9yZSBpdCBzZW5kcyB0aGUgbmV4dCBnbG9iYWwgc25hcHNob3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdGFyZ2V0SWRzIHRoYXQgdGhlIHdhdGNoIGNoYW5nZSBhcHBsaWVzIHRvOiBlaXRoZXIgdGhlXG4gICAgICogdGFyZ2V0SWRzIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBjaGFuZ2Ugb3IgdGhlIHRhcmdldElkcyBvZiBhbGwgY3VycmVudGx5XG4gICAgICogYWN0aXZlIHRhcmdldHMuXG4gICAgICovXG4gICAgZm9yRWFjaFRhcmdldCh0YXJnZXRDaGFuZ2UsIGZuKSB7XG4gICAgICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS50YXJnZXRJZHMuZm9yRWFjaChmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICBmbih0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBleGlzdGVuY2UgZmlsdGVycyBhbmQgc3ludGhlc2l6ZXMgZGVsZXRlcyBmb3IgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgICogVGFyZ2V0cyB0aGF0IGFyZSBpbnZhbGlkYXRlZCBieSBmaWx0ZXIgbWlzbWF0Y2hlcyBhcmUgYWRkZWQgdG9cbiAgICAgKiBgcGVuZGluZ1RhcmdldFJlc2V0c2AuXG4gICAgICovXG4gICAgaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gd2F0Y2hDaGFuZ2UudGFyZ2V0SWQ7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIuY291bnQ7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4aXN0ZW5jZSBmaWx0ZXIgdG9sZCB1cyB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QuIFdlIGRlZHVjZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QgYW5kIGFwcGx5IGEgZGVsZXRlZCBkb2N1bWVudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvdXIgdXBkYXRlcy4gV2l0aG91dCBhcHBseWluZyB0aGlzIGRlbGV0ZWQgZG9jdW1lbnQgdGhlcmUgbWlnaHQgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBxdWVyeSB0aGF0IHdpbGwgcmFpc2UgdGhpcyBkb2N1bWVudCBhcyBwYXJ0IG9mIGEgc25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgaXQgaXMgcmVzb2x2ZWQsIGVzc2VudGlhbGx5IGV4cG9zaW5nIGluY29uc2lzdGVuY3kgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAvLyBxdWVyaWVzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChleHBlY3RlZENvdW50ID09PSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuZ2V0Q3VycmVudERvY3VtZW50Q291bnRGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIC8vIEV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guIE1hcmsgdGhlIGRvY3VtZW50cyBhcyBiZWluZyBpbiBsaW1ibywgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmFpc2UgYSBzbmFwc2hvdCB3aXRoIGBpc0Zyb21DYWNoZTp0cnVlYC5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNpemUgIT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYmxvb20gZmlsdGVyIHRvIGlkZW50aWZ5IGFuZCBtYXJrIHJlbW92ZWQgZG9jdW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9vbUZpbHRlciA9IHRoaXMucGFyc2VCbG9vbUZpbHRlcih3YXRjaENoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGJsb29tRmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYXBwbHlCbG9vbUZpbHRlcihibG9vbUZpbHRlciwgd2F0Y2hDaGFuZ2UsIGN1cnJlbnRTaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU2tpcHBlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGJsb29tIGZpbHRlciBhcHBsaWNhdGlvbiBmYWlscywgd2UgcmVzZXQgdGhlIG1hcHBpbmcgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlLXJ1biBvZiB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1cnBvc2UgPSBzdGF0dXMgPT09IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaFwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMuaW5zZXJ0KHRhcmdldElkLCBwdXJwb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXN0aW5nSG9va3NTcGkgPT09IG51bGwgfHwgdGVzdGluZ0hvb2tzU3BpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXN0aW5nSG9va3NTcGkubm90aWZ5T25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjcmVhdGVFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEluZm9Gb3JUZXN0aW5nSG9va3MoY3VycmVudFNpemUsIHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlciwgdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKSwgYmxvb21GaWx0ZXIsIHN0YXR1cykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgYmxvb20gZmlsdGVyIGZyb20gdGhlIFwidW5jaGFuZ2VkX25hbWVzXCIgZmllbGQgb2YgYW4gZXhpc3RlbmNlXG4gICAgICogZmlsdGVyLlxuICAgICAqL1xuICAgIHBhcnNlQmxvb21GaWx0ZXIod2F0Y2hDaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgdW5jaGFuZ2VkTmFtZXMgPSB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIudW5jaGFuZ2VkTmFtZXM7XG4gICAgICAgIGlmICghdW5jaGFuZ2VkTmFtZXMgfHwgIXVuY2hhbmdlZE5hbWVzLmJpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYml0czogeyBiaXRtYXAgPSAnJywgcGFkZGluZyA9IDAgfSwgaGFzaENvdW50ID0gMCB9ID0gdW5jaGFuZ2VkTmFtZXM7XG4gICAgICAgIGxldCBub3JtYWxpemVkQml0bWFwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplZEJpdG1hcCA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYml0bWFwKS50b1VpbnQ4QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQmFzZTY0RGVjb2RlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdEZWNvZGluZyB0aGUgYmFzZTY0IGJsb29tIGZpbHRlciBpbiBleGlzdGVuY2UgZmlsdGVyIGZhaWxlZCAoJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgJyk7IGlnbm9yaW5nIHRoZSBibG9vbSBmaWx0ZXIgYW5kIGZhbGxpbmcgYmFjayB0byBmdWxsIHJlLXF1ZXJ5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBibG9vbUZpbHRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJsb29tRmlsdGVyIHRocm93cyBlcnJvciBpZiB0aGUgaW5wdXRzIGFyZSBpbnZhbGlkLlxuICAgICAgICAgICAgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIobm9ybWFsaXplZEJpdG1hcCwgcGFkZGluZywgaGFzaENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQmxvb21GaWx0ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0Jsb29tRmlsdGVyIGVycm9yOiAnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybignQXBwbHlpbmcgYmxvb20gZmlsdGVyIGZhaWxlZDogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9vbUZpbHRlci5iaXRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSBibG9vbSBmaWx0ZXIgdG8gcmVtb3ZlIHRoZSBkZWxldGVkIGRvY3VtZW50cywgYW5kIHJldHVybiB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBzdGF0dXMuXG4gICAgICovXG4gICAgYXBwbHlCbG9vbUZpbHRlcihibG9vbUZpbHRlciwgd2F0Y2hDaGFuZ2UsIGN1cnJlbnRDb3VudCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLmNvdW50O1xuICAgICAgICBjb25zdCByZW1vdmVkRG9jdW1lbnRDb3VudCA9IHRoaXMuZmlsdGVyUmVtb3ZlZERvY3VtZW50cyhibG9vbUZpbHRlciwgd2F0Y2hDaGFuZ2UudGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWRDb3VudCA9PT0gY3VycmVudENvdW50IC0gcmVtb3ZlZERvY3VtZW50Q291bnRcbiAgICAgICAgICAgID8gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi9cbiAgICAgICAgICAgIDogMiAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLkZhbHNlUG9zaXRpdmUgKi87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlciBvdXQgcmVtb3ZlZCBkb2N1bWVudHMgYmFzZWQgb24gYmxvb20gZmlsdGVyIG1lbWJlcnNoaXAgcmVzdWx0IGFuZFxuICAgICAqIHJldHVybiBudW1iZXIgb2YgZG9jdW1lbnRzIHJlbW92ZWQuXG4gICAgICovXG4gICAgZmlsdGVyUmVtb3ZlZERvY3VtZW50cyhibG9vbUZpbHRlciwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICBsZXQgcmVtb3ZhbENvdW50ID0gMDtcbiAgICAgICAgZXhpc3RpbmdLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0RGF0YWJhc2VJZCgpO1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRQYXRoID0gYHByb2plY3RzLyR7ZGF0YWJhc2VJZC5wcm9qZWN0SWR9YCArXG4gICAgICAgICAgICAgICAgYC9kYXRhYmFzZXMvJHtkYXRhYmFzZUlkLmRhdGFiYXNlfWAgK1xuICAgICAgICAgICAgICAgIGAvZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIGlmICghYmxvb21GaWx0ZXIubWlnaHRDb250YWluKGRvY3VtZW50UGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcbiAgICAgICAgICAgICAgICByZW1vdmFsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZW1vdmFsQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50bHkgYWNjdW11bGF0ZWQgc3RhdGUgaW50byBhIHJlbW90ZSBldmVudCBhdCB0aGVcbiAgICAgKiBwcm92aWRlZCBzbmFwc2hvdCB2ZXJzaW9uLiBSZXNldHMgdGhlIGFjY3VtdWxhdGVkIGNoYW5nZXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgKi9cbiAgICBjcmVhdGVSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZm9yRWFjaCgodGFyZ2V0U3RhdGUsIHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmN1cnJlbnQgJiYgdGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXREYXRhLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgcXVlcmllcyBmb3IgZG9jdW1lbnQgdGhhdCBkb24ndCBleGlzdCBjYW4gcHJvZHVjZSBhbiBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgc2V0LiBUbyB1cGRhdGUgb3VyIGxvY2FsIGNhY2hlLCB3ZSBzeW50aGVzaXplIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGlmIHdlIGhhdmUgbm90IHByZXZpb3VzbHkgcmVjZWl2ZWQgdGhlIGRvY3VtZW50IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldC4gVGhpcyByZXNvbHZlcyB0aGUgbGltYm8gc3RhdGUgb2YgdGhlIGRvY3VtZW50LCByZW1vdmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIGxpbWJvRG9jdW1lbnRSZWZzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhbiBleHBsaWNpdCBsb29rdXAgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgcmVzdWx0aW5nIGluIGFuIGV4cGxpY2l0IGRlbGV0ZSBtZXNzYWdlIGFuZCB3ZSBjb3VsZFxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBzcGVjaWFsIGxvZ2ljLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0RGF0YS50YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbnN1cmVEb2N1bWVudFVwZGF0ZUJ5VGFyZ2V0KGtleSkuaGFzKHRhcmdldElkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCBzbmFwc2hvdFZlcnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U3RhdGUuaGFzUGVuZGluZ0NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlcy5zZXQodGFyZ2V0SWQsIHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCkpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5jbGVhclBlbmRpbmdDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICAvLyBXZSBleHRyYWN0IHRoZSBzZXQgb2YgbGltYm8tb25seSBkb2N1bWVudCB1cGRhdGVzIGFzIHRoZSBHQyBsb2dpY1xuICAgICAgICAvLyBzcGVjaWFsLWNhc2VzIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBhcHBlYXIgaW4gdGhlIHRhcmdldCBjYWNoZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVE9ETyhnc29sdGlzKTogRXhwYW5kIG9uIHRoaXMgY29tbWVudCBvbmNlIEdDIGlzIGF2YWlsYWJsZSBpbiB0aGUgSlNcbiAgICAgICAgLy8gY2xpZW50LlxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZm9yRWFjaCgoa2V5LCB0YXJnZXRzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNPbmx5TGltYm9UYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoV2hpbGUodGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXREYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEucHVycG9zZSAhPT0gXCJUYXJnZXRQdXJwb3NlTGltYm9SZXNvbHV0aW9uXCIgLyogVGFyZ2V0UHVycG9zZS5MaW1ib1Jlc29sdXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaXNPbmx5TGltYm9UYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzT25seUxpbWJvVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IHJlc29sdmVkTGltYm9Eb2N1bWVudHMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuZm9yRWFjaCgoXywgZG9jKSA9PiBkb2Muc2V0UmVhZFRpbWUoc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gbmV3IFJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbiwgdGFyZ2V0Q2hhbmdlcywgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLCB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMsIHJlc29sdmVkTGltYm9Eb2N1bWVudHMpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzQnlUYXJnZXQgPSBkb2N1bWVudFRhcmdldE1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPSBkb2N1bWVudFRhcmdldE1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHByb3ZpZGVkIGRvY3VtZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGRvY3VtZW50IHVwZGF0ZXMgYW5kXG4gICAgICogaXRzIGRvY3VtZW50IGtleSB0byB0aGUgZ2l2ZW4gdGFyZ2V0J3MgbWFwcGluZy5cbiAgICAgKi9cbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICAgIGFkZERvY3VtZW50VG9UYXJnZXQodGFyZ2V0SWQsIGRvY3VtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VUeXBlID0gdGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBkb2N1bWVudC5rZXkpXG4gICAgICAgICAgICA/IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqL1xuICAgICAgICAgICAgOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi87XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XG4gICAgICAgIHRhcmdldFN0YXRlLmFkZERvY3VtZW50Q2hhbmdlKGRvY3VtZW50LmtleSwgY2hhbmdlVHlwZSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0Lmluc2VydChkb2N1bWVudC5rZXksIHRoaXMuZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChkb2N1bWVudC5rZXksIHRoaXMuZW5zdXJlRG9jdW1lbnRUYXJnZXRNYXBwaW5nKGRvY3VtZW50LmtleSkuYWRkKHRhcmdldElkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGZyb20gdGhlIHRhcmdldCBtYXBwaW5nLiBJZiB0aGVcbiAgICAgKiBkb2N1bWVudCBubyBsb25nZXIgbWF0Y2hlcyB0aGUgdGFyZ2V0LCBidXQgdGhlIGRvY3VtZW50J3Mgc3RhdGUgaXMgc3RpbGxcbiAgICAgKiBrbm93biAoZS5nLiB3ZSBrbm93IHRoYXQgdGhlIGRvY3VtZW50IHdhcyBkZWxldGVkIG9yIHdlIHJlY2VpdmVkIHRoZSBjaGFuZ2VcbiAgICAgKiB0aGF0IGNhdXNlZCB0aGUgZmlsdGVyIG1pc21hdGNoKSwgdGhlIG5ldyBkb2N1bWVudCBjYW4gYmUgcHJvdmlkZWRcbiAgICAgKiB0byB1cGRhdGUgdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZS5cbiAgICAgKi9cbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICAgIHJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCB1cGRhdGVkRG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFN0YXRlLmFkZERvY3VtZW50Q2hhbmdlKGtleSwgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IG1heSBoYXZlIGVudGVyZWQgYW5kIGxlZnQgdGhlIHRhcmdldCBiZWZvcmUgd2UgcmFpc2VkIGFcbiAgICAgICAgICAgIC8vIHNuYXBzaG90LCBzbyB3ZSBjYW4ganVzdCBpZ25vcmUgdGhlIGNoYW5nZS5cbiAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlbW92ZURvY3VtZW50Q2hhbmdlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpLmRlbGV0ZSh0YXJnZXRJZCkpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRoaXMuZW5zdXJlRG9jdW1lbnRUYXJnZXRNYXBwaW5nKGtleSkuYWRkKHRhcmdldElkKSk7XG4gICAgICAgIGlmICh1cGRhdGVkRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcy5pbnNlcnQoa2V5LCB1cGRhdGVkRG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvdW50IG9mIGRvY3VtZW50cyBpbiB0aGUgdGFyZ2V0LiBUaGlzIGluY2x1ZGVzIGJvdGhcbiAgICAgKiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHRoZSBMb2NhbFN0b3JlIGNvbnNpZGVycyB0byBiZSBwYXJ0IG9mIHRoZVxuICAgICAqIHRhcmdldCBhcyB3ZWxsIGFzIGFueSBhY2N1bXVsYXRlZCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnREb2N1bWVudENvdW50Rm9yVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpLnNpemUgK1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgLVxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGFja3MgbmVlZGVkIGZyb20gd2F0Y2ggYmVmb3JlIHdlIGNhbiBjb25zaWRlciB0aGVcbiAgICAgKiBzZXJ2ZXIgdG8gYmUgJ2luLXN5bmMnIHdpdGggdGhlIGNsaWVudCdzIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAqL1xuICAgIHJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIHJlcXVlc3Qgd2UgZ2V0IHdlIG5lZWQgdG8gcmVjb3JkIHdlIG5lZWQgYSByZXNwb25zZSBmb3IgaXQuXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XG4gICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnRhcmdldFN0YXRlcy5nZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRhcmdldFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5zdXJlRG9jdW1lbnRUYXJnZXRNYXBwaW5nKGtleSkge1xuICAgICAgICBsZXQgdGFyZ2V0TWFwcGluZyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBwaW5nID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRhcmdldE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRNYXBwaW5nO1xuICAgIH1cbiAgICBlbnN1cmVEb2N1bWVudFVwZGF0ZUJ5VGFyZ2V0KGtleSkge1xuICAgICAgICBsZXQgdGFyZ2V0TWFwcGluZyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0LmdldChrZXkpO1xuICAgICAgICBpZiAoIXRhcmdldE1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRhcmdldE1hcHBpbmcgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzQnlUYXJnZXQgPVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0Lmluc2VydChrZXksIHRhcmdldE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSB1c2VyIGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhpcyB0YXJnZXQgKGJ5IGNhbGxpbmdcbiAgICAgKiBgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCgpYCkgYW5kIHRoYXQgd2UgYXJlIG5vdCB3YWl0aW5nIGZvciBwZW5kaW5nIEFERHNcbiAgICAgKiBmcm9tIHdhdGNoLlxuICAgICAqL1xuICAgIGlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEFjdGl2ZSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkgIT09IG51bGw7XG4gICAgICAgIGlmICghdGFyZ2V0QWN0aXZlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGcsICdEZXRlY3RlZCBpbmFjdGl2ZSB0YXJnZXQnLCB0YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldEFjdGl2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVGFyZ2V0RGF0YSBmb3IgYW4gYWN0aXZlIHRhcmdldCAoaS5lLiBhIHRhcmdldCB0aGF0IHRoZSB1c2VyXG4gICAgICogaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGF0IGhhcyBubyBvdXRzdGFuZGluZyB0YXJnZXQgY2hhbmdlIHJlcXVlc3RzKS5cbiAgICAgKi9cbiAgICB0YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlICYmIHRhcmdldFN0YXRlLmlzUGVuZGluZ1xuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiBhIFdhdGNoIHRhcmdldCB0byBpdHMgaW5pdGlhbCBzdGF0ZSAoZS5nLiBzZXRzXG4gICAgICogJ2N1cnJlbnQnIHRvIGZhbHNlLCBjbGVhcnMgdGhlIHJlc3VtZSB0b2tlbiBhbmQgcmVtb3ZlcyBpdHMgdGFyZ2V0IG1hcHBpbmdcbiAgICAgKiBmcm9tIGFsbCBkb2N1bWVudHMpLlxuICAgICAqL1xuICAgIHJlc2V0VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLnNldCh0YXJnZXRJZCwgbmV3IFRhcmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlbW92YWwgZm9yIGFueSBkb2N1bWVudHMgY3VycmVudGx5IG1hcHBlZCB0byB0aGlzIHRhcmdldC5cbiAgICAgICAgLy8gVGhlc2UgcmVtb3ZhbHMgd2lsbCBiZSBwYXJ0IG9mIHRoZSBpbml0aWFsIHNuYXBzaG90IGlmIFdhdGNoIGRvZXMgbm90XG4gICAgICAgIC8vIHJlc2VuZCB0aGVzZSBkb2N1bWVudHMuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgZXhpc3RpbmdLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIC8qdXBkYXRlZERvY3VtZW50PSovIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBMb2NhbFN0b3JlIGNvbnNpZGVycyB0aGUgZG9jdW1lbnQgdG8gYmUgcGFydCBvZiB0aGVcbiAgICAgKiBzcGVjaWZpZWQgdGFyZ2V0LlxuICAgICAqL1xuICAgIHRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0tleXMuaGFzKGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9jdW1lbnRUYXJnZXRNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG59XG5mdW5jdGlvbiBzbmFwc2hvdENoYW5nZXNNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG59XG5mdW5jdGlvbiBjcmVhdGVFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEluZm9Gb3JUZXN0aW5nSG9va3MobG9jYWxDYWNoZUNvdW50LCBleGlzdGVuY2VGaWx0ZXIsIGRhdGFiYXNlSWQsIGJsb29tRmlsdGVyLCBibG9vbUZpbHRlclN0YXR1cykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbG9jYWxDYWNoZUNvdW50LFxuICAgICAgICBleGlzdGVuY2VGaWx0ZXJDb3VudDogZXhpc3RlbmNlRmlsdGVyLmNvdW50LFxuICAgICAgICBkYXRhYmFzZUlkOiBkYXRhYmFzZUlkLmRhdGFiYXNlLFxuICAgICAgICBwcm9qZWN0SWQ6IGRhdGFiYXNlSWQucHJvamVjdElkXG4gICAgfTtcbiAgICBjb25zdCB1bmNoYW5nZWROYW1lcyA9IGV4aXN0ZW5jZUZpbHRlci51bmNoYW5nZWROYW1lcztcbiAgICBpZiAodW5jaGFuZ2VkTmFtZXMpIHtcbiAgICAgICAgcmVzdWx0LmJsb29tRmlsdGVyID0ge1xuICAgICAgICAgICAgYXBwbGllZDogYmxvb21GaWx0ZXJTdGF0dXMgPT09IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovLFxuICAgICAgICAgICAgaGFzaENvdW50OiAoX2EgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuaGFzaENvdW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgYml0bWFwTGVuZ3RoOiAoX2QgPSAoX2MgPSAoX2IgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuYml0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJpdG1hcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IChfZiA9IChfZSA9IHVuY2hhbmdlZE5hbWVzID09PSBudWxsIHx8IHVuY2hhbmdlZE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmNoYW5nZWROYW1lcy5iaXRzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucGFkZGluZykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMCxcbiAgICAgICAgICAgIG1pZ2h0Q29udGFpbjogKHZhbHVlKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGJsb29tRmlsdGVyID09PSBudWxsIHx8IGJsb29tRmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9vbUZpbHRlci5taWdodENvbnRhaW4odmFsdWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTsgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRElSRUNUSU9OUyA9ICgoKSA9PiB7XG4gICAgY29uc3QgZGlycyA9IHt9O1xuICAgIGRpcnNbXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXSA9ICdBU0NFTkRJTkcnO1xuICAgIGRpcnNbXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi9dID0gJ0RFU0NFTkRJTkcnO1xuICAgIHJldHVybiBkaXJzO1xufSkoKTtcbmNvbnN0IE9QRVJBVE9SUyA9ICgoKSA9PiB7XG4gICAgY29uc3Qgb3BzID0ge307XG4gICAgb3BzW1wiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqL10gPSAnTEVTU19USEFOJztcbiAgICBvcHNbXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqL10gPSAnTEVTU19USEFOX09SX0VRVUFMJztcbiAgICBvcHNbXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovXSA9ICdHUkVBVEVSX1RIQU4nO1xuICAgIG9wc1tcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovXSA9ICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnO1xuICAgIG9wc1tcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi9dID0gJ0VRVUFMJztcbiAgICBvcHNbXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqL10gPSAnTk9UX0VRVUFMJztcbiAgICBvcHNbXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovXSA9ICdBUlJBWV9DT05UQUlOUyc7XG4gICAgb3BzW1wiaW5cIiAvKiBPcGVyYXRvci5JTiAqL10gPSAnSU4nO1xuICAgIG9wc1tcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL10gPSAnTk9UX0lOJztcbiAgICBvcHNbXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi9dID0gJ0FSUkFZX0NPTlRBSU5TX0FOWSc7XG4gICAgcmV0dXJuIG9wcztcbn0pKCk7XG5jb25zdCBDT01QT1NJVEVfT1BFUkFUT1JTID0gKCgpID0+IHtcbiAgICBjb25zdCBvcHMgPSB7fTtcbiAgICBvcHNbXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi9dID0gJ0FORCc7XG4gICAgb3BzW1wib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqL10gPSAnT1InO1xuICAgIHJldHVybiBvcHM7XG59KSgpO1xuZnVuY3Rpb24gYXNzZXJ0UHJlc2VudCh2YWx1ZSwgZGVzY3JpcHRpb24pIHtcbn1cbi8qKlxuICogVGhpcyBjbGFzcyBnZW5lcmF0ZXMgSnNvbk9iamVjdCB2YWx1ZXMgZm9yIHRoZSBEYXRhc3RvcmUgQVBJIHN1aXRhYmxlIGZvclxuICogc2VuZGluZyB0byBlaXRoZXIgR1JQQyBzdHViIG1ldGhvZHMgb3IgdmlhIHRoZSBKU09OL0hUVFAgUkVTVCBBUEkuXG4gKlxuICogVGhlIHNlcmlhbGl6ZXIgc3VwcG9ydHMgYm90aCBQcm90b2J1Zi5qcyBhbmQgUHJvdG8zIEpTT04gZm9ybWF0cy4gQnlcbiAqIHNldHRpbmcgYHVzZVByb3RvM0pzb25gIHRvIHRydWUsIHRoZSBzZXJpYWxpemVyIHdpbGwgdXNlIHRoZSBQcm90bzMgSlNPTlxuICogZm9ybWF0LlxuICpcbiAqIEZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBQcm90bzMgSlNPTiBmb3JtYXQgY2hlY2tcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzMjanNvblxuICpcbiAqIFRPRE8oa2xpbXQpOiBXZSBjYW4gcmVtb3ZlIHRoZSBkYXRhYmFzZUlkIGFyZ3VtZW50IGlmIHdlIGtlZXAgdGhlIGZ1bGxcbiAqIHJlc291cmNlIG5hbWUgaW4gZG9jdW1lbnRzLlxuICovXG5jbGFzcyBKc29uUHJvdG9TZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCB1c2VQcm90bzNKc29uKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMudXNlUHJvdG8zSnNvbiA9IHVzZVByb3RvM0pzb247XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVJwY1N0YXR1cyhzdGF0dXMpIHtcbiAgICBjb25zdCBjb2RlID0gc3RhdHVzLmNvZGUgPT09IHVuZGVmaW5lZCA/IENvZGUuVU5LTk9XTiA6IG1hcENvZGVGcm9tUnBjQ29kZShzdGF0dXMuY29kZSk7XG4gICAgcmV0dXJuIG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBzdGF0dXMubWVzc2FnZSB8fCAnJyk7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgKG9yIG51bGwpIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50b1xuICogYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cbiAqIERPIE5PVCBVU0UgVEhJUyBGT1IgQU5ZVEhJTkcgRUxTRS5cbiAqIFRoaXMgbWV0aG9kIGNoZWF0cy4gSXQncyB0eXBlZCBhcyByZXR1cm5pbmcgXCJudW1iZXJcIiBiZWNhdXNlIHRoYXQncyB3aGF0XG4gKiBvdXIgZ2VuZXJhdGVkIHByb3RvIGludGVyZmFjZXMgc2F5IEludDMyVmFsdWUgbXVzdCBiZS4gQnV0IEdSUEMgYWN0dWFsbHlcbiAqIGV4cGVjdHMgYSB7IHZhbHVlOiA8bnVtYmVyPiB9IHN0cnVjdC5cbiAqL1xuZnVuY3Rpb24gdG9JbnQzMlByb3RvKHNlcmlhbGl6ZXIsIHZhbCkge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24gfHwgaXNOdWxsT3JVbmRlZmluZWQodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbCB9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciAob3IgbnVsbCkgZnJvbSBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIHByb3RvLlxuICovXG5mdW5jdGlvbiBmcm9tSW50MzJQcm90byh2YWwpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXN1bHQgPSB2YWwudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIGZvciBhIERhdGUgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXG4gKi9cbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIHRpbWVzdGFtcCkge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcbiAgICAgICAgLy8gU2VyaWFsaXplIHRvIElTTy04NjAxIGRhdGUgZm9ybWF0LCBidXQgd2l0aCBmdWxsIG5hbm8gcmVzb2x1dGlvbi5cbiAgICAgICAgLy8gU2luY2UgSlMgRGF0ZSBoYXMgb25seSBtaWxsaXMsIGxldCdzIG9ubHkgdXNlIGl0IGZvciB0aGUgc2Vjb25kcyBhbmRcbiAgICAgICAgLy8gdGhlbiBtYW51YWxseSBhZGQgdGhlIGZyYWN0aW9ucyB0byB0aGUgZW5kLlxuICAgICAgICBjb25zdCBqc0RhdGVTdHIgPSBuZXcgRGF0ZSh0aW1lc3RhbXAuc2Vjb25kcyAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIC8vIFJlbW92ZSAueHh4IGZyYWMgcGFydCBhbmQgWiBpbiB0aGUgZW5kLlxuICAgICAgICBjb25zdCBzdHJVbnRpbFNlY29uZHMgPSBqc0RhdGVTdHIucmVwbGFjZSgvXFwuXFxkKi8sICcnKS5yZXBsYWNlKCdaJywgJycpO1xuICAgICAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIG91dCB0byA5IGRpZ2l0cyAobmFub3MpLlxuICAgICAgICBjb25zdCBuYW5vU3RyID0gKCcwMDAwMDAwMDAnICsgdGltZXN0YW1wLm5hbm9zZWNvbmRzKS5zbGljZSgtOSk7XG4gICAgICAgIHJldHVybiBgJHtzdHJVbnRpbFNlY29uZHN9LiR7bmFub1N0cn1aYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWNvbmRzOiAnJyArIHRpbWVzdGFtcC5zZWNvbmRzLFxuICAgICAgICAgICAgbmFub3M6IHRpbWVzdGFtcC5uYW5vc2Vjb25kc1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tVGltZXN0YW1wKGRhdGUpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSk7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wLnNlY29uZHMsIHRpbWVzdGFtcC5uYW5vcyk7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYnl0ZXMgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbiBhIHByb3RvLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoc2VyaWFsaXplciwgYnl0ZXMpIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XG4gICAgICAgIHJldHVybiBieXRlcy50b0Jhc2U2NCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvVWludDhBcnJheSgpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEJ5dGVTdHJpbmcgYmFzZWQgb24gdGhlIHByb3RvIHN0cmluZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZnJvbUJ5dGVzKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcodmFsdWUgPyB2YWx1ZSA6ICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhhcmRBc3NlcnQodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGJvdGggQnVmZmVyIGFuZCBVaW50OEFycmF5LFxuICAgICAgICAgICAgLy8gZGVzcGl0ZSB0aGUgZmFjdCB0aGF0IEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXkuIEluIHNvbWVcbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50cywgc3VjaCBhcyBqc2RvbSwgdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBCdWZmZXJcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IGluZGljYXRlIHRoYXQgaXQgZXh0ZW5kcyBVaW50OEFycmF5LlxuICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIgfHxcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KHZhbHVlID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1ZlcnNpb24oc2VyaWFsaXplciwgdmVyc2lvbikge1xuICAgIHJldHVybiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB2ZXJzaW9uLnRvVGltZXN0YW1wKCkpO1xufVxuZnVuY3Rpb24gZnJvbVZlcnNpb24odmVyc2lvbikge1xuICAgIGhhcmRBc3NlcnQoISF2ZXJzaW9uKTtcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAoZnJvbVRpbWVzdGFtcCh2ZXJzaW9uKSk7XG59XG5mdW5jdGlvbiB0b1Jlc291cmNlTmFtZShkYXRhYmFzZUlkLCBwYXRoKSB7XG4gICAgcmV0dXJuIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHBhdGgpLmNhbm9uaWNhbFN0cmluZygpO1xufVxuZnVuY3Rpb24gdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcGF0aCkge1xuICAgIGNvbnN0IHJlc291cmNlUGF0aCA9IGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKS5jaGlsZCgnZG9jdW1lbnRzJyk7XG4gICAgcmV0dXJuIHBhdGggPT09IHVuZGVmaW5lZCA/IHJlc291cmNlUGF0aCA6IHJlc291cmNlUGF0aC5jaGlsZChwYXRoKTtcbn1cbmZ1bmN0aW9uIGZyb21SZXNvdXJjZU5hbWUobmFtZSkge1xuICAgIGNvbnN0IHJlc291cmNlID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcobmFtZSk7XG4gICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlKSk7XG4gICAgcmV0dXJuIHJlc291cmNlO1xufVxuZnVuY3Rpb24gdG9OYW1lKHNlcmlhbGl6ZXIsIGtleSkge1xuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIGtleS5wYXRoKTtcbn1cbmZ1bmN0aW9uIGZyb21OYW1lKHNlcmlhbGl6ZXIsIG5hbWUpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IGZyb21SZXNvdXJjZU5hbWUobmFtZSk7XG4gICAgaWYgKHJlc291cmNlLmdldCgxKSAhPT0gc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IHByb2plY3Q6ICcgK1xuICAgICAgICAgICAgcmVzb3VyY2UuZ2V0KDEpICtcbiAgICAgICAgICAgICcgdnMgJyArXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQucHJvamVjdElkKTtcbiAgICB9XG4gICAgaWYgKHJlc291cmNlLmdldCgzKSAhPT0gc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUcmllZCB0byBkZXNlcmlhbGl6ZSBrZXkgZnJvbSBkaWZmZXJlbnQgZGF0YWJhc2U6ICcgK1xuICAgICAgICAgICAgcmVzb3VyY2UuZ2V0KDMpICtcbiAgICAgICAgICAgICcgdnMgJyArXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlKSk7XG59XG5mdW5jdGlvbiB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXRoKSB7XG4gICAgcmV0dXJuIHRvUmVzb3VyY2VOYW1lKHNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgcGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tUXVlcnlQYXRoKG5hbWUpIHtcbiAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xuICAgIC8vIEluIHYxYmV0YTEgcXVlcmllcyBmb3IgY29sbGVjdGlvbnMgYXQgdGhlIHJvb3QgZGlkIG5vdCBoYXZlIGEgdHJhaWxpbmdcbiAgICAvLyBcIi9kb2N1bWVudHNcIi4gSW4gdjEgYWxsIHJlc291cmNlIHBhdGhzIGNvbnRhaW4gXCIvZG9jdW1lbnRzXCIuIFByZXNlcnZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gcmVhZCB0aGUgdjFiZXRhMSBmb3JtIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcXVlcmllcyBwZXJzaXN0ZWRcbiAgICAvLyBpbiB0aGUgbG9jYWwgdGFyZ2V0IGNhY2hlLlxuICAgIGlmIChyZXNvdXJjZU5hbWUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZU5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RlZERhdGFiYXNlSWQoc2VyaWFsaXplcikge1xuICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKFtcbiAgICAgICAgJ3Byb2plY3RzJyxcbiAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCxcbiAgICAgICAgJ2RhdGFiYXNlcycsXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZVxuICAgIF0pO1xuICAgIHJldHVybiBwYXRoLmNhbm9uaWNhbFN0cmluZygpO1xufVxuZnVuY3Rpb24gZnVsbHlRdWFsaWZpZWRQcmVmaXhQYXRoKGRhdGFiYXNlSWQpIHtcbiAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXG4gICAgICAgICdwcm9qZWN0cycsXG4gICAgICAgIGRhdGFiYXNlSWQucHJvamVjdElkLFxuICAgICAgICAnZGF0YWJhc2VzJyxcbiAgICAgICAgZGF0YWJhc2VJZC5kYXRhYmFzZVxuICAgIF0pO1xufVxuZnVuY3Rpb24gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKSB7XG4gICAgaGFyZEFzc2VydChyZXNvdXJjZU5hbWUubGVuZ3RoID4gNCAmJiByZXNvdXJjZU5hbWUuZ2V0KDQpID09PSAnZG9jdW1lbnRzJyk7XG4gICAgcmV0dXJuIHJlc291cmNlTmFtZS5wb3BGaXJzdCg1KTtcbn1cbi8qKiBDcmVhdGVzIGEgRG9jdW1lbnQgcHJvdG8gZnJvbSBrZXkgYW5kIGZpZWxkcyAoYnV0IG5vIGNyZWF0ZS91cGRhdGUgdGltZSkgKi9cbmZ1bmN0aW9uIHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBrZXksIGZpZWxkcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRvTmFtZShzZXJpYWxpemVyLCBrZXkpLFxuICAgICAgICBmaWVsZHM6IGZpZWxkcy52YWx1ZS5tYXBWYWx1ZS5maWVsZHNcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Eb2N1bWVudChzZXJpYWxpemVyLCBkb2N1bWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRvTmFtZShzZXJpYWxpemVyLCBkb2N1bWVudC5rZXkpLFxuICAgICAgICBmaWVsZHM6IGRvY3VtZW50LmRhdGEudmFsdWUubWFwVmFsdWUuZmllbGRzLFxuICAgICAgICB1cGRhdGVUaW1lOiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCBkb2N1bWVudC52ZXJzaW9uLnRvVGltZXN0YW1wKCkpLFxuICAgICAgICBjcmVhdGVUaW1lOiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCBkb2N1bWVudC5jcmVhdGVUaW1lLnRvVGltZXN0YW1wKCkpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudChzZXJpYWxpemVyLCBkb2N1bWVudCwgaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQubmFtZSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgIC8vIElmIHdlIHJlYWQgYSBkb2N1bWVudCBmcm9tIHBlcnNpc3RlbmNlIHRoYXQgaXMgbWlzc2luZyBjcmVhdGVUaW1lLCBpdCdzIGR1ZVxuICAgIC8vIHRvIG9sZGVyIFNESyB2ZXJzaW9ucyBub3Qgc3RvcmluZyB0aGlzIGluZm9ybWF0aW9uLiBJbiBzdWNoIGNhc2VzLCB3ZSdsbFxuICAgIC8vIHNldCB0aGUgY3JlYXRlVGltZSB0byB6ZXJvLiBUaGlzIGNhbiBiZSByZW1vdmVkIGluIHRoZSBsb25nIHRlcm0uXG4gICAgY29uc3QgY3JlYXRlVGltZSA9IGRvY3VtZW50LmNyZWF0ZVRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihkb2N1bWVudC5jcmVhdGVUaW1lKVxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2N1bWVudC5maWVsZHMgfSB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xuICAgIGlmIChoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ29tbWl0dGVkTXV0YXRpb25zID8gcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIGRvYykge1xuICAgIGhhcmRBc3NlcnQoISFkb2MuZm91bmQpO1xuICAgIGFzc2VydFByZXNlbnQoZG9jLmZvdW5kLm5hbWUpO1xuICAgIGFzc2VydFByZXNlbnQoZG9jLmZvdW5kLnVwZGF0ZVRpbWUpO1xuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvYy5mb3VuZC5uYW1lKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZG9jLmZvdW5kLnVwZGF0ZVRpbWUpO1xuICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBkb2MuZm91bmQuY3JlYXRlVGltZVxuICAgICAgICA/IGZyb21WZXJzaW9uKGRvYy5mb3VuZC5jcmVhdGVUaW1lKVxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2MuZm91bmQuZmllbGRzIH0gfSk7XG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpIHtcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0Lm1pc3NpbmcpO1xuICAgIGhhcmRBc3NlcnQoISFyZXN1bHQucmVhZFRpbWUpO1xuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHJlc3VsdC5taXNzaW5nKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzdWx0LnJlYWRUaW1lKTtcbiAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCB2ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xuICAgIGlmICgnZm91bmQnIGluIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtaXNzaW5nJyBpbiByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21NaXNzaW5nKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmYWlsKCk7XG59XG5mdW5jdGlvbiBmcm9tV2F0Y2hDaGFuZ2Uoc2VyaWFsaXplciwgY2hhbmdlKSB7XG4gICAgbGV0IHdhdGNoQ2hhbmdlO1xuICAgIGlmICgndGFyZ2V0Q2hhbmdlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UudGFyZ2V0Q2hhbmdlKTtcbiAgICAgICAgLy8gcHJvdG8zIGRlZmF1bHQgdmFsdWUgaXMgdW5zZXQgaW4gSlNPTiAodW5kZWZpbmVkKSwgc28gdXNlICdOT19DSEFOR0UnXG4gICAgICAgIC8vIGlmIHVuc2V0XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRDaGFuZ2VUeXBlIHx8ICdOT19DSEFOR0UnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzID0gY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRJZHMgfHwgW107XG4gICAgICAgIGNvbnN0IHJlc3VtZVRva2VuID0gZnJvbUJ5dGVzKHNlcmlhbGl6ZXIsIGNoYW5nZS50YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICBjb25zdCBjYXVzZVByb3RvID0gY2hhbmdlLnRhcmdldENoYW5nZS5jYXVzZTtcbiAgICAgICAgY29uc3QgY2F1c2UgPSBjYXVzZVByb3RvICYmIGZyb21ScGNTdGF0dXMoY2F1c2VQcm90byk7XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IFdhdGNoVGFyZ2V0Q2hhbmdlKHN0YXRlLCB0YXJnZXRJZHMsIHJlc3VtZVRva2VuLCBjYXVzZSB8fCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50Q2hhbmdlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICBjb25zdCBlbnRpdHlDaGFuZ2UgPSBjaGFuZ2UuZG9jdW1lbnRDaGFuZ2U7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50KTtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQubmFtZSk7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQubmFtZSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihlbnRpdHlDaGFuZ2UuZG9jdW1lbnQudXBkYXRlVGltZSk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuY3JlYXRlVGltZVxuICAgICAgICAgICAgPyBmcm9tVmVyc2lvbihlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuY3JlYXRlVGltZSlcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHtcbiAgICAgICAgICAgIG1hcFZhbHVlOiB7IGZpZWxkczogZW50aXR5Q2hhbmdlLmRvY3VtZW50LmZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xuICAgICAgICBjb25zdCB1cGRhdGVkVGFyZ2V0SWRzID0gZW50aXR5Q2hhbmdlLnRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKHVwZGF0ZWRUYXJnZXRJZHMsIHJlbW92ZWRUYXJnZXRJZHMsIGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudERlbGV0ZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50RGVsZXRlKTtcbiAgICAgICAgY29uc3QgZG9jRGVsZXRlID0gY2hhbmdlLmRvY3VtZW50RGVsZXRlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY0RlbGV0ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY0RlbGV0ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBkb2NEZWxldGUucmVhZFRpbWVcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZG9jRGVsZXRlLnJlYWRUaW1lKVxuICAgICAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIGNvbnN0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NEZWxldGUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywgZG9jLmtleSwgZG9jKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50UmVtb3ZlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRSZW1vdmUpO1xuICAgICAgICBjb25zdCBkb2NSZW1vdmUgPSBjaGFuZ2UuZG9jdW1lbnRSZW1vdmU7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZG9jUmVtb3ZlLmRvY3VtZW50KTtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jUmVtb3ZlLmRvY3VtZW50KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGRvY1JlbW92ZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBrZXksIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZmlsdGVyJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBpbXBsZW1lbnQgZXhpc3RlbmNlIGZpbHRlciBwYXJzaW5nIHdpdGggc3RyYXRlZ3kuXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmZpbHRlcik7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNoYW5nZS5maWx0ZXI7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZmlsdGVyLnRhcmdldElkKTtcbiAgICAgICAgY29uc3QgeyBjb3VudCA9IDAsIHVuY2hhbmdlZE5hbWVzIH0gPSBmaWx0ZXI7XG4gICAgICAgIGNvbnN0IGV4aXN0ZW5jZUZpbHRlciA9IG5ldyBFeGlzdGVuY2VGaWx0ZXIoY291bnQsIHVuY2hhbmdlZE5hbWVzKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBmaWx0ZXIudGFyZ2V0SWQ7XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IEV4aXN0ZW5jZUZpbHRlckNoYW5nZSh0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxuICAgIHJldHVybiB3YXRjaENoYW5nZTtcbn1cbmZ1bmN0aW9uIGZyb21XYXRjaFRhcmdldENoYW5nZVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSAnTk9fQ0hBTkdFJykge1xuICAgICAgICByZXR1cm4gMCAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLk5vQ2hhbmdlICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ0FERCcpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdSRU1PVkUnKSB7XG4gICAgICAgIHJldHVybiAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdDVVJSRU5UJykge1xuICAgICAgICByZXR1cm4gMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVTRVQnKSB7XG4gICAgICAgIHJldHVybiA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZlcnNpb25Gcm9tTGlzdGVuUmVzcG9uc2UoY2hhbmdlKSB7XG4gICAgLy8gV2UgaGF2ZSBvbmx5IHJlYWNoZWQgYSBjb25zaXN0ZW50IHNuYXBzaG90IGZvciB0aGUgZW50aXJlIHN0cmVhbSBpZiB0aGVyZVxuICAgIC8vIGlzIGEgcmVhZF90aW1lIHNldCBhbmQgaXQgYXBwbGllcyB0byBhbGwgdGFyZ2V0cyAoaS5lLiB0aGUgbGlzdCBvZlxuICAgIC8vIHRhcmdldHMgaXMgZW1wdHkpLiBUaGUgYmFja2VuZCBpcyBndWFyYW50ZWVkIHRvIHNlbmQgc3VjaCByZXNwb25zZXMuXG4gICAgaWYgKCEoJ3RhcmdldENoYW5nZScgaW4gY2hhbmdlKSkge1xuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSBjaGFuZ2UudGFyZ2V0Q2hhbmdlO1xuICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzICYmIHRhcmdldENoYW5nZS50YXJnZXRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgfVxuICAgIGlmICghdGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKSB7XG4gICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tVmVyc2lvbih0YXJnZXRDaGFuZ2UucmVhZFRpbWUpO1xufVxuZnVuY3Rpb24gdG9NdXRhdGlvbihzZXJpYWxpemVyLCBtdXRhdGlvbikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBEZWxldGVNdXRhdGlvbikge1xuICAgICAgICByZXN1bHQgPSB7IGRlbGV0ZTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHVwZGF0ZTogdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSwgbXV0YXRpb24uZGF0YSksXG4gICAgICAgICAgICB1cGRhdGVNYXNrOiB0b0RvY3VtZW50TWFzayhtdXRhdGlvbi5maWVsZE1hc2spXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgVmVyaWZ5TXV0YXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0b05hbWUoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC51cGRhdGVUcmFuc2Zvcm1zID0gbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgaWYgKCFtdXRhdGlvbi5wcmVjb25kaXRpb24uaXNOb25lKSB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50RG9jdW1lbnQgPSB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBtdXRhdGlvbi5wcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbU11dGF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvKSB7XG4gICAgY29uc3QgcHJlY29uZGl0aW9uID0gcHJvdG8uY3VycmVudERvY3VtZW50XG4gICAgICAgID8gZnJvbVByZWNvbmRpdGlvbihwcm90by5jdXJyZW50RG9jdW1lbnQpXG4gICAgICAgIDogUHJlY29uZGl0aW9uLm5vbmUoKTtcbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybXMgPSBwcm90by51cGRhdGVUcmFuc2Zvcm1zXG4gICAgICAgID8gcHJvdG8udXBkYXRlVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKVxuICAgICAgICA6IFtdO1xuICAgIGlmIChwcm90by51cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChwcm90by51cGRhdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnVwZGF0ZS5uYW1lKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgT2JqZWN0VmFsdWUoe1xuICAgICAgICAgICAgbWFwVmFsdWU6IHsgZmllbGRzOiBwcm90by51cGRhdGUuZmllbGRzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm90by51cGRhdGVNYXNrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE1hc2sgPSBmcm9tRG9jdW1lbnRNYXNrKHByb3RvLnVwZGF0ZU1hc2spO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdmFsdWUsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHZhbHVlLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdG8uZGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLmRlbGV0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm90by52ZXJpZnkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udmVyaWZ5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvUHJlY29uZGl0aW9uKHNlcmlhbGl6ZXIsIHByZWNvbmRpdGlvbikge1xuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cGRhdGVUaW1lOiB0b1ZlcnNpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBleGlzdHM6IHByZWNvbmRpdGlvbi5leGlzdHMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVByZWNvbmRpdGlvbihwcmVjb25kaXRpb24pIHtcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUoZnJvbVZlcnNpb24ocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKHByZWNvbmRpdGlvbi5leGlzdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVdyaXRlUmVzdWx0KHByb3RvLCBjb21taXRUaW1lKSB7XG4gICAgLy8gTk9URTogRGVsZXRlcyBkb24ndCBoYXZlIGFuIHVwZGF0ZVRpbWUuXG4gICAgbGV0IHZlcnNpb24gPSBwcm90by51cGRhdGVUaW1lXG4gICAgICAgID8gZnJvbVZlcnNpb24ocHJvdG8udXBkYXRlVGltZSlcbiAgICAgICAgOiBmcm9tVmVyc2lvbihjb21taXRUaW1lKTtcbiAgICBpZiAodmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgLy8gVGhlIEZpcmVzdG9yZSBFbXVsYXRvciBjdXJyZW50bHkgcmV0dXJucyBhbiB1cGRhdGUgdGltZSBvZiAwIGZvclxuICAgICAgICAvLyBkZWxldGVzIG9mIG5vbi1leGlzdGluZyBkb2N1bWVudHMgKHJhdGhlciB0aGFuIG51bGwpLiBUaGlzIGJyZWFrcyB0aGVcbiAgICAgICAgLy8gdGVzdCBcImdldCBkZWxldGVkIGRvYyB3aGlsZSBvZmZsaW5lIHdpdGggc291cmNlPWNhY2hlXCIgYXMgTm9Eb2N1bWVudHNcbiAgICAgICAgLy8gd2l0aCB2ZXJzaW9uIDAgYXJlIGZpbHRlcmVkIGJ5IEluZGV4ZWREYidzIFJlbW90ZURvY3VtZW50Q2FjaGUuXG4gICAgICAgIC8vIFRPRE8oIzIxNDkpOiBSZW1vdmUgdGhpcyB3aGVuIEVtdWxhdG9yIGlzIGZpeGVkXG4gICAgICAgIHZlcnNpb24gPSBmcm9tVmVyc2lvbihjb21taXRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdXRhdGlvblJlc3VsdCh2ZXJzaW9uLCBwcm90by50cmFuc2Zvcm1SZXN1bHRzIHx8IFtdKTtcbn1cbmZ1bmN0aW9uIGZyb21Xcml0ZVJlc3VsdHMocHJvdG9zLCBjb21taXRUaW1lKSB7XG4gICAgaWYgKHByb3RvcyAmJiBwcm90b3MubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXJkQXNzZXJ0KGNvbW1pdFRpbWUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBwcm90b3MubWFwKHByb3RvID0+IGZyb21Xcml0ZVJlc3VsdChwcm90bywgY29tbWl0VGltZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgZmllbGRUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcbiAgICAgICAgICAgIHNldFRvU2VydmVyVmFsdWU6ICdSRVFVRVNUX1RJTUUnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICBhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRQYXRoOiBmaWVsZFRyYW5zZm9ybS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSxcbiAgICAgICAgICAgIHJlbW92ZUFsbEZyb21BcnJheToge1xuICAgICAgICAgICAgICAgIHZhbHVlczogdHJhbnNmb3JtLmVsZW1lbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICBpbmNyZW1lbnQ6IHRyYW5zZm9ybS5vcGVyYW5kXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbUZpZWxkVHJhbnNmb3JtKHNlcmlhbGl6ZXIsIHByb3RvKSB7XG4gICAgbGV0IHRyYW5zZm9ybSA9IG51bGw7XG4gICAgaWYgKCdzZXRUb1NlcnZlclZhbHVlJyBpbiBwcm90bykge1xuICAgICAgICBoYXJkQXNzZXJ0KHByb3RvLnNldFRvU2VydmVyVmFsdWUgPT09ICdSRVFVRVNUX1RJTUUnKTtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYXBwZW5kTWlzc2luZ0VsZW1lbnRzJyBpbiBwcm90bykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm90by5hcHBlbmRNaXNzaW5nRWxlbWVudHMudmFsdWVzIHx8IFtdO1xuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbih2YWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVtb3ZlQWxsRnJvbUFycmF5JyBpbiBwcm90bykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm90by5yZW1vdmVBbGxGcm9tQXJyYXkudmFsdWVzIHx8IFtdO1xuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2luY3JlbWVudCcgaW4gcHJvdG8pIHtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24oc2VyaWFsaXplciwgcHJvdG8uaW5jcmVtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRQYXRoID0gRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChwcm90by5maWVsZFBhdGgpO1xuICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oZmllbGRQYXRoLCB0cmFuc2Zvcm0pO1xufVxuZnVuY3Rpb24gdG9Eb2N1bWVudHNUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHsgZG9jdW1lbnRzOiBbdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgdGFyZ2V0LnBhdGgpXSB9O1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50c1RhcmdldChkb2N1bWVudHNUYXJnZXQpIHtcbiAgICBjb25zdCBjb3VudCA9IGRvY3VtZW50c1RhcmdldC5kb2N1bWVudHMubGVuZ3RoO1xuICAgIGhhcmRBc3NlcnQoY291bnQgPT09IDEpO1xuICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzWzBdO1xuICAgIHJldHVybiBxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChmcm9tUXVlcnlQYXRoKG5hbWUpKSk7XG59XG5mdW5jdGlvbiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xuICAgIC8vIERpc3NlY3QgdGhlIHBhdGggaW50byBwYXJlbnQsIGNvbGxlY3Rpb25JZCwgYW5kIG9wdGlvbmFsIGtleSBmaWx0ZXIuXG4gICAgY29uc3QgcXVlcnlUYXJnZXQgPSB7IHN0cnVjdHVyZWRRdWVyeToge30gfTtcbiAgICBjb25zdCBwYXRoID0gdGFyZ2V0LnBhdGg7XG4gICAgbGV0IHBhcmVudDtcbiAgICBpZiAodGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQgPSBwYXRoO1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZnJvbSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgICAgICAgICAgYWxsRGVzY2VuZGFudHM6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZnJvbSA9IFt7IGNvbGxlY3Rpb25JZDogcGF0aC5sYXN0U2VnbWVudCgpIH1dO1xuICAgIH1cbiAgICBxdWVyeVRhcmdldC5wYXJlbnQgPSB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXJlbnQpO1xuICAgIGNvbnN0IHdoZXJlID0gdG9GaWx0ZXJzKHRhcmdldC5maWx0ZXJzKTtcbiAgICBpZiAod2hlcmUpIHtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LndoZXJlID0gd2hlcmU7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyQnkgPSB0b09yZGVyKHRhcmdldC5vcmRlckJ5KTtcbiAgICBpZiAob3JkZXJCeSkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdG9JbnQzMlByb3RvKHNlcmlhbGl6ZXIsIHRhcmdldC5saW1pdCk7XG4gICAgaWYgKGxpbWl0ICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5saW1pdCA9IGxpbWl0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnN0YXJ0QXQpIHtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LnN0YXJ0QXQgPSB0b1N0YXJ0QXRDdXJzb3IodGFyZ2V0LnN0YXJ0QXQpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LmVuZEF0KSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5lbmRBdCA9IHRvRW5kQXRDdXJzb3IodGFyZ2V0LmVuZEF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcXVlcnlUYXJnZXQsIHBhcmVudCB9O1xufVxuZnVuY3Rpb24gdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChzZXJpYWxpemVyLCB0YXJnZXQsIGFnZ3JlZ2F0ZXMsIHNraXBBbGlhc2luZykge1xuICAgIGNvbnN0IHsgcXVlcnlUYXJnZXQsIHBhcmVudCB9ID0gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpO1xuICAgIGNvbnN0IGFsaWFzTWFwID0ge307XG4gICAgY29uc3QgYWdncmVnYXRpb25zID0gW107XG4gICAgbGV0IGFnZ3JlZ2F0aW9uTnVtID0gMDtcbiAgICBhZ2dyZWdhdGVzLmZvckVhY2goYWdncmVnYXRlID0+IHtcbiAgICAgICAgLy8gTWFwIGFsbCBjbGllbnQtc2lkZSBhbGlhc2VzIHRvIGEgdW5pcXVlIHNob3J0LWZvcm1cbiAgICAgICAgLy8gYWxpYXMuIFRoaXMgYXZvaWRzIGlzc3VlcyB3aXRoIGNsaWVudC1zaWRlIGFsaWFzZXMgdGhhdFxuICAgICAgICAvLyBleGNlZWQgdGhlIDE1MDAtYnl0ZSBzdHJpbmcgc2l6ZSBsaW1pdC5cbiAgICAgICAgY29uc3Qgc2VydmVyQWxpYXMgPSBza2lwQWxpYXNpbmdcbiAgICAgICAgICAgID8gYWdncmVnYXRlLmFsaWFzXG4gICAgICAgICAgICA6IGBhZ2dyZWdhdGVfJHthZ2dyZWdhdGlvbk51bSsrfWA7XG4gICAgICAgIGFsaWFzTWFwW3NlcnZlckFsaWFzXSA9IGFnZ3JlZ2F0ZS5hbGlhcztcbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlID09PSAnY291bnQnKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxuICAgICAgICAgICAgICAgIGNvdW50OiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxuICAgICAgICAgICAgICAgIGF2Zzoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoYWdncmVnYXRlLmZpZWxkUGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhbGlhczogc2VydmVyQWxpYXMsXG4gICAgICAgICAgICAgICAgc3VtOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShhZ2dyZWdhdGUuZmllbGRQYXRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgc3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnk6IHtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJlbnQ6IHF1ZXJ5VGFyZ2V0LnBhcmVudFxuICAgICAgICB9LFxuICAgICAgICBhbGlhc01hcCxcbiAgICAgICAgcGFyZW50XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XG4gICAgbGV0IHBhdGggPSBmcm9tUXVlcnlQYXRoKHRhcmdldC5wYXJlbnQpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGFyZ2V0LnN0cnVjdHVyZWRRdWVyeTtcbiAgICBjb25zdCBmcm9tQ291bnQgPSBxdWVyeS5mcm9tID8gcXVlcnkuZnJvbS5sZW5ndGggOiAwO1xuICAgIGxldCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsO1xuICAgIGlmIChmcm9tQ291bnQgPiAwKSB7XG4gICAgICAgIGhhcmRBc3NlcnQoZnJvbUNvdW50ID09PSAxKTtcbiAgICAgICAgY29uc3QgZnJvbSA9IHF1ZXJ5LmZyb21bMF07XG4gICAgICAgIGlmIChmcm9tLmFsbERlc2NlbmRhbnRzKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uR3JvdXAgPSBmcm9tLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkKGZyb20uY29sbGVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnkgPSBbXTtcbiAgICBpZiAocXVlcnkud2hlcmUpIHtcbiAgICAgICAgZmlsdGVyQnkgPSBmcm9tRmlsdGVycyhxdWVyeS53aGVyZSk7XG4gICAgfVxuICAgIGxldCBvcmRlckJ5ID0gW107XG4gICAgaWYgKHF1ZXJ5Lm9yZGVyQnkpIHtcbiAgICAgICAgb3JkZXJCeSA9IGZyb21PcmRlcihxdWVyeS5vcmRlckJ5KTtcbiAgICB9XG4gICAgbGV0IGxpbWl0ID0gbnVsbDtcbiAgICBpZiAocXVlcnkubGltaXQpIHtcbiAgICAgICAgbGltaXQgPSBmcm9tSW50MzJQcm90byhxdWVyeS5saW1pdCk7XG4gICAgfVxuICAgIGxldCBzdGFydEF0ID0gbnVsbDtcbiAgICBpZiAocXVlcnkuc3RhcnRBdCkge1xuICAgICAgICBzdGFydEF0ID0gZnJvbVN0YXJ0QXRDdXJzb3IocXVlcnkuc3RhcnRBdCk7XG4gICAgfVxuICAgIGxldCBlbmRBdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LmVuZEF0KSB7XG4gICAgICAgIGVuZEF0ID0gZnJvbUVuZEF0Q3Vyc29yKHF1ZXJ5LmVuZEF0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeSwgZmlsdGVyQnksIGxpbWl0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8sIHN0YXJ0QXQsIGVuZEF0KTtcbn1cbmZ1bmN0aW9uIGZyb21RdWVyeVRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHRhcmdldCkpO1xufVxuZnVuY3Rpb24gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRvTGFiZWwodGFyZ2V0RGF0YS5wdXJwb3NlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZ29vZy1saXN0ZW4tdGFncyc6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9MYWJlbChwdXJwb3NlKSB7XG4gICAgc3dpdGNoIChwdXJwb3NlKSB7XG4gICAgICAgIGNhc2UgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi86XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaFwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi86XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXN0ZW5jZS1maWx0ZXItbWlzbWF0Y2gnO1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb21cIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb20gKi86XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXN0ZW5jZS1maWx0ZXItbWlzbWF0Y2gtYmxvb20nO1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuICdsaW1iby1kb2N1bWVudCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldERhdGEudGFyZ2V0O1xuICAgIGlmICh0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgcmVzdWx0ID0geyBkb2N1bWVudHM6IHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHsgcXVlcnk6IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KS5xdWVyeVRhcmdldCB9O1xuICAgIH1cbiAgICByZXN1bHQudGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgIGlmICh0YXJnZXREYXRhLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgcmVzdWx0LnJlc3VtZVRva2VuID0gdG9CeXRlcyhzZXJpYWxpemVyLCB0YXJnZXREYXRhLnJlc3VtZVRva2VuKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXREYXRhLmV4cGVjdGVkQ291bnQpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRDb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhTbmFwc2hvdFZlcnNpb24ubWluKCkpID4gMCkge1xuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IENvbnNpZGVyIHJlbW92aW5nIGFib3ZlIGNoZWNrIGJlY2F1c2UgaXQgaXMgbW9zdCBsaWtlbHkgdHJ1ZS5cbiAgICAgICAgLy8gUmlnaHQgbm93LCBtYW55IHRlc3RzIGRlcGVuZCBvbiB0aGlzIGJlaGF2aW91ciB0aG91Z2ggKGxlYXZpbmcgbWluKCkgb3V0XG4gICAgICAgIC8vIG9mIHNlcmlhbGl6YXRpb24pLlxuICAgICAgICByZXN1bHQucmVhZFRpbWUgPSB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXREYXRhLmV4cGVjdGVkQ291bnQpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRDb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b0ZpbHRlcnMoZmlsdGVycykge1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0b0ZpbHRlcihDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKGZpbHRlcnMsIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovKSk7XG59XG5mdW5jdGlvbiBmcm9tRmlsdGVycyhmaWx0ZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBmcm9tRmlsdGVyKGZpbHRlcik7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciAmJlxuICAgICAgICBjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuZ2V0RmlsdGVycygpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3VsdF07XG59XG5mdW5jdGlvbiBmcm9tRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIudW5hcnlGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbVVuYXJ5RmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5maWVsZEZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyLmNvbXBvc2l0ZUZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmcm9tQ29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvT3JkZXIob3JkZXJCeXMpIHtcbiAgICBpZiAob3JkZXJCeXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyQnlzLm1hcChvcmRlciA9PiB0b1Byb3BlcnR5T3JkZXIob3JkZXIpKTtcbn1cbmZ1bmN0aW9uIGZyb21PcmRlcihvcmRlckJ5cykge1xuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gZnJvbVByb3BlcnR5T3JkZXIob3JkZXIpKTtcbn1cbmZ1bmN0aW9uIHRvU3RhcnRBdEN1cnNvcihjdXJzb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiZWZvcmU6IGN1cnNvci5pbmNsdXNpdmUsXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvRW5kQXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiAhY3Vyc29yLmluY2x1c2l2ZSxcbiAgICAgICAgdmFsdWVzOiBjdXJzb3IucG9zaXRpb25cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVN0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgY29uc3QgaW5jbHVzaXZlID0gISFjdXJzb3IuYmVmb3JlO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnZhbHVlcyB8fCBbXTtcbiAgICByZXR1cm4gbmV3IEJvdW5kKHBvc2l0aW9uLCBpbmNsdXNpdmUpO1xufVxuZnVuY3Rpb24gZnJvbUVuZEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIGNvbnN0IGluY2x1c2l2ZSA9ICFjdXJzb3IuYmVmb3JlO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnZhbHVlcyB8fCBbXTtcbiAgICByZXR1cm4gbmV3IEJvdW5kKHBvc2l0aW9uLCBpbmNsdXNpdmUpO1xufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9EaXJlY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTlNbZGlyXTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIGZyb21EaXJlY3Rpb24oZGlyKSB7XG4gICAgc3dpdGNoIChkaXIpIHtcbiAgICAgICAgY2FzZSAnQVNDRU5ESU5HJzpcbiAgICAgICAgICAgIHJldHVybiBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi87XG4gICAgICAgIGNhc2UgJ0RFU0NFTkRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiB0b09wZXJhdG9yTmFtZShvcCkge1xuICAgIHJldHVybiBPUEVSQVRPUlNbb3BdO1xufVxuZnVuY3Rpb24gdG9Db21wb3NpdGVPcGVyYXRvck5hbWUob3ApIHtcbiAgICByZXR1cm4gQ09NUE9TSVRFX09QRVJBVE9SU1tvcF07XG59XG5mdW5jdGlvbiBmcm9tT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICdFUVVBTCc6XG4gICAgICAgICAgICByZXR1cm4gXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovO1xuICAgICAgICBjYXNlICdOT1RfRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi87XG4gICAgICAgIGNhc2UgJ0dSRUFURVJfVEhBTic6XG4gICAgICAgICAgICByZXR1cm4gXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovO1xuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi87XG4gICAgICAgIGNhc2UgJ0xFU1NfVEhBTic6XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovO1xuICAgICAgICBjYXNlICdMRVNTX1RIQU5fT1JfRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi87XG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TJzpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi87XG4gICAgICAgIGNhc2UgJ0lOJzpcbiAgICAgICAgICAgIHJldHVybiBcImluXCIgLyogT3BlcmF0b3IuSU4gKi87XG4gICAgICAgIGNhc2UgJ05PVF9JTic6XG4gICAgICAgICAgICByZXR1cm4gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi87XG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TX0FOWSc6XG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XG4gICAgICAgIGNhc2UgJ09QRVJBVE9SX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVPcGVyYXRvck5hbWUob3ApIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi87XG4gICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvRmllbGRQYXRoUmVmZXJlbmNlKHBhdGgpIHtcbiAgICByZXR1cm4geyBmaWVsZFBhdGg6IHBhdGguY2Fub25pY2FsU3RyaW5nKCkgfTtcbn1cbmZ1bmN0aW9uIGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmllbGRSZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChmaWVsZFJlZmVyZW5jZS5maWVsZFBhdGgpO1xufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyQnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksXG4gICAgICAgIGRpcmVjdGlvbjogdG9EaXJlY3Rpb24ob3JkZXJCeS5kaXIpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyQnkpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyQnkoZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShvcmRlckJ5LmZpZWxkKSwgZnJvbURpcmVjdGlvbihvcmRlckJ5LmRpcmVjdGlvbikpO1xufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9GaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0b1VuYXJ5T3JGaWVsZEZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQ29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ29tcG9zaXRlRmlsdGVyKGZpbHRlcikge1xuICAgIGNvbnN0IHByb3RvcyA9IGZpbHRlci5nZXRGaWx0ZXJzKCkubWFwKGZpbHRlciA9PiB0b0ZpbHRlcihmaWx0ZXIpKTtcbiAgICBpZiAocHJvdG9zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcHJvdG9zWzBdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb3NpdGVGaWx0ZXI6IHtcbiAgICAgICAgICAgIG9wOiB0b0NvbXBvc2l0ZU9wZXJhdG9yTmFtZShmaWx0ZXIub3ApLFxuICAgICAgICAgICAgZmlsdGVyczogcHJvdG9zXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gdG9VbmFyeU9yRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlci5vcCA9PT0gXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovKSB7XG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTkFOJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsVmFsdWUoZmlsdGVyLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OVUxMJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyLm9wID09PSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovKSB7XG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTk9UX05BTidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTk9UX05VTEwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZEZpbHRlcjoge1xuICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICBvcDogdG9PcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcbiAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXIudmFsdWVcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tVW5hcnlGaWx0ZXIoZmlsdGVyKSB7XG4gICAgc3dpdGNoIChmaWx0ZXIudW5hcnlGaWx0ZXIub3ApIHtcbiAgICAgICAgY2FzZSAnSVNfTkFOJzpcbiAgICAgICAgICAgIGNvbnN0IG5hbkZpZWxkID0gZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIudW5hcnlGaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShuYW5GaWVsZCwgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05VTEwnOlxuICAgICAgICAgICAgY29uc3QgbnVsbEZpZWxkID0gZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIudW5hcnlGaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShudWxsRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xuICAgICAgICAgICAgICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnSVNfTk9UX05BTic6XG4gICAgICAgICAgICBjb25zdCBub3ROYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TmFuRmllbGQsIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIHtcbiAgICAgICAgICAgICAgICBkb3VibGVWYWx1ZTogTmFOXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnSVNfTk9UX05VTEwnOlxuICAgICAgICAgICAgY29uc3Qgbm90TnVsbEZpZWxkID0gZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIudW5hcnlGaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShub3ROdWxsRmllbGQsIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIHtcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ09QRVJBVE9SX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21GaWVsZEZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkRmlsdGVyLmZpZWxkKSwgZnJvbU9wZXJhdG9yTmFtZShmaWx0ZXIuZmllbGRGaWx0ZXIub3ApLCBmaWx0ZXIuZmllbGRGaWx0ZXIudmFsdWUpO1xufVxuZnVuY3Rpb24gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBmcm9tRmlsdGVyKGZpbHRlcikpLCBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIub3ApKTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnRNYXNrKGZpZWxkTWFzaykge1xuICAgIGNvbnN0IGNhbm9uaWNhbEZpZWxkcyA9IFtdO1xuICAgIGZpZWxkTWFzay5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjYW5vbmljYWxGaWVsZHMucHVzaChmaWVsZC5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpZWxkUGF0aHM6IGNhbm9uaWNhbEZpZWxkc1xuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRNYXNrKHByb3RvKSB7XG4gICAgY29uc3QgcGF0aHMgPSBwcm90by5maWVsZFBhdGhzIHx8IFtdO1xuICAgIHJldHVybiBuZXcgRmllbGRNYXNrKHBhdGhzLm1hcChwYXRoID0+IEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQocGF0aCkpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRSZXNvdXJjZU5hbWUocGF0aCkge1xuICAgIC8vIFJlc291cmNlIG5hbWVzIGhhdmUgYXQgbGVhc3QgNCBjb21wb25lbnRzIChwcm9qZWN0IElELCBkYXRhYmFzZSBJRClcbiAgICByZXR1cm4gKHBhdGgubGVuZ3RoID49IDQgJiZcbiAgICAgICAgcGF0aC5nZXQoMCkgPT09ICdwcm9qZWN0cycgJiZcbiAgICAgICAgcGF0aC5nZXQoMikgPT09ICdkYXRhYmFzZXMnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW1tdXRhYmxlIHNldCBvZiBtZXRhZGF0YSB0aGF0IHRoZSBsb2NhbCBzdG9yZSB0cmFja3MgZm9yIGVhY2ggdGFyZ2V0LlxuICovXG5jbGFzcyBUYXJnZXREYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHRhcmdldCBiZWluZyBsaXN0ZW5lZCB0by4gKi9cbiAgICB0YXJnZXQsIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgSUQgdG8gd2hpY2ggdGhlIHRhcmdldCBjb3JyZXNwb25kczsgQXNzaWduZWQgYnkgdGhlXG4gICAgICogTG9jYWxTdG9yZSBmb3IgdXNlciBsaXN0ZW5zIGFuZCBieSB0aGUgU3luY0VuZ2luZSBmb3IgbGltYm8gd2F0Y2hlcy5cbiAgICAgKi9cbiAgICB0YXJnZXRJZCwgXG4gICAgLyoqIFRoZSBwdXJwb3NlIG9mIHRoZSB0YXJnZXQuICovXG4gICAgcHVycG9zZSwgXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgbGFzdCB0cmFuc2FjdGlvbiBkdXJpbmcgd2hpY2ggdGhpcyB0YXJnZXQgZGF0YVxuICAgICAqIHdhcyBtb2RpZmllZC5cbiAgICAgKi9cbiAgICBzZXF1ZW5jZU51bWJlciwgXG4gICAgLyoqIFRoZSBsYXRlc3Qgc25hcHNob3QgdmVyc2lvbiBzZWVuIGZvciB0aGlzIHRhcmdldC4gKi9cbiAgICBzbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHNuYXBzaG90IHZlcnNpb24gYXQgd2hpY2ggdGhlIGFzc29jaWF0ZWQgdmlld1xuICAgICAqIGNvbnRhaW5lZCBubyBsaW1ibyBkb2N1bWVudHMuXG4gICAgICovXG4gICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgLyoqXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgbGFzdCBtYXRjaGVkIHRoZSBxdWVyeSBhdCB0aGUgcmVzdW1lIHRva2VuIG9yXG4gICAgICogcmVhZCB0aW1lLiBEb2N1bWVudHMgYXJlIGNvdW50ZWQgb25seSB3aGVuIG1ha2luZyBhIGxpc3RlbiByZXF1ZXN0IHdpdGhcbiAgICAgKiByZXN1bWUgdG9rZW4gb3IgcmVhZCB0aW1lLCBvdGhlcndpc2UsIGtlZXAgaXQgbnVsbC5cbiAgICAgKi9cbiAgICBleHBlY3RlZENvdW50ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnB1cnBvc2UgPSBwdXJwb3NlO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLnJlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRDb3VudCA9IGV4cGVjdGVkQ291bnQ7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBzZXF1ZW5jZSBudW1iZXIuICovXG4gICAgd2l0aFNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCBzZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgdGhpcy5leHBlY3RlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgcmVzdW1lIHRva2VuIGFuZFxuICAgICAqIHNuYXBzaG90IHZlcnNpb24uXG4gICAgICovXG4gICAgd2l0aFJlc3VtZVRva2VuKHJlc3VtZVRva2VuLCBzbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldElkLCB0aGlzLnB1cnBvc2UsIHRoaXMuc2VxdWVuY2VOdW1iZXIsIHNuYXBzaG90VmVyc2lvbiwgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCByZXN1bWVUb2tlbiwgXG4gICAgICAgIC8qIGV4cGVjdGVkQ291bnQ9ICovIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBleHBlY3RlZCBjb3VudC5cbiAgICAgKi9cbiAgICB3aXRoRXhwZWN0ZWRDb3VudChleHBlY3RlZENvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCB0aGlzLnNlcXVlbmNlTnVtYmVyLCB0aGlzLnNuYXBzaG90VmVyc2lvbiwgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCB0aGlzLnJlc3VtZVRva2VuLCBleHBlY3RlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgbGFzdCBsaW1ibyBmcmVlXG4gICAgICogc25hcHNob3QgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgd2l0aExhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24obGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFNlcmlhbGl6ZXIgZm9yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIExvY2FsU3RvcmUuICovXG5jbGFzcyBMb2NhbFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbW90ZVNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVTZXJpYWxpemVyID0gcmVtb3RlU2VyaWFsaXplcjtcbiAgICB9XG59XG4vKiogRGVjb2RlcyBhIHJlbW90ZSBkb2N1bWVudCBmcm9tIHN0b3JhZ2UgbG9jYWxseSB0byBhIERvY3VtZW50LiAqL1xuZnVuY3Rpb24gZnJvbURiUmVtb3RlRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLCByZW1vdGVEb2MpIHtcbiAgICBsZXQgZG9jO1xuICAgIGlmIChyZW1vdGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgZG9jID0gZnJvbURvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCByZW1vdGVEb2MuZG9jdW1lbnQsICEhcmVtb3RlRG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2Mubm9Eb2N1bWVudC5wYXRoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChyZW1vdGVEb2Mubm9Eb2N1bWVudC5yZWFkVGltZSk7XG4gICAgICAgIGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgICAgIGlmIChyZW1vdGVEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgICAgICAgICBkb2Muc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC5wYXRoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50LnZlcnNpb24pO1xuICAgICAgICBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3VW5rbm93bkRvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbiAgICBpZiAocmVtb3RlRG9jLnJlYWRUaW1lKSB7XG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShmcm9tRGJUaW1lc3RhbXBLZXkocmVtb3RlRG9jLnJlYWRUaW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG59XG4vKiogRW5jb2RlcyBhIGRvY3VtZW50IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXG5mdW5jdGlvbiB0b0RiUmVtb3RlRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLCBkb2N1bWVudCkge1xuICAgIGNvbnN0IGtleSA9IGRvY3VtZW50LmtleTtcbiAgICBjb25zdCByZW1vdGVEb2MgPSB7XG4gICAgICAgIHByZWZpeFBhdGg6IGtleS5nZXRDb2xsZWN0aW9uUGF0aCgpLnBvcExhc3QoKS50b0FycmF5KCksXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDoga2V5LmNvbGxlY3Rpb25Hcm91cCxcbiAgICAgICAgZG9jdW1lbnRJZDoga2V5LnBhdGgubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXBLZXkoZG9jdW1lbnQucmVhZFRpbWUpLFxuICAgICAgICBoYXNDb21taXR0ZWRNdXRhdGlvbnM6IGRvY3VtZW50Lmhhc0NvbW1pdHRlZE11dGF0aW9uc1xuICAgIH07XG4gICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy5kb2N1bWVudCA9IHRvRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgcmVtb3RlRG9jLm5vRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXG4gICAgICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcChkb2N1bWVudC52ZXJzaW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudC5pc1Vua25vd25Eb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXG4gICAgICAgICAgICB2ZXJzaW9uOiB0b0RiVGltZXN0YW1wKGRvY3VtZW50LnZlcnNpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlRG9jO1xufVxuZnVuY3Rpb24gdG9EYlRpbWVzdGFtcEtleShzbmFwc2hvdFZlcnNpb24pIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcbiAgICByZXR1cm4gW3RpbWVzdGFtcC5zZWNvbmRzLCB0aW1lc3RhbXAubmFub3NlY29uZHNdO1xufVxuZnVuY3Rpb24gZnJvbURiVGltZXN0YW1wS2V5KGRiVGltZXN0YW1wS2V5KSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcChkYlRpbWVzdGFtcEtleVswXSwgZGJUaW1lc3RhbXBLZXlbMV0pO1xuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xufVxuZnVuY3Rpb24gdG9EYlRpbWVzdGFtcChzbmFwc2hvdFZlcnNpb24pIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcbiAgICByZXR1cm4geyBzZWNvbmRzOiB0aW1lc3RhbXAuc2Vjb25kcywgbmFub3NlY29uZHM6IHRpbWVzdGFtcC5uYW5vc2Vjb25kcyB9O1xufVxuZnVuY3Rpb24gZnJvbURiVGltZXN0YW1wKGRiVGltZXN0YW1wKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcChkYlRpbWVzdGFtcC5zZWNvbmRzLCBkYlRpbWVzdGFtcC5uYW5vc2Vjb25kcyk7XG4gICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKHRpbWVzdGFtcCk7XG59XG4vKiogRW5jb2RlcyBhIGJhdGNoIG9mIG11dGF0aW9ucyBpbnRvIGEgRGJNdXRhdGlvbkJhdGNoIGZvciBsb2NhbCBzdG9yYWdlLiAqL1xuZnVuY3Rpb24gdG9EYk11dGF0aW9uQmF0Y2gobG9jYWxTZXJpYWxpemVyLCB1c2VySWQsIGJhdGNoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEJhc2VNdXRhdGlvbnMgPSBiYXRjaC5iYXNlTXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICBjb25zdCBzZXJpYWxpemVkTXV0YXRpb25zID0gYmF0Y2gubXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIGJhdGNoSWQ6IGJhdGNoLmJhdGNoSWQsXG4gICAgICAgIGxvY2FsV3JpdGVUaW1lTXM6IGJhdGNoLmxvY2FsV3JpdGVUaW1lLnRvTWlsbGlzKCksXG4gICAgICAgIGJhc2VNdXRhdGlvbnM6IHNlcmlhbGl6ZWRCYXNlTXV0YXRpb25zLFxuICAgICAgICBtdXRhdGlvbnM6IHNlcmlhbGl6ZWRNdXRhdGlvbnNcbiAgICB9O1xufVxuLyoqIERlY29kZXMgYSBEYk11dGF0aW9uQmF0Y2ggaW50byBhIE11dGF0aW9uQmF0Y2ggKi9cbmZ1bmN0aW9uIGZyb21EYk11dGF0aW9uQmF0Y2gobG9jYWxTZXJpYWxpemVyLCBkYkJhdGNoKSB7XG4gICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IChkYkJhdGNoLmJhc2VNdXRhdGlvbnMgfHwgW10pLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xuICAgIC8vIFNxdWFzaCBvbGQgdHJhbnNmb3JtIG11dGF0aW9ucyBpbnRvIGV4aXN0aW5nIHBhdGNoIG9yIHNldCBtdXRhdGlvbnMuXG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IG9mIHJlcHJlc2VudGluZyBgdHJhbnNmb3Jtc2Agd2l0aCBgdXBkYXRlX3RyYW5zZm9ybXNgXG4gICAgLy8gb24gdGhlIFNESyBtZWFucyB0aGF0IG9sZCBgdHJhbnNmb3JtYCBtdXRhdGlvbnMgc3RvcmVkIGluIEluZGV4ZWREQiBuZWVkXG4gICAgLy8gdG8gYmUgdXBkYXRlZCB0byBgdXBkYXRlX3RyYW5zZm9ybXNgLlxuICAgIC8vIFRPRE8oYi8xNzQ2MDgzNzQpOiBSZW1vdmUgdGhpcyBjb2RlIG9uY2Ugd2UgcGVyZm9ybSBhIHNjaGVtYSBtaWdyYXRpb24uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYkJhdGNoLm11dGF0aW9ucy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE11dGF0aW9uID0gZGJCYXRjaC5tdXRhdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IGkgKyAxIDwgZGJCYXRjaC5tdXRhdGlvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYkJhdGNoLm11dGF0aW9uc1tpICsgMV0udHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChoYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU11dGF0aW9uID0gZGJCYXRjaC5tdXRhdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgY3VycmVudE11dGF0aW9uLnVwZGF0ZVRyYW5zZm9ybXMgPVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU11dGF0aW9uLnRyYW5zZm9ybS5maWVsZFRyYW5zZm9ybXM7XG4gICAgICAgICAgICBkYkJhdGNoLm11dGF0aW9ucy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG11dGF0aW9ucyA9IGRiQmF0Y2gubXV0YXRpb25zLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRiQmF0Y2gubG9jYWxXcml0ZVRpbWVNcyk7XG4gICAgcmV0dXJuIG5ldyBNdXRhdGlvbkJhdGNoKGRiQmF0Y2guYmF0Y2hJZCwgdGltZXN0YW1wLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpO1xufVxuLyoqIERlY29kZXMgYSBEYlRhcmdldCBpbnRvIFRhcmdldERhdGEgKi9cbmZ1bmN0aW9uIGZyb21EYlRhcmdldChkYlRhcmdldCkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAoZGJUYXJnZXQucmVhZFRpbWUpO1xuICAgIGNvbnN0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBkYlRhcmdldC5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmcm9tRGJUaW1lc3RhbXAoZGJUYXJnZXQubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbilcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgbGV0IHRhcmdldDtcbiAgICBpZiAoaXNEb2N1bWVudFF1ZXJ5KGRiVGFyZ2V0LnF1ZXJ5KSkge1xuICAgICAgICB0YXJnZXQgPSBmcm9tRG9jdW1lbnRzVGFyZ2V0KGRiVGFyZ2V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IGZyb21RdWVyeVRhcmdldChkYlRhcmdldC5xdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0YXJnZXQsIGRiVGFyZ2V0LnRhcmdldElkLCBcIlRhcmdldFB1cnBvc2VMaXN0ZW5cIiAvKiBUYXJnZXRQdXJwb3NlLkxpc3RlbiAqLywgZGJUYXJnZXQubGFzdExpc3RlblNlcXVlbmNlTnVtYmVyLCB2ZXJzaW9uLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCBCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoZGJUYXJnZXQucmVzdW1lVG9rZW4pKTtcbn1cbi8qKiBFbmNvZGVzIFRhcmdldERhdGEgaW50byBhIERiVGFyZ2V0IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXG5mdW5jdGlvbiB0b0RiVGFyZ2V0KGxvY2FsU2VyaWFsaXplciwgdGFyZ2V0RGF0YSkge1xuICAgIGNvbnN0IGRiVGltZXN0YW1wID0gdG9EYlRpbWVzdGFtcCh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbik7XG4gICAgY29uc3QgZGJMYXN0TGltYm9GcmVlVGltZXN0YW1wID0gdG9EYlRpbWVzdGFtcCh0YXJnZXREYXRhLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pO1xuICAgIGxldCBxdWVyeVByb3RvO1xuICAgIGlmICh0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSkge1xuICAgICAgICBxdWVyeVByb3RvID0gdG9Eb2N1bWVudHNUYXJnZXQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHRhcmdldERhdGEudGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXJ5UHJvdG8gPSB0b1F1ZXJ5VGFyZ2V0KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCB0YXJnZXREYXRhLnRhcmdldCkucXVlcnlUYXJnZXQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbid0IHN0b3JlIHRoZSByZXN1bWVUb2tlbiBhcyBhIEJ5dGVTdHJpbmcgaW4gSW5kZXhlZERiLCBzbyB3ZVxuICAgIC8vIGNvbnZlcnQgaXQgdG8gYSBiYXNlNjQgc3RyaW5nIGZvciBzdG9yYWdlLlxuICAgIGNvbnN0IHJlc3VtZVRva2VuID0gdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi50b0Jhc2U2NCgpO1xuICAgIC8vIGxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciBpcyBhbHdheXMgMCB1bnRpbCB3ZSBkbyByZWFsIEdDLlxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldElkOiB0YXJnZXREYXRhLnRhcmdldElkLFxuICAgICAgICBjYW5vbmljYWxJZDogY2Fub25pZnlUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpLFxuICAgICAgICByZWFkVGltZTogZGJUaW1lc3RhbXAsXG4gICAgICAgIHJlc3VtZVRva2VuLFxuICAgICAgICBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI6IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb246IGRiTGFzdExpbWJvRnJlZVRpbWVzdGFtcCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5UHJvdG9cbiAgICB9O1xufVxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZmlndXJpbmcgb3V0IHdoYXQga2luZCBvZiBxdWVyeSBoYXMgYmVlbiBzdG9yZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRRdWVyeShkYlF1ZXJ5KSB7XG4gICAgcmV0dXJuIGRiUXVlcnkuZG9jdW1lbnRzICE9PSB1bmRlZmluZWQ7XG59XG4vKiogRW5jb2RlcyBhIERiQnVuZGxlIHRvIGEgQnVuZGxlTWV0YWRhdGEgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZnJvbURiQnVuZGxlKGRiQnVuZGxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGRiQnVuZGxlLmJ1bmRsZUlkLFxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tRGJUaW1lc3RhbXAoZGJCdW5kbGUuY3JlYXRlVGltZSksXG4gICAgICAgIHZlcnNpb246IGRiQnVuZGxlLnZlcnNpb25cbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBCdW5kbGVNZXRhZGF0YSB0byBhIERiQnVuZGxlLiAqL1xuZnVuY3Rpb24gdG9EYkJ1bmRsZShtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1bmRsZUlkOiBtZXRhZGF0YS5pZCxcbiAgICAgICAgY3JlYXRlVGltZTogdG9EYlRpbWVzdGFtcChmcm9tVmVyc2lvbihtZXRhZGF0YS5jcmVhdGVUaW1lKSksXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb25cbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBEYk5hbWVkUXVlcnkgdG8gYSBOYW1lZFF1ZXJ5LiAqL1xuZnVuY3Rpb24gZnJvbURiTmFtZWRRdWVyeShkYk5hbWVkUXVlcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBkYk5hbWVkUXVlcnkubmFtZSxcbiAgICAgICAgcXVlcnk6IGZyb21CdW5kbGVkUXVlcnkoZGJOYW1lZFF1ZXJ5LmJ1bmRsZWRRdWVyeSksXG4gICAgICAgIHJlYWRUaW1lOiBmcm9tRGJUaW1lc3RhbXAoZGJOYW1lZFF1ZXJ5LnJlYWRUaW1lKVxuICAgIH07XG59XG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgZnJvbSBhIGJ1bmRsZSBwcm90byB0byBhIERiTmFtZWRRdWVyeS4gKi9cbmZ1bmN0aW9uIHRvRGJOYW1lZFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcXVlcnkubmFtZSxcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24ocXVlcnkucmVhZFRpbWUpKSxcbiAgICAgICAgYnVuZGxlZFF1ZXJ5OiBxdWVyeS5idW5kbGVkUXVlcnlcbiAgICB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYEJ1bmRsZWRRdWVyeWAgZnJvbSBidW5kbGUgcHJvdG8gdG8gYSBRdWVyeSBvYmplY3QuXG4gKlxuICogVGhpcyByZWNvbnN0cnVjdHMgdGhlIG9yaWdpbmFsIHF1ZXJ5IHVzZWQgdG8gYnVpbGQgdGhlIGJ1bmRsZSBiZWluZyBsb2FkZWQsXG4gKiBpbmNsdWRpbmcgZmVhdHVyZXMgZXhpc3RzIG9ubHkgaW4gU0RLcyAoZm9yIGV4YW1wbGU6IGxpbWl0LXRvLWxhc3QpLlxuICovXG5mdW5jdGlvbiBmcm9tQnVuZGxlZFF1ZXJ5KGJ1bmRsZWRRdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh7XG4gICAgICAgIHBhcmVudDogYnVuZGxlZFF1ZXJ5LnBhcmVudCxcbiAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBidW5kbGVkUXVlcnkuc3RydWN0dXJlZFF1ZXJ5XG4gICAgfSk7XG4gICAgaWYgKGJ1bmRsZWRRdWVyeS5saW1pdFR5cGUgPT09ICdMQVNUJykge1xuICAgICAgICByZXR1cm4gcXVlcnlXaXRoTGltaXQocXVlcnksIHF1ZXJ5LmxpbWl0LCBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn1cbi8qKiBFbmNvZGVzIGEgTmFtZWRRdWVyeSBwcm90byBvYmplY3QgdG8gYSBOYW1lZFF1ZXJ5IG1vZGVsIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21Qcm90b05hbWVkUXVlcnkobmFtZWRRdWVyeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWVkUXVlcnkubmFtZSxcbiAgICAgICAgcXVlcnk6IGZyb21CdW5kbGVkUXVlcnkobmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxuICAgICAgICByZWFkVGltZTogZnJvbVZlcnNpb24obmFtZWRRdWVyeS5yZWFkVGltZSlcbiAgICB9O1xufVxuLyoqIERlY29kZXMgYSBCdW5kbGVNZXRhZGF0YSBwcm90byBpbnRvIGEgQnVuZGxlTWV0YWRhdGEgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZnJvbUJ1bmRsZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IG1ldGFkYXRhLmlkLFxuICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uLFxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tVmVyc2lvbihtZXRhZGF0YS5jcmVhdGVUaW1lKVxuICAgIH07XG59XG4vKiogRW5jb2RlcyBhIERiRG9jdW1lbnRPdmVybGF5IG9iamVjdCB0byBhbiBPdmVybGF5IG1vZGVsIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21EYkRvY3VtZW50T3ZlcmxheShsb2NhbFNlcmlhbGl6ZXIsIGRiRG9jdW1lbnRPdmVybGF5KSB7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5KGRiRG9jdW1lbnRPdmVybGF5Lmxhcmdlc3RCYXRjaElkLCBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIGRiRG9jdW1lbnRPdmVybGF5Lm92ZXJsYXlNdXRhdGlvbikpO1xufVxuLyoqIERlY29kZXMgYW4gT3ZlcmxheSBtb2RlbCBvYmplY3QgaW50byBhIERiRG9jdW1lbnRPdmVybGF5IG9iamVjdC4gKi9cbmZ1bmN0aW9uIHRvRGJEb2N1bWVudE92ZXJsYXkobG9jYWxTZXJpYWxpemVyLCB1c2VySWQsIG92ZXJsYXkpIHtcbiAgICBjb25zdCBbXywgY29sbGVjdGlvblBhdGgsIGRvY3VtZW50SWRdID0gdG9EYkRvY3VtZW50T3ZlcmxheUtleSh1c2VySWQsIG92ZXJsYXkubXV0YXRpb24ua2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIGNvbGxlY3Rpb25QYXRoLFxuICAgICAgICBkb2N1bWVudElkLFxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IG92ZXJsYXkubXV0YXRpb24ua2V5LmdldENvbGxlY3Rpb25Hcm91cCgpLFxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCxcbiAgICAgICAgb3ZlcmxheU11dGF0aW9uOiB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBvdmVybGF5Lm11dGF0aW9uKVxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIERiRG9jdW1lbnRPdmVybGF5S2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHVzZXIgYW5kXG4gKiBkb2N1bWVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodXNlcklkLCBkb2NLZXkpIHtcbiAgICBjb25zdCBkb2NJZCA9IGRvY0tleS5wYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoZG9jS2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICByZXR1cm4gW3VzZXJJZCwgY29sbGVjdGlvblBhdGgsIGRvY0lkXTtcbn1cbmZ1bmN0aW9uIHRvRGJJbmRleENvbmZpZ3VyYXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleElkOiBpbmRleC5pbmRleElkLFxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IGluZGV4LmNvbGxlY3Rpb25Hcm91cCxcbiAgICAgICAgZmllbGRzOiBpbmRleC5maWVsZHMubWFwKHMgPT4gW3MuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBzLmtpbmRdKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tRGJJbmRleENvbmZpZ3VyYXRpb24oaW5kZXgsIHN0YXRlKSB7XG4gICAgY29uc3QgZGVjb2RlZFN0YXRlID0gc3RhdGVcbiAgICAgICAgPyBuZXcgSW5kZXhTdGF0ZShzdGF0ZS5zZXF1ZW5jZU51bWJlciwgbmV3IEluZGV4T2Zmc2V0KGZyb21EYlRpbWVzdGFtcChzdGF0ZS5yZWFkVGltZSksIG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgoc3RhdGUuZG9jdW1lbnRLZXkpKSwgc3RhdGUubGFyZ2VzdEJhdGNoSWQpKVxuICAgICAgICA6IEluZGV4U3RhdGUuZW1wdHkoKTtcbiAgICBjb25zdCBkZWNvZGVkU2VnbWVudHMgPSBpbmRleC5maWVsZHMubWFwKChbZmllbGRQYXRoLCBraW5kXSkgPT4gbmV3IEluZGV4U2VnbWVudChGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KGZpZWxkUGF0aCksIGtpbmQpKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkSW5kZXgoaW5kZXguaW5kZXhJZCwgaW5kZXguY29sbGVjdGlvbkdyb3VwLCBkZWNvZGVkU2VnbWVudHMsIGRlY29kZWRTdGF0ZSk7XG59XG5mdW5jdGlvbiB0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB1aWQsIHNlcXVlbmNlTnVtYmVyLCBvZmZzZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleElkLFxuICAgICAgICB1aWQsXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyLFxuICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcChvZmZzZXQucmVhZFRpbWUpLFxuICAgICAgICBkb2N1bWVudEtleTogZW5jb2RlUmVzb3VyY2VQYXRoKG9mZnNldC5kb2N1bWVudEtleS5wYXRoKSxcbiAgICAgICAgbGFyZ2VzdEJhdGNoSWQ6IG9mZnNldC5sYXJnZXN0QmF0Y2hJZFxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbmRleGVkRGJCdW5kbGVDYWNoZSB7XG4gICAgZ2V0QnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZUlkKSB7XG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KGJ1bmRsZUlkKVxuICAgICAgICAgICAgLm5leHQoYnVuZGxlID0+IHtcbiAgICAgICAgICAgIGlmIChidW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiQnVuZGxlKGJ1bmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gYnVuZGxlc1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQodG9EYkJ1bmRsZShidW5kbGVNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkUXVlcmllc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChxdWVyeU5hbWUpXG4gICAgICAgICAgICAubmV4dChxdWVyeSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiTmFtZWRRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuYW1lZFF1ZXJpZXNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJOYW1lZFF1ZXJ5KHF1ZXJ5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGJ1bmRsZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBidW5kbGVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJCdW5kbGVTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbmFtZWRRdWVyaWVzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gbmFtZWRRdWVyaWVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJOYW1lZFF1ZXJ5U3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBEb2N1bWVudE92ZXJsYXlDYWNoZSB1c2luZyBJbmRleGVkRGIuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBkb2N1bWVudCBzZXJpYWxpemVyLlxuICAgICAqIEBwYXJhbSB1c2VySWQgLSBUaGUgdXNlcklkIGZvciB3aGljaCB3ZSBhcmUgYWNjZXNzaW5nIG92ZXJsYXlzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIsIHVzZXJJZCkge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcbiAgICB9XG4gICAgc3RhdGljIGZvclVzZXIoc2VyaWFsaXplciwgdXNlcikge1xuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLnVpZCB8fCAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZShzZXJpYWxpemVyLCB1c2VySWQpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldCh0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHRoaXMudXNlcklkLCBrZXkpKVxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5ID0+IHtcbiAgICAgICAgICAgIGlmIChkYk92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgZGJPdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXModHJhbnNhY3Rpb24sIGtleXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KS5uZXh0KG92ZXJsYXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBzYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBvdmVybGF5cykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChfLCBtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IG5ldyBPdmVybGF5KGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbik7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIHJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRocyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBzZXQgb2YgdW5pcXVlIGNvbGxlY3Rpb24gcGF0aHMuXG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGtleSA9PiBjb2xsZWN0aW9uUGF0aHMuYWRkKGVuY29kZVJlc291cmNlUGF0aChrZXkuZ2V0Q29sbGVjdGlvblBhdGgoKSkpKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29sbGVjdGlvblBhdGhzLmZvckVhY2goY29sbGVjdGlvblBhdGggPT4ge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBiYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgYmF0Y2hJZCArIDFdLCBcbiAgICAgICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbikuZGVsZXRlQWxsKERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgsIHJhbmdlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIGNvbGxlY3Rpb24sIHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGNvbGxlY3Rpb24pO1xuICAgICAgICAvLyBXZSB3YW50IGJhdGNoIElEcyBsYXJnZXIgdGhhbiBgc2luY2VCYXRjaElkYCwgYW5kIHNvIHRoZSBsb3dlciBib3VuZFxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIHNpbmNlQmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgcmFuZ2UpXG4gICAgICAgICAgICAubmV4dChkYk92ZXJsYXlzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJPdmVybGF5IG9mIGRiT3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZnJvbURiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgZGJPdmVybGF5KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBsZXQgY3VycmVudEJhdGNoSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFdlIHdhbnQgYmF0Y2ggSURzIGxhcmdlciB0aGFuIGBzaW5jZUJhdGNoSWRgLCBhbmQgc28gdGhlIGxvd2VyIGJvdW5kXG4gICAgICAgIC8vIGlzIG5vdCBpbmNsdXNpdmUuXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCxcbiAgICAgICAgICAgIHJhbmdlXG4gICAgICAgIH0sIChfLCBkYk92ZXJsYXksIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJldHVybiBwYXJ0aWFsIGJhdGNoIG92ZXJsYXlzLCBldmVuIGlmIHRoZSBzaXplXG4gICAgICAgICAgICAvLyBvZiB0aGUgcmVzdWx0IHNldCBleGNlZWRzIHRoZSBnaXZlbiBgY291bnRgIGFyZ3VtZW50LiBUaGVyZWZvcmUsIHdlXG4gICAgICAgICAgICAvLyBjb250aW51ZSB0byBhZ2dyZWdhdGUgcmVzdWx0cyBldmVuIGFmdGVyIHRoZSByZXN1bHQgc2l6ZSBleGNlZWRzXG4gICAgICAgICAgICAvLyBgY291bnRgIGlmIHRoZXJlIGFyZSBtb3JlIG92ZXJsYXlzIGZyb20gdGhlIGBjdXJyZW50QmF0Y2hJZGAuXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZnJvbURiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgZGJPdmVybGF5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSgpIDwgY291bnQgfHxcbiAgICAgICAgICAgICAgICBvdmVybGF5Lmxhcmdlc3RCYXRjaElkID09PSBjdXJyZW50QmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEJhdGNoSWQgPSBvdmVybGF5Lmxhcmdlc3RCYXRjaElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBzYXZlT3ZlcmxheSh0cmFuc2FjdGlvbiwgb3ZlcmxheSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIG92ZXJsYXkpKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgZG9jdW1lbnQgb3ZlcmxheSBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50T3ZlcmxheVN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiRG9jdW1lbnRPdmVybGF5U3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiR2xvYmFsc0NhY2hlIHtcbiAgICBnbG9iYWxzU3RvcmUodHhuKSB7XG4gICAgICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiR2xvYmFsc1N0b3JlKTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvblRva2VuKHR4bikge1xuICAgICAgICBjb25zdCBnbG9iYWxzID0gdGhpcy5nbG9iYWxzU3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbHMuZ2V0KCdzZXNzaW9uVG9rZW4nKS5uZXh0KGdsb2JhbCA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdsb2JhbCA9PT0gbnVsbCB8fCBnbG9iYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTZXNzaW9uVG9rZW4odHhuLCBzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsc1N0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLnB1dCh7XG4gICAgICAgICAgICBuYW1lOiAnc2Vzc2lvblRva2VuJyxcbiAgICAgICAgICAgIHZhbHVlOiBzZXNzaW9uVG9rZW4udG9VaW50OEFycmF5KClcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTm90ZTogVGhpcyBjb2RlIGlzIGNvcGllZCBmcm9tIHRoZSBiYWNrZW5kLiBDb2RlIHRoYXQgaXMgbm90IHVzZWQgYnlcbi8vIEZpcmVzdG9yZSB3YXMgcmVtb3ZlZC5cbmNvbnN0IElOREVYX1RZUEVfTlVMTCA9IDU7XG5jb25zdCBJTkRFWF9UWVBFX0JPT0xFQU4gPSAxMDtcbmNvbnN0IElOREVYX1RZUEVfTkFOID0gMTM7XG5jb25zdCBJTkRFWF9UWVBFX05VTUJFUiA9IDE1O1xuY29uc3QgSU5ERVhfVFlQRV9USU1FU1RBTVAgPSAyMDtcbmNvbnN0IElOREVYX1RZUEVfU1RSSU5HID0gMjU7XG5jb25zdCBJTkRFWF9UWVBFX0JMT0IgPSAzMDtcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFID0gMzc7XG5jb25zdCBJTkRFWF9UWVBFX0dFT1BPSU5UID0gNDU7XG5jb25zdCBJTkRFWF9UWVBFX0FSUkFZID0gNTA7XG5jb25zdCBJTkRFWF9UWVBFX1ZFQ1RPUiA9IDUzO1xuY29uc3QgSU5ERVhfVFlQRV9NQVAgPSA1NTtcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQgPSA2MDtcbi8vIEEgdGVybWluYXRvciB0aGF0IGluZGljYXRlcyB0aGF0IGEgdHJ1bmNhdGFibGUgdmFsdWUgd2FzIG5vdCB0cnVuY2F0ZWQuXG4vLyBUaGlzIG11c3QgYmUgc21hbGxlciB0aGFuIGFsbCBvdGhlciB0eXBlIGxhYmVscy5cbmNvbnN0IE5PVF9UUlVOQ0FURUQgPSAyO1xuLyoqIEZpcmVzdG9yZSBpbmRleCB2YWx1ZSB3cml0ZXIuICAqL1xuY2xhc3MgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvLyBUaGUgd3JpdGUgbWV0aG9kcyBiZWxvdyBzaG9ydC1jaXJjdWl0IHdyaXRpbmcgdGVybWluYXRvcnMgZm9yIHZhbHVlc1xuICAgIC8vIGNvbnRhaW5pbmcgYSAodGVybWluYXRpbmcpIHRydW5jYXRlZCB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSByZXN1bHRpbmcgZW5jb2RpbmcgZm9yOlxuICAgIC8vXG4gICAgLy8gW1wiYmFyXCIsIFsyLCBcImZvb1wiXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBURVJNLCBURVJNLCBURVJNKVxuICAgIC8vIFtcImJhclwiLCBbMiwgdHJ1bmNhdGVkKFwiZm9vXCIpXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBUUlVOQylcbiAgICAvLyBbXCJiYXJcIiwgdHJ1bmNhdGVkKFtcImZvb1wiXSldIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLiBTVFJJTkcsIFwiZm9vXCIsIFRFUk0sIFRSVU5DKVxuICAgIC8qKiBXcml0ZXMgYW4gaW5kZXggdmFsdWUuICAqL1xuICAgIHdyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eCh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgIC8vIFdyaXRlIHNlcGFyYXRvciB0byBzcGxpdCBpbmRleCB2YWx1ZXNcbiAgICAgICAgLy8gKHNlZSBnby9maXJlc3RvcmUtc3RvcmFnZS1mb3JtYXQjZW5jb2RpbmdzKS5cbiAgICAgICAgZW5jb2Rlci53cml0ZUluZmluaXR5KCk7XG4gICAgfVxuICAgIHdyaXRlSW5kZXhWYWx1ZUF1eChpbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGlmICgnbnVsbFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9OVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CT09MRUFOKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoaW5kZXhWYWx1ZS5ib29sZWFuVmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobm9ybWFsaXplTnVtYmVyKGluZGV4VmFsdWUuaW50ZWdlclZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9ybWFsaXplTnVtYmVyKGluZGV4VmFsdWUuZG91YmxlVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTkFOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmVaZXJvKG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0wLjAsIDAgYW5kIDAuMCBhcmUgYWxsIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcigwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gaW5kZXhWYWx1ZS50aW1lc3RhbXBWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1RJTUVTVEFNUCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoYCR7dGltZXN0YW1wLnNlY29uZHMgfHwgJyd9YCk7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKHRpbWVzdGFtcC5uYW5vcyB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhpbmRleFZhbHVlLnN0cmluZ1ZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CTE9CKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVCeXRlcyhub3JtYWxpemVCeXRlU3RyaW5nKGluZGV4VmFsdWUuYnl0ZXNWYWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhFbnRpdHlSZWYoaW5kZXhWYWx1ZS5yZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlb1BvaW50ID0gaW5kZXhWYWx1ZS5nZW9Qb2ludFZhbHVlO1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfR0VPUE9JTlQpO1xuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihnZW9Qb2ludC5sYXRpdHVkZSB8fCAwKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubG9uZ2l0dWRlIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzTWF4VmFsdWUoaW5kZXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWZWN0b3JWYWx1ZShpbmRleFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZlY3RvcihpbmRleFZhbHVlLm1hcFZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleE1hcChpbmRleFZhbHVlLm1hcFZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4QXJyYXkoaW5kZXhWYWx1ZS5hcnJheVZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9TVFJJTkcpO1xuICAgICAgICB0aGlzLndyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcik7XG4gICAgfVxuICAgIHdyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHN0cmluZ0luZGV4VmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUluZGV4TWFwKG1hcEluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX01BUCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhrZXksIGVuY29kZXIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgobWFwW2tleV0sIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlSW5kZXhWZWN0b3IobWFwSW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtYXAgPSBtYXBJbmRleFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfVkVDVE9SKTtcbiAgICAgICAgLy8gVmVjdG9ycyBzb3J0IGZpcnN0IGJ5IGxlbmd0aFxuICAgICAgICBjb25zdCBrZXkgPSBWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoKF9iID0gKF9hID0gbWFwW2tleV0uYXJyYXlWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihub3JtYWxpemVOdW1iZXIobGVuZ3RoKSk7XG4gICAgICAgIC8vIFZlY3RvcnMgdGhlbiBzb3J0IGJ5IHBvc2l0aW9uIHZhbHVlXG4gICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhrZXksIGVuY29kZXIpO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChtYXBba2V5XSwgZW5jb2Rlcik7XG4gICAgfVxuICAgIHdyaXRlSW5kZXhBcnJheShhcnJheUluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gYXJyYXlJbmRleFZhbHVlLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQVJSQVkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChlbGVtZW50LCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4RW50aXR5UmVmKHJlZmVyZW5jZVZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBEb2N1bWVudEtleS5mcm9tTmFtZShyZWZlcmVuY2VWYWx1ZSkucGF0aDtcbiAgICAgICAgcGF0aC5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHNlZ21lbnQsIGVuY29kZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCB0eXBlT3JkZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0eXBlT3JkZXIpO1xuICAgIH1cbiAgICB3cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcikge1xuICAgICAgICAvLyBXaGlsZSB0aGUgU0RLIGRvZXMgbm90IGltcGxlbWVudCB0cnVuY2F0aW9uLCB0aGUgdHJ1bmNhdGlvbiBtYXJrZXIgaXNcbiAgICAgICAgLy8gdXNlZCB0byB0ZXJtaW5hdGUgYWxsIHZhcmlhYmxlIGxlbmd0aCB2YWx1ZXMgKHdoaWNoIGFyZSBzdHJpbmdzLCBieXRlcyxcbiAgICAgICAgLy8gcmVmZXJlbmNlcywgYXJyYXlzIGFuZCBtYXBzKS5cbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihOT1RfVFJVTkNBVEVEKTtcbiAgICB9XG59XG5GaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFID0gbmV3IEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyB8IGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIHwgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3MgfCBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBUaGVzZSBjb25zdGFudHMgYXJlIHRha2VuIGZyb20gdGhlIGJhY2tlbmQuICovXG5jb25zdCBNSU5fU1VSUk9HQVRFID0gJ1xcdUQ4MDAnO1xuY29uc3QgTUFYX1NVUlJPR0FURSA9ICdcXHVEQkZGJztcbmNvbnN0IEVTQ0FQRTEgPSAweDAwO1xuY29uc3QgTlVMTF9CWVRFID0gMHhmZjsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXG5jb25zdCBTRVBBUkFUT1IgPSAweDAxOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTFcbmNvbnN0IEVTQ0FQRTIgPSAweGZmO1xuY29uc3QgSU5GSU5JVFkgPSAweGZmOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTJcbmNvbnN0IEZGX0JZVEUgPSAweDAwOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTJcbmNvbnN0IExPTkdfU0laRSA9IDY0O1xuY29uc3QgQllURV9TSVpFID0gODtcbi8qKlxuICogVGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgYnVmZmVyLiBUaGlzIGlzIGFyYml0cmFyeSwgYnV0IGxpa2VseSBsYXJnZXIgdGhhblxuICogbW9zdCBpbmRleCB2YWx1ZXMgc28gdGhhdCBsZXNzIGNvcGllcyBvZiB0aGUgdW5kZXJseWluZyBidWZmZXIgd2lsbCBiZSBtYWRlLlxuICogRm9yIGxhcmdlIHZhbHVlcywgYSBzaW5nbGUgY29weSB3aWxsIG1hZGUgdG8gZG91YmxlIHRoZSBidWZmZXIgbGVuZ3RoLlxuICovXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gMTAyNDtcbi8qKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgbnVtYmVyIHRvIGEgYnl0ZSBhcnJheSAodXNpbmcgYmlnIGVuZGlhbiBlbmNvZGluZykuICovXG5mdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzKHZhbHVlKSB7XG4gICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgICBkdi5zZXRGbG9hdDY0KDAsIHZhbHVlLCAvKiBsaXR0bGVFbmRpYW49ICovIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHYuYnVmZmVyKTtcbn1cbi8qKlxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgemVyb3MgaW4gYSBieXRlLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKHgpIHtcbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgbGV0IHplcm9zID0gMDtcbiAgICBpZiAoeCA+PiA0ID09PSAwKSB7XG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IGZvdXIgYml0cyBhcmUgemVyby5cbiAgICAgICAgemVyb3MgKz0gNDtcbiAgICAgICAgeCA9IHggPDwgNDtcbiAgICB9XG4gICAgaWYgKHggPj4gNiA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCB0d28gKG9yIG5leHQgdHdvKSBiaXRzIGFyZSB6ZXJvLlxuICAgICAgICB6ZXJvcyArPSAyO1xuICAgICAgICB4ID0geCA8PCAyO1xuICAgIH1cbiAgICBpZiAoeCA+PiA3ID09PSAwKSB7XG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIHJlbWFpbmluZyBiaXQgaXMgemVyby5cbiAgICAgICAgemVyb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9zO1xufVxuLyoqIENvdW50cyB0aGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgaW4gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuICovXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvcyhieXRlcykge1xuICAgIGxldCBsZWFkaW5nWmVyb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGNvbnN0IHplcm9zID0gbnVtYmVyT2ZMZWFkaW5nWmVyb3NJbkJ5dGUoYnl0ZXNbaV0gJiAweGZmKTtcbiAgICAgICAgbGVhZGluZ1plcm9zICs9IHplcm9zO1xuICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWFkaW5nWmVyb3M7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBcInZhbHVlXCIuIExlYWRpbmcgemVybyBieXRlc1xuICogYXJlIHNraXBwZWQuXG4gKi9cbmZ1bmN0aW9uIHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKSB7XG4gICAgLy8gVGhpcyBpcyBqdXN0IHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICAgIGNvbnN0IG51bUJpdHMgPSBMT05HX1NJWkUgLSBudW1iZXJPZkxlYWRpbmdaZXJvcyh2YWx1ZSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChudW1CaXRzIC8gQllURV9TSVpFKTtcbn1cbi8qKlxuICogT3JkZXJlZENvZGVXcml0ZXIgaXMgYSBtaW5pbWFsLWFsbG9jYXRpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHdyaXRpbmdcbiAqIGJlaGF2aW9yIGRlZmluZWQgYnkgdGhlIGJhY2tlbmQuXG4gKlxuICogVGhlIGNvZGUgaXMgcG9ydGVkIGZyb20gaXRzIEphdmEgY291bnRlcnBhcnQuXG4gKi9cbmNsYXNzIE9yZGVyZWRDb2RlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShERUZBVUxUX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXNBc2NlbmRpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXQgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoYnl0ZS52YWx1ZSk7XG4gICAgICAgICAgICBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgd3JpdGVCeXRlc0Rlc2NlbmRpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXQgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKGJ5dGUudmFsdWUpO1xuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGFzY2VuZGluZy4gKi9cbiAgICB3cml0ZVV0ZjhBc2NlbmRpbmcoc2VxdWVuY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlcXVlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZyhjaGFyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNikgfCAoY2hhckNvZGUgPj4+IDYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IE1JTl9TVVJST0dBVEUgfHwgTUFYX1NVUlJPR0FURSA8IGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGRlc2NlbmRpbmcgKi9cbiAgICB3cml0ZVV0ZjhEZXNjZW5kaW5nKHNlcXVlbmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNikgfCAoY2hhckNvZGUgPj4+IDYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDUpIHwgKGNoYXJDb2RlID4+PiAxMikpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA0KSB8IChjb2RlUG9pbnQgPj4+IDE4KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjb2RlUG9pbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpO1xuICAgIH1cbiAgICB3cml0ZU51bWJlckFzY2VuZGluZyh2YWwpIHtcbiAgICAgICAgLy8gVmFsdWVzIGFyZSBlbmNvZGVkIHdpdGggYSBzaW5nbGUgYnl0ZSBsZW5ndGggcHJlZml4LCBmb2xsb3dlZCBieSB0aGVcbiAgICAgICAgLy8gYWN0dWFsIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBsZW4gJiAweGZmOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSBsZW47IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IHZhbHVlW2ldICYgMHhmZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZU51bWJlckRlc2NlbmRpbmcodmFsKSB7XG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXG4gICAgICAgIC8vIGludmVydGVkIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KGxlbiAmIDB4ZmYpOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSBsZW47IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH4odmFsdWVbaV0gJiAweGZmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYWZ0ZXIgYWxsIG90aGVyIGJ5dGVcbiAgICAgKiBzZXF1ZW5jZXMgd3JpdHRlbiBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICovXG4gICAgd3JpdGVJbmZpbml0eUFzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoSU5GSU5JVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYmVmb3JlIGFsbCBvdGhlciBieXRlXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKi9cbiAgICB3cml0ZUluZmluaXR5RGVzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhJTkZJTklUWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYnVmZmVyIHN1Y2ggdGhhdCBpdCBpcyB0aGUgc2FtZSBhcyB3aGVuIGl0IHdhcyBuZXdseVxuICAgICAqIGNvbnN0cnVjdGVkLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgc2VlZChlbmNvZGVkQnl0ZXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoZW5jb2RlZEJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnNldChlbmNvZGVkQnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGVuY29kZWRCeXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGVuY29kZWQgYnl0ZXMgaW4gdGhpcyBidWZmZXIuICAqL1xuICAgIGVuY29kZWRCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGB2YWxgIGludG8gYW4gZW5jb2Rpbmcgc28gdGhhdCB0aGUgb3JkZXIgbWF0Y2hlcyB0aGUgSUVFRSA3NTRcbiAgICAgKiBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIHJlc3VsdHMgd2l0aCB0aGUgZm9sbG93aW5nIGV4Y2VwdGlvbnM6XG4gICAgICogICAtMC4wIDwgMC4wXG4gICAgICogICBhbGwgbm9uLU5hTiA8IE5hTlxuICAgICAqICAgTmFOID0gTmFOXG4gICAgICovXG4gICAgdG9PcmRlcmVkQml0cyh2YWwpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb3VibGVUb0xvbmdCaXRzKHZhbCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBiaXQgaXMgc2V0LiBXZSB1c2UgYSBiaXQgbWFzayBzaW5jZSB2YWx1ZVswXSBpc1xuICAgICAgICAvLyBlbmNvZGVkIGFzIGEgbnVtYmVyIGZyb20gMCB0byAyNTUuXG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodmFsdWVbMF0gJiAweDgwKSAhPT0gMDtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSB0d28gY29tcGxlbWVudCB0byBnZXQgbmF0dXJhbCBvcmRlcmluZ1xuICAgICAgICB2YWx1ZVswXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4ODA7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhbHVlW2ldIF49IGlzTmVnYXRpdmUgPyAweGZmIDogMHgwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBXcml0ZXMgYSBzaW5nbGUgYnl0ZSBhc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gKi9cbiAgICB3cml0ZUJ5dGVBc2NlbmRpbmcoYikge1xuICAgICAgICBjb25zdCBtYXNrZWQgPSBiICYgMHhmZjtcbiAgICAgICAgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTEpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKE5VTExfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMik7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRkZfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcobWFza2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgZGVzY2VuZGluZyB0byB0aGUgYnVmZmVyLiAgKi9cbiAgICB3cml0ZUJ5dGVEZXNjZW5kaW5nKGIpIHtcbiAgICAgICAgY29uc3QgbWFza2VkID0gYiAmIDB4ZmY7XG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKE5VTExfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhGRl9CWVRFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKFNFUEFSQVRPUik7XG4gICAgfVxuICAgIHdyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhTRVBBUkFUT1IpO1xuICAgIH1cbiAgICB3cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKGIpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSk7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBiO1xuICAgIH1cbiAgICB3cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhiKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gfmI7XG4gICAgfVxuICAgIGVuc3VyZUF2YWlsYWJsZShieXRlcykge1xuICAgICAgICBjb25zdCBtaW5DYXBhY2l0eSA9IGJ5dGVzICsgdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKG1pbkNhcGFjaXR5IDw9IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkb3VibGluZy5cbiAgICAgICAgbGV0IG5ld0xlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAqIDI7XG4gICAgICAgIC8vIFN0aWxsIG5vdCBiaWcgZW5vdWdoPyBKdXN0IGFsbG9jYXRlIHRoZSByaWdodCBzaXplLlxuICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkNhcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGJ1ZmZlci5cbiAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlcik7IC8vIGNvcHkgb2xkIGRhdGFcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgfVxufVxuXG5jbGFzcyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhBc2NlbmRpbmcodmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmZpbml0eSgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5QXNjZW5kaW5nKCk7XG4gICAgfVxufVxuY2xhc3MgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yZGVyZWRDb2RlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBvcmRlcmVkQ29kZTtcbiAgICB9XG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlQnl0ZXNEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZU51bWJlckRlc2NlbmRpbmcodmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUluZmluaXR5KCkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlSW5maW5pdHlEZXNjZW5kaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGBEaXJlY3Rpb25hbEluZGV4Qnl0ZUVuY29kZXJgIHVzaW5nIGBPcmRlcmVkQ29kZVdyaXRlcmAgZm9yIHRoZVxuICogYWN0dWFsIGVuY29kaW5nLlxuICovXG5jbGFzcyBJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZSA9IG5ldyBPcmRlcmVkQ29kZVdyaXRlcigpO1xuICAgICAgICB0aGlzLmFzY2VuZGluZyA9IG5ldyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xuICAgICAgICB0aGlzLmRlc2NlbmRpbmcgPSBuZXcgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIodGhpcy5vcmRlcmVkQ29kZSk7XG4gICAgfVxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUuc2VlZChlbmNvZGVkQnl0ZXMpO1xuICAgIH1cbiAgICBmb3JLaW5kKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLyA/IHRoaXMuYXNjZW5kaW5nIDogdGhpcy5kZXNjZW5kaW5nO1xuICAgIH1cbiAgICBlbmNvZGVkQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRDb2RlLmVuY29kZWRCeXRlcygpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS5yZXNldCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBSZXByZXNlbnRzIGFuIGluZGV4IGVudHJ5IHNhdmVkIGJ5IHRoZSBTREsgaW4gcGVyc2lzdGVkIHN0b3JhZ2UuICovXG5jbGFzcyBJbmRleEVudHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihpbmRleElkLCBkb2N1bWVudEtleSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4SWQgPSBpbmRleElkO1xuICAgICAgICB0aGlzLmRvY3VtZW50S2V5ID0gZG9jdW1lbnRLZXk7XG4gICAgICAgIHRoaXMuYXJyYXlWYWx1ZSA9IGFycmF5VmFsdWU7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uYWxWYWx1ZSA9IGRpcmVjdGlvbmFsVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gSW5kZXhFbnRyeSBlbnRyeSB0aGF0IHNvcnRzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICogZGlyZWN0aW9uYWwgdmFsdWUuXG4gICAgICovXG4gICAgc3VjY2Vzc29yKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGVuZ3RoID0gdGhpcy5kaXJlY3Rpb25hbFZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gY3VycmVudExlbmd0aCA9PT0gMCB8fCB0aGlzLmRpcmVjdGlvbmFsVmFsdWVbY3VycmVudExlbmd0aCAtIDFdID09PSAyNTVcbiAgICAgICAgICAgID8gY3VycmVudExlbmd0aCArIDFcbiAgICAgICAgICAgIDogY3VycmVudExlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc29yID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgc3VjY2Vzc29yLnNldCh0aGlzLmRpcmVjdGlvbmFsVmFsdWUsIDApO1xuICAgICAgICBpZiAobmV3TGVuZ3RoICE9PSBjdXJyZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWNjZXNzb3Iuc2V0KFswXSwgdGhpcy5kaXJlY3Rpb25hbFZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3N1Y2Nlc3NvcltzdWNjZXNzb3IubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleEVudHJ5KHRoaXMuaW5kZXhJZCwgdGhpcy5kb2N1bWVudEtleSwgdGhpcy5hcnJheVZhbHVlLCBzdWNjZXNzb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZGV4RW50cnlDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGNtcCA9IGxlZnQuaW5kZXhJZCAtIHJpZ2h0LmluZGV4SWQ7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBjbXAgPSBjb21wYXJlQnl0ZUFycmF5cyhsZWZ0LmFycmF5VmFsdWUsIHJpZ2h0LmFycmF5VmFsdWUpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgY21wID0gY29tcGFyZUJ5dGVBcnJheXMobGVmdC5kaXJlY3Rpb25hbFZhbHVlLCByaWdodC5kaXJlY3Rpb25hbFZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQsIHJpZ2h0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aCAmJiBpIDwgcmlnaHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IGxlZnRbaV0gLSByaWdodFtpXTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Lmxlbmd0aCAtIHJpZ2h0Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBsaWdodCBxdWVyeSBwbGFubmVyIGZvciBGaXJlc3RvcmUuXG4gKlxuICogVGhpcyBjbGFzcyBtYXRjaGVzIGEgYEZpZWxkSW5kZXhgIGFnYWluc3QgYSBGaXJlc3RvcmUgUXVlcnkgYFRhcmdldGAuIEl0XG4gKiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHRhYmxlIHNob3djYXNlcyBzb21lIHBvc3NpYmxlIGluZGV4IGNvbmZpZ3VyYXRpb25zOlxuICpcbiAqIFF1ZXJ5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEluZGV4XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0MsIGIgREVTQ1xuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGIgREVTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKSAgICAgICAgICAgICAgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJywgJ2Rlc2MnKSAgICAgICAgICB8IGEgREVTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKS5vcmRlckJ5KCdiJykgICAgIHwgYSBBU0MsIGIgQVNDXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScpLm9yZGVyQnkoJ2InKSAgICAgfCBhIEFTQ1xuICogd2hlcmUoJ2EnLCAnYXJyYXktY29udGFpbnMnLCAnYScpLm9yZGVyQnkoJ2InKSAgICAgIHwgYSBDT05UQUlOUywgYiBBU0NFTkRJTkdcbiAqIHdoZXJlKCdhJywgJ2FycmF5LWNvbnRhaW5zJywgJ2EnKS5vcmRlckJ5KCdiJykgICAgICB8IGEgQ09OVEFJTlNcbiAqL1xuY2xhc3MgVGFyZ2V0SW5kZXhNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgLy8gVGhlIGluZXF1YWxpdHkgZmlsdGVycyBvZiB0aGUgdGFyZ2V0IChpZiBpdCBleGlzdHMpLlxuICAgICAgICAvLyBOb3RlOiBUaGUgc29ydCBvbiBGaWVsZEZpbHRlcnMgaXMgbm90IHJlcXVpcmVkLiBVc2luZyBTb3J0ZWRTZXQgaGVyZSBqdXN0IHRvIHV0aWxpemUgdGhlIGN1c3RvbVxuICAgICAgICAvLyBjb21wYXJhdG9yLlxuICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gbmV3IFNvcnRlZFNldCgobGhzLCByaHMpID0+IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGhzLmZpZWxkLCByaHMuZmllbGQpKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uSWQgPVxuICAgICAgICAgICAgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXG4gICAgICAgICAgICAgICAgOiB0YXJnZXQucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICB0aGlzLm9yZGVyQnlzID0gdGFyZ2V0Lm9yZGVyQnk7XG4gICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRhcmdldC5maWx0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAgIGlmIChmaWVsZEZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmFkZChmaWVsZEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWFsaXR5RmlsdGVycy5wdXNoKGZpZWxkRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzTXVsdGlwbGVJbmVxdWFsaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgVGFyZ2V0SW5kZXhNYXRjaGVyJ3NcbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBBbiBpbmRleCBpcyBjb25zaWRlcmVkIGNhcGFibGUgb2Ygc2VydmluZyB0aGUgdGFyZ2V0IHdoZW46XG4gICAgICogLSBUaGUgdGFyZ2V0IHVzZXMgYWxsIGluZGV4IHNlZ21lbnRzIGZvciBpdHMgZmlsdGVycyBhbmQgb3JkZXJCeSBjbGF1c2VzLlxuICAgICAqICAgVGhlIHRhcmdldCBjYW4gaGF2ZSBhZGRpdGlvbmFsIGZpbHRlciBhbmQgb3JkZXJCeSBjbGF1c2VzLCBidXQgbm90XG4gICAgICogICBmZXdlci5cbiAgICAgKiAtIElmIGFuIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueWZpbHRlciBpcyB1c2VkLCB0aGUgaW5kZXggbXVzdCBhbHNvXG4gICAgICogICBoYXZlIGEgY29ycmVzcG9uZGluZyBgQ09OVEFJTlNgIHNlZ21lbnQuXG4gICAgICogLSBBbGwgZGlyZWN0aW9uYWwgaW5kZXggc2VnbWVudHMgY2FuIGJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0IGFzIGEgc2VyaWVzIG9mXG4gICAgICogICBlcXVhbGl0eSBmaWx0ZXJzLCBhIHNpbmdsZSBpbmVxdWFsaXR5IGZpbHRlciBhbmQgYSBzZXJpZXMgb2Ygb3JkZXJCeVxuICAgICAqICAgY2xhdXNlcy5cbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGUgZXF1YWxpdHkgZmlsdGVycyBtYXkgYXBwZWFyIG91dCBvZiBvcmRlci5cbiAgICAgKiAtIFRoZSBvcHRpb25hbCBzZWdtZW50IGZvciB0aGUgaW5lcXVhbGl0eSBmaWx0ZXIgbXVzdCBhcHBlYXIgYWZ0ZXIgYWxsXG4gICAgICogICBlcXVhbGl0eSBzZWdtZW50cy5cbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGF0IG9yZGVyQnkgY2xhdXNlIG9mIHRoZSB0YXJnZXQgbXVzdCBhcHBlYXJcbiAgICAgKiAgIGluIG9yZGVyIGFmdGVyIGFsbCBlcXVhbGl0eSBhbmQgaW5lcXVhbGl0eSBzZWdtZW50cy4gU2luZ2xlIG9yZGVyQnlcbiAgICAgKiAgIGNsYXVzZXMgY2Fubm90IGJlIHNraXBwZWQsIGJ1dCBhIGNvbnRpbnVvdXMgb3JkZXJCeSBzdWZmaXggbWF5IGJlXG4gICAgICogICBvbWl0dGVkLlxuICAgICAqL1xuICAgIHNlcnZlZEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaGFyZEFzc2VydChpbmRleC5jb2xsZWN0aW9uR3JvdXAgPT09IHRoaXMuY29sbGVjdGlvbklkKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTXVsdGlwbGVJbmVxdWFsaXR5KSB7XG4gICAgICAgICAgICAvLyBPbmx5IHNpbmdsZSBpbmVxdWFsaXR5IGlzIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAgICAgICAgLy8gVE9ETyhBZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgaW5lcXVhbGl0eSBxdWVyeSk6IGIvMjk4NDQxMDQzXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYXJyYXkgZWxlbWVudCwgZmluZCBhIG1hdGNoaW5nIGZpbHRlci5cbiAgICAgICAgY29uc3QgYXJyYXlTZWdtZW50ID0gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChpbmRleCk7XG4gICAgICAgIGlmIChhcnJheVNlZ21lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIXRoaXMuaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihhcnJheVNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhpbmRleCk7XG4gICAgICAgIGxldCBlcXVhbGl0eVNlZ21lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgc2VnbWVudEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG9yZGVyQnlzSW5kZXggPSAwO1xuICAgICAgICAvLyBQcm9jZXNzIGFsbCBlcXVhbGl0aWVzIGZpcnN0LiBFcXVhbGl0aWVzIGNhbiBhcHBlYXIgb3V0IG9mIG9yZGVyLlxuICAgICAgICBmb3IgKDsgc2VnbWVudEluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyArK3NlZ21lbnRJbmRleCkge1xuICAgICAgICAgICAgLy8gV2UgYXR0ZW1wdCB0byBncmVlZGlseSBtYXRjaCBhbGwgc2VnbWVudHMgdG8gZXF1YWxpdHkgZmlsdGVycy4gSWYgYVxuICAgICAgICAgICAgLy8gZmlsdGVyIG1hdGNoZXMgYW4gaW5kZXggc2VnbWVudCwgd2UgY2FuIG1hcmsgdGhlIHNlZ21lbnQgYXMgdXNlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoc2VnbWVudHNbc2VnbWVudEluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBlcXVhbGl0eVNlZ21lbnRzID0gZXF1YWxpdHlTZWdtZW50cy5hZGQoc2VnbWVudHNbc2VnbWVudEluZGV4XS5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgYSBtYXRjaGluZyBmaWx0ZXIsIHdlIG5lZWQgdG8gdmVyaWZ5IHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVtYWluaW5nIHNlZ21lbnRzIG1hcCB0byB0aGUgdGFyZ2V0J3MgaW5lcXVhbGl0eSBhbmQgaXRzIG9yZGVyQnlcbiAgICAgICAgICAgICAgICAvLyBjbGF1c2VzLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBwcm9jZXNzZWQgYWxsIHNlZ21lbnRzLCBhbGwgc2VnbWVudHMgYXJlIHVzZWQgdG8gc2VydmVcbiAgICAgICAgLy8gdGhlIGVxdWFsaXR5IGZpbHRlcnMgYW5kIHdlIGRvIG5vdCBuZWVkIHRvIG1hcCBhbnkgc2VnbWVudHMgdG8gdGhlXG4gICAgICAgIC8vIHRhcmdldCdzIGluZXF1YWxpdHkgYW5kIG9yZGVyQnkgY2xhdXNlcy5cbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgLy8gT25seSBhIHNpbmdsZSBpbmVxdWFsaXR5IGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuIEdldCB0aGUgb25seSBlbnRyeSBpbiB0aGUgc2V0LlxuICAgICAgICAgICAgY29uc3QgaW5lcXVhbGl0eUZpbHRlciA9IHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuZ2V0SXRlcmF0b3IoKS5nZXROZXh0KCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbmVxdWFsaXR5IGZpbHRlciBhbmQgdGhlIGZpZWxkIHdhcyBub3QgaW4gb25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXF1YWxpdHkgZmlsdGVycyBhYm92ZSwgdGhlIG5leHQgc2VnbWVudCBtdXN0IG1hdGNoIGJvdGggdGhlIGZpbHRlclxuICAgICAgICAgICAgLy8gYW5kIHRoZSBmaXJzdCBvcmRlckJ5IGNsYXVzZS5cbiAgICAgICAgICAgIGlmICghZXF1YWxpdHlTZWdtZW50cy5oYXMoaW5lcXVhbGl0eUZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hlc0ZpbHRlcihpbmVxdWFsaXR5RmlsdGVyLCBzZWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzT3JkZXJCeSh0aGlzLm9yZGVyQnlzW29yZGVyQnlzSW5kZXgrK10sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3NlZ21lbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgcmVtYWluaW5nIHNlZ21lbnRzIG5lZWQgdG8gcmVwcmVzZW50IHRoZSBwcmVmaXggb2YgdGhlIHRhcmdldCdzXG4gICAgICAgIC8vIG9yZGVyQnkuXG4gICAgICAgIGZvciAoOyBzZWdtZW50SW5kZXggPCBzZWdtZW50cy5sZW5ndGg7ICsrc2VnbWVudEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5c0luZGV4ID49IHRoaXMub3JkZXJCeXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc09yZGVyQnkodGhpcy5vcmRlckJ5c1tvcmRlckJ5c0luZGV4KytdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bGwgbWF0Y2hlZCBmaWVsZCBpbmRleCBmb3IgdGhpcyB0YXJnZXQuIEN1cnJlbnRseSBtdWx0aXBsZVxuICAgICAqIGluZXF1YWxpdHkgcXVlcnkgaXMgbm90IHN1cHBvcnRlZCBzbyBmdW5jdGlvbiByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgYnVpbGRUYXJnZXRJbmRleCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTXVsdGlwbGVJbmVxdWFsaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBzZWdtZW50IGNyZWF0ZWQgZm9yIG9uZSBmaWVsZC4gRm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIGluIGNhc2UgbGlrZSBhID09IDMgYW5kIGEgPiAyLCBJbmRleCB7YSBBU0NFTkRJTkd9IHdpbGwgb25seSBiZSBjcmVhdGVkXG4gICAgICAgIC8vIG9uY2UuXG4gICAgICAgIGxldCB1bmlxdWVGaWVsZHMgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLmVxdWFsaXR5RmlsdGVycykge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzQXJyYXlPcGVyYXRvciA9IGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XG4gICAgICAgICAgICAgICAgZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLztcbiAgICAgICAgICAgIGlmIChpc0FycmF5T3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmlsdGVyLmZpZWxkLCAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZUZpZWxkcy5oYXMoZmlsdGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlRmllbGRzID0gdW5pcXVlRmllbGRzLmFkZChmaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWx0ZXIuZmllbGQsIDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFdlIGRvIG5vdCBleHBsaWNpdGx5IGNoZWNrIGB0aGlzLmluZXF1YWxpdHlGaWx0ZXJgIGJ1dCByYXRoZXIgcmVseVxuICAgICAgICAvLyBvbiB0aGUgdGFyZ2V0IGRlZmluaW5nIGFuIGFwcHJvcHJpYXRlIFwib3JkZXIgYnlcIiB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVxdWlyZWQgaW5kZXggc2VnbWVudCBpcyBhZGRlZC4gVGhlIHF1ZXJ5IGVuZ2luZSB3b3VsZCByZWplY3QgYSBxdWVyeVxuICAgICAgICAvLyB3aXRoIGFuIGluZXF1YWxpdHkgZmlsdGVyIHRoYXQgbGFja3MgdGhlIHJlcXVpcmVkIG9yZGVyLWJ5IGNsYXVzZS5cbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRoaXMub3JkZXJCeXMpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgYWRkaW5nIG1vcmUgc2VnbWVudHMgaWYgd2Ugc2VlIGEgb3JkZXItYnkgb24ga2V5LiBUeXBpY2FsbHkgdGhpc1xuICAgICAgICAgICAgLy8gaXMgdGhlIGRlZmF1bHQgaW1wbGljaXQgb3JkZXItYnkgd2hpY2ggaXMgY292ZXJlZCBpbiB0aGUgaW5kZXhfZW50cnlcbiAgICAgICAgICAgIC8vIHRhYmxlIGFzIGEgc2VwYXJhdGUgY29sdW1uLiBJZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgb3JkZXItYnksIHRoZVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGluZGV4IHdpbGwgYmUgbWlzc2luZyBzb21lIHNlZ21lbnRzIG9wdGltaXplZCBmb3Igb3JkZXItYnlzLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgcHJvYmFibHkgZmluZS5cbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXF1ZUZpZWxkcy5oYXMob3JkZXJCeS5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZUZpZWxkcyA9IHVuaXF1ZUZpZWxkcy5hZGQob3JkZXJCeS5maWVsZCk7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQob3JkZXJCeS5maWVsZCwgb3JkZXJCeS5kaXIgPT09IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgID8gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXG4gICAgICAgICAgICAgICAgOiAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZEluZGV4KEZpZWxkSW5kZXguVU5LTk9XTl9JRCwgdGhpcy5jb2xsZWN0aW9uSWQsIHNlZ21lbnRzLCBJbmRleFN0YXRlLmVtcHR5KCkpO1xuICAgIH1cbiAgICBoYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKHNlZ21lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5lcXVhbGl0eUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoZXNGaWx0ZXIoZmlsdGVyLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWF0Y2hlc0ZpbHRlcihmaWx0ZXIsIHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkIHx8ICFmaWx0ZXIuZmllbGQuaXNFcXVhbChzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0FycmF5T3BlcmF0b3IgPSBmaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fFxuICAgICAgICAgICAgZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLztcbiAgICAgICAgcmV0dXJuIChzZWdtZW50LmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSA9PT0gaXNBcnJheU9wZXJhdG9yO1xuICAgIH1cbiAgICBtYXRjaGVzT3JkZXJCeShvcmRlckJ5LCBzZWdtZW50KSB7XG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovICYmXG4gICAgICAgICAgICBvcmRlckJ5LmRpciA9PT0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovKSB8fFxuICAgICAgICAgICAgKHNlZ21lbnQua2luZCA9PT0gMSAvKiBJbmRleEtpbmQuREVTQ0VORElORyAqLyAmJlxuICAgICAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBoZWxwIHdpdGggYm9vbGVhbiBsb2dpYyB0cmFuc2Zvcm1hdGlvbnMgbmVlZGVkIGZvciBoYW5kbGluZ1xuICogY29tcGxleCBmaWx0ZXJzIHVzZWQgaW4gcXVlcmllcy5cbiAqL1xuLyoqXG4gKiBUaGUgYGluYCBmaWx0ZXIgaXMgb25seSBhIHN5bnRhY3RpYyBzdWdhciBvdmVyIGEgZGlzanVuY3Rpb24gb2YgZXF1YWxpdGllcy4gRm9yIGluc3RhbmNlOiBgYSBpblxuICogWzEsMiwzXWAgaXMgaW4gZmFjdCBgYT09MSB8fCBhPT0yIHx8IGE9PTNgLiBUaGlzIG1ldGhvZCBleHBhbmRzIGFueSBgaW5gIGZpbHRlciBpbiB0aGUgZ2l2ZW5cbiAqIGlucHV0IGludG8gYSBkaXNqdW5jdGlvbiBvZiBlcXVhbGl0eSBmaWx0ZXJzIGFuZCByZXR1cm5zIHRoZSBleHBhbmRlZCBmaWx0ZXIuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEluRmlsdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZEZpbHRlcnMgPSAoKF9iID0gKF9hID0gZmlsdGVyLnZhbHVlLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXAodmFsdWUgPT4gRmllbGRGaWx0ZXIuY3JlYXRlKGZpbHRlci5maWVsZCwgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovLCB2YWx1ZSkpKSB8fCBbXTtcbiAgICAgICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKGV4cGFuZGVkRmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCBvdGhlciBraW5kcyBvZiBmaWVsZCBmaWx0ZXJzLlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGEgY29tcG9zaXRlIGZpbHRlci5cbiAgICBjb25zdCBleHBhbmRlZEZpbHRlcnMgPSBmaWx0ZXIuZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGNvbXB1dGVJbkV4cGFuc2lvbihzdWJmaWx0ZXIpKTtcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIGZpbHRlci5vcCk7XG59XG4vKipcbiAqIEdpdmVuIGEgY29tcG9zaXRlIGZpbHRlciwgcmV0dXJucyB0aGUgbGlzdCBvZiB0ZXJtcyBpbiBpdHMgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0uXG4gKlxuICogPHA+RWFjaCBlbGVtZW50IGluIHRoZSByZXR1cm4gdmFsdWUgaXMgb25lIHRlcm0gb2YgdGhlIHJlc3VsdGluZyBETkYuIEZvciBpbnN0YW5jZTogRm9yIHRoZVxuICogaW5wdXQ6IChBIHx8IEIpICYmIEMsIHRoZSBETkYgZm9ybSBpczogKEEgJiYgQykgfHwgKEIgJiYgQyksIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIGEgbGlzdFxuICogd2l0aCB0d28gZWxlbWVudHM6IGEgY29tcG9zaXRlIGZpbHRlciB0aGF0IHBlcmZvcm1zIChBICYmIEMpLCBhbmQgYSBjb21wb3NpdGUgZmlsdGVyIHRoYXRcbiAqIHBlcmZvcm1zIChCICYmIEMpLlxuICpcbiAqIEBwYXJhbSBmaWx0ZXIgdGhlIGNvbXBvc2l0ZSBmaWx0ZXIgdG8gY2FsY3VsYXRlIERORiB0cmFuc2Zvcm0gZm9yLlxuICogQHJldHVybiB0aGUgdGVybXMgaW4gdGhlIERORiB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIGdldERuZlRlcm1zKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbXB1dGVEaXN0cmlidXRlZE5vcm1hbEZvcm0oY29tcHV0ZUluRXhwYW5zaW9uKGZpbHRlcikpO1xuICAgIGhhcmRBc3NlcnQoaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0ocmVzdWx0KSk7XG4gICAgaWYgKGlzU2luZ2xlRmllbGRGaWx0ZXIocmVzdWx0KSB8fCBpc0ZsYXRDb25qdW5jdGlvbihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5nZXRGaWx0ZXJzKCk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgYSBzaW5nbGUgZmllbGQgZmlsdGVyLiBlLmcuIChhID09IDEwKS4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZpbHRlciBpcyB0aGUgY29uanVuY3Rpb24gb2Ygb25lIG9yIG1vcmUgZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMFxuICogJiYgYiA9PSAyMClcbiAqL1xuZnVuY3Rpb24gaXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSB7XG4gICAgcmV0dXJuIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGZpbHRlciBpcyBpbiBkaXNqdW5jdGl2ZSBub3JtYWwgZm9ybSAoRE5GKS5cbiAqXG4gKiA8cD5JbiBib29sZWFuIGxvZ2ljLCBhIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpIGlzIGEgY2Fub25pY2FsIG5vcm1hbCBmb3JtIG9mIGEgbG9naWNhbFxuICogZm9ybXVsYSBjb25zaXN0aW5nIG9mIGEgZGlzanVuY3Rpb24gb2YgY29uanVuY3Rpb25zOyBpdCBjYW4gYWxzbyBiZSBkZXNjcmliZWQgYXMgYW4gT1Igb2YgQU5Ecy5cbiAqXG4gKiA8cD5Gb3IgbW9yZSBpbmZvLCB2aXNpdDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzanVuY3RpdmVfbm9ybWFsX2Zvcm1cbiAqL1xuZnVuY3Rpb24gaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0oZmlsdGVyKSB7XG4gICAgcmV0dXJuIChpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikgfHxcbiAgICAgICAgaXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSB8fFxuICAgICAgICBpc0Rpc2p1bmN0aW9uT2ZGaWVsZEZpbHRlcnNBbmRGbGF0Q29uanVuY3Rpb25zKGZpbHRlcikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZpbHRlciBpcyB0aGUgZGlzanVuY3Rpb24gb2Ygb25lIG9yIG1vcmUgXCJmbGF0IGNvbmp1bmN0aW9uc1wiIGFuZFxuICogZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMCkgfHwgKGI9PTIwICYmIGM9PTMwKVxuICovXG5mdW5jdGlvbiBpc0Rpc2p1bmN0aW9uT2ZGaWVsZEZpbHRlcnNBbmRGbGF0Q29uanVuY3Rpb25zKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24oZmlsdGVyKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2YgZmlsdGVyLmdldEZpbHRlcnMoKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNTaW5nbGVGaWVsZEZpbHRlcihzdWJGaWx0ZXIpICYmICFpc0ZsYXRDb25qdW5jdGlvbihzdWJGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGZpbHRlcikge1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5maWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShmaWx0ZXIuZmlsdGVyc1swXSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgRE5GIGZvciBlYWNoIG9mIHRoZSBzdWJmaWx0ZXJzIGZpcnN0XG4gICAgY29uc3QgcmVzdWx0ID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKHN1YmZpbHRlcikpO1xuICAgIGxldCBuZXdGaWx0ZXIgPSBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHJlc3VsdCwgZmlsdGVyLm9wKTtcbiAgICBuZXdGaWx0ZXIgPSBhcHBseUFzc29jaWF0aW9uKG5ld0ZpbHRlcik7XG4gICAgaWYgKGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKG5ld0ZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ld0ZpbHRlcjtcbiAgICB9XG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xuICAgIGhhcmRBc3NlcnQoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihuZXdGaWx0ZXIpKTtcbiAgICBoYXJkQXNzZXJ0KG5ld0ZpbHRlci5maWx0ZXJzLmxlbmd0aCA+IDEpO1xuICAgIHJldHVybiBuZXdGaWx0ZXIuZmlsdGVycy5yZWR1Y2UoKHJ1bm5pbmdSZXN1bHQsIGZpbHRlcikgPT4gYXBwbHlEaXN0cmlidXRpb24ocnVubmluZ1Jlc3VsdCwgZmlsdGVyKSk7XG59XG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbihsaHMsIHJocykge1xuICAgIGhhcmRBc3NlcnQobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgbGhzIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBoYXJkQXNzZXJ0KHJocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IHJocyBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgaWYgKHJocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgICAgICAvLyBGaWVsZEZpbHRlciBGaWVsZEZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIEZpZWxkRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhyaHMsIGxocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb21wb3NpdGVGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkNvbXBvc2l0ZUZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbkZpZWxkRmlsdGVycyhsaHMsIHJocykge1xuICAgIC8vIENvbmp1bmN0aW9uIGRpc3RyaWJ1dGlvbiBmb3IgdHdvIGZpZWxkIGZpbHRlcnMgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIHRoZW0uXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoW2xocywgcmhzXSwgXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8pO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKSB7XG4gICAgaGFyZEFzc2VydChsaHMuZmlsdGVycy5sZW5ndGggPiAwICYmIHJocy5maWx0ZXJzLmxlbmd0aCA+IDApO1xuICAgIC8vIFRoZXJlIGFyZSBmb3VyIGNhc2VzOlxuICAgIC8vIChBICYgQikgJiAoQyAmIEQpIC0tPiAoQSAmIEIgJiBDICYgRClcbiAgICAvLyAoQSAmIEIpICYgKEMgfCBEKSAtLT4gKEEgJiBCICYgQykgfCAoQSAmIEIgJiBEKVxuICAgIC8vIChBIHwgQikgJiAoQyAmIEQpIC0tPiAoQyAmIEQgJiBBKSB8IChDICYgRCAmIEIpXG4gICAgLy8gKEEgfCBCKSAmIChDIHwgRCkgLS0+IChBICYgQykgfCAoQSAmIEQpIHwgKEIgJiBDKSB8IChCICYgRClcbiAgICAvLyBDYXNlIDEgaXMgYSBtZXJnZS5cbiAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihsaHMpICYmIGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24ocmhzKSkge1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhsaHMsIHJocy5nZXRGaWx0ZXJzKCkpO1xuICAgIH1cbiAgICAvLyBDYXNlIDIsMyw0IGFsbCBoYXZlIGF0IGxlYXN0IG9uZSBzaWRlIChsaHMgb3IgcmhzKSB0aGF0IGlzIGEgZGlzanVuY3Rpb24uIEluIGFsbCB0aHJlZSBjYXNlc1xuICAgIC8vIHdlIHNob3VsZCB0YWtlIGVhY2ggZWxlbWVudCBvZiB0aGUgZGlzanVuY3Rpb24gYW5kIGRpc3RyaWJ1dGUgaXQgb3ZlciB0aGUgb3RoZXIgc2lkZSwgYW5kXG4gICAgLy8gcmV0dXJuIHRoZSBkaXNqdW5jdGlvbiBvZiB0aGUgZGlzdHJpYnV0aW9uIHJlc3VsdHMuXG4gICAgY29uc3QgZGlzanVuY3Rpb25TaWRlID0gY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihsaHMpID8gbGhzIDogcmhzO1xuICAgIGNvbnN0IG90aGVyU2lkZSA9IGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24obGhzKSA/IHJocyA6IGxocztcbiAgICBjb25zdCByZXN1bHRzID0gZGlzanVuY3Rpb25TaWRlLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihzdWJmaWx0ZXIsIG90aGVyU2lkZSkpO1xuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHJlc3VsdHMsIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLyk7XG59XG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhmaWVsZEZpbHRlciwgY29tcG9zaXRlRmlsdGVyKSB7XG4gICAgLy8gVGhlcmUgYXJlIHR3byBjYXNlczpcbiAgICAvLyBBICYgKEIgJiBDKSAtLT4gKEEgJiBCICYgQylcbiAgICAvLyBBICYgKEIgfCBDKSAtLT4gKEEgJiBCKSB8IChBICYgQylcbiAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpKSB7XG4gICAgICAgIC8vIENhc2UgMVxuICAgICAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhjb21wb3NpdGVGaWx0ZXIsIGZpZWxkRmlsdGVyLmdldEZpbHRlcnMoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDYXNlIDJcbiAgICAgICAgY29uc3QgbmV3RmlsdGVycyA9IGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gYXBwbHlEaXN0cmlidXRpb24oZmllbGRGaWx0ZXIsIHN1YmZpbHRlcikpO1xuICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShuZXdGaWx0ZXJzLCBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi8pO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyB0aGUgYXNzb2NpYXRpdml0eSBwcm9wZXJ0eSB0byB0aGUgZ2l2ZW4gZmlsdGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZmlsdGVyLlxuICpcbiAqIDx1bD5cbiAqICAgPGxpPkEgfCAoQiB8IEMpID09IChBIHwgQikgfCBDID09IChBIHwgQiB8IEMpXG4gKiAgIDxsaT5BICYgKEIgJiBDKSA9PSAoQSAmIEIpICYgQyA9PSAoQSAmIEIgJiBDKVxuICogPC91bD5cbiAqXG4gKiA8cD5Gb3IgbW9yZSBpbmZvLCB2aXNpdDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXNzb2NpYXRpdmVfcHJvcGVydHkjUHJvcG9zaXRpb25hbF9sb2dpY1xuICovXG5mdW5jdGlvbiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcikge1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVycyA9IGZpbHRlci5nZXRGaWx0ZXJzKCk7XG4gICAgLy8gSWYgdGhlIGNvbXBvc2l0ZSBmaWx0ZXIgb25seSBjb250YWlucyAxIGZpbHRlciwgYXBwbHkgYXNzb2NpYXRpdml0eSB0byBpdC5cbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXNzb2NpYXRpb24oZmlsdGVyc1swXSk7XG4gICAgfVxuICAgIC8vIEFzc29jaWF0aXZpdHkgYXBwbGllZCB0byBhIGZsYXQgY29tcG9zaXRlIGZpbHRlciByZXN1bHRzIGlzIGl0c2VsZi5cbiAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNGbGF0KGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgLy8gRmlyc3QgYXBwbHkgYXNzb2NpYXRpdml0eSB0byBhbGwgc3ViZmlsdGVycy4gVGhpcyB3aWxsIGluIHR1cm4gcmVjdXJzaXZlbHkgYXBwbHlcbiAgICAvLyBhc3NvY2lhdGl2aXR5IHRvIGFsbCBuZXN0ZWQgY29tcG9zaXRlIGZpbHRlcnMgYW5kIGZpZWxkIGZpbHRlcnMuXG4gICAgY29uc3QgdXBkYXRlZEZpbHRlcnMgPSBmaWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gYXBwbHlBc3NvY2lhdGlvbihzdWJmaWx0ZXIpKTtcbiAgICAvLyBGb3IgY29tcG9zaXRlIHN1YmZpbHRlcnMgdGhhdCBwZXJmb3JtIHRoZSBzYW1lIGtpbmQgb2YgbG9naWNhbCBvcGVyYXRpb24gYXMgYGNvbXBvc2l0ZUZpbHRlcmBcbiAgICAvLyB0YWtlIG91dCB0aGVpciBmaWx0ZXJzIGFuZCBhZGQgdGhlbSB0byBgY29tcG9zaXRlRmlsdGVyYC4gRm9yIGV4YW1wbGU6XG4gICAgLy8gY29tcG9zaXRlRmlsdGVyID0gKEEgfCAoQiB8IEMgfCBEKSlcbiAgICAvLyBjb21wb3NpdGVTdWJmaWx0ZXIgPSAoQiB8IEMgfCBEKVxuICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQyB8IEQpXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBgY29tcG9zaXRlU3ViZmlsdGVyYCBoYXMgYmVlbiBlbGltaW5hdGVkLCBhbmQgaXRzIGZpbHRlcnMgKEIsIEMsIEQpIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSB0b3AtbGV2ZWwgXCJjb21wb3NpdGVGaWx0ZXJcIi5cbiAgICBjb25zdCBuZXdTdWJmaWx0ZXJzID0gW107XG4gICAgdXBkYXRlZEZpbHRlcnMuZm9yRWFjaChzdWJmaWx0ZXIgPT4ge1xuICAgICAgICBpZiAoc3ViZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaChzdWJmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHN1YmZpbHRlci5vcCA9PT0gZmlsdGVyLm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlRmlsdGVyOiAoQSB8IChCIHwgQykpXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiB8IEMpXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IEIgfCBDKVxuICAgICAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaCguLi5zdWJmaWx0ZXIuZmlsdGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGVGaWx0ZXI6IChBIHwgKEIgJiBDKSlcbiAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGVTdWJmaWx0ZXI6IChCICYgQylcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQ6IChBIHwgKEIgJiBDKSlcbiAgICAgICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goc3ViZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChuZXdTdWJmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3U3ViZmlsdGVyc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobmV3U3ViZmlsdGVycywgZmlsdGVyLm9wKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIEluZGV4TWFuYWdlci5cbiAqL1xuY2xhc3MgTWVtb3J5SW5kZXhNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXggPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XG4gICAgfVxuICAgIGFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUGF0aCkge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5hZGQoY29sbGVjdGlvblBhdGgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXguZ2V0RW50cmllcyhjb2xsZWN0aW9uSWQpKTtcbiAgICB9XG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRlbGV0ZUZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgwIC8qIEluZGV4VHlwZS5OT05FICovKTtcbiAgICB9XG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgZ2V0TmV4dENvbGxlY3Rpb25Hcm91cFRvVXBkYXRlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZ2V0TWluT2Zmc2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKEluZGV4T2Zmc2V0Lm1pbigpKTtcbiAgICB9XG4gICAgZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cbi8qKlxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGV4cG9zZWQgYnkgTWVtb3J5SW5kZXhNYW5hZ2VyLlxuICogQWxzbyB1c2VkIGZvciBpbi1tZW1vcnkgY2FjaGluZyBieSBJbmRleGVkRGJJbmRleE1hbmFnZXIgYW5kIGluaXRpYWwgaW5kZXggcG9wdWxhdGlvblxuICogaW4gaW5kZXhlZGRiX3NjaGVtYS50c1xuICovXG5jbGFzcyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluZGV4ID0ge307XG4gICAgfVxuICAgIC8vIFJldHVybnMgZmFsc2UgaWYgdGhlIGVudHJ5IGFscmVhZHkgZXhpc3RlZC5cbiAgICBhZGQoY29sbGVjdGlvblBhdGgpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGNvbGxlY3Rpb25QYXRoLnBvcExhc3QoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdIHx8XG4gICAgICAgICAgICBuZXcgU29ydGVkU2V0KFJlc291cmNlUGF0aC5jb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3QgYWRkZWQgPSAhZXhpc3RpbmdQYXJlbnRzLmhhcyhwYXJlbnRQYXRoKTtcbiAgICAgICAgdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdID0gZXhpc3RpbmdQYXJlbnRzLmFkZChwYXJlbnRQYXRoKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkO1xuICAgIH1cbiAgICBoYXMoY29sbGVjdGlvblBhdGgpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGNvbGxlY3Rpb25QYXRoLnBvcExhc3QoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQYXJlbnRzICYmIGV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XG4gICAgfVxuICAgIGdldEVudHJpZXMoY29sbGVjdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdIHx8XG4gICAgICAgICAgICBuZXcgU29ydGVkU2V0KFJlc291cmNlUGF0aC5jb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzLnRvQXJyYXkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGYgPSAnSW5kZXhlZERiSW5kZXhNYW5hZ2VyJztcbmNvbnN0IEVNUFRZX1ZBTFVFID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4vKipcbiAqIEEgcGVyc2lzdGVkIGltcGxlbWVudGF0aW9uIG9mIEluZGV4TWFuYWdlci5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFVubGlrZSBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXZWIgU0RLIGRvZXMgbm90IG1lbW9pemUgaW5kZXhcbiAqIGRhdGEgYXMgaXQgc3VwcG9ydHMgbXVsdGktdGFiIGFjY2Vzcy5cbiAqL1xuY2xhc3MgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyLCBkYXRhYmFzZUlkKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbi1tZW1vcnkgY29weSBvZiB0aGUgaW5kZXggZW50cmllcyB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc2luY2UgdGhlIFNES1xuICAgICAgICAgKiBsYXVuY2hlZC4gVXNlZCB0byBhdm9pZCByZS13cml0aW5nIHRoZSBzYW1lIGVudHJ5IHJlcGVhdGVkbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgKk5PVCogYSBjb21wbGV0ZSBjYWNoZSBvZiB3aGF0J3MgaW4gcGVyc2lzdGVuY2UgYW5kIHNvIGNhbiBuZXZlciBiZVxuICAgICAgICAgKiB1c2VkIHRvIHNhdGlzZnkgcmVhZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUgPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGZyb20gYSB0YXJnZXQgdG8gaXRzIGVxdWl2YWxlbnQgbGlzdCBvZiBzdWItdGFyZ2V0cy4gRWFjaCBzdWItdGFyZ2V0XG4gICAgICAgICAqIGNvbnRhaW5zIG9ubHkgb25lIHRlcm0gZnJvbSB0aGUgdGFyZ2V0J3MgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0gKERORikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldFRvRG5mU3ViVGFyZ2V0cyA9IG5ldyBPYmplY3RNYXAodCA9PiBjYW5vbmlmeVRhcmdldCh0KSwgKGwsIHIpID0+IHRhcmdldEVxdWFscyhsLCByKSk7XG4gICAgICAgIHRoaXMudWlkID0gdXNlci51aWQgfHwgJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGNvbGxlY3Rpb24gcGFyZW50IGluZGV4LlxuICAgICAqXG4gICAgICogUmVwZWF0ZWQgY2FsbHMgZm9yIHRoZSBzYW1lIGNvbGxlY3Rpb25QYXRoIHNob3VsZCBiZSBhdm9pZGVkIHdpdGhpbiBhXG4gICAgICogdHJhbnNhY3Rpb24gYXMgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIG9ubHkgY2FjaGVzIHdyaXRlcyBvbmNlIGEgdHJhbnNhY3Rpb25cbiAgICAgKiBoYXMgYmVlbiBjb21taXR0ZWQuXG4gICAgICovXG4gICAgYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlLmhhcyhjb2xsZWN0aW9uUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb2xsZWN0aW9uIHRvIHRoZSBpbiBtZW1vcnkgY2FjaGUgb25seSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUuYWRkKGNvbGxlY3Rpb25QYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudCA9IHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBlbmNvZGVSZXNvdXJjZVBhdGgocGFyZW50UGF0aClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KGNvbGxlY3Rpb25QYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2xsZWN0aW9uUGFyZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gW107XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW2NvbGxlY3Rpb25JZCwgJyddLCBbaW1tZWRpYXRlU3VjY2Vzc29yKGNvbGxlY3Rpb25JZCksICcnXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwocmFuZ2UpXG4gICAgICAgICAgICAubmV4dChlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29sbGVjdGlvbklkIGd1YXJkIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgKGFuZCBpc24ndCBhcyBsb25nXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgcnVubmluZyBpbiBhIHJlYWwgYnJvd3NlciksIGJ1dCB0aGVyZSdzIGEgYnVnIGluXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhlZGRic2hpbSB0aGF0IGJyZWFrcyBvdXIgcmFuZ2UgaW4gb3VyIHRlc3RzIHJ1bm5pbmcgaW4gbm9kZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXhlbWNsaW9uL0luZGV4ZWREQlNoaW0vaXNzdWVzLzMzNFxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jb2xsZWN0aW9uSWQgIT09IGNvbGxlY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50UGF0aHMucHVzaChkZWNvZGVSZXNvdXJjZVBhdGgoZW50cnkucGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50UGF0aHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogVmVyaWZ5IHRoYXQgdGhlIGF1dG8taW5jcmVtZW50aW5nIGluZGV4IElEIHdvcmtzIGluXG4gICAgICAgIC8vIFNhZmFyaSAmIEZpcmVmb3guXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGRiSW5kZXggPSB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KTtcbiAgICAgICAgZGVsZXRlIGRiSW5kZXguaW5kZXhJZDsgLy8gYGluZGV4SWRgIGlzIGF1dG8tcG9wdWxhdGVkIGJ5IEluZGV4ZWREYlxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleGVzLmFkZChkYkluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4LmluZGV4U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHQoaW5kZXhJZCA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB0aGlzLnVpZCwgaW5kZXguaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlciwgaW5kZXguaW5kZXhTdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ZXNcbiAgICAgICAgICAgIC5kZWxldGUoaW5kZXguaW5kZXhJZClcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHN0YXRlcy5kZWxldGUoSURCS2V5UmFuZ2UuYm91bmQoW2luZGV4LmluZGV4SWRdLCBbaW5kZXguaW5kZXhJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBlbnRyaWVzLmRlbGV0ZShJREJLZXlSYW5nZS5ib3VuZChbaW5kZXguaW5kZXhJZF0sIFtpbmRleC5pbmRleElkICsgMV0sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpKSk7XG4gICAgfVxuICAgIGRlbGV0ZUFsbEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gaW5kZXhlc1xuICAgICAgICAgICAgLmRlbGV0ZUFsbCgpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBlbnRyaWVzLmRlbGV0ZUFsbCgpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gc3RhdGVzLmRlbGV0ZUFsbCgpKTtcbiAgICB9XG4gICAgY3JlYXRlVGFyZ2V0SW5kZXhlcyh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXhUeXBlKHRyYW5zYWN0aW9uLCBzdWJUYXJnZXQpLm5leHQodHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8gfHwgdHlwZSA9PT0gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleE1hdGNoZXIgPSBuZXcgVGFyZ2V0SW5kZXhNYXRjaGVyKHN1YlRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSB0YXJnZXRJbmRleE1hdGNoZXIuYnVpbGRUYXJnZXRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGxldCBjYW5TZXJ2ZVRhcmdldCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICBjYW5TZXJ2ZVRhcmdldCAmJiAoY2FuU2VydmVUYXJnZXQgPSAhIWluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnNldChzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2FuU2VydmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhlcywgKGluZGV4LCBzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRmLCBgVXNpbmcgaW5kZXggJHtmaWVsZEluZGV4VG9TdHJpbmcoaW5kZXgpfSB0byBleGVjdXRlICR7Y2Fub25pZnlUYXJnZXQodGFyZ2V0KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZXMgPSB0YXJnZXRHZXRBcnJheVZhbHVlcyhzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90SW5WYWx1ZXMgPSB0YXJnZXRHZXROb3RJblZhbHVlcyhzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHRhcmdldEdldExvd2VyQm91bmQoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0YXJnZXRHZXRVcHBlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgbG93ZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmRFbmNvZGVkID0gdGhpcy5lbmNvZGVCb3VuZChpbmRleCwgc3ViVGFyZ2V0LCB1cHBlckJvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90SW5FbmNvZGVkID0gdGhpcy5lbmNvZGVWYWx1ZXMoaW5kZXgsIHN1YlRhcmdldCwgbm90SW5WYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFJhbmdlcyA9IHRoaXMuZ2VuZXJhdGVJbmRleFJhbmdlcyhpbmRleC5pbmRleElkLCBhcnJheVZhbHVlcywgbG93ZXJCb3VuZEVuY29kZWQsIGxvd2VyQm91bmQuaW5jbHVzaXZlLCB1cHBlckJvdW5kRW5jb2RlZCwgdXBwZXJCb3VuZC5pbmNsdXNpdmUsIG5vdEluRW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleFJhbmdlcywgKGluZGV4UmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubG9hZEZpcnN0KGluZGV4UmFuZ2UsIHRhcmdldC5saW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmV4dChlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhlbnRyeS5kb2N1bWVudEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdLZXlzLmhhcyhkb2N1bWVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5cyA9IGV4aXN0aW5nS2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHN1YlRhcmdldHMgPSB0aGlzLnRhcmdldFRvRG5mU3ViVGFyZ2V0cy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHN1YlRhcmdldHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJUYXJnZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1YlRhcmdldHMgPSBbdGFyZ2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGltcGxpY2l0IEFORCBvcGVyYXRpb24gYmV0d2VlbiBhbGwgdGhlIGZpbHRlcnMgc3RvcmVkIGluIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIGNvbnN0IGRuZiA9IGdldERuZlRlcm1zKENvbXBvc2l0ZUZpbHRlci5jcmVhdGUodGFyZ2V0LmZpbHRlcnMsIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovKSk7XG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gZG5mLm1hcCh0ZXJtID0+IG5ld1RhcmdldCh0YXJnZXQucGF0aCwgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCwgdGFyZ2V0Lm9yZGVyQnksIHRlcm0uZ2V0RmlsdGVycygpLCB0YXJnZXQubGltaXQsIHRhcmdldC5zdGFydEF0LCB0YXJnZXQuZW5kQXQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldFRvRG5mU3ViVGFyZ2V0cy5zZXQodGFyZ2V0LCBzdWJUYXJnZXRzKTtcbiAgICAgICAgcmV0dXJuIHN1YlRhcmdldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBrZXkgcmFuZ2UgcXVlcnkgb24gYERiSW5kZXhFbnRyeVN0b3JlYCB0aGF0IHVuaW9ucyBhbGxcbiAgICAgKiBib3VuZHMuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbmRleFJhbmdlcyhpbmRleElkLCBhcnJheVZhbHVlcywgbG93ZXJCb3VuZHMsIGxvd2VyQm91bmRJbmNsdXNpdmUsIHVwcGVyQm91bmRzLCB1cHBlckJvdW5kSW5jbHVzaXZlLCBub3RJblZhbHVlcykge1xuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHRvdGFsIGluZGV4IHNjYW5zIHdlIHVuaW9uIHRvZ2V0aGVyLiBUaGlzIGlzIHNpbWlsYXIgdG8gYVxuICAgICAgICAvLyBkaXN0cmlidXRlZCBub3JtYWwgZm9ybSwgYnV0IGFkYXB0ZWQgZm9yIGFycmF5IHZhbHVlcy4gV2UgY3JlYXRlIGEgc2luZ2xlXG4gICAgICAgIC8vIGluZGV4IHJhbmdlIHBlciB2YWx1ZSBpbiBhbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTlkgZmlsdGVyXG4gICAgICAgIC8vIGNvbWJpbmVkIHdpdGggdGhlIHZhbHVlcyBmcm9tIHRoZSBxdWVyeSBib3VuZHMuXG4gICAgICAgIGNvbnN0IHRvdGFsU2NhbnMgPSAoYXJyYXlWYWx1ZXMgIT0gbnVsbCA/IGFycmF5VmFsdWVzLmxlbmd0aCA6IDEpICpcbiAgICAgICAgICAgIE1hdGgubWF4KGxvd2VyQm91bmRzLmxlbmd0aCwgdXBwZXJCb3VuZHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc2NhbnNQZXJBcnJheUVsZW1lbnQgPSB0b3RhbFNjYW5zIC8gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKTtcbiAgICAgICAgY29uc3QgaW5kZXhSYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNjYW5zOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBhcnJheVZhbHVlc1xuICAgICAgICAgICAgICAgID8gdGhpcy5lbmNvZGVTaW5nbGVFbGVtZW50KGFycmF5VmFsdWVzW2kgLyBzY2Fuc1BlckFycmF5RWxlbWVudF0pXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9WQUxVRTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0aGlzLmdlbmVyYXRlTG93ZXJCb3VuZChpbmRleElkLCBhcnJheVZhbHVlLCBsb3dlckJvdW5kc1tpICUgc2NhbnNQZXJBcnJheUVsZW1lbnRdLCBsb3dlckJvdW5kSW5jbHVzaXZlKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0aGlzLmdlbmVyYXRlVXBwZXJCb3VuZChpbmRleElkLCBhcnJheVZhbHVlLCB1cHBlckJvdW5kc1tpICUgc2NhbnNQZXJBcnJheUVsZW1lbnRdLCB1cHBlckJvdW5kSW5jbHVzaXZlKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdEluQm91bmQgPSBub3RJblZhbHVlcy5tYXAobm90SW4gPT4gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbm90SW4sIFxuICAgICAgICAgICAgLyogaW5jbHVzaXZlPSAqLyB0cnVlKSk7XG4gICAgICAgICAgICBpbmRleFJhbmdlcy5wdXNoKC4uLnRoaXMuY3JlYXRlUmFuZ2UobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgbm90SW5Cb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleFJhbmdlcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlcyB0aGUgbG93ZXIgYm91bmQgZm9yIGBhcnJheVZhbHVlYCBhbmQgYGRpcmVjdGlvbmFsVmFsdWVgLiAqL1xuICAgIGdlbmVyYXRlTG93ZXJCb3VuZChpbmRleElkLCBhcnJheVZhbHVlLCBkaXJlY3Rpb25hbFZhbHVlLCBpbmNsdXNpdmUpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgSW5kZXhFbnRyeShpbmRleElkLCBEb2N1bWVudEtleS5lbXB0eSgpLCBhcnJheVZhbHVlLCBkaXJlY3Rpb25hbFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGluY2x1c2l2ZSA/IGVudHJ5IDogZW50cnkuc3VjY2Vzc29yKCk7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZXMgdGhlIHVwcGVyIGJvdW5kIGZvciBgYXJyYXlWYWx1ZWAgYW5kIGBkaXJlY3Rpb25hbFZhbHVlYC4gKi9cbiAgICBnZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBpbmNsdXNpdmUgPyBlbnRyeS5zdWNjZXNzb3IoKSA6IGVudHJ5O1xuICAgIH1cbiAgICBnZXRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXhNYXRjaGVyID0gbmV3IFRhcmdldEluZGV4TWF0Y2hlcih0YXJnZXQpO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0YXJnZXQuY29sbGVjdGlvbkdyb3VwICE9IG51bGxcbiAgICAgICAgICAgID8gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cFxuICAgICAgICAgICAgOiB0YXJnZXQucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkubmV4dChpbmRleGVzID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgaW5kZXggd2l0aCB0aGUgbW9zdCBudW1iZXIgb2Ygc2VnbWVudHMuXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0YXJnZXRJbmRleE1hdGNoZXIuc2VydmVkQnlJbmRleChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICYmXG4gICAgICAgICAgICAgICAgICAgICghaW5kZXggfHwgY2FuZGlkYXRlLmZpZWxkcy5sZW5ndGggPiBpbmRleC5maWVsZHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICBsZXQgaW5kZXhUeXBlID0gMiAvKiBJbmRleFR5cGUuRlVMTCAqLztcbiAgICAgICAgY29uc3Qgc3ViVGFyZ2V0cyA9IHRoaXMuZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goc3ViVGFyZ2V0cywgKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KS5uZXh0KGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDAgLyogSW5kZXhUeXBlLk5PTkUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4VHlwZSAhPT0gMCAvKiBJbmRleFR5cGUuTk9ORSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRleC5maWVsZHMubGVuZ3RoIDwgdGFyZ2V0R2V0U2VnbWVudENvdW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUeXBlID0gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIGhhdmUgbW9yZSB0aGFuIG9uZSBzdWItdGFyZ2V0IChvbmUgc3ViLXRhcmdldCBwZXIgRE5GIHRlcm0pLiBXZSBjdXJyZW50bHkgY29uc2lkZXJcbiAgICAgICAgICAgIC8vIE9SIHF1ZXJpZXMgdGhhdCBoYXZlIGEgYGxpbWl0YCB0byBoYXZlIGEgcGFydGlhbCBpbmRleC4gRm9yIHN1Y2ggcXVlcmllcyB3ZSBwZXJmb3JtIHNvcnRpbmdcbiAgICAgICAgICAgIC8vIGFuZCBhcHBseSB0aGUgbGltaXQgaW4gbWVtb3J5IGFzIGEgcG9zdC1wcm9jZXNzaW5nIHN0ZXAuXG4gICAgICAgICAgICBpZiAodGFyZ2V0SGFzTGltaXQodGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgIHN1YlRhcmdldHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9PT0gMiAvKiBJbmRleFR5cGUuRlVMTCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4VHlwZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJ5dGUgZW5jb2RlZCBmb3JtIG9mIHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgaW4gdGhlIGZpZWxkIGluZGV4LlxuICAgICAqIFJldHVybnMgYG51bGxgIGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGFsbCBmaWVsZHMgc3BlY2lmaWVkIGluIHRoZVxuICAgICAqIGluZGV4LlxuICAgICAqL1xuICAgIGVuY29kZURpcmVjdGlvbmFsRWxlbWVudHMoZmllbGRJbmRleCwgZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBkb2N1bWVudC5kYXRhLmZpZWxkKHNlZ21lbnQuZmllbGRQYXRoKTtcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25hbEVuY29kZXIgPSBlbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKTtcbiAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKGZpZWxkLCBkaXJlY3Rpb25hbEVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyLmVuY29kZWRCeXRlcygpO1xuICAgIH1cbiAgICAvKiogRW5jb2RlcyBhIHNpbmdsZSB2YWx1ZSB0byB0aGUgYXNjZW5kaW5nIGluZGV4IGZvcm1hdC4gKi9cbiAgICBlbmNvZGVTaW5nbGVFbGVtZW50KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlci5mb3JLaW5kKDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLykpO1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbmNvZGVkIGZvcm0gb2YgdGhlIGRvY3VtZW50IGtleSB0aGF0IHNvcnRzIGJhc2VkIG9uIHRoZSBrZXlcbiAgICAgKiBvcmRlcmluZyBvZiB0aGUgZmllbGQgaW5kZXguXG4gICAgICovXG4gICAgZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XG4gICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKHJlZlZhbHVlKHRoaXMuZGF0YWJhc2VJZCwgZG9jdW1lbnRLZXkpLCBlbmNvZGVyLmZvcktpbmQoZmllbGRJbmRleEdldEtleU9yZGVyKGZpZWxkSW5kZXgpKSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVyLmVuY29kZWRCeXRlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBmaWVsZCB2YWx1ZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGluIGB0YXJnZXRgLlxuICAgICAqIEZvciBJTiBxdWVyaWVzLCBhIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGVuY29kZVZhbHVlcyhmaWVsZEluZGV4LCB0YXJnZXQsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuY29kZXJzID0gW107XG4gICAgICAgIGVuY29kZXJzLnB1c2gobmV3IEluZGV4Qnl0ZUVuY29kZXIoKSk7XG4gICAgICAgIGxldCB2YWx1ZUlkeCA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHgrK107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kZXIgb2YgZW5jb2RlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luRmlsdGVyKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXJzID0gdGhpcy5leHBhbmRJbmRleFZhbHVlcyhlbmNvZGVycywgc2VnbWVudCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XG4gICAgICAgICAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKHZhbHVlLCBkaXJlY3Rpb25hbEVuY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBib3VuZHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGluIGB0YXJnZXRgLiBGb3IgSU5cbiAgICAgKiBxdWVyaWVzLCBhIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGVuY29kZUJvdW5kKGZpZWxkSW5kZXgsIHRhcmdldCwgYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlVmFsdWVzKGZpZWxkSW5kZXgsIHRhcmdldCwgYm91bmQucG9zaXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgYnl0ZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGVuY29kZXJzLiAqL1xuICAgIGdldEVuY29kZWRCeXRlcyhlbmNvZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gZW5jb2RlcnNbaV0uZW5jb2RlZEJ5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNlcGFyYXRlIGVuY29kZXIgZm9yIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXBwZW5kcyBlYWNoIHZhbHVlIHRvIGFsbCBleGlzdGluZyBlbmNvZGVycyAoZS5nLiBmaWx0ZXIoXCJhXCIsXG4gICAgICogXCI9PVwiLCBcImExXCIpLmZpbHRlcihcImJcIiwgXCJpblwiLCBbXCJiMVwiLCBcImIyXCJdKSBiZWNvbWVzIFtcImExLGIxXCIsIFwiYTEsYjJcIl0pLiBBXG4gICAgICogbGlzdCBvZiBuZXcgZW5jb2RlcnMgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVzID0gWy4uLmVuY29kZXJzXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5RWxlbWVudCBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWRFbmNvZGVyID0gbmV3IEluZGV4Qnl0ZUVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICBjbG9uZWRFbmNvZGVyLnNlZWQocHJlZml4LmVuY29kZWRCeXRlcygpKTtcbiAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShhcnJheUVsZW1lbnQsIGNsb25lZEVuY29kZXIuZm9yS2luZChzZWdtZW50LmtpbmQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY2xvbmVkRW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlzSW5GaWx0ZXIodGFyZ2V0LCBmaWVsZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuICEhdGFyZ2V0LmZpbHRlcnMuZmluZChmID0+IGYgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJlxuICAgICAgICAgICAgZi5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkgJiZcbiAgICAgICAgICAgIChmLm9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgZi5vcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pKTtcbiAgICB9XG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uR3JvdXBcbiAgICAgICAgICAgID8gaW5kZXhlcy5sb2FkQWxsKERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXgsIElEQktleVJhbmdlLmJvdW5kKGNvbGxlY3Rpb25Hcm91cCwgY29sbGVjdGlvbkdyb3VwKSlcbiAgICAgICAgICAgIDogaW5kZXhlcy5sb2FkQWxsKCkpLm5leHQoaW5kZXhDb25maWdzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluZGV4Q29uZmlncywgKGluZGV4Q29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0KFtpbmRleENvbmZpZy5pbmRleElkLCB0aGlzLnVpZF0pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGluZGV4U3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcm9tRGJJbmRleENvbmZpZ3VyYXRpb24oaW5kZXhDb25maWcsIGluZGV4U3RhdGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pLm5leHQoaW5kZXhlcyA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ZXMuc29ydCgobCwgcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtcCA9IGwuaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlciAtIHIuaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gY21wXG4gICAgICAgICAgICAgICAgICAgIDogcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNvbGxlY3Rpb25Hcm91cCwgci5jb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlc1swXS5jb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikubmV4dChuZXh0U2VxdWVuY2VOdW1iZXIgPT4gaW5kZXhlc1xuICAgICAgICAgICAgLmxvYWRBbGwoRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleCwgSURCS2V5UmFuZ2UuYm91bmQoY29sbGVjdGlvbkdyb3VwLCBjb2xsZWN0aW9uR3JvdXApKVxuICAgICAgICAgICAgLm5leHQoY29uZmlncyA9PiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChjb25maWdzLCAoY29uZmlnKSA9PiBzdGF0ZXMucHV0KHRvRGJJbmRleFN0YXRlKGNvbmZpZy5pbmRleElkLCB0aGlzLnVpZCwgbmV4dFNlcXVlbmNlTnVtYmVyLCBvZmZzZXQpKSkpKTtcbiAgICB9XG4gICAgdXBkYXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudHMpIHtcbiAgICAgICAgLy8gUG9ydGluZyBOb3RlOiBgZ2V0RmllbGRJbmRleGVzKClgIG9uIFdlYiBkb2VzIG5vdCBjYWNoZSBpbmRleCBsb29rdXBzIGFzXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHVzZWQgYWNyb3NzIGRpZmZlcmVudCBJbmRleGVkREIgdHJhbnNhY3Rpb25zLiBBcyBhbnkgY2FjaGVkXG4gICAgICAgIC8vIGRhdGEgbWlnaHQgYmUgaW52YWxpZGF0ZWQgYnkgb3RoZXIgbXVsdGktdGFiIGNsaWVudHMsIHdlIGNhbiBvbmx5IHRydXN0XG4gICAgICAgIC8vIGRhdGEgd2l0aGluIGEgc2luZ2xlIEluZGV4ZWREQiB0cmFuc2FjdGlvbi4gV2UgdGhlcmVmb3JlIGFkZCBhIGNhY2hlXG4gICAgICAgIC8vIGhlcmUuXG4gICAgICAgIGNvbnN0IG1lbW9pemVkSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGRvY3VtZW50cywgKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzID0gbWVtb2l6ZWRJbmRleGVzLmdldChrZXkuY29sbGVjdGlvbkdyb3VwKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXhlcyA9IG1lbW9pemVkQ29sbGVjdGlvbkluZGV4ZXNcbiAgICAgICAgICAgICAgICA/IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG1lbW9pemVkQ29sbGVjdGlvbkluZGV4ZXMpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwga2V5LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRJbmRleGVzLm5leHQoZmllbGRJbmRleGVzID0+IHtcbiAgICAgICAgICAgICAgICBtZW1vaXplZEluZGV4ZXMuc2V0KGtleS5jb2xsZWN0aW9uR3JvdXAsIGZpZWxkSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGZpZWxkSW5kZXhlcywgKGZpZWxkSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhpc3RpbmdJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGtleSwgZmllbGRJbmRleCkubmV4dChleGlzdGluZ0VudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RW50cmllcyA9IHRoaXMuY29tcHV0ZUluZGV4RW50cmllcyhkb2MsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0VudHJpZXMuaXNFcXVhbChuZXdFbnRyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUVudHJpZXModHJhbnNhY3Rpb24sIGRvYywgZmllbGRJbmRleCwgZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzLnB1dCh7XG4gICAgICAgICAgICBpbmRleElkOiBpbmRleEVudHJ5LmluZGV4SWQsXG4gICAgICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICAgICAgYXJyYXlWYWx1ZTogaW5kZXhFbnRyeS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uYWxWYWx1ZTogaW5kZXhFbnRyeS5kaXJlY3Rpb25hbFZhbHVlLFxuICAgICAgICAgICAgb3JkZXJlZERvY3VtZW50S2V5OiB0aGlzLmVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50LmtleSksXG4gICAgICAgICAgICBkb2N1bWVudEtleTogZG9jdW1lbnQua2V5LnBhdGgudG9BcnJheSgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGVJbmRleEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgaW5kZXhFbnRyeSkge1xuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXMuZGVsZXRlKFtcbiAgICAgICAgICAgIGluZGV4RW50cnkuaW5kZXhJZCxcbiAgICAgICAgICAgIHRoaXMudWlkLFxuICAgICAgICAgICAgaW5kZXhFbnRyeS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgaW5kZXhFbnRyeS5kaXJlY3Rpb25hbFZhbHVlLFxuICAgICAgICAgICAgdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudC5rZXkpLFxuICAgICAgICAgICAgZG9jdW1lbnQua2V5LnBhdGgudG9BcnJheSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBnZXRFeGlzdGluZ0luZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIGZpZWxkSW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KFtcbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4LmluZGV4SWQsXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudEtleSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0sIChfLCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuYWRkKG5ldyBJbmRleEVudHJ5KGZpZWxkSW5kZXguaW5kZXhJZCwgZG9jdW1lbnRLZXksIGVudHJ5LmFycmF5VmFsdWUsIGVudHJ5LmRpcmVjdGlvbmFsVmFsdWUpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyB0aGUgaW5kZXggZW50cmllcyBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xuICAgIGNvbXB1dGVJbmRleEVudHJpZXMoZG9jdW1lbnQsIGZpZWxkSW5kZXgpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBuZXcgU29ydGVkU2V0KGluZGV4RW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxWYWx1ZSA9IHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxFbGVtZW50cyhmaWVsZEluZGV4LCBkb2N1bWVudCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb25hbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5U2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCk7XG4gICAgICAgIGlmIChhcnJheVNlZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5kYXRhLmZpZWxkKGFycmF5U2VnbWVudC5maWVsZFBhdGgpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcnJheVZhbHVlIG9mIHZhbHVlLmFycmF5VmFsdWUudmFsdWVzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50LmtleSwgdGhpcy5lbmNvZGVTaW5nbGVFbGVtZW50KGFycmF5VmFsdWUpLCBkaXJlY3Rpb25hbFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuYWRkKG5ldyBJbmRleEVudHJ5KGZpZWxkSW5kZXguaW5kZXhJZCwgZG9jdW1lbnQua2V5LCBFTVBUWV9WQUxVRSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBpbmRleCBlbnRyaWVzIGZvciB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgYnkgZGVsZXRpbmcgZW50cmllc1xuICAgICAqIHRoYXQgYXJlIG5vIGxvbmdlciByZWZlcmVuY2VkIGluIGBuZXdFbnRyaWVzYCBhbmQgYWRkaW5nIGFsbCBuZXdseSBhZGRlZFxuICAgICAqIGVudHJpZXMuXG4gICAgICovXG4gICAgdXBkYXRlRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcykge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGYsIFwiVXBkYXRpbmcgaW5kZXggZW50cmllcyBmb3IgZG9jdW1lbnQgJyVzJ1wiLCBkb2N1bWVudC5rZXkpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBkaWZmU29ydGVkU2V0cyhleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMsIGluZGV4RW50cnlDb21wYXJhdG9yLCBcbiAgICAgICAgLyogb25BZGQ9ICovIGVudHJ5ID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5hZGRJbmRleEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZW50cnkpKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8qIG9uUmVtb3ZlPSAqLyBlbnRyeSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGVudHJ5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXROZXh0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IG5leHRTZXF1ZW5jZU51bWJlciA9IDE7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBzdGF0ZXNcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS51cHBlckJvdW5kKFt0aGlzLnVpZCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdKVxuICAgICAgICB9LCAoXywgc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZG9uZSgpO1xuICAgICAgICAgICAgbmV4dFNlcXVlbmNlTnVtYmVyID0gc3RhdGUuc2VxdWVuY2VOdW1iZXIgKyAxO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbmV4dFNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXQgb2YgSURCIHJhbmdlcyB0aGF0IHNwbGl0cyB0aGUgZXhpc3RpbmcgcmFuZ2UgYW5kIGV4Y2x1ZGVzXG4gICAgICogYW55IHZhbHVlcyB0aGF0IG1hdGNoIHRoZSBgbm90SW5WYWx1ZWAgZnJvbSB0aGVzZSByYW5nZXMuIEFzIGFuIGV4YW1wbGUsXG4gICAgICogJ1tmb28gPiAyICYmIGZvbyAhPSAzXWAgYmVjb21lcyAgYFtmb28gPiAyICYmIDwgMywgZm9vID4gM11gLlxuICAgICAqL1xuICAgIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgbm90SW5WYWx1ZXMpIHtcbiAgICAgICAgLy8gVGhlIG5vdEluIHZhbHVlcyBuZWVkIHRvIGJlIHNvcnRlZCBhbmQgdW5pcXVlIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhXG4gICAgICAgIC8vIHNvcnRlZCBzZXQgb2Ygbm9uLW92ZXJsYXBwaW5nIHJhbmdlcy5cbiAgICAgICAgbm90SW5WYWx1ZXMgPSBub3RJblZhbHVlc1xuICAgICAgICAgICAgLnNvcnQoKGwsIHIpID0+IGluZGV4RW50cnlDb21wYXJhdG9yKGwsIHIpKVxuICAgICAgICAgICAgLmZpbHRlcigoZWwsIGksIHZhbHVlcykgPT4gIWkgfHwgaW5kZXhFbnRyeUNvbXBhcmF0b3IoZWwsIHZhbHVlc1tpIC0gMV0pICE9PSAwKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gW107XG4gICAgICAgIGJvdW5kcy5wdXNoKGxvd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBub3RJblZhbHVlIG9mIG5vdEluVmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBjbXBUb0xvd2VyID0gaW5kZXhFbnRyeUNvbXBhcmF0b3Iobm90SW5WYWx1ZSwgbG93ZXIpO1xuICAgICAgICAgICAgY29uc3QgY21wVG9VcHBlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIHVwcGVyKTtcbiAgICAgICAgICAgIGlmIChjbXBUb0xvd2VyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIGlzIHRoZSBsb3dlciBib3VuZC4gV2UgdGhlcmVmb3JlIG5lZWQgdG8gcmFpc2UgdGhlIGJvdW5kXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG5leHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgYm91bmRzWzBdID0gbG93ZXIuc3VjY2Vzc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXBUb0xvd2VyID4gMCAmJiBjbXBUb1VwcGVyIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgIGJvdW5kcy5wdXNoKG5vdEluVmFsdWUpO1xuICAgICAgICAgICAgICAgIGJvdW5kcy5wdXNoKG5vdEluVmFsdWUuc3VjY2Vzc29yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wVG9VcHBlciA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgKGFuZCBhbGwgZm9sbG93aW5nIHZhbHVlcykgYXJlIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib3VuZHMucHVzaCh1cHBlcik7XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIHR3byBib3VuZHMgdGhhdCB3aWxsIGNyZWF0ZSBhbiB1bm1hdGNoYWJsZSBrZXkgcmFuZ2UsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHJldHVybiBhbiBlbXB0eSBzZXQgb2Yga2V5IHJhbmdlcy5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2VNYXRjaGFibGUoYm91bmRzW2ldLCBib3VuZHNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSBbXG4gICAgICAgICAgICAgICAgYm91bmRzW2ldLmluZGV4SWQsXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgYm91bmRzW2ldLmFycmF5VmFsdWUsXG4gICAgICAgICAgICAgICAgYm91bmRzW2ldLmRpcmVjdGlvbmFsVmFsdWUsXG4gICAgICAgICAgICAgICAgRU1QVFlfVkFMVUUsXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gW1xuICAgICAgICAgICAgICAgIGJvdW5kc1tpICsgMV0uaW5kZXhJZCxcbiAgICAgICAgICAgICAgICB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICBib3VuZHNbaSArIDFdLmFycmF5VmFsdWUsXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5kaXJlY3Rpb25hbFZhbHVlLFxuICAgICAgICAgICAgICAgIEVNUFRZX1ZBTFVFLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goSURCS2V5UmFuZ2UuYm91bmQobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGlzUmFuZ2VNYXRjaGFibGUobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgICAgICAvLyBJZiBsb3dlciBib3VuZCBpcyBncmVhdGVyIHRoYW4gdGhlIHVwcGVyIGJvdW5kLCB0aGVuIHRoZSBrZXlcbiAgICAgICAgLy8gcmFuZ2UgY2FuIG5ldmVyIGJlIG1hdGNoZWQuXG4gICAgICAgIHJldHVybiBpbmRleEVudHJ5Q29tcGFyYXRvcihsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA+IDA7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkubmV4dChnZXRNaW5PZmZzZXRGcm9tRmllbGRJbmRleGVzKTtcbiAgICB9XG4gICAgZ2V0TWluT2Zmc2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5tYXBBcnJheSh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4gdGhpcy5nZXRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBzdWJUYXJnZXQpLm5leHQoaW5kZXggPT4gaW5kZXggPyBpbmRleCA6IGZhaWwoKSkpLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNvbGxlY3Rpb25QYXJlbnRzXG4gKiBkb2N1bWVudCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggZW50cnkgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBpbmRleEVudHJpZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4RW50cnlTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IHN0YXRlIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhTdGF0ZVN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhTdGF0ZVN0b3JlKTtcbn1cbmZ1bmN0aW9uIGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMoZmllbGRJbmRleGVzKSB7XG4gICAgaGFyZEFzc2VydChmaWVsZEluZGV4ZXMubGVuZ3RoICE9PSAwKTtcbiAgICBsZXQgbWluT2Zmc2V0ID0gZmllbGRJbmRleGVzWzBdLmluZGV4U3RhdGUub2Zmc2V0O1xuICAgIGxldCBtYXhCYXRjaElkID0gbWluT2Zmc2V0Lmxhcmdlc3RCYXRjaElkO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmllbGRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5ld09mZnNldCA9IGZpZWxkSW5kZXhlc1tpXS5pbmRleFN0YXRlLm9mZnNldDtcbiAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdPZmZzZXQsIG1pbk9mZnNldCkgPCAwKSB7XG4gICAgICAgICAgICBtaW5PZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEJhdGNoSWQgPCBuZXdPZmZzZXQubGFyZ2VzdEJhdGNoSWQpIHtcbiAgICAgICAgICAgIG1heEJhdGNoSWQgPSBuZXdPZmZzZXQubGFyZ2VzdEJhdGNoSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChtaW5PZmZzZXQucmVhZFRpbWUsIG1pbk9mZnNldC5kb2N1bWVudEtleSwgbWF4QmF0Y2hJZCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERlbGV0ZSBhIG11dGF0aW9uIGJhdGNoIGFuZCB0aGUgYXNzb2NpYXRlZCBkb2N1bWVudCBtdXRhdGlvbnMuXG4gKiBAcmV0dXJucyBBIFBlcnNpc3RlbmNlUHJvbWlzZSBvZiB0aGUgZG9jdW1lbnQgbXV0YXRpb25zIHRoYXQgd2VyZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgdXNlcklkLCBiYXRjaCkge1xuICAgIGNvbnN0IG11dGF0aW9uU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xuICAgIGNvbnN0IGluZGV4VHhuID0gdHhuLnN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2Uub25seShiYXRjaC5iYXRjaElkKTtcbiAgICBsZXQgbnVtRGVsZXRlZCA9IDA7XG4gICAgY29uc3QgcmVtb3ZlUHJvbWlzZSA9IG11dGF0aW9uU3RvcmUuaXRlcmF0ZSh7IHJhbmdlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgIG51bURlbGV0ZWQrKztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZXMucHVzaChyZW1vdmVQcm9taXNlLm5leHQoKCkgPT4ge1xuICAgICAgICBoYXJkQXNzZXJ0KG51bURlbGV0ZWQgPT09IDEpO1xuICAgIH0pKTtcbiAgICBjb25zdCByZW1vdmVkRG9jdW1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBiYXRjaC5tdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25LZXkodXNlcklkLCBtdXRhdGlvbi5rZXkucGF0aCwgYmF0Y2guYmF0Y2hJZCk7XG4gICAgICAgIHByb21pc2VzLnB1c2goaW5kZXhUeG4uZGVsZXRlKGluZGV4S2V5KSk7XG4gICAgICAgIHJlbW92ZWREb2N1bWVudHMucHVzaChtdXRhdGlvbi5rZXkpO1xuICAgIH1cbiAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVtb3ZlZERvY3VtZW50cyk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgc2l6ZSBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiBkYkRvY3VtZW50U2l6ZShkb2MpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChkb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgdmFsdWUgPSBkb2MuZG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvYy51bmtub3duRG9jdW1lbnQpIHtcbiAgICAgICAgdmFsdWUgPSBkb2MudW5rbm93bkRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2Mubm9Eb2N1bWVudCkge1xuICAgICAgICB2YWx1ZSA9IGRvYy5ub0RvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBBIG11dGF0aW9uIHF1ZXVlIGZvciBhIHNwZWNpZmljIHVzZXIsIGJhY2tlZCBieSBJbmRleGVkREIuICovXG5jbGFzcyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbm9ybWFsaXplZCB1c2VySWQgKGUuZy4gbnVsbCBVSUQgPT4gXCJcIiB1c2VySWQpIHVzZWQgdG8gc3RvcmUgL1xuICAgICAqIHJldHJpZXZlIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICB1c2VySWQsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIGRvY3VtZW50IGtleXMgZm9yIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcy4gSWYgdGhlIG11dGF0aW9uXG4gICAgICAgICAqIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBJbmRleGVkRGIsIHRoZSBjYWNoZWQgdmFsdWUgbWF5IGNvbnRpbnVlIHRvXG4gICAgICAgICAqIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGJhdGNoJ3MgZG9jdW1lbnQga2V5cy4gVG8gcmVtb3ZlIGEgY2FjaGVkIHZhbHVlXG4gICAgICAgICAqIGxvY2FsbHksIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgc2hvdWxkIGJlIGludm9rZWQgZWl0aGVyIGRpcmVjdGx5XG4gICAgICAgICAqIG9yIHRocm91Z2ggYHJlbW92ZU11dGF0aW9uQmF0Y2hlcygpYC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBtdWx0aS10YWIsIHdoZW4gdGhlIHByaW1hcnkgY2xpZW50IGFja25vd2xlZGdlcyBvciByZWplY3RzIGEgbXV0YXRpb24sXG4gICAgICAgICAqIHRoaXMgY2FjaGUgaXMgdXNlZCBieSBzZWNvbmRhcnkgY2xpZW50cyB0byBpbnZhbGlkYXRlIHRoZSBsb2NhbFxuICAgICAgICAgKiB2aWV3IG9mIHRoZSBkb2N1bWVudHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgYWZmZWN0ZWQgYnkgdGhlIG11dGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cbiAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWQgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gICAgICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlciBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgbXV0YXRpb24gcXVldWUuXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgc2VyaWFsaXplciB0byB1c2Ugd2hlbiBwZXJzaXN0aW5nIHRvIEluZGV4ZWREYi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yVXNlcih1c2VyLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgIC8vIFRPRE8obWNnKTogRmlndXJlIG91dCB3aGF0IGNvbnN0cmFpbnRzIHRoZXJlIGFyZSBvbiB1c2VySURzXG4gICAgICAgIC8vIEluIHBhcnRpY3VsYXIsIGFyZSB0aGVyZSBhbnkgcmVzZXJ2ZWQgY2hhcmFjdGVycz8gYXJlIGVtcHR5IGlkcyBhbGxvd2VkP1xuICAgICAgICAvLyBGb3IgdGhlIG1vbWVudCBzdG9yZSB0aGVzZSB0b2dldGhlciBpbiB0aGUgc2FtZSBtdXRhdGlvbnMgdGFibGUgYXNzdW1pbmdcbiAgICAgICAgLy8gdGhhdCBlbXB0eSB1c2VySURzIGFyZW4ndCBhbGxvd2VkLlxuICAgICAgICBoYXJkQXNzZXJ0KHVzZXIudWlkICE9PSAnJyk7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHVzZXIuaXNBdXRoZW50aWNhdGVkKCkgPyB1c2VyLnVpZCA6ICcnO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYk11dGF0aW9uUXVldWUodXNlcklkLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKTtcbiAgICB9XG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSwgW3RoaXMudXNlcklkLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW1wdHkpO1xuICAgIH1cbiAgICBhZGRNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50U3RvcmUgPSBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdG9yZSA9IG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgLy8gVGhlIEluZGV4ZWREYiBpbXBsZW1lbnRhdGlvbiBpbiBDaHJvbWUgKGFuZCBGaXJlZm94KSBkb2VzIG5vdCBoYW5kbGVcbiAgICAgICAgLy8gY29tcG91bmQgaW5kaWNlcyB0aGF0IGluY2x1ZGUgYXV0by1nZW5lcmF0ZWQga2V5cyBjb3JyZWN0bHkuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBpbmRleCBlbnRyeSBpcyBhZGRlZCBjb3JyZWN0bHkgaW4gYWxsIGJyb3dzZXJzLCB3ZSBwZXJmb3JtIHR3b1xuICAgICAgICAvLyB3cml0ZXM6IFRoZSBmaXJzdCB3cml0ZSBpcyB1c2VkIHRvIHJldHJpZXZlIHRoZSBuZXh0IGF1dG8tZ2VuZXJhdGVkIEJhdGNoXG4gICAgICAgIC8vIElELCBhbmQgdGhlIHNlY29uZCB3cml0ZSBwb3B1bGF0ZXMgdGhlIGluZGV4IGFuZCBzdG9yZXMgdGhlIGFjdHVhbFxuICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaC5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03MDE5NzJcbiAgICAgICAgLy8gV2Ugd3JpdGUgYW4gZW1wdHkgb2JqZWN0IHRvIG9idGFpbiBrZXlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uU3RvcmUuYWRkKHt9KS5uZXh0KGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgaGFyZEFzc2VydCh0eXBlb2YgYmF0Y2hJZCA9PT0gJ251bWJlcicpO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRiQmF0Y2ggPSB0b0RiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIHRoaXMudXNlcklkLCBiYXRjaCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHRoaXMudXNlcklkLCBtdXRhdGlvbi5rZXkucGF0aCwgYmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQobXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG11dGF0aW9uU3RvcmUucHV0KGRiQmF0Y2gpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50U3RvcmUucHV0KGluZGV4S2V5LCBEYkRvY3VtZW50TXV0YXRpb25QbGFjZWhvbGRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIHBhcmVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRPbkNvbW1pdHRlZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IGJhdGNoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChiYXRjaElkKVxuICAgICAgICAgICAgLm5leHQoZGJCYXRjaCA9PiB7XG4gICAgICAgICAgICBpZiAoZGJCYXRjaCkge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBrZXlzIGZvciB0aGUgbXV0YXRpb24gYmF0Y2ggd2l0aCB0aGUgZ2l2ZW4gYmF0Y2hJZC5cbiAgICAgKiBGb3IgcHJpbWFyeSBjbGllbnRzLCB0aGlzIG1ldGhvZCByZXR1cm5zIGBudWxsYCBhZnRlclxuICAgICAqIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAgaGFzIGJlZW4gY2FsbGVkLiBTZWNvbmRhcnkgY2xpZW50cyByZXR1cm4gYVxuICAgICAqIGNhY2hlZCByZXN1bHQgdW50aWwgYHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cygpYCBpcyBpbnZva2VkLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgbG9va3VwTXV0YXRpb25LZXlzKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpLm5leHQoYmF0Y2ggPT4ge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gYmF0Y2gua2V5cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGtleXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgbmV4dEJhdGNoSWQgPSBiYXRjaElkICsgMTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKFt0aGlzLnVzZXJJZCwgbmV4dEJhdGNoSWRdKTtcbiAgICAgICAgbGV0IGZvdW5kQmF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlIH0sIChrZXksIGRiQmF0Y2gsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChkYkJhdGNoLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpIHtcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2guYmF0Y2hJZCA+PSBuZXh0QmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgZm91bmRCYXRjaCA9IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZm91bmRCYXRjaCk7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKFtcbiAgICAgICAgICAgIHRoaXMudXNlcklkLFxuICAgICAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYmF0Y2hJZCA9IEJBVENISURfVU5LTk9XTjtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSwgcmV2ZXJzZTogdHJ1ZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBiYXRjaElkID0gZGJCYXRjaC5iYXRjaElkO1xuICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBiYXRjaElkKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBCQVRDSElEX1VOS05PV05dLCBbdGhpcy51c2VySWQsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0pO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAubG9hZEFsbChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZGJCYXRjaGVzID0+IGRiQmF0Y2hlcy5tYXAoZGJCYXRjaCA9PiBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCkpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIC8vIFNjYW4gdGhlIGRvY3VtZW50LW11dGF0aW9uIGluZGV4IHN0YXJ0aW5nIHdpdGggYSBwcmVmaXggc3RhcnRpbmcgd2l0aFxuICAgICAgICAvLyB0aGUgZ2l2ZW4gZG9jdW1lbnRLZXkuXG4gICAgICAgIGNvbnN0IGluZGV4UHJlZml4ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4UHJlZml4KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IGluZGV4U3RhcnQgfSwgKGluZGV4S2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0gPSBpbmRleEtleTtcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgcm93cyBtYXRjaGluZyBleGFjdGx5IHRoZSBzcGVjaWZpYyBrZXkgb2ZcbiAgICAgICAgICAgIC8vIGludGVyZXN0LiBOb3RlIHRoYXQgYmVjYXVzZSB3ZSBvcmRlciBieSBwYXRoIGZpcnN0LCBhbmQgd2VcbiAgICAgICAgICAgIC8vIG9yZGVyIHRlcm1pbmF0b3JzIGJlZm9yZSBwYXRoIHNlcGFyYXRvcnMsIHdlJ2xsIGVuY291bnRlciBhbGxcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleCByb3dzIGZvciBkb2N1bWVudEtleSBjb250aWd1b3VzbHkuIEluIHBhcnRpY3VsYXIsIGFsbFxuICAgICAgICAgICAgLy8gdGhlIHJvd3MgZm9yIGRvY3VtZW50S2V5IHdpbGwgb2NjdXIgYmVmb3JlIGFueSByb3dzIGZvclxuICAgICAgICAgICAgLy8gZG9jdW1lbnRzIG5lc3RlZCBpbiBhIHN1YmNvbGxlY3Rpb24gYmVuZWF0aCBkb2N1bWVudEtleSBzbyB3ZVxuICAgICAgICAgICAgLy8gY2FuIHN0b3AgYXMgc29vbiBhcyB3ZSBoaXQgYW55IHN1Y2ggcm93LlxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCB8fCAhZG9jdW1lbnRLZXkucGF0aC5pc0VxdWFsKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgbXV0YXRpb24gYmF0Y2ggaW4gdGhlIHN0b3JlLlxuICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobXV0YXRpb24udXNlcklkID09PSB0aGlzLnVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBtdXRhdGlvbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZG9jdW1lbnRLZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIGRvY3VtZW50S2V5LnBhdGgpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4U3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pLml0ZXJhdGUoeyByYW5nZSB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJRF0gPSBpbmRleEtleTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHJvd3MgbWF0Y2hpbmcgZXhhY3RseSB0aGUgc3BlY2lmaWMga2V5IG9mXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxuICAgICAgICAgICAgICAgIC8vIG9yZGVyIHRlcm1pbmF0b3JzIGJlZm9yZSBwYXRoIHNlcGFyYXRvcnMsIHdlJ2xsIGVuY291bnRlciBhbGxcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggcm93cyBmb3IgZG9jdW1lbnRLZXkgY29udGlndW91c2x5LiBJbiBwYXJ0aWN1bGFyLCBhbGxcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXG4gICAgICAgICAgICAgICAgLy8gZG9jdW1lbnRzIG5lc3RlZCBpbiBhIHN1YmNvbGxlY3Rpb24gYmVuZWF0aCBkb2N1bWVudEtleSBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBzdG9wIGFzIHNvb24gYXMgd2UgaGl0IGFueSBzdWNoIHJvdy5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCB8fCAhZG9jdW1lbnRLZXkucGF0aC5pc0VxdWFsKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gcXVlcnkucGF0aDtcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5MZW5ndGggPSBxdWVyeVBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBBY3R1YWxseSBpbXBsZW1lbnQgYSBzaW5nbGUtY29sbGVjdGlvbiBxdWVyeVxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGlzIGFjdHVhbGx5IGV4ZWN1dGluZyBhbiBhbmNlc3RvciBxdWVyeSwgdHJhdmVyc2luZyB0aGUgd2hvbGVcbiAgICAgICAgLy8gc3VidHJlZSBiZWxvdyB0aGUgY29sbGVjdGlvbiB3aGljaCBjYW4gYmUgaG9ycmlmaWNhbGx5IGluZWZmaWNpZW50IGZvclxuICAgICAgICAvLyBzb21lIHN0cnVjdHVyZXMuIFRoZSByaWdodCB3YXkgdG8gc29sdmUgdGhpcyBpcyB0byBpbXBsZW1lbnQgdGhlIGZ1bGxcbiAgICAgICAgLy8gdmFsdWUgaW5kZXgsIGJ1dCB0aGF0J3Mgbm90IGluIHRoZSBjYXJkcyBpbiB0aGUgbmVhciBmdXR1cmUgc28gdGhpcyBpc1xuICAgICAgICAvLyB0aGUgYmVzdCB3ZSBjYW4gZG8gZm9yIHRoZSBtb21lbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IHlldCBpbmRleCB0aGUgYWN0dWFsIHByb3BlcnRpZXMgaW4gdGhlIG11dGF0aW9ucywgb3VyXG4gICAgICAgIC8vIGN1cnJlbnQgYXBwcm9hY2ggaXMgdG8ganVzdCByZXR1cm4gYWxsIG11dGF0aW9uIGJhdGNoZXMgdGhhdCBhZmZlY3RcbiAgICAgICAgLy8gZG9jdW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGJlaW5nIHF1ZXJpZWQuXG4gICAgICAgIGNvbnN0IGluZGV4UHJlZml4ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgcXVlcnlQYXRoKTtcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xuICAgICAgICAvLyBDb2xsZWN0IHVwIHVuaXF1ZSBiYXRjaElEcyBlbmNvdW50ZXJlZCBkdXJpbmcgYSBzY2FuIG9mIHRoZSBpbmRleC4gVXNlIGFcbiAgICAgICAgLy8gU29ydGVkU2V0IHRvIGFjY3VtdWxhdGUgYmF0Y2ggSURzIHNvIHRoZXkgY2FuIGJlIHRyYXZlcnNlZCBpbiBvcmRlciBpbiBhXG4gICAgICAgIC8vIHNjYW4gb2YgdGhlIG1haW4gdGFibGUuXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt1c2VySUQsIGVuY29kZWRQYXRoLCBiYXRjaElEXSA9IGluZGV4S2V5O1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCB8fCAhcXVlcnlQYXRoLmlzUHJlZml4T2YocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3dzIHdpdGggZG9jdW1lbnQga2V5cyBtb3JlIHRoYW4gb25lIHNlZ21lbnQgbG9uZ2VyIHRoYW4gdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXRoIGNhbid0IGJlIG1hdGNoZXMuIEZvciBleGFtcGxlLCBhIHF1ZXJ5IG9uICdyb29tcydcbiAgICAgICAgICAgIC8vIGNhbid0IG1hdGNoIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cbiAgICAgICAgICAgIC8vIFRPRE8obWNnKTogd2UnbGwgbmVlZCBhIGRpZmZlcmVudCBzY2FubmVyIHdoZW4gd2UgaW1wbGVtZW50XG4gICAgICAgICAgICAvLyBhbmNlc3RvciBxdWVyaWVzLlxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSBpbW1lZGlhdGVDaGlsZHJlbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIHVuaXF1ZUJhdGNoSURzKSk7XG4gICAgfVxuICAgIGxvb2t1cE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbiwgYmF0Y2hJRHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBUT0RPKHJvY2t3b29kKTogSW1wbGVtZW50IHRoaXMgdXNpbmcgaXRlcmF0ZS5cbiAgICAgICAgYmF0Y2hJRHMuZm9yRWFjaChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgLmdldChiYXRjaElkKVxuICAgICAgICAgICAgICAgIC5uZXh0KG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KG11dGF0aW9uLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiByZXN1bHRzKTtcbiAgICB9XG4gICAgcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24uc2ltcGxlRGJUcmFuc2FjdGlvbiwgdGhpcy51c2VySWQsIGJhdGNoKS5uZXh0KHJlbW92ZWREb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2guYmF0Y2hJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChyZW1vdmVkRG9jdW1lbnRzLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHJhbnNhY3Rpb24sIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FjaGVkIGtleXMgZm9yIGEgbXV0YXRpb24gYmF0Y2guIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgICAqIGNhbGxlZCBieSBzZWNvbmRhcnkgY2xpZW50cyBhZnRlciB0aGV5IHByb2Nlc3MgbXV0YXRpb24gdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBoYXZlIHRvIGJlIGNhbGxlZCBmcm9tIHByaW1hcnkgY2xpZW50cyBhc1xuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIGVudHJpZXMgYXJlIGNsZWFyZWQgd2hlbiBhbiBhY2tub3dsZWRnZWQgb3JcbiAgICAgKiByZWplY3RlZCBiYXRjaCBpcyByZW1vdmVkIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcbiAgICByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2hJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF07XG4gICAgfVxuICAgIHBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VtcHR5KHR4bikubmV4dChlbXB0eSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBhcmUgbm8gZW50cmllcyBpbiB0aGUgZG9jdW1lbnRNdXRhdGlvbnMgaW5kZXggaWZcbiAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclVzZXIodGhpcy51c2VySWQpKTtcbiAgICAgICAgICAgIGNvbnN0IGRhbmdsaW5nTXV0YXRpb25SZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogc3RhcnRSYW5nZSB9LCAoa2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklEID0ga2V5WzBdO1xuICAgICAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGRhbmdsaW5nTXV0YXRpb25SZWZlcmVuY2VzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcy5sZW5ndGggPT09IDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdGhpcy51c2VySWQsIGtleSk7XG4gICAgfVxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkgKHN0YXRlIGlzIGhlbGQgaW4gbWVtb3J5IGluIG90aGVyIGNsaWVudHMpLlxuICAgIC8qKiBSZXR1cm5zIHRoZSBtdXRhdGlvbiBxdWV1ZSdzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLiAqL1xuICAgIGdldE11dGF0aW9uUXVldWVNZXRhZGF0YSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQodGhpcy51c2VySWQpXG4gICAgICAgICAgICAubmV4dCgobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEgfHwge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogdGhpcy51c2VySWQsXG4gICAgICAgICAgICAgICAgbGFzdEFja25vd2xlZGdlZEJhdGNoSWQ6IEJBVENISURfVU5LTk9XTixcbiAgICAgICAgICAgICAgICBsYXN0U3RyZWFtVG9rZW46ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIgY29udGFpbnMgYSBwZW5kaW5nXG4gKiAgICAgICAgIG11dGF0aW9uIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICovXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGtleSkge1xuICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh1c2VySWQsIGtleS5wYXRoKTtcbiAgICBjb25zdCBlbmNvZGVkUGF0aCA9IGluZGV4S2V5WzFdO1xuICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4S2V5KTtcbiAgICBsZXQgY29udGFpbnNLZXkgPSBmYWxzZTtcbiAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0eG4pXG4gICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VySUQsIGtleVBhdGgsIC8qYmF0Y2hJRCovIF9dID0ga2V5O1xuICAgICAgICBpZiAodXNlcklEID09PSB1c2VySWQgJiYga2V5UGF0aCA9PT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5zS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICB9KVxuICAgICAgICAubmV4dCgoKSA9PiBjb250YWluc0tleSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGFueSBtdXRhdGlvbiBxdWV1ZSBjb250YWlucyB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBkb2NLZXkpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pXG4gICAgICAgIC5pdGVyYXRlU2VyaWFsKHVzZXJJZCA9PiB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGRvY0tleSkubmV4dChjb250YWluc0tleSA9PiB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnNLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoIWNvbnRhaW5zS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLm5leHQoKCkgPT4gZm91bmQpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9ucyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uUXVldWVTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogT2Zmc2V0IHRvIGVuc3VyZSBub24tb3ZlcmxhcHBpbmcgdGFyZ2V0IGlkcy4gKi9cbmNvbnN0IE9GRlNFVCA9IDI7XG4vKipcbiAqIEdlbmVyYXRlcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdGFyZ2V0IElEcyBmb3Igc2VuZGluZyB0YXJnZXRzIHRvIHRoZVxuICogd2F0Y2ggc3RyZWFtLlxuICpcbiAqIFRoZSBjbGllbnQgY29uc3RydWN0cyB0d28gZ2VuZXJhdG9ycywgb25lIGZvciB0aGUgdGFyZ2V0IGNhY2hlLCBhbmQgb25lIGZvclxuICogZm9yIHRoZSBzeW5jIGVuZ2luZSAodG8gZ2VuZXJhdGUgbGltYm8gZG9jdW1lbnRzIHRhcmdldHMpLiBUaGVzZVxuICogZ2VuZXJhdG9ycyBwcm9kdWNlIG5vbi1vdmVybGFwcGluZyBJRHMgKGJ5IHVzaW5nIGV2ZW4gYW5kIG9kZCBJRHNcbiAqIHJlc3BlY3RpdmVseSkuXG4gKlxuICogQnkgc2VwYXJhdGluZyB0aGUgdGFyZ2V0IElEIHNwYWNlLCB0aGUgcXVlcnkgY2FjaGUgY2FuIGdlbmVyYXRlIHRhcmdldCBJRHNcbiAqIHRoYXQgcGVyc2lzdCBhY3Jvc3MgY2xpZW50IHJlc3RhcnRzLCB3aGlsZSBzeW5jIGVuZ2luZSBjYW4gaW5kZXBlbmRlbnRseVxuICogZ2VuZXJhdGUgaW4tbWVtb3J5IHRhcmdldCBJRHMgdGhhdCBhcmUgdHJhbnNpZW50IGFuZCBjYW4gYmUgcmV1c2VkIGFmdGVyIGFcbiAqIHJlc3RhcnQuXG4gKi9cbmNsYXNzIFRhcmdldElkR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXN0SWQpIHtcbiAgICAgICAgdGhpcy5sYXN0SWQgPSBsYXN0SWQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMubGFzdElkICs9IE9GRlNFVDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yVGFyZ2V0Q2FjaGUoKSB7XG4gICAgICAgIC8vIFRoZSB0YXJnZXQgY2FjaGUgZ2VuZXJhdG9yIG11c3QgcmV0dXJuICcyJyBpbiBpdHMgZmlyc3QgY2FsbCB0byBgbmV4dCgpYFxuICAgICAgICAvLyBhcyB0aGVyZSBpcyBubyBkaWZmZXJlbnRpYXRpb24gaW4gdGhlIHByb3RvY29sIGxheWVyIGJldHdlZW4gYW4gdW5zZXRcbiAgICAgICAgLy8gbnVtYmVyIGFuZCB0aGUgbnVtYmVyICcwJy4gSWYgd2Ugd2VyZSB0byBzZW50IGEgdGFyZ2V0IHdpdGggdGFyZ2V0IElEXG4gICAgICAgIC8vICcwJywgdGhlIGJhY2tlbmQgd291bGQgY29uc2lkZXIgaXQgdW5zZXQgYW5kIHJlcGxhY2UgaXQgd2l0aCBpdHMgb3duIElELlxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDIgLSBPRkZTRVQpO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yU3luY0VuZ2luZSgpIHtcbiAgICAgICAgLy8gU3luYyBlbmdpbmUgYXNzaWducyB0YXJnZXQgSURzIGZvciBsaW1ibyBkb2N1bWVudCBkZXRlY3Rpb24uXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IoMSAtIE9GRlNFVCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiVGFyZ2V0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgLy8gUE9SVElORyBOT1RFOiBXZSBkb24ndCBjYWNoZSBnbG9iYWwgbWV0YWRhdGEgZm9yIHRoZSB0YXJnZXQgY2FjaGUsIHNpbmNlXG4gICAgLy8gc29tZSBvZiBpdCAoaW4gcGFydGljdWxhciBgaGlnaGVzdFRhcmdldElkYCkgY2FuIGJlIG1vZGlmaWVkIGJ5IHNlY29uZGFyeVxuICAgIC8vIHRhYnMuIFdlIGNvdWxkIHBlcmhhcHMgYmUgbW9yZSBncmFudWxhciAoYW5kIGUuZy4gc3RpbGwgY2FjaGVcbiAgICAvLyBgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbmAgaW4gbWVtb3J5KSBidXQgZm9yIHNpbXBsaWNpdHkgd2UgY3VycmVudGx5IGdvXG4gICAgLy8gdG8gSW5kZXhlZERiIHdoZW5ldmVyIHdlIG5lZWQgdG8gcmVhZCBtZXRhZGF0YS4gV2UgY2FuIHJldmlzaXQgaWYgaXQgdHVybnNcbiAgICAvLyBvdXQgdG8gaGF2ZSBhIG1lYW5pbmdmdWwgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgIGFsbG9jYXRlVGFyZ2V0SWQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcihtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xuICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkID0gdGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSkubmV4dCgoKSA9PiBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChuZXcgVGltZXN0YW1wKG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24uc2Vjb25kcywgbWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbi5uYW5vc2Vjb25kcykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQodGFyZ2V0R2xvYmFsID0+IHRhcmdldEdsb2JhbC5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBzZXRUYXJnZXRzTWV0YWRhdGEodHJhbnNhY3Rpb24sIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudGFyZ2V0Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0SWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEudGFyZ2V0Q291bnQgPiAwKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnRhcmdldENvdW50IC09IDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyb3BzIGFueSB0YXJnZXRzIHdpdGggc2VxdWVuY2UgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdXBwZXIgYm91bmQsIGV4Y2VwdGluZyB0aG9zZVxuICAgICAqIHByZXNlbnQgaW4gYGFjdGl2ZVRhcmdldElkc2AuIERvY3VtZW50IGFzc29jaWF0aW9ucyBmb3IgdGhlIHJlbW92ZWQgdGFyZ2V0cyBhcmUgYWxzbyByZW1vdmVkLlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXJnZXRzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHR4bilcbiAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyIDw9IHVwcGVyQm91bmQgJiZcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHMuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVtb3ZlVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBwcm92aWRlZCBmdW5jdGlvbiB3aXRoIGVhY2ggYFRhcmdldERhdGFgIHRoYXQgd2UgaGF2ZSBjYWNoZWQuXG4gICAgICovXG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pLml0ZXJhdGUoKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBmcm9tRGJUYXJnZXQodmFsdWUpO1xuICAgICAgICAgICAgZih0YXJnZXREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChEYlRhcmdldEdsb2JhbEtleSlcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEgIT09IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUodHJhbnNhY3Rpb24pLnB1dChEYlRhcmdldEdsb2JhbEtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICBzYXZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQodG9EYlRhcmdldCh0aGlzLnNlcmlhbGl6ZXIsIHRhcmdldERhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4tcGxhY2UgdXBkYXRlcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEgdG8gYWNjb3VudCBmb3IgdmFsdWVzIGluIHRoZSBnaXZlblxuICAgICAqIFRhcmdldERhdGEuIFNhdmluZyBpcyBkb25lIHNlcGFyYXRlbHkuIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSB3ZXJlIGFueVxuICAgICAqIGNoYW5nZXMgdG8gdGhlIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRhcmdldERhdGEudGFyZ2V0SWQgPiBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID0gdGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDb3VudCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IG1ldGFkYXRhLnRhcmdldENvdW50KTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIEl0ZXJhdGluZyBieSB0aGUgY2Fub25pY2FsSWQgbWF5IHlpZWxkIG1vcmUgdGhhbiBvbmUgcmVzdWx0IGJlY2F1c2VcbiAgICAgICAgLy8gY2Fub25pY2FsSWQgdmFsdWVzIGFyZSBub3QgcmVxdWlyZWQgdG8gYmUgdW5pcXVlIHBlciB0YXJnZXQuIFRoaXMgcXVlcnlcbiAgICAgICAgLy8gZGVwZW5kcyBvbiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4IHRvIGJlIGVmZmljaWVudC5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsSWQgPSBjYW5vbmlmeVRhcmdldCh0YXJnZXQpO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtjYW5vbmljYWxJZCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSwgW2Nhbm9uaWNhbElkLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlLCBpbmRleDogRGJUYXJnZXRRdWVyeVRhcmdldHNJbmRleE5hbWUgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIEFmdGVyIGZpbmRpbmcgYSBwb3RlbnRpYWwgbWF0Y2gsIGNoZWNrIHRoYXQgdGhlIHRhcmdldCBpc1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZXF1YWwgdG8gdGhlIHJlcXVlc3RlZCB0YXJnZXQuXG4gICAgICAgICAgICBpZiAodGFyZ2V0RXF1YWxzKHRhcmdldCwgZm91bmQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgYWRkTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBUaGUgcmV2ZXJzZSBpbmRleCAoZG9jdW1lbnRzVGFyZ2V0cykgaXMgbWFpbnRhaW5lZCBieVxuICAgICAgICAvLyBJbmRleGVkRGIuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzdG9yZS5wdXQoeyB0YXJnZXRJZCwgcGF0aCB9KSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBUaGUgcmV2ZXJzZSBpbmRleCAoZG9jdW1lbnRzVGFyZ2V0cykgaXMgbWFpbnRhaW5lZCBieVxuICAgICAgICAvLyBJbmRleGVkRGIuXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IoW1xuICAgICAgICAgICAgICAgIHN0b3JlLmRlbGV0ZShbdGFyZ2V0SWQsIHBhdGhdKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RhcmdldElkXSwgW3RhcmdldElkICsgMV0sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKHJhbmdlKTtcbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XG4gICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICByZXR1cm4gc3RvcmVcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoa2V5WzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY0tleSA9IG5ldyBEb2N1bWVudEtleShwYXRoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZG9jS2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtwYXRoXSwgW2ltbWVkaWF0ZVN1Y2Nlc3NvcihwYXRoKV0sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4LFxuICAgICAgICAgICAga2V5c09ubHk6IHRydWUsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICB9LCAoW3RhcmdldElkLCBwYXRoXSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgLy8gSGF2aW5nIGEgc2VudGluZWwgcm93IGZvciBhIGRvY3VtZW50IGRvZXMgbm90IGNvdW50IGFzIGNvbnRhaW5pbmcgdGhhdCBkb2N1bWVudDtcbiAgICAgICAgICAgIC8vIEZvciB0aGUgdGFyZ2V0IGNhY2hlLCBjb250YWluaW5nIHRoZSBkb2N1bWVudCBtZWFucyB0aGUgZG9jdW1lbnQgaXMgcGFydCBvZiBzb21lXG4gICAgICAgICAgICAvLyB0YXJnZXQuXG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY291bnQgPiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYSBUYXJnZXREYXRhIGVudHJ5IGJ5IHRhcmdldCBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRJZCAtIFRoZSB0YXJnZXQgSUQgb2YgdGhlIFRhcmdldERhdGEgZW50cnkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIFRhcmdldERhdGEgZW50cnksIG9yIG51bGwgaWYgdGhlIGNhY2hlIGhhcyBubyBlbnRyeSBmb3JcbiAgICAgKiB0aGUgdGFyZ2V0LlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCh0cmFuc2FjdGlvbiwgdGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQodGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dChmb3VuZCA9PiB7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiVGFyZ2V0KGZvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcXVlcmllcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldHNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSB0YXJnZXQgZ2xvYmFscyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGdsb2JhbFRhcmdldFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IHRhcmdldCBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEdDX0RJRF9OT1RfUlVOID0ge1xuICAgIGRpZFJ1bjogZmFsc2UsXG4gICAgc2VxdWVuY2VOdW1iZXJzQ29sbGVjdGVkOiAwLFxuICAgIHRhcmdldHNSZW1vdmVkOiAwLFxuICAgIGRvY3VtZW50c1JlbW92ZWQ6IDBcbn07XG5jb25zdCBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCA9IC0xO1xuY29uc3QgTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUyA9IDQwICogMTAyNCAqIDEwMjQ7XG5jbGFzcyBMcnVQYXJhbXMge1xuICAgIHN0YXRpYyB3aXRoQ2FjaGVTaXplKGNhY2hlU2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IExydVBhcmFtcyhjYWNoZVNpemUsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFdoZW4gd2UgYXR0ZW1wdCB0byBjb2xsZWN0LCB3ZSB3aWxsIG9ubHkgZG8gc28gaWYgdGhlIGNhY2hlIHNpemUgaXMgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICAvLyB0aHJlc2hvbGQuIFBhc3NpbmcgYENPTExFQ1RJT05fRElTQUJMRURgIGhlcmUgd2lsbCBjYXVzZSBjb2xsZWN0aW9uIHRvIGFsd2F5cyBiZSBza2lwcGVkLlxuICAgIGNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQsIFxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3ZSB3aWxsIGF0dGVtcHQgdG8gY29sbGVjdFxuICAgIHBlcmNlbnRpbGVUb0NvbGxlY3QsIFxuICAgIC8vIEEgY2FwIG9uIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VxdWVuY2UgbnVtYmVycyB0aGF0IHdpbGwgYmUgY29sbGVjdGVkLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gdXMgZnJvbSBjb2xsZWN0aW5nIGEgaHVnZSBudW1iZXIgb2Ygc2VxdWVuY2UgbnVtYmVycyBpZiB0aGUgY2FjaGUgaGFzIGdyb3duIHZlcnkgbGFyZ2UuXG4gICAgbWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCkge1xuICAgICAgICB0aGlzLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgPSBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnBlcmNlbnRpbGVUb0NvbGxlY3QgPSBwZXJjZW50aWxlVG9Db2xsZWN0O1xuICAgICAgICB0aGlzLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBtYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0O1xuICAgIH1cbn1cbkxydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSA9IDEwO1xuTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCA9IDEwMDA7XG5McnVQYXJhbXMuREVGQVVMVCA9IG5ldyBMcnVQYXJhbXMoTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUywgTHJ1UGFyYW1zLkRFRkFVTFRfQ09MTEVDVElPTl9QRVJDRU5USUxFLCBMcnVQYXJhbXMuREVGQVVMVF9NQVhfU0VRVUVOQ0VfTlVNQkVSU19UT19DT0xMRUNUKTtcbkxydVBhcmFtcy5ESVNBQkxFRCA9IG5ldyBMcnVQYXJhbXMoTFJVX0NPTExFQ1RJT05fRElTQUJMRUQsIDAsIDApO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRlID0gJ0xydUdhcmJhZ2VDb2xsZWN0b3InO1xuY29uc3QgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUyA9IDEgKiAxMDI0ICogMTAyNDtcbi8qKiBIb3cgbG9uZyB3ZSB3YWl0IHRvIHRyeSBydW5uaW5nIExSVSBHQyBhZnRlciBTREsgaW5pdGlhbGl6YXRpb24uICovXG5jb25zdCBJTklUSUFMX0dDX0RFTEFZX01TID0gMSAqIDYwICogMTAwMDtcbi8qKiBNaW5pbXVtIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gR0MgY2hlY2tzLCBhZnRlciB0aGUgZmlyc3Qgb25lLiAqL1xuY29uc3QgUkVHVUxBUl9HQ19ERUxBWV9NUyA9IDUgKiA2MCAqIDEwMDA7XG5mdW5jdGlvbiBidWZmZXJFbnRyeUNvbXBhcmF0b3IoW2FTZXF1ZW5jZSwgYUluZGV4XSwgW2JTZXF1ZW5jZSwgYkluZGV4XSkge1xuICAgIGNvbnN0IHNlcUNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IoYVNlcXVlbmNlLCBiU2VxdWVuY2UpO1xuICAgIGlmIChzZXFDbXAgPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBvcmRlciBkb2Vzbid0IG1hdHRlciwgYnV0IHdlIGNhbiBiaWFzIGFnYWluc3QgY2h1cm4gYnkgc29ydGluZ1xuICAgICAgICAvLyBlbnRyaWVzIGNyZWF0ZWQgZWFybGllciBhcyBsZXNzIHRoYW4gbmV3ZXIgZW50cmllcy5cbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IoYUluZGV4LCBiSW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcUNtcDtcbiAgICB9XG59XG4vKipcbiAqIFVzZWQgdG8gY2FsY3VsYXRlIHRoZSBudGggc2VxdWVuY2UgbnVtYmVyLiBLZWVwcyBhIHJvbGxpbmcgYnVmZmVyIG9mIHRoZVxuICogbG93ZXN0IG4gdmFsdWVzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAsIGFuZCBmaW5hbGx5IHJlcG9ydHMgdGhlIGxhcmdlc3Qgb2ZcbiAqIHRoZW0gaW4gYG1heFZhbHVlYC5cbiAqL1xuY2xhc3MgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50cykge1xuICAgICAgICB0aGlzLm1heEVsZW1lbnRzID0gbWF4RWxlbWVudHM7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFNvcnRlZFNldChidWZmZXJFbnRyeUNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLnByZXZpb3VzSW5kZXggPSAwO1xuICAgIH1cbiAgICBuZXh0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiArK3RoaXMucHJldmlvdXNJbmRleDtcbiAgICB9XG4gICAgYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICBjb25zdCBlbnRyeSA9IFtzZXF1ZW5jZU51bWJlciwgdGhpcy5uZXh0SW5kZXgoKV07XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5zaXplIDwgdGhpcy5tYXhFbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5hZGQoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGlnaGVzdFZhbHVlID0gdGhpcy5idWZmZXIubGFzdCgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckVudHJ5Q29tcGFyYXRvcihlbnRyeSwgaGlnaGVzdFZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLmRlbGV0ZShoaWdoZXN0VmFsdWUpLmFkZChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICAvLyBHdWFyYW50ZWVkIHRvIGJlIG5vbi1lbXB0eS4gSWYgd2UgZGVjaWRlIHdlIGFyZSBub3QgY29sbGVjdGluZyBhbnlcbiAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVycywgbnRoU2VxdWVuY2VOdW1iZXIgYmVsb3cgc2hvcnQtY2lyY3VpdHMuIElmIHdlIGhhdmVcbiAgICAgICAgLy8gZGVjaWRlZCB0aGF0IHdlIGFyZSBjb2xsZWN0aW5nIG4gc2VxdWVuY2UgbnVtYmVycywgaXQncyBiZWNhdXNlIG4gaXMgc29tZVxuICAgICAgICAvLyBwZXJjZW50YWdlIG9mIHRoZSBleGlzdGluZyBzZXF1ZW5jZSBudW1iZXJzLiBUaGF0IG1lYW5zIHdlIHNob3VsZCBuZXZlclxuICAgICAgICAvLyBiZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhcmUgY29sbGVjdGluZyBzZXF1ZW5jZSBudW1iZXJzIGJ1dCBkb24ndFxuICAgICAgICAvLyBhY3R1YWxseSBoYXZlIGFueS5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxhc3QoKVswXTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBzY2hlZHVsaW5nIG9mIExSVSBnYXJiYWdlIGNvbGxlY3Rpb24uIEl0IGhhbmRsZXMgY2hlY2tpbmdcbiAqIHdoZXRoZXIgb3Igbm90IEdDIGlzIGVuYWJsZWQsIGFzIHdlbGwgYXMgd2hpY2ggZGVsYXkgdG8gdXNlIGJlZm9yZSB0aGUgbmV4dCBydW4uXG4gKi9cbmNsYXNzIExydVNjaGVkdWxlciB7XG4gICAgY29uc3RydWN0b3IoZ2FyYmFnZUNvbGxlY3RvciwgYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSkge1xuICAgICAgICB0aGlzLmdhcmJhZ2VDb2xsZWN0b3IgPSBnYXJiYWdlQ29sbGVjdG9yO1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5nYXJiYWdlQ29sbGVjdG9yLnBhcmFtcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkICE9PVxuICAgICAgICAgICAgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVHQyhJTklUSUFMX0dDX0RFTEFZX01TKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5nY1Rhc2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2NUYXNrLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nY1Rhc2sgIT09IG51bGw7XG4gICAgfVxuICAgIHNjaGVkdWxlR0MoZGVsYXkpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRlLCBgR2FyYmFnZSBjb2xsZWN0aW9uIHNjaGVkdWxlZCBpbiAke2RlbGF5fW1zYCk7XG4gICAgICAgIHRoaXMuZ2NUYXNrID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwibHJ1X2dhcmJhZ2VfY29sbGVjdGlvblwiIC8qIFRpbWVySWQuTHJ1R2FyYmFnZUNvbGxlY3Rpb24gKi8sIGRlbGF5LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubG9jYWxTdG9yZS5jb2xsZWN0R2FyYmFnZSh0aGlzLmdhcmJhZ2VDb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlR0MoUkVHVUxBUl9HQ19ERUxBWV9NUyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgc3RlcHMgZm9yIExSVSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gKi9cbmNsYXNzIExydUdhcmJhZ2VDb2xsZWN0b3JJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVRhcmdldENvdW50KHR4biwgcGVyY2VudGlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5nZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikubmV4dCh0YXJnZXRDb3VudCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigocGVyY2VudGlsZSAvIDEwMC4wKSAqIHRhcmdldENvdW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG50aFNlcXVlbmNlTnVtYmVyKHR4biwgbikge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKExpc3RlblNlcXVlbmNlLklOVkFMSUQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBSb2xsaW5nU2VxdWVuY2VOdW1iZXJCdWZmZXIobik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlXG4gICAgICAgICAgICAuZm9yRWFjaFRhcmdldCh0eG4sIHRhcmdldCA9PiBidWZmZXIuYWRkRWxlbWVudCh0YXJnZXQuc2VxdWVuY2VOdW1iZXIpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIHNlcXVlbmNlTnVtYmVyID0+IGJ1ZmZlci5hZGRFbGVtZW50KHNlcXVlbmNlTnVtYmVyKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBidWZmZXIubWF4VmFsdWUpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpO1xuICAgIH1cbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKTtcbiAgICB9XG4gICAgY29sbGVjdCh0eG4sIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCA9PT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgJ0dhcmJhZ2UgY29sbGVjdGlvbiBza2lwcGVkOyBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKEdDX0RJRF9OT1RfUlVOKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZVNpemUodHhuKS5uZXh0KGNhY2hlU2l6ZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FjaGVTaXplIDwgdGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgYEdhcmJhZ2UgY29sbGVjdGlvbiBza2lwcGVkOyBDYWNoZSBzaXplICR7Y2FjaGVTaXplfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGlzIGxvd2VyIHRoYW4gdGhyZXNob2xkICR7dGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gR0NfRElEX05PVF9SVU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5HYXJiYWdlQ29sbGVjdGlvbih0eG4sIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmdldENhY2hlU2l6ZSh0eG4pO1xuICAgIH1cbiAgICBydW5HYXJiYWdlQ29sbGVjdGlvbih0eG4sIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICBsZXQgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICBsZXQgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0LCB0YXJnZXRzUmVtb3ZlZDtcbiAgICAgICAgLy8gVGltZXN0YW1wcyBmb3IgdmFyaW91cyBwaWVjZXMgb2YgdGhlIHByb2Nlc3NcbiAgICAgICAgbGV0IGNvdW50ZWRUYXJnZXRzVHMsIGZvdW5kVXBwZXJCb3VuZFRzLCByZW1vdmVkVGFyZ2V0c1RzLCByZW1vdmVkRG9jdW1lbnRzVHM7XG4gICAgICAgIGNvbnN0IHN0YXJ0VHMgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHRoaXMucGFyYW1zLnBlcmNlbnRpbGVUb0NvbGxlY3QpXG4gICAgICAgICAgICAubmV4dChzZXF1ZW5jZU51bWJlcnMgPT4ge1xuICAgICAgICAgICAgLy8gQ2FwIGF0IHRoZSBjb25maWd1cmVkIG1heFxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVycyA+IHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsICdDYXBwaW5nIHNlcXVlbmNlIG51bWJlcnMgdG8gY29sbGVjdCBkb3duICcgK1xuICAgICAgICAgICAgICAgICAgICBgdG8gdGhlIG1heGltdW0gb2YgJHt0aGlzLnBhcmFtcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0fSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGZyb20gJHtzZXF1ZW5jZU51bWJlcnN9YCk7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9IHNlcXVlbmNlTnVtYmVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZWRUYXJnZXRzVHMgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnRoU2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQodXBwZXJCb3VuZCA9PiB7XG4gICAgICAgICAgICB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIgPSB1cHBlckJvdW5kO1xuICAgICAgICAgICAgZm91bmRVcHBlckJvdW5kVHMgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlciwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KG51bVRhcmdldHNSZW1vdmVkID0+IHtcbiAgICAgICAgICAgIHRhcmdldHNSZW1vdmVkID0gbnVtVGFyZ2V0c1JlbW92ZWQ7XG4gICAgICAgICAgICByZW1vdmVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50c1JlbW92ZWQgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlZERvY3VtZW50c1RzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9ICdMUlUgR2FyYmFnZSBDb2xsZWN0aW9uXFxuJyArXG4gICAgICAgICAgICAgICAgICAgIGBcXHRDb3VudGVkIHRhcmdldHMgaW4gJHtjb3VudGVkVGFyZ2V0c1RzIC0gc3RhcnRUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0RGV0ZXJtaW5lZCBsZWFzdCByZWNlbnRseSB1c2VkICR7c2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0fSBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7Zm91bmRVcHBlckJvdW5kVHMgLSBjb3VudGVkVGFyZ2V0c1RzfW1zXFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGBcXHRSZW1vdmVkICR7dGFyZ2V0c1JlbW92ZWR9IHRhcmdldHMgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3JlbW92ZWRUYXJnZXRzVHMgLSBmb3VuZFVwcGVyQm91bmRUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0UmVtb3ZlZCAke2RvY3VtZW50c1JlbW92ZWR9IGRvY3VtZW50cyBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7cmVtb3ZlZERvY3VtZW50c1RzIC0gcmVtb3ZlZFRhcmdldHNUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgVG90YWwgRHVyYXRpb246ICR7cmVtb3ZlZERvY3VtZW50c1RzIC0gc3RhcnRUc31tc2A7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCBkZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZGlkUnVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0LFxuICAgICAgICAgICAgICAgIHRhcmdldHNSZW1vdmVkLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50c1JlbW92ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdMcnVHYXJiYWdlQ29sbGVjdG9yKGRlbGVnYXRlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IExydUdhcmJhZ2VDb2xsZWN0b3JJbXBsKGRlbGVnYXRlLCBwYXJhbXMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFByb3ZpZGVzIExSVSBmdW5jdGlvbmFsaXR5IGZvciBJbmRleGVkREIgcGVyc2lzdGVuY2UuICovXG5jbGFzcyBJbmRleGVkRGJMcnVEZWxlZ2F0ZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGRiLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLmdhcmJhZ2VDb2xsZWN0b3IgPSBuZXdMcnVHYXJiYWdlQ29sbGVjdG9yKHRoaXMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldFNlcXVlbmNlTnVtYmVyQ291bnQodHhuKSB7XG4gICAgICAgIGNvbnN0IGRvY0NvdW50UHJvbWlzZSA9IHRoaXMub3JwaGFuZWREb2N1bWVudENvdW50KHR4bik7XG4gICAgICAgIGNvbnN0IHRhcmdldENvdW50UHJvbWlzZSA9IHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5nZXRUYXJnZXRDb3VudCh0eG4pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Q291bnRQcm9taXNlLm5leHQodGFyZ2V0Q291bnQgPT4gZG9jQ291bnRQcm9taXNlLm5leHQoZG9jQ291bnQgPT4gdGFyZ2V0Q291bnQgKyBkb2NDb3VudCkpO1xuICAgIH1cbiAgICBvcnBoYW5lZERvY3VtZW50Q291bnQodHhuKSB7XG4gICAgICAgIGxldCBvcnBoYW5lZENvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIF8gPT4ge1xuICAgICAgICAgICAgb3JwaGFuZWRDb3VudCsrO1xuICAgICAgICB9KS5uZXh0KCgpID0+IG9ycGhhbmVkQ291bnQpO1xuICAgIH1cbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRUYXJnZXRDYWNoZSgpLmZvckVhY2hUYXJnZXQodHhuLCBmKTtcbiAgICB9XG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCAoZG9jS2V5LCBzZXF1ZW5jZU51bWJlcikgPT4gZihzZXF1ZW5jZU51bWJlcikpO1xuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICB9XG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55dGhpbmcgd291bGQgcHJldmVudCB0aGlzIGRvY3VtZW50IGZyb20gYmVpbmcgZ2FyYmFnZVxuICAgICAqIGNvbGxlY3RlZCwgZ2l2ZW4gdGhhdCB0aGUgZG9jdW1lbnQgaW4gcXVlc3Rpb24gaXMgbm90IHByZXNlbnQgaW4gYW55XG4gICAgICogdGFyZ2V0cyBhbmQgaGFzIGEgc2VxdWVuY2UgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdXBwZXIgYm91bmQgZm9yXG4gICAgICogdGhlIGNvbGxlY3Rpb24gcnVuLlxuICAgICAqL1xuICAgIGlzUGlubmVkKHR4biwgZG9jS2V5KSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBkb2NLZXkpO1xuICAgIH1cbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRDYWNoZSA9IHRoaXMuZGIuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBkb2N1bWVudENhY2hlLm5ld0NoYW5nZUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBsZXQgZG9jdW1lbnRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbiA9IHRoaXMuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCAoZG9jS2V5LCBzZXF1ZW5jZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyIDw9IHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5pc1Bpbm5lZCh0eG4sIGRvY0tleSkubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQaW5uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciBzaXplIGFjY291bnRpbmcgcmVxdWlyZXMgdXMgdG8gcmVhZCBhbGwgZG9jdW1lbnRzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ1ZmZlci5yZW1vdmVFbnRyeShkb2NLZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKS5kZWxldGUoc2VudGluZWxLZXkkMShkb2NLZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVyYXRpb25cbiAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZUJ1ZmZlci5hcHBseSh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRDb3VudCk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHRhcmdldERhdGEud2l0aFNlcXVlbmNlTnVtYmVyKHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRUYXJnZXRDYWNoZSgpLnVwZGF0ZVRhcmdldERhdGEodHhuLCB1cGRhdGVkKTtcbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgcHJvdmlkZWQgZnVuY3Rpb24gZm9yIGVhY2ggZG9jdW1lbnQgaW4gdGhlIGNhY2hlIHRoYXQgaXMgJ29ycGhhbmVkJy4gT3JwaGFuZWRcbiAgICAgKiBtZWFucyBub3QgYSBwYXJ0IG9mIGFueSB0YXJnZXQsIHNvIHRoZSBvbmx5IGVudHJ5IGluIHRoZSB0YXJnZXQtZG9jdW1lbnQgaW5kZXggZm9yXG4gICAgICogdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSBzZW50aW5lbCByb3cgKHRhcmdldElkIDApLCB3aGljaCB3aWxsIGFsc28gaGF2ZSB0aGUgc2VxdWVuY2VcbiAgICAgKiBudW1iZXIgZm9yIHRoZSBsYXN0IHRpbWUgdGhlIGRvY3VtZW50IHdhcyBhY2Nlc3NlZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoT3JwaGFuZWREb2N1bWVudCh0eG4sIGYpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XG4gICAgICAgIGxldCBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xuICAgICAgICBsZXQgbmV4dFBhdGg7XG4gICAgICAgIHJldHVybiBzdG9yZVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleFxuICAgICAgICB9LCAoW3RhcmdldElkLCBkb2NLZXldLCB7IHBhdGgsIHNlcXVlbmNlTnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5leHRUb1JlcG9ydCBpcyB2YWxpZCwgcmVwb3J0IGl0LCB0aGlzIGlzIGEgbmV3IGtleSBzbyB0aGVcbiAgICAgICAgICAgICAgICAvLyBsYXN0IG9uZSBtdXN0IG5vdCBiZSBhIG1lbWJlciBvZiBhbnkgdGFyZ2V0cy5cbiAgICAgICAgICAgICAgICBpZiAobmV4dFRvUmVwb3J0ICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGYobmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChuZXh0UGF0aCkpLCBuZXh0VG9SZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV4dFRvUmVwb3J0IHRvIGJlIHRoaXMgc2VxdWVuY2UgbnVtYmVyLiBJdCdzIHRoZSBuZXh0IG9uZSB3ZVxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHJlcG9ydCwgaWYgd2UgZG9uJ3QgZmluZCBhbnkgdGFyZ2V0cyBmb3IgdGhpcyBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHNlcXVlbmNlIG51bWJlciBtdXN0IGJlIGRlZmluZWQgd2hlbiB0aGUgdGFyZ2V0SWRcbiAgICAgICAgICAgICAgICAvLyBpcyAwLlxuICAgICAgICAgICAgICAgIG5leHRUb1JlcG9ydCA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgIG5leHRQYXRoID0gcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCBuZXh0VG9SZXBvcnQgdG8gYmUgaW52YWxpZCwgd2Uga25vdyB3ZSBkb24ndCBuZWVkIHRvIHJlcG9ydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lIHNpbmNlIHdlIGZvdW5kIGEgdGFyZ2V0IGZvciBpdC5cbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgcmVwb3J0IHNlcXVlbmNlIG51bWJlcnMgYWZ0ZXIgZ2V0dGluZyB0byB0aGUgbmV4dCBrZXksIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBsYXN0IGtleSB3ZSBpdGVyYXRlZCBvdmVyIHdhcyBhbiBvcnBoYW5lZFxuICAgICAgICAgICAgLy8gZG9jdW1lbnQgYW5kIHJlcG9ydCBpdC5cbiAgICAgICAgICAgIGlmIChuZXh0VG9SZXBvcnQgIT09IExpc3RlblNlcXVlbmNlLklOVkFMSUQpIHtcbiAgICAgICAgICAgICAgICBmKG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgobmV4dFBhdGgpKSwgbmV4dFRvUmVwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZW50aW5lbEtleSQxKGtleSkge1xuICAgIHJldHVybiBbMCwgZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKV07XG59XG4vKipcbiAqIEByZXR1cm5zIEEgdmFsdWUgc3VpdGFibGUgZm9yIHdyaXRpbmcgYSBzZW50aW5lbCByb3cgaW4gdGhlIHRhcmdldC1kb2N1bWVudFxuICogc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIHNlbnRpbmVsUm93KGtleSwgc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4geyB0YXJnZXRJZDogMCwgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKSwgc2VxdWVuY2VOdW1iZXIgfTtcbn1cbmZ1bmN0aW9uIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pLnB1dChzZW50aW5lbFJvdyhrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW4tbWVtb3J5IGJ1ZmZlciBvZiBlbnRyaWVzIHRvIGJlIHdyaXR0ZW4gdG8gYSBSZW1vdGVEb2N1bWVudENhY2hlLlxuICogSXQgY2FuIGJlIHVzZWQgdG8gYmF0Y2ggdXAgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSB3cml0dGVuIHRvIHRoZSBjYWNoZSwgYnV0XG4gKiBhZGRpdGlvbmFsbHkgc3VwcG9ydHMgcmVhZGluZyBlbnRyaWVzIGJhY2sgd2l0aCB0aGUgYGdldEVudHJ5KClgIG1ldGhvZCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgdW5kZXJseWluZyBSZW1vdGVEb2N1bWVudENhY2hlIGlmIG5vIGVudHJ5IGlzXG4gKiBidWZmZXJlZC5cbiAqXG4gKiBFbnRyaWVzIGFkZGVkIHRvIHRoZSBjYWNoZSAqbXVzdCogYmUgcmVhZCBmaXJzdC4gVGhpcyBpcyB0byBmYWNpbGl0YXRlXG4gKiBjYWxjdWxhdGluZyB0aGUgc2l6ZSBkZWx0YSBvZiB0aGUgcGVuZGluZyBjaGFuZ2VzLlxuICpcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBjbGFzcyB3YXMgaW1wbGVtZW50ZWQgdGhlbiByZW1vdmVkIGZyb20gb3RoZXIgcGxhdGZvcm1zLlxuICogSWYgYnl0ZS1jb3VudGluZyBlbmRzIHVwIGJlaW5nIG5lZWRlZCBvbiB0aGUgb3RoZXIgcGxhdGZvcm1zLCBjb25zaWRlclxuICogcG9ydGluZyB0aGlzIGNsYXNzIGFzIHBhcnQgb2YgdGhhdCBpbXBsZW1lbnRhdGlvbiB3b3JrLlxuICovXG5jbGFzcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXkgdG8gdGhlIG5ldyBjYWNoZSBlbnRyeSB0aGF0IHNob3VsZCBiZSB3cml0dGVuLlxuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgT2JqZWN0TWFwKGtleSA9PiBrZXkudG9TdHJpbmcoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlc0FwcGxpZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVmZmVycyBhIGBSZW1vdGVEb2N1bWVudENhY2hlLmFkZEVudHJ5KClgIGNhbGwuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9ubHkgbW9kaWZ5IGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcbiAgICAgKiBgZ2V0RW50cnkoKS9nZXRFbnRyaWVzKClgIChlbmZvcmNlZCB2aWEgSW5kZXhlZERicyBgYXBwbHkoKWApLlxuICAgICAqL1xuICAgIGFkZEVudHJ5KGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90QXBwbGllZCgpO1xuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWZmZXJzIGEgYFJlbW90ZURvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoKWAgY2FsbC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb25seSByZW1vdmUgZG9jdW1lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIHZpYVxuICAgICAqIGBnZXRFbnRyeSgpL2dldEVudHJpZXMoKWAgKGVuZm9yY2VkIHZpYSBJbmRleGVkRGJzIGBhcHBseSgpYCkuXG4gICAgICovXG4gICAgcmVtb3ZlRW50cnkoa2V5LCByZWFkVGltZSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChrZXksIE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoa2V5KS5zZXRSZWFkVGltZShyZWFkVGltZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBhbiBlbnRyeSBpbiB0aGUgY2FjaGUuIFRoZSBidWZmZXJlZCBjaGFuZ2VzIHdpbGwgZmlyc3QgYmUgY2hlY2tlZCxcbiAgICAgKiBhbmQgaWYgbm8gYnVmZmVyZWQgY2hhbmdlIGFwcGxpZXMsIHRoaXMgd2lsbCBmb3J3YXJkIHRvXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gaW4gd2hpY2ggdG8gcGVyZm9ybSBhbnkgcGVyc2lzdGVuY2VcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXkgLSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBsb29rIHVwLlxuICAgICAqIEByZXR1cm5zIFRoZSBjYWNoZWQgZG9jdW1lbnQgb3IgYW4gaW52YWxpZCBkb2N1bWVudCBpZiB3ZSBoYXZlIG5vdGhpbmdcbiAgICAgKiBjYWNoZWQuXG4gICAgICovXG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90QXBwbGllZCgpO1xuICAgICAgICBjb25zdCBidWZmZXJlZEVudHJ5ID0gdGhpcy5jaGFuZ2VzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgIGlmIChidWZmZXJlZEVudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShidWZmZXJlZEVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIHNldmVyYWwgZW50cmllcyBpbiB0aGUgY2FjaGUsIGZvcndhcmRpbmcgdG9cbiAgICAgKiBgUmVtb3RlRG9jdW1lbnRDYWNoZS5nZXRFbnRyeSgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiBpbiB3aGljaCB0byBwZXJmb3JtIGFueSBwZXJzaXN0ZW5jZVxuICAgICAqICAgICBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleXMgLSBUaGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBsb29rIHVwLlxuICAgICAqIEByZXR1cm5zIEEgbWFwIG9mIGNhY2hlZCBkb2N1bWVudHMsIGluZGV4ZWQgYnkga2V5LiBJZiBhbiBlbnRyeSBjYW5ub3QgYmVcbiAgICAgKiAgICAgZm91bmQsIHRoZSBjb3JyZXNwb25kaW5nIGtleSB3aWxsIGJlIG1hcHBlZCB0byBhbiBpbnZhbGlkIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYnVmZmVyZWQgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBSZW1vdGVEb2N1bWVudENhY2hlLCB1c2luZ1xuICAgICAqIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhcHBseSh0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzQXBwbGllZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKiBIZWxwZXIgdG8gYXNzZXJ0IHRoaXMuY2hhbmdlcyBpcyBub3QgbnVsbCAgKi9cbiAgICBhc3NlcnROb3RBcHBsaWVkKCkge1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcbiAqIGBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKClgLlxuICovXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICBzZXRJbmRleE1hbmFnZXIoaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzdXBwbGllZCBlbnRyaWVzIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgYWRkRW50cnlgIGFyZSByZXF1aXJlZCB0byBnbyB0aHJvdWdoIHRoZSBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlclxuICAgICAqIHJldHVybmVkIGJ5IGBuZXdDaGFuZ2VCdWZmZXIoKWAgdG8gZW5zdXJlIHByb3BlciBhY2NvdW50aW5nIG9mIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIGFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRvYykge1xuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRTdG9yZS5wdXQoZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGRvY3VtZW50IGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQWxsIGNhbGxzIG9mIGByZW1vdmVFbnRyeWAgIGFyZSByZXF1aXJlZCB0byBnbyB0aHJvdWdoIHRoZSBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlclxuICAgICAqIHJldHVybmVkIGJ5IGBuZXdDaGFuZ2VCdWZmZXIoKWAgdG8gZW5zdXJlIHByb3BlciBhY2NvdW50aW5nIG9mIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSwgcmVhZFRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBzdG9yZS5kZWxldGUoZGJSZWFkVGltZUtleShkb2N1bWVudEtleSwgcmVhZFRpbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBjYWNoZSBzaXplLlxuICAgICAqXG4gICAgICogQ2FsbGVycyB0byBgYWRkRW50cnkoKWAgYW5kIGByZW1vdmVFbnRyeSgpYCAqbXVzdCogY2FsbCB0aGlzIGFmdGVyd2FyZHMgdG8gdXBkYXRlIHRoZVxuICAgICAqIGNhY2hlJ3MgbWV0YWRhdGEuXG4gICAgICovXG4gICAgdXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBtZXRhZGF0YS5ieXRlU2l6ZSArPSBzaXplRGVsdGE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGxldCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoZGJLZXkoZG9jdW1lbnRLZXkpKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIGRvYyA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChkb2N1bWVudEtleSwgZGJSZW1vdGVEb2MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IGVudHJ5IGFuZCBpdHMgc2l6ZS5cbiAgICAgKi9cbiAgICBnZXRTaXplZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGRvY3VtZW50OiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShkYktleShkb2N1bWVudEtleSkpXG4gICAgICAgIH0sIChfLCBkYlJlbW90ZURvYykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKSxcbiAgICAgICAgICAgICAgICBzaXplOiBkYkRvY3VtZW50U2l6ZShkYlJlbW90ZURvYylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChrZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIHNldmVyYWwgZW50cmllcyBpbiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXlzIC0gVGhlIHNldCBvZiBrZXlzIGVudHJpZXMgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBkb2N1bWVudHMgaW5kZXhlZCBieSBrZXkgYW5kIGEgbWFwIG9mIHNpemVzIGluZGV4ZWQgYnlcbiAgICAgKiAgICAga2V5ICh6ZXJvIGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBleGlzdCkuXG4gICAgICovXG4gICAgZ2V0U2l6ZWRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IHNpemVNYXAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoRGJFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCAoa2V5LCBkYlJlbW90ZURvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGtleSwgZGJSZW1vdGVEb2MpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgIHNpemVNYXAgPSBzaXplTWFwLmluc2VydChrZXksIGRiRG9jdW1lbnRTaXplKGRiUmVtb3RlRG9jKSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9jdW1lbnRzOiByZXN1bHRzLCBzaXplTWFwIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3JFYWNoRGJFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoZG9jdW1lbnRLZXlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvcnRlZEtleXMgPSBuZXcgU29ydGVkU2V0KGRiS2V5Q29tcGFyYXRvcik7XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGUgPT4gKHNvcnRlZEtleXMgPSBzb3J0ZWRLZXlzLmFkZChlKSkpO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKGRiS2V5KHNvcnRlZEtleXMuZmlyc3QoKSksIGRiS2V5KHNvcnRlZEtleXMubGFzdCgpKSk7XG4gICAgICAgIGNvbnN0IGtleUl0ZXIgPSBzb3J0ZWRLZXlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBuZXh0S2V5ID0ga2V5SXRlci5nZXROZXh0KCk7XG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LCByYW5nZSB9LCAoXywgZGJSZW1vdGVEb2MsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhbXG4gICAgICAgICAgICAgICAgLi4uZGJSZW1vdGVEb2MucHJlZml4UGF0aCxcbiAgICAgICAgICAgICAgICBkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgICAgICAgICAgZGJSZW1vdGVEb2MuZG9jdW1lbnRJZFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGtleXMgbm90IGZvdW5kIGluIGNhY2hlLlxuICAgICAgICAgICAgd2hpbGUgKG5leHRLZXkgJiYgZGJLZXlDb21wYXJhdG9yKG5leHRLZXksIHBvdGVudGlhbEtleSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRLZXkgJiYgbmV4dEtleS5pc0VxdWFsKHBvdGVudGlhbEtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBLZXkgZm91bmQgaW4gY2FjaGUuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgZGJSZW1vdGVEb2MpO1xuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmhhc05leHQoKSA/IGtleUl0ZXIuZ2V0TmV4dCgpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgdG8gdGhlIG5leHQga2V5IChpZiB0aGVyZSBpcyBvbmUpLlxuICAgICAgICAgICAgaWYgKG5leHRLZXkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnNraXAoZGJLZXkobmV4dEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUga2V5cyBhcmUgbm90IGluIHRoZSBjYWNoZS4gT25lIGNhc2Ugd2hlcmUgYGl0ZXJhdGVgXG4gICAgICAgICAgICAvLyBhYm92ZSB3b24ndCBnbyB0aHJvdWdoIHRoZW0gaXMgd2hlbiB0aGUgY2FjaGUgaXMgZW1wdHkuXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmhhc05leHQoKSA/IGtleUl0ZXIuZ2V0TmV4dCgpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG11dGF0ZWREb2NzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBxdWVyeS5wYXRoO1xuICAgICAgICBjb25zdCBzdGFydEtleSA9IFtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIHRvRGJUaW1lc3RhbXBLZXkob2Zmc2V0LnJlYWRUaW1lKSxcbiAgICAgICAgICAgIG9mZnNldC5kb2N1bWVudEtleS5wYXRoLmlzRW1wdHkoKVxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IG9mZnNldC5kb2N1bWVudEtleS5wYXRoLmxhc3RTZWdtZW50KClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZW5kS2V5ID0gW1xuICAgICAgICAgICAgY29sbGVjdGlvbi5wb3BMYXN0KCkudG9BcnJheSgpLFxuICAgICAgICAgICAgY29sbGVjdGlvbi5sYXN0U2VnbWVudCgpLFxuICAgICAgICAgICAgW051bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0sXG4gICAgICAgICAgICAnJ1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAubG9hZEFsbChJREJLZXlSYW5nZS5ib3VuZChzdGFydEtleSwgZW5kS2V5LCB0cnVlKSlcbiAgICAgICAgICAgIC5uZXh0KGRiUmVtb3RlRG9jcyA9PiB7XG4gICAgICAgICAgICBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoZGJSZW1vdGVEb2NzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYlJlbW90ZURvYyBvZiBkYlJlbW90ZURvY3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoZGJSZW1vdGVEb2MucHJlZml4UGF0aC5jb25jYXQoZGJSZW1vdGVEb2MuY29sbGVjdGlvbkdyb3VwLCBkYlJlbW90ZURvYy5kb2N1bWVudElkKSksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpIHx8IG11dGF0ZWREb2NzLmhhcyhkb2N1bWVudC5rZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgdGhlIGRvY3VtZW50IG1hdGNoZXMgdGhlIGdpdmVuIHF1ZXJ5LCBvciBpdCBpcyBtdXRhdGVkLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgbGltaXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGVuZEtleSA9IGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgSW5kZXhPZmZzZXQubWF4KCkpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLmJvdW5kKHN0YXJ0S2V5LCBlbmRLZXksIHRydWUpXG4gICAgICAgIH0sIChfLCBkYlJlbW90ZURvYywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGRiUmVtb3RlRG9jLnByZWZpeFBhdGguY29uY2F0KGRiUmVtb3RlRG9jLmNvbGxlY3Rpb25Hcm91cCwgZGJSZW1vdGVEb2MuZG9jdW1lbnRJZCkpLCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5zaXplID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcywgISFvcHRpb25zICYmIG9wdGlvbnMudHJhY2tSZW1vdmFscyk7XG4gICAgfVxuICAgIGdldFNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHR4bikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS5ieXRlU2l6ZSk7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKHR4bikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRHbG9iYWxTdG9yZSh0eG4pXG4gICAgICAgICAgICAuZ2V0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KCEhbWV0YWRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0TWV0YWRhdGEodHhuLCBtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRHbG9iYWxTdG9yZSh0eG4pLnB1dChEYlJlbW90ZURvY3VtZW50R2xvYmFsS2V5LCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYGRiUmVtb3RlRG9jYCBhbmQgcmV0dXJucyB0aGUgZG9jdW1lbnQgKG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIGZvcm1hdCB1c2VkIGZvciBzZW50aW5lbCBkZWxldGVzKS5cbiAgICAgKi9cbiAgICBtYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYykge1xuICAgICAgICBpZiAoZGJSZW1vdGVEb2MpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGZyb21EYlJlbW90ZURvY3VtZW50KHRoaXMuc2VyaWFsaXplciwgZGJSZW1vdGVEb2MpO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0aGUgZG9jdW1lbnQgaXMgYSBzZW50aW5lbCByZW1vdmFsIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGluIHRoZVxuICAgICAgICAgICAgLy8gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxuICAgICAgICAgICAgY29uc3QgaXNTZW50aW5lbFJlbW92YWwgPSBkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgaWYgKCFpc1NlbnRpbmVsUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpO1xuICAgIH1cbn1cbi8qKiBDcmVhdGVzIGEgbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUuICovXG5mdW5jdGlvbiBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHNlcmlhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNlcmlhbGl6ZXIpO1xufVxuLyoqXG4gKiBIYW5kbGVzIHRoZSBkZXRhaWxzIG9mIGFkZGluZyBhbmQgdXBkYXRpbmcgZG9jdW1lbnRzIGluIHRoZSBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlLlxuICpcbiAqIFVubGlrZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIsIHRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gY29tcHV0ZXMgdGhlIHNpemVcbiAqIGRlbHRhIGZvciBhbGwgc3VibWl0dGVkIGNoYW5nZXMuIFRoaXMgYXZvaWRzIGhhdmluZyB0byByZS1yZWFkIGFsbCBkb2N1bWVudHMgZnJvbSBJbmRleGVkRGJcbiAqIHdoZW4gd2UgYXBwbHkgdGhlIGNoYW5nZXMuXG4gKi9cbmNsYXNzIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIGV4dGVuZHMgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudENhY2hlIC0gVGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gICAgICogQHBhcmFtIHRyYWNrUmVtb3ZhbHMgLSBXaGV0aGVyIHRvIGNyZWF0ZSBzZW50aW5lbCBkZWxldGVzIHRoYXQgY2FuIGJlIHRyYWNrZWQgYnlcbiAgICAgKiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50Q2FjaGUsIHRyYWNrUmVtb3ZhbHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcbiAgICAgICAgdGhpcy50cmFja1JlbW92YWxzID0gdHJhY2tSZW1vdmFscztcbiAgICAgICAgLy8gQSBtYXAgb2YgZG9jdW1lbnQgc2l6ZXMgYW5kIHJlYWQgdGltZXMgcHJpb3IgdG8gYXBwbHlpbmcgdGhlIGNoYW5nZXMgaW5cbiAgICAgICAgLy8gdGhpcyBidWZmZXIuXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMgPSBuZXcgT2JqZWN0TWFwKGtleSA9PiBrZXkudG9TdHJpbmcoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgfVxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBsZXQgc2l6ZURlbHRhID0gMDtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5mb3JFYWNoKChrZXksIGRvY3VtZW50Q2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0RvYyA9IHRoaXMuZG9jdW1lbnRTdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBwcmV2aW91c0RvYy5yZWFkVGltZSkpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50Q2hhbmdlLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gdG9EYlJlbW90ZURvY3VtZW50KHRoaXMuZG9jdW1lbnRDYWNoZS5zZXJpYWxpemVyLCBkb2N1bWVudENoYW5nZSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQoa2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gZGJEb2N1bWVudFNpemUoZG9jKTtcbiAgICAgICAgICAgICAgICBzaXplRGVsdGEgKz0gc2l6ZSAtIHByZXZpb3VzRG9jLnNpemU7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaXplRGVsdGEgLT0gcHJldmlvdXNEb2Muc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JlbW92YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHRyYWNrIHJlbW92YWxzLCB3ZSBzdG9yZSBhIFwic2VudGluZWwgZGVsZXRlXCIgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW90ZURvY3VtZW50Q2FjaGUuIFRoaXMgZW50cnkgaXMgcmVwcmVzZW50ZWQgYnkgYSBOb0RvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggYSB2ZXJzaW9uIG9mIDAgYW5kIGlnbm9yZWQgYnkgYG1heWJlRGVjb2RlRG9jdW1lbnQoKWAgYnV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlZCBpbiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVkRG9jID0gdG9EYlJlbW90ZURvY3VtZW50KHRoaXMuZG9jdW1lbnRDYWNoZS5zZXJpYWxpemVyLCBkb2N1bWVudENoYW5nZS5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkZWxldGVkRG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvblBhcmVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLnVwZGF0ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBzaXplRGVsdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgZ2V0RnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHNpemUgb2YgZXZlcnl0aGluZyB3ZSBsb2FkIGZyb20gdGhlIGNhY2hlIHNvIHdlIGNhbiBjb21wdXRlIGEgZGVsdGEgbGF0ZXIuXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRTaXplZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSlcbiAgICAgICAgICAgIC5uZXh0KGdldFJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGVzLnNldChkb2N1bWVudEtleSwge1xuICAgICAgICAgICAgICAgIHNpemU6IGdldFJlc3VsdC5zaXplLFxuICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBnZXRSZXN1bHQuZG9jdW1lbnQucmVhZFRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlc3VsdC5kb2N1bWVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFsbEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgc2l6ZSBvZiBldmVyeXRoaW5nIHdlIGxvYWQgZnJvbSB0aGUgY2FjaGUgc28gd2UgY2FuIGNvbXB1dGVcbiAgICAgICAgLy8gYSBkZWx0YSBsYXRlci5cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxuICAgICAgICAgICAgLm5leHQoKHsgZG9jdW1lbnRzLCBzaXplTWFwIH0pID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGBnZXRBbGxGcm9tQ2FjaGVgIHJldHVybnMgdHdvIG1hcHMgaW5zdGVhZCBvZiBhIHNpbmdsZSBtYXAgZnJvbVxuICAgICAgICAgICAgLy8ga2V5cyB0byBgRG9jdW1lbnRTaXplRW50cnlgcy4gVGhpcyBpcyB0byBhbGxvdyByZXR1cm5pbmcgdGhlXG4gICAgICAgICAgICAvLyBgTXV0YWJsZURvY3VtZW50TWFwYCBkaXJlY3RseSwgd2l0aG91dCBhIGNvbnZlcnNpb24uXG4gICAgICAgICAgICBzaXplTWFwLmZvckVhY2goKGRvY3VtZW50S2V5LCBzaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcy5zZXQoZG9jdW1lbnRLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRpbWU6IGRvY3VtZW50cy5nZXQoZG9jdW1lbnRLZXkpLnJlYWRUaW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSByZW1vdGVEb2N1bWVudHMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiByZW1vdGVEb2N1bWVudHNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50U3RvcmUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEga2V5IHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRvY3VtZW50IGxvb2t1cHMgb24gdGhlXG4gKiBgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXhgIGluZGV4LlxuICovXG5mdW5jdGlvbiBkYktleShkb2N1bWVudEtleSkge1xuICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudEtleS5wYXRoLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvKiBwcmVmaXggcGF0aCAqLyBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMiksXG4gICAgICAgIC8qIGNvbGxlY3Rpb24gaWQgKi8gcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICBdO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEga2V5IHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRvY3VtZW50IGxvb2t1cHMgdmlhIHRoZSBwcmltYXJ5IGtleSBvZlxuICogdGhlIERiUmVtb3RlRG9jdW1lbnQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkYlJlYWRUaW1lS2V5KGRvY3VtZW50S2V5LCByZWFkVGltZSkge1xuICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudEtleS5wYXRoLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvKiBwcmVmaXggcGF0aCAqLyBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMiksXG4gICAgICAgIC8qIGNvbGxlY3Rpb24gaWQgKi8gcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KHJlYWRUaW1lKSxcbiAgICAgICAgLyogZG9jdW1lbnQgaWQgKi8gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gICAgXTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkb2N1bWVudCBsb29rdXBzIG9uIHRoZVxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4YCBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZGJDb2xsZWN0aW9uR3JvdXBLZXkoY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQpIHtcbiAgICBjb25zdCBwYXRoID0gb2Zmc2V0LmRvY3VtZW50S2V5LnBhdGgudG9BcnJheSgpO1xuICAgIHJldHVybiBbXG4gICAgICAgIC8qIGNvbGxlY3Rpb24gaWQgKi8gY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcbiAgICAgICAgLyogZG9jdW1lbnQgaWQgKi8gcGF0aC5sZW5ndGggPiAwID8gcGF0aFtwYXRoLmxlbmd0aCAtIDFdIDogJydcbiAgICBdO1xufVxuLyoqXG4gKiBDb21wYXJhdG9yIHRoYXQgY29tcGFyZXMgZG9jdW1lbnQga2V5cyBhY2NvcmRpbmcgdG8gdGhlIHByaW1hcnkga2V5IHNvcnRpbmdcbiAqIHVzZWQgYnkgdGhlIGBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRgIHN0b3JlIChieSBwcmVmaXggcGF0aCwgY29sbGVjdGlvbiBpZFxuICogYW5kIHRoZW4gZG9jdW1lbnQgSUQpLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGRiS2V5Q29tcGFyYXRvcihsLCByKSB7XG4gICAgY29uc3QgbGVmdCA9IGwucGF0aC50b0FycmF5KCk7XG4gICAgY29uc3QgcmlnaHQgPSByLnBhdGgudG9BcnJheSgpO1xuICAgIC8vIFRoZSBvcmRlcmluZyBpcyBiYXNlZCBvbiBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vYmxpbmsvKy9mZTVjMjFmZWY5NGRhZTcxYzFjMzM0NDc3NWI4ZDhhN2Y3ZTZkOWVjL1NvdXJjZS9tb2R1bGVzL2luZGV4ZWRkYi9JREJLZXkuY3BwIzc0XG4gICAgbGV0IGNtcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aCAtIDIgJiYgaSA8IHJpZ2h0Lmxlbmd0aCAtIDI7ICsraSkge1xuICAgICAgICBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRbaV0sIHJpZ2h0W2ldKTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xuICAgIGlmIChjbXApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2xlZnQubGVuZ3RoIC0gMl0sIHJpZ2h0W3JpZ2h0Lmxlbmd0aCAtIDJdKTtcbiAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRbbGVmdC5sZW5ndGggLSAxXSwgcmlnaHRbcmlnaHQubGVuZ3RoIC0gMV0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTY2hlbWEgVmVyc2lvbiBmb3IgdGhlIFdlYiBjbGllbnQ6XG4gKiAxLiAgSW5pdGlhbCB2ZXJzaW9uIGluY2x1ZGluZyBNdXRhdGlvbiBRdWV1ZSwgUXVlcnkgQ2FjaGUsIGFuZCBSZW1vdGVcbiAqICAgICBEb2N1bWVudCBDYWNoZVxuICogMi4gIFVzZWQgdG8gZW5zdXJlIGEgdGFyZ2V0R2xvYmFsIG9iamVjdCBleGlzdHMgYW5kIGFkZCB0YXJnZXRDb3VudCB0byBpdC4gTm9cbiAqICAgICBsb25nZXIgcmVxdWlyZWQgYmVjYXVzZSBtaWdyYXRpb24gMyB1bmNvbmRpdGlvbmFsbHkgY2xlYXJzIGl0LlxuICogMy4gIERyb3BwZWQgYW5kIHJlLWNyZWF0ZWQgUXVlcnkgQ2FjaGUgdG8gZGVhbCB3aXRoIGNhY2hlIGNvcnJ1cHRpb24gcmVsYXRlZFxuICogICAgIHRvIGxpbWJvIHJlc29sdXRpb24uIEFkZHJlc3Nlc1xuICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1pb3Mtc2RrL2lzc3Vlcy8xNTQ4XG4gKiA0LiAgTXVsdGktVGFiIFN1cHBvcnQuXG4gKiA1LiAgUmVtb3ZhbCBvZiBoZWxkIHdyaXRlIGFja3MuXG4gKiA2LiAgQ3JlYXRlIGRvY3VtZW50IGdsb2JhbCBmb3IgdHJhY2tpbmcgZG9jdW1lbnQgY2FjaGUgc2l6ZS5cbiAqIDcuICBFbnN1cmUgZXZlcnkgY2FjaGVkIGRvY3VtZW50IGhhcyBhIHNlbnRpbmVsIHJvdyB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLlxuICogOC4gIEFkZCBjb2xsZWN0aW9uLXBhcmVudCBpbmRleCBmb3IgQ29sbGVjdGlvbiBHcm91cCBxdWVyaWVzLlxuICogOS4gIENoYW5nZSBSZW1vdGVEb2N1bWVudENoYW5nZXMgc3RvcmUgdG8gYmUga2V5ZWQgYnkgcmVhZFRpbWUgcmF0aGVyIHRoYW5cbiAqICAgICBhbiBhdXRvLWluY3JlbWVudGluZyBJRC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgSW5kZXgtRnJlZSBxdWVyaWVzLlxuICogMTAuIFJld3JpdGUgdGhlIGNhbm9uaWNhbCBJRHMgdG8gdGhlIGV4cGxpY2l0IFByb3RvYnVmLWJhc2VkIGZvcm1hdC5cbiAqIDExLiBBZGQgYnVuZGxlcyBhbmQgbmFtZWRfcXVlcmllcyBmb3IgYnVuZGxlIHN1cHBvcnQuXG4gKiAxMi4gQWRkIGRvY3VtZW50IG92ZXJsYXlzLlxuICogMTMuIFJld3JpdGUgdGhlIGtleXMgb2YgdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZSB0byBhbGxvdyBmb3IgZWZmaWNpZW50XG4gKiAgICAgZG9jdW1lbnQgbG9va3VwIHZpYSBgZ2V0QWxsKClgLlxuICogMTQuIEFkZCBvdmVybGF5cy5cbiAqIDE1LiBBZGQgaW5kZXhpbmcgc3VwcG9ydC5cbiAqIDE2LiBQYXJzZSB0aW1lc3RhbXAgc3RyaW5ncyBiZWZvcmUgY3JlYXRpbmcgaW5kZXggZW50cmllcy5cbiAqL1xuY29uc3QgU0NIRU1BX1ZFUlNJT04gPSAxNztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGxvY2FsIHZpZXcgKG92ZXJsYXkpIG9mIGEgZG9jdW1lbnQsIGFuZCB0aGUgZmllbGRzIHRoYXQgYXJlXG4gKiBsb2NhbGx5IG11dGF0ZWQuXG4gKi9cbmNsYXNzIE92ZXJsYXllZERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvdmVybGF5ZWREb2N1bWVudCwgXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkcyB0aGF0IGFyZSBsb2NhbGx5IG11dGF0ZWQgYnkgcGF0Y2ggbXV0YXRpb25zLlxuICAgICAqXG4gICAgICogSWYgdGhlIG92ZXJsYXllZFx0ZG9jdW1lbnQgaXMgZnJvbSBzZXQgb3IgZGVsZXRlIG11dGF0aW9ucywgdGhpcyBpcyBgbnVsbGAuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gb3ZlcmxheSAobXV0YXRpb24pIGZvciB0aGUgZG9jdW1lbnQsIHRoaXMgaXMgYW4gZW1wdHkgYEZpZWxkTWFza2AuXG4gICAgICovXG4gICAgbXV0YXRlZEZpZWxkcykge1xuICAgICAgICB0aGlzLm92ZXJsYXllZERvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubXV0YXRlZEZpZWxkcyA9IG11dGF0ZWRGaWVsZHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHJlYWRvbmx5IHZpZXcgb2YgdGhlIGxvY2FsIHN0YXRlIG9mIGFsbCBkb2N1bWVudHMgd2UncmUgdHJhY2tpbmcgKGkuZS4gd2VcbiAqIGhhdmUgYSBjYWNoZWQgdmVyc2lvbiBpbiByZW1vdGVEb2N1bWVudENhY2hlIG9yIGxvY2FsIG11dGF0aW9ucyBmb3IgdGhlXG4gKiBkb2N1bWVudCkuIFRoZSB2aWV3IGlzIGNvbXB1dGVkIGJ5IGFwcGx5aW5nIHRoZSBtdXRhdGlvbnMgaW4gdGhlXG4gKiBNdXRhdGlvblF1ZXVlIHRvIHRoZSBSZW1vdGVEb2N1bWVudENhY2hlLlxuICovXG5jbGFzcyBMb2NhbERvY3VtZW50c1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHJlbW90ZURvY3VtZW50Q2FjaGUsIG11dGF0aW9uUXVldWUsIGRvY3VtZW50T3ZlcmxheUNhY2hlLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlID0gcmVtb3RlRG9jdW1lbnRDYWNoZTtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlID0gbXV0YXRpb25RdWV1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSA9IGRvY3VtZW50T3ZlcmxheUNhY2hlO1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudCBpZGVudGlmaWVkIGJ5IGBrZXlgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTG9jYWwgdmlldyBvZiB0aGUgZG9jdW1lbnQgb3IgbnVsbCBpZiB3ZSBkb24ndCBoYXZlIGFueSBjYWNoZWRcbiAgICAgKiBzdGF0ZSBmb3IgaXQuXG4gICAgICovXG4gICAgZ2V0RG9jdW1lbnQodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlXG4gICAgICAgICAgICAuZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KVxuICAgICAgICAgICAgLm5leHQodmFsdWUgPT4ge1xuICAgICAgICAgICAgb3ZlcmxheSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZS5nZXRFbnRyeSh0cmFuc2FjdGlvbiwga2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvY3VtZW50LCBGaWVsZE1hc2suZW1wdHkoKSwgVGltZXN0YW1wLm5vdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBpZGVudGlmaWVkIGJ5IGBrZXlzYC5cbiAgICAgKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHN0YXRlIGZvciBhIGRvY3VtZW50IGluIGBrZXlzYCwgYSBOb0RvY3VtZW50IHdpbGxcbiAgICAgKiBiZSBzdG9yZWQgZm9yIHRoYXQga2V5IGluIHRoZSByZXN1bHRpbmcgc2V0LlxuICAgICAqL1xuICAgIGdldERvY3VtZW50cyh0cmFuc2FjdGlvbiwga2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwga2V5cylcbiAgICAgICAgICAgIC5uZXh0KGRvY3MgPT4gdGhpcy5nZXRMb2NhbFZpZXdPZkRvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcywgZG9jdW1lbnRLZXlTZXQoKSkubmV4dCgoKSA9PiBkb2NzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gYGdldERvY3VtZW50c2AsIGJ1dCBjcmVhdGVzIHRoZSBsb2NhbCB2aWV3IGZyb20gdGhlIGdpdmVuXG4gICAgICogYGJhc2VEb2NzYCB3aXRob3V0IHJldHJpZXZpbmcgZG9jdW1lbnRzIGZyb20gdGhlIGxvY2FsIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRoaXMgb3BlcmF0aW9uIGlzIHNjb3BlZCB0by5cbiAgICAgKiBAcGFyYW0gZG9jcyAtIFRoZSBkb2N1bWVudHMgdG8gYXBwbHkgbG9jYWwgbXV0YXRpb25zIHRvIGdldCB0aGUgbG9jYWwgdmlld3MuXG4gICAgICogQHBhcmFtIGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZCAtIFRoZSBzZXQgb2YgZG9jdW1lbnQga2V5cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGVcbiAgICAgKiAgIGlzIGNoYW5nZWQuIFRoaXMgaXMgdXNlZnVsIHRvIGRldGVybWluZSBpZiBzb21lIGRvY3VtZW50cyBvdmVybGF5IG5lZWRzXG4gICAgICogICB0byBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MsIGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZCA9IGRvY3VtZW50S2V5U2V0KCkpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBkb2NzKS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVWaWV3cyh0cmFuc2FjdGlvbiwgZG9jcywgb3ZlcmxheXMsIGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZCkubmV4dChjb21wdXRlVmlld3NSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudE1hcCgpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVWaWV3c1Jlc3VsdC5mb3JFYWNoKChkb2N1bWVudEtleSwgb3ZlcmxheWVkRG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmluc2VydChkb2N1bWVudEtleSwgb3ZlcmxheWVkRG9jdW1lbnQub3ZlcmxheWVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG92ZXJsYXllZCBkb2N1bWVudHMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBtYXAsIHdoaWNoIHdpbGwgaW5jbHVkZVxuICAgICAqIHRoZSBsb2NhbCB2aWV3IG9mIHRob3NlIGRvY3VtZW50cyBhbmQgYSBgRmllbGRNYXNrYCBpbmRpY2F0aW5nIHdoaWNoIGZpZWxkc1xuICAgICAqIGFyZSBtdXRhdGVkIGxvY2FsbHksIGBudWxsYCBpZiBvdmVybGF5IGlzIGEgU2V0IG9yIERlbGV0ZSBtdXRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRPdmVybGF5ZWREb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBkb2NzKS5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZG9jdW1lbnRLZXlTZXQoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBvdmVybGF5cyBmb3Ige0Bjb2RlIGRvY3N9IGFuZCBhZGRzIHRoZW0gdG8gcHJvdmlkZWQgb3ZlcmxheSBtYXBcbiAgICAgKiBpZiB0aGUgbWFwIGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBhbiBlbnRyeSBmb3IgdGhlIGdpdmVuIGRvY3VtZW50IGtleS5cbiAgICAgKi9cbiAgICBwb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykge1xuICAgICAgICBjb25zdCBtaXNzaW5nT3ZlcmxheXMgPSBbXTtcbiAgICAgICAgZG9jcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoIW92ZXJsYXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ092ZXJsYXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlXG4gICAgICAgICAgICAuZ2V0T3ZlcmxheXModHJhbnNhY3Rpb24sIG1pc3NpbmdPdmVybGF5cylcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgoa2V5LCB2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9jYWwgdmlldyBmb3IgdGhlIGdpdmVuIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2NzIC0gVGhlIGRvY3VtZW50cyB0byBjb21wdXRlIHZpZXdzIGZvci4gSXQgYWxzbyBoYXMgdGhlIGJhc2VcbiAgICAgKiAgIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheXMgLSBUaGUgb3ZlcmxheXMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdpdmVuIGJhc2VcbiAgICAgKiAgIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gZXhpc3RlbmNlU3RhdGVDaGFuZ2VkIC0gQSBzZXQgb2YgZG9jdW1lbnRzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZXNcbiAgICAgKiAgIG1pZ2h0IGhhdmUgY2hhbmdlZC4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZVxuICAgICAqICAgb3ZlcmxheXMgZnJvbSBtdXRhdGlvbiBxdWV1ZXMuXG4gICAgICogQHJldHVybiBBIG1hcCByZXByZXNlbnRzIHRoZSBsb2NhbCBkb2N1bWVudHMgdmlldy5cbiAgICAgKi9cbiAgICBjb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgbGV0IHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGNvbnN0IG11dGF0ZWRGaWVsZHMgPSBuZXdEb2N1bWVudEtleU1hcCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3T3ZlcmxheWVkRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgZG9jcy5mb3JFYWNoKChfLCBkb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoZG9jLmtleSk7XG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBhbiBvdmVybGF5IGlmIHRoZSBkb2N1bWVudCdzIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2VkIGR1ZSB0b1xuICAgICAgICAgICAgLy8gYSByZW1vdGUgZXZlbnQgKmFuZCogdGhlIG92ZXJsYXkgaXMgYSBQYXRjaE11dGF0aW9uLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGV4aXN0ZW5jZSBzdGF0ZSBjYW4gY2hhbmdlIGlmIHNvbWUgcGF0Y2ggbXV0YXRpb24nc1xuICAgICAgICAgICAgLy8gcHJlY29uZGl0aW9ucyBhcmUgbWV0LlxuICAgICAgICAgICAgLy8gTk9URTogd2UgcmVjYWxjdWxhdGUgd2hlbiBgb3ZlcmxheWAgaXMgdW5kZWZpbmVkIGFzIHdlbGwsIGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgcGF0Y2ggbXV0YXRpb24gd2hvc2UgcHJlY29uZGl0aW9uIGRvZXMgbm90IG1hdGNoIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGNoYW5nZSAoaGVuY2Ugb3ZlcmxheSBpcyB1bmRlZmluZWQpLCBidXQgd291bGQgbm93IG1hdGNoLlxuICAgICAgICAgICAgaWYgKGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZC5oYXMoZG9jLmtleSkgJiZcbiAgICAgICAgICAgICAgICAob3ZlcmxheSA9PT0gdW5kZWZpbmVkIHx8IG92ZXJsYXkubXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gcmVjYWxjdWxhdGVEb2N1bWVudHMuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzLnNldChkb2Mua2V5LCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpKTtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jLCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpLCBUaW1lc3RhbXAubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gb3ZlcmxheSBleGlzdHNcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBFTVBUWSB0byBpbmRpY2F0ZSB0aGVyZSBpcyBubyBvdmVybGF5IGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgRmllbGRNYXNrLmVtcHR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIHJlY2FsY3VsYXRlRG9jdW1lbnRzKS5uZXh0KHJlY2FsY3VsYXRlZEZpZWxkcyA9PiB7XG4gICAgICAgICAgICByZWNhbGN1bGF0ZWRGaWVsZHMuZm9yRWFjaCgoZG9jdW1lbnRLZXksIG1hc2spID0+IG11dGF0ZWRGaWVsZHMuc2V0KGRvY3VtZW50S2V5LCBtYXNrKSk7XG4gICAgICAgICAgICBkb2NzLmZvckVhY2goKGRvY3VtZW50S2V5LCBkb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5zZXQoZG9jdW1lbnRLZXksIG5ldyBPdmVybGF5ZWREb2N1bWVudChkb2N1bWVudCwgKF9hID0gbXV0YXRlZEZpZWxkcy5nZXQoZG9jdW1lbnRLZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpIHtcbiAgICAgICAgY29uc3QgbWFza3MgPSBuZXdEb2N1bWVudEtleU1hcCgpO1xuICAgICAgICAvLyBBIHJldmVyc2UgbG9va3VwIG1hcCBmcm9tIGJhdGNoIGlkIHRvIHRoZSBkb2N1bWVudHMgd2l0aGluIHRoYXQgYmF0Y2guXG4gICAgICAgIGxldCBkb2N1bWVudHNCeUJhdGNoSWQgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XG4gICAgICAgIGxldCBwcm9jZXNzZWQgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvblF1ZXVlXG4gICAgICAgICAgICAuZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBkb2NzKVxuICAgICAgICAgICAgLm5leHQoYmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIGJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlRG9jID0gZG9jcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VEb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWFzayA9IG1hc2tzLmdldChrZXkpIHx8IEZpZWxkTWFzay5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gYmF0Y2guYXBwbHlUb0xvY2FsVmlldyhiYXNlRG9jLCBtYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgbWFza3Muc2V0KGtleSwgbWFzayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NldCA9IChkb2N1bWVudHNCeUJhdGNoSWQuZ2V0KGJhdGNoLmJhdGNoSWQpIHx8IGRvY3VtZW50S2V5U2V0KCkpLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudHNCeUJhdGNoSWQgPSBkb2N1bWVudHNCeUJhdGNoSWQuaW5zZXJ0KGJhdGNoLmJhdGNoSWQsIG5ld1NldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIGJhdGNoIElEcywgYW5kIHNraXAgZG9jdW1lbnRzIHRoYXQgYXJlXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHNhdmVkLlxuICAgICAgICAgICAgY29uc3QgaXRlciA9IGRvY3VtZW50c0J5QmF0Y2hJZC5nZXRSZXZlcnNlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hJZCA9IGVudHJ5LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdNdXRhdGlvbk1hcCgpO1xuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheU11dGF0aW9uID0gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKGRvY3MuZ2V0KGtleSksIG1hc2tzLmdldChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5TXV0YXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQoa2V5LCBvdmVybGF5TXV0YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlLnNhdmVPdmVybGF5cyh0cmFuc2FjdGlvbiwgYmF0Y2hJZCwgb3ZlcmxheXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBtYXNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyBvdmVybGF5cyBieSByZWFkaW5nIHRoZSBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGVcbiAgICAgKiBmaXJzdCwgYW5kIHNhdmVzIHRoZW0gYWZ0ZXIgdGhleSBhcmUgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICByZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCB2aWV3IG9mIGFsbCBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgcGVyc2lzdGVuY2UgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIG1hdGNoIGRvY3VtZW50cyBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBSZWFkIHRpbWUgYW5kIGtleSB0byBzdGFydCBzY2FubmluZyBieSAoZXhjbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIEEgb3B0aW9uYWwgdHJhY2tlciB0byBrZWVwIGEgcmVjb3JkIG9mIGltcG9ydGFudCBkZXRhaWxzXG4gICAgICogICBkdXJpbmcgZGF0YWJhc2UgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRRdWVyeSQxKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdEb2N1bWVudFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeS5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uR3JvdXBRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb2xsZWN0aW9uIGdyb3VwLCByZXR1cm5zIHRoZSBuZXh0IGRvY3VtZW50cyB0aGF0IGZvbGxvdyB0aGUgcHJvdmlkZWQgb2Zmc2V0LCBhbG9uZ1xuICAgICAqIHdpdGggYW4gdXBkYXRlZCBiYXRjaCBJRC5cbiAgICAgKlxuICAgICAqIDxwPlRoZSBkb2N1bWVudHMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgYXJlIG9yZGVyZWQgYnkgcmVtb3RlIHZlcnNpb24gZnJvbSB0aGUgcHJvdmlkZWRcbiAgICAgKiBvZmZzZXQuIElmIHRoZXJlIGFyZSBubyBtb3JlIHJlbW90ZSBkb2N1bWVudHMgYWZ0ZXIgdGhlIHByb3ZpZGVkIG9mZnNldCwgZG9jdW1lbnRzIHdpdGhcbiAgICAgKiBtdXRhdGlvbnMgaW4gb3JkZXIgb2YgYmF0Y2ggaWQgZnJvbSB0aGUgb2Zmc2V0IGFyZSByZXR1cm5lZC4gU2luY2UgYWxsIGRvY3VtZW50cyBpbiBhIGJhdGNoIGFyZVxuICAgICAqIHJldHVybmVkIHRvZ2V0aGVyLCB0aGUgdG90YWwgbnVtYmVyIG9mIGRvY3VtZW50cyByZXR1cm5lZCBjYW4gZXhjZWVkIHtAY29kZSBjb3VudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbkdyb3VwIFRoZSBjb2xsZWN0aW9uIGdyb3VwIGZvciB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBpbmRleCBpbnRvLlxuICAgICAqIEBwYXJhbSBjb3VudCBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJuIEEgTG9jYWxXcml0ZVJlc3VsdCB3aXRoIHRoZSBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCBhbmQgdGhlIGxhc3QgcHJvY2Vzc2VkIGJhdGNoIGlkLlxuICAgICAqL1xuICAgIGdldE5leHREb2N1bWVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KVxuICAgICAgICAgICAgLm5leHQoKG9yaWdpbmFsRG9jcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXNQcm9taXNlID0gY291bnQgLSBvcmlnaW5hbERvY3Muc2l6ZSA+IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUuZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkLCBjb3VudCAtIG9yaWdpbmFsRG9jcy5zaXplKVxuICAgICAgICAgICAgICAgIDogUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobmV3T3ZlcmxheU1hcCgpKTtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsc2l0ZSB3aWxsIHVzZSB0aGUgbGFyZ2VzdCBiYXRjaCBJRCB0b2dldGhlciB3aXRoIHRoZSBsYXRlc3QgcmVhZCB0aW1lIHRvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBuZXcgaW5kZXggb2Zmc2V0LiBTaW5jZSB3ZSBvbmx5IHByb2Nlc3MgYmF0Y2ggSURzIGlmIGFsbCByZW1vdGUgZG9jdW1lbnRzIGhhdmUgYmVlbiByZWFkLFxuICAgICAgICAgICAgLy8gbm8gb3ZlcmxheSB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsIHJlYWQgdGltZS4gVGhpcyBpcyB3aHkgd2Ugb25seSBuZWVkIHRvIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgLy8gdGhlIGJhdGNoIGlkLlxuICAgICAgICAgICAgbGV0IGxhcmdlc3RCYXRjaElkID0gSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkRG9jcyA9IG9yaWdpbmFsRG9jcztcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5c1Byb21pc2UubmV4dChvdmVybGF5cyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKG92ZXJsYXlzLCAoa2V5LCBvdmVybGF5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXJnZXN0QmF0Y2hJZCA8IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhcmdlc3RCYXRjaElkID0gb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxEb2NzLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KGRvYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZERvY3MgPSBtb2RpZmllZERvY3MuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5wb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgb3JpZ2luYWxEb2NzKSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIG1vZGlmaWVkRG9jcywgb3ZlcmxheXMsIGRvY3VtZW50S2V5U2V0KCkpKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChsb2NhbERvY3MgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hJZDogbGFyZ2VzdEJhdGNoSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAobG9jYWxEb2NzKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdEb2N1bWVudFF1ZXJ5KHRyYW5zYWN0aW9uLCBkb2NQYXRoKSB7XG4gICAgICAgIC8vIEp1c3QgZG8gYSBzaW1wbGUgZG9jdW1lbnQgbG9va3VwLlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudCh0cmFuc2FjdGlvbiwgbmV3IERvY3VtZW50S2V5KGRvY1BhdGgpKS5uZXh0KGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudE1hcCgpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBkb2N1bWVudE1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgIC5nZXRDb2xsZWN0aW9uUGFyZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbklkKVxuICAgICAgICAgICAgLm5leHQocGFyZW50cyA9PiB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIGEgY29sbGVjdGlvbiBxdWVyeSBhZ2FpbnN0IGVhY2ggcGFyZW50IHRoYXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAvLyBjb2xsZWN0aW9uSWQgYW5kIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChwYXJlbnRzLCAocGFyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblF1ZXJ5ID0gYXNDb2xsZWN0aW9uUXVlcnlBdFBhdGgocXVlcnksIHBhcmVudC5jaGlsZChjb2xsZWN0aW9uSWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpLm5leHQociA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHIuZm9yRWFjaCgoa2V5LCBkb2MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFF1ZXJ5IHRoZSByZW1vdGUgZG9jdW1lbnRzIGFuZCBvdmVybGF5IG11dGF0aW9ucy5cbiAgICAgICAgbGV0IG92ZXJsYXlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZVxuICAgICAgICAgICAgLmdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbih0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkKVxuICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIG92ZXJsYXlzID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZS5nZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBvdmVybGF5cywgY29udGV4dCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChyZW1vdGVEb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgLy8gQXMgZG9jdW1lbnRzIG1pZ2h0IG1hdGNoIHRoZSBxdWVyeSBiZWNhdXNlIG9mIHRoZWlyIG92ZXJsYXkgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gaW5jbHVkZSBkb2N1bWVudHMgZm9yIGFsbCBvdmVybGF5cyBpbiB0aGUgaW5pdGlhbCBkb2N1bWVudCBzZXQuXG4gICAgICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChfLCBvdmVybGF5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlRG9jdW1lbnRzLmdldChrZXkpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZURvY3VtZW50cyA9IHJlbW90ZURvY3VtZW50cy5pbnNlcnQoa2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG92ZXJsYXlzIGFuZCBtYXRjaCBhZ2FpbnN0IHRoZSBxdWVyeS5cbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgIHJlbW90ZURvY3VtZW50cy5mb3JFYWNoKChrZXksIGRvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IG92ZXJsYXlzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvY3VtZW50LCBGaWVsZE1hc2suZW1wdHkoKSwgVGltZXN0YW1wLm5vdygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgaW5zZXJ0IHRoZSBkb2N1bWVudHMgdGhhdCBzdGlsbCBtYXRjaCB0aGUgcXVlcnlcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeUJ1bmRsZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuYnVuZGxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5idW5kbGVzLmdldChidW5kbGVJZCkpO1xuICAgIH1cbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuYnVuZGxlcy5zZXQoYnVuZGxlTWV0YWRhdGEuaWQsIGZyb21CdW5kbGVNZXRhZGF0YShidW5kbGVNZXRhZGF0YSkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0TmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnlOYW1lKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm5hbWVkUXVlcmllcy5nZXQocXVlcnlOYW1lKSk7XG4gICAgfVxuICAgIHNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xuICAgICAgICB0aGlzLm5hbWVkUXVlcmllcy5zZXQocXVlcnkubmFtZSwgZnJvbVByb3RvTmFtZWRRdWVyeShxdWVyeSkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBEb2N1bWVudE92ZXJsYXlDYWNoZS5cbiAqL1xuY2xhc3MgTWVtb3J5RG9jdW1lbnRPdmVybGF5Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBBIG1hcCBzb3J0ZWQgYnkgRG9jdW1lbnRLZXksIHdob3NlIHZhbHVlIGlzIGEgcGFpciBvZiB0aGUgbGFyZ2VzdCBiYXRjaCBpZFxuICAgICAgICAvLyBmb3IgdGhlIG92ZXJsYXkgYW5kIHRoZSBvdmVybGF5IGl0c2VsZi5cbiAgICAgICAgdGhpcy5vdmVybGF5cyA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm92ZXJsYXlzLmdldChrZXkpKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXModHJhbnNhY3Rpb24sIGtleXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KS5uZXh0KG92ZXJsYXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBzYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBvdmVybGF5cykge1xuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChfLCBtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYXZlT3ZlcmxheSh0cmFuc2FjdGlvbiwgbGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChiYXRjaElkKTtcbiAgICAgICAgaWYgKGtleXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiAodGhpcy5vdmVybGF5cyA9IHRoaXMub3ZlcmxheXMucmVtb3ZlKGtleSkpKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5kZWxldGUoYmF0Y2hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbih0cmFuc2FjdGlvbiwgY29sbGVjdGlvbiwgc2luY2VCYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBuZXcgRG9jdW1lbnRLZXkoY29sbGVjdGlvbi5jaGlsZCgnJykpO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5vdmVybGF5cy5nZXRJdGVyYXRvckZyb20ocHJlZml4KTtcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvbi5pc1ByZWZpeE9mKGtleS5wYXRoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9jdW1lbnRzIGZyb20gc3ViLWNvbGxlY3Rpb25zXG4gICAgICAgICAgICBpZiAoa2V5LnBhdGgubGVuZ3RoICE9PSBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVybGF5Lmxhcmdlc3RCYXRjaElkID4gc2luY2VCYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkLCBjb3VudCkge1xuICAgICAgICBsZXQgYmF0Y2hJZFRvT3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLm92ZXJsYXlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG92ZXJsYXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LmdldENvbGxlY3Rpb25Hcm91cCgpICE9PSBjb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVybGF5Lmxhcmdlc3RCYXRjaElkID4gc2luY2VCYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJsYXlzRm9yQmF0Y2hJZCA9IGJhdGNoSWRUb092ZXJsYXlzLmdldChvdmVybGF5Lmxhcmdlc3RCYXRjaElkKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheXNGb3JCYXRjaElkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hJZFRvT3ZlcmxheXMgPSBiYXRjaElkVG9PdmVybGF5cy5pbnNlcnQob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXNGb3JCYXRjaElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3ZlcmxheXNGb3JCYXRjaElkLnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIGNvbnN0IGJhdGNoSXRlciA9IGJhdGNoSWRUb092ZXJsYXlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlIChiYXRjaEl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGJhdGNoSXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoa2V5LCBvdmVybGF5KSA9PiByZXN1bHQuc2V0KGtleSwgb3ZlcmxheSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplKCkgPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGFzc29jaWF0aW9uIG9mIHRoZSBvdmVybGF5IHRvIGl0cyBiYXRjaCBpZC5cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLm92ZXJsYXlzLmdldChtdXRhdGlvbi5rZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NldCA9IHRoaXMub3ZlcmxheUJ5QmF0Y2hJZFxuICAgICAgICAgICAgICAgIC5nZXQoZXhpc3RpbmcubGFyZ2VzdEJhdGNoSWQpXG4gICAgICAgICAgICAgICAgLmRlbGV0ZShtdXRhdGlvbi5rZXkpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkLnNldChleGlzdGluZy5sYXJnZXN0QmF0Y2hJZCwgbmV3U2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5pbnNlcnQobXV0YXRpb24ua2V5LCBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhc3NvY2lhdGlvbiBvZiB0aGlzIG92ZXJsYXkgdG8gdGhlIGdpdmVuIGxhcmdlc3RCYXRjaElkLlxuICAgICAgICBsZXQgYmF0Y2ggPSB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuZ2V0KGxhcmdlc3RCYXRjaElkKTtcbiAgICAgICAgaWYgKGJhdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhdGNoID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQobGFyZ2VzdEJhdGNoSWQsIGJhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGxhcmdlc3RCYXRjaElkLCBiYXRjaC5hZGQobXV0YXRpb24ua2V5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5R2xvYmFsc0NhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HO1xuICAgIH1cbiAgICBnZXRTZXNzaW9uVG9rZW4odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2Vzc2lvblRva2VuKTtcbiAgICB9XG4gICAgc2V0U2Vzc2lvblRva2VuKHRyYW5zYWN0aW9uLCBzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBzZXNzaW9uVG9rZW47XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBmcm9tIHNvbWUga2luZCBvZiBudW1iZXJlZCBlbnRpdHlcbiAqIChlaXRoZXIgYSB0YXJnZXQgSUQgb3IgYmF0Y2ggSUQpLiBBcyByZWZlcmVuY2VzIGFyZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb21cbiAqIHRoZSBzZXQgY29ycmVzcG9uZGluZyBldmVudHMgYXJlIGVtaXR0ZWQgdG8gYSByZWdpc3RlcmVkIGdhcmJhZ2UgY29sbGVjdG9yLlxuICpcbiAqIEVhY2ggcmVmZXJlbmNlIGlzIHJlcHJlc2VudGVkIGJ5IGEgRG9jdW1lbnRSZWZlcmVuY2Ugb2JqZWN0LiBFYWNoIG9mIHRoZW1cbiAqIGNvbnRhaW5zIGVub3VnaCBpbmZvcm1hdGlvbiB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgcmVmZXJlbmNlLiBUaGV5IGFyZSBhbGxcbiAqIHN0b3JlZCBwcmltYXJpbHkgaW4gYSBzZXQgc29ydGVkIGJ5IGtleS4gQSBkb2N1bWVudCBpcyBjb25zaWRlcmVkIGdhcmJhZ2UgaWZcbiAqIHRoZXJlJ3Mgbm8gcmVmZXJlbmNlcyBpbiB0aGF0IHNldCAodGhpcyBjYW4gYmUgZWZmaWNpZW50bHkgY2hlY2tlZCB0aGFua3MgdG9cbiAqIHNvcnRpbmcgYnkga2V5KS5cbiAqXG4gKiBSZWZlcmVuY2VTZXQgYWxzbyBrZWVwcyBhIHNlY29uZGFyeSBzZXQgdGhhdCBjb250YWlucyByZWZlcmVuY2VzIHNvcnRlZCBieVxuICogSURzLiBUaGlzIG9uZSBpcyB1c2VkIHRvIGVmZmljaWVudGx5IGltcGxlbWVudCByZW1vdmFsIG9mIGFsbCByZWZlcmVuY2VzIGJ5XG4gKiBzb21lIHRhcmdldCBJRC5cbiAqL1xuY2xhc3MgUmVmZXJlbmNlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gQSBzZXQgb2Ygb3V0c3RhbmRpbmcgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IHNvcnRlZCBieSBrZXkuXG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5S2V5KTtcbiAgICAgICAgLy8gQSBzZXQgb2Ygb3V0c3RhbmRpbmcgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IHNvcnRlZCBieSB0YXJnZXQgaWQuXG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5VGFyZ2V0SWQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2Ugc2V0IGNvbnRhaW5zIG5vIHJlZmVyZW5jZXMuICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmc0J5S2V5LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleSBmb3IgdGhlIGdpdmVuIElELiAqL1xuICAgIGFkZFJlZmVyZW5jZShrZXksIGlkKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCBpZCk7XG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gdGhpcy5yZWZzQnlLZXkuYWRkKHJlZik7XG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0ID0gdGhpcy5yZWZzQnlUYXJnZXQuYWRkKHJlZik7XG4gICAgfVxuICAgIC8qKiBBZGQgcmVmZXJlbmNlcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5cyBmb3IgdGhlIGdpdmVuIElELiAqL1xuICAgIGFkZFJlZmVyZW5jZXMoa2V5cywgaWQpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLmFkZFJlZmVyZW5jZShrZXksIGlkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleSBmb3IgdGhlIGdpdmVuXG4gICAgICogSUQuXG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWYobmV3IERvY1JlZmVyZW5jZShrZXksIGlkKSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZXMoa2V5cywgaWQpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLnJlbW92ZVJlZmVyZW5jZShrZXksIGlkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgcmVmZXJlbmNlcyB3aXRoIGEgZ2l2ZW4gSUQuIENhbGxzIHJlbW92ZVJlZigpIGZvciBlYWNoIGtleVxuICAgICAqIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlc0ZvcklkKGlkKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5S2V5ID0gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoW10pKTtcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XG4gICAgICAgIGNvbnN0IGVuZFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkICsgMSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWYocmVmKTtcbiAgICAgICAgICAgIGtleXMucHVzaChyZWYua2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICByZW1vdmVBbGxSZWZlcmVuY2VzKCkge1xuICAgICAgICB0aGlzLnJlZnNCeUtleS5mb3JFYWNoKHJlZiA9PiB0aGlzLnJlbW92ZVJlZihyZWYpKTtcbiAgICB9XG4gICAgcmVtb3ZlUmVmKHJlZikge1xuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IHRoaXMucmVmc0J5S2V5LmRlbGV0ZShyZWYpO1xuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IHRoaXMucmVmc0J5VGFyZ2V0LmRlbGV0ZShyZWYpO1xuICAgIH1cbiAgICByZWZlcmVuY2VzRm9ySWQoaWQpIHtcbiAgICAgICAgY29uc3QgZW1wdHlLZXkgPSBuZXcgRG9jdW1lbnRLZXkobmV3IFJlc291cmNlUGF0aChbXSkpO1xuICAgICAgICBjb25zdCBzdGFydFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkKTtcbiAgICAgICAgY29uc3QgZW5kUmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQgKyAxKTtcbiAgICAgICAgbGV0IGtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldC5mb3JFYWNoSW5SYW5nZShbc3RhcnRSZWYsIGVuZFJlZl0sIHJlZiA9PiB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5hZGQocmVmLmtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCAwKTtcbiAgICAgICAgY29uc3QgZmlyc3RSZWYgPSB0aGlzLnJlZnNCeUtleS5maXJzdEFmdGVyT3JFcXVhbChyZWYpO1xuICAgICAgICByZXR1cm4gZmlyc3RSZWYgIT09IG51bGwgJiYga2V5LmlzRXF1YWwoZmlyc3RSZWYua2V5KTtcbiAgICB9XG59XG5jbGFzcyBEb2NSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdGFyZ2V0T3JCYXRjaElkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnRhcmdldE9yQmF0Y2hJZCA9IHRhcmdldE9yQmF0Y2hJZDtcbiAgICB9XG4gICAgLyoqIENvbXBhcmUgYnkga2V5IHRoZW4gYnkgSUQgKi9cbiAgICBzdGF0aWMgY29tcGFyZUJ5S2V5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSB8fFxuICAgICAgICAgICAgcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnRhcmdldE9yQmF0Y2hJZCwgcmlnaHQudGFyZ2V0T3JCYXRjaElkKSk7XG4gICAgfVxuICAgIC8qKiBDb21wYXJlIGJ5IElEIHRoZW4gYnkga2V5ICovXG4gICAgc3RhdGljIGNvbXBhcmVCeVRhcmdldElkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAocHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnRhcmdldE9yQmF0Y2hJZCwgcmlnaHQudGFyZ2V0T3JCYXRjaElkKSB8fFxuICAgICAgICAgICAgRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5TXV0YXRpb25RdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNldCBvZiBhbGwgbXV0YXRpb25zIHRoYXQgaGF2ZSBiZWVuIHNlbnQgYnV0IG5vdCB5ZXQgYmVlbiBhcHBsaWVkIHRvXG4gICAgICAgICAqIHRoZSBiYWNrZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlID0gW107XG4gICAgICAgIC8qKiBOZXh0IHZhbHVlIHRvIHVzZSB3aGVuIGFzc2lnbmluZyBzZXF1ZW50aWFsIElEcyB0byBlYWNoIG11dGF0aW9uIGJhdGNoLiAqL1xuICAgICAgICB0aGlzLm5leHRCYXRjaElkID0gMTtcbiAgICAgICAgLyoqIEFuIG9yZGVyZWQgbWFwcGluZyBiZXR3ZWVuIGRvY3VtZW50cyBhbmQgdGhlIG11dGF0aW9ucyBiYXRjaCBJRHMuICovXG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlLZXkpO1xuICAgIH1cbiAgICBjaGVja0VtcHR5KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwKTtcbiAgICB9XG4gICAgYWRkTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBiYXRjaElkID0gdGhpcy5uZXh0QmF0Y2hJZDtcbiAgICAgICAgdGhpcy5uZXh0QmF0Y2hJZCsrO1xuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZVt0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlLnB1c2goYmF0Y2gpO1xuICAgICAgICAvLyBUcmFjayByZWZlcmVuY2VzIGJ5IGRvY3VtZW50IGtleSBhbmQgaW5kZXggY29sbGVjdGlvbiBwYXJlbnRzLlxuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleSA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuYWRkKG5ldyBEb2NSZWZlcmVuY2UobXV0YXRpb24ua2V5LCBiYXRjaElkKSk7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgbXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpKTtcbiAgICB9XG4gICAgZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgbmV4dEJhdGNoSWQgPSBiYXRjaElkICsgMTtcbiAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBiYXRjaElkIG1heSBzdGlsbCBiZSBvdXQgb2YgcmFuZ2Ugc28gbm9ybWFsaXplIGl0IHRvIHRoZVxuICAgICAgICAvLyBzdGFydCBvZiB0aGUgcXVldWUuXG4gICAgICAgIGNvbnN0IHJhd0luZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChuZXh0QmF0Y2hJZCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmF3SW5kZXggPCAwID8gMCA6IHJhd0luZGV4O1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA+IGluZGV4ID8gdGhpcy5tdXRhdGlvblF1ZXVlW2luZGV4XSA6IG51bGwpO1xuICAgIH1cbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCA/IEJBVENISURfVU5LTk9XTiA6IHRoaXMubmV4dEJhdGNoSWQgLSAxKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUuc2xpY2UoKSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIDApO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoSW5SYW5nZShbc3RhcnQsIGVuZF0sIHJlZiA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2gocmVmLnRhcmdldE9yQmF0Y2hJZCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZG9jdW1lbnRLZXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hJblJhbmdlKFtzdGFydCwgZW5kXSwgcmVmID0+IHtcbiAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChyZWYudGFyZ2V0T3JCYXRjaElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmluZE11dGF0aW9uQmF0Y2hlcyh1bmlxdWVCYXRjaElEcykpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBxdWVyeSBwYXRoIGFzIGEgcHJlZml4IGZvciB0ZXN0aW5nIGlmIGEgZG9jdW1lbnQgbWF0Y2hlcyB0aGVcbiAgICAgICAgLy8gcXVlcnkuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuUGF0aExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyAxO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBkb2N1bWVudCByZWZlcmVuY2UgZm9yIGFjdHVhbGx5IHNjYW5uaW5nIHRoZSBpbmRleC4gVW5saWtlXG4gICAgICAgIC8vIHRoZSBwcmVmaXggdGhlIGRvY3VtZW50IGtleSBpbiB0aGlzIHJlZmVyZW5jZSBtdXN0IGhhdmUgYW4gZXZlbiBudW1iZXIgb2ZcbiAgICAgICAgLy8gc2VnbWVudHMuIFRoZSBlbXB0eSBzZWdtZW50IGNhbiBiZSB1c2VkIGEgc3VmZml4IG9mIHRoZSBxdWVyeSBwYXRoXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgcHJlY2VkZXMgYWxsIG90aGVyIHNlZ21lbnRzIGluIGFuIG9yZGVyZWQgdHJhdmVyc2FsLlxuICAgICAgICBsZXQgc3RhcnRQYXRoID0gcHJlZml4O1xuICAgICAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkoc3RhcnRQYXRoKSkge1xuICAgICAgICAgICAgc3RhcnRQYXRoID0gc3RhcnRQYXRoLmNoaWxkKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEb2NSZWZlcmVuY2UobmV3IERvY3VtZW50S2V5KHN0YXJ0UGF0aCksIDApO1xuICAgICAgICAvLyBGaW5kIHVuaXF1ZSBiYXRjaElEcyByZWZlcmVuY2VkIGJ5IGFsbCBkb2N1bWVudHMgcG90ZW50aWFsbHkgbWF0Y2hpbmcgdGhlXG4gICAgICAgIC8vIHF1ZXJ5LlxuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hXaGlsZShyZWYgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93S2V5UGF0aCA9IHJlZi5rZXkucGF0aDtcbiAgICAgICAgICAgIGlmICghcHJlZml4LmlzUHJlZml4T2Yocm93S2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSb3dzIHdpdGggZG9jdW1lbnQga2V5cyBtb3JlIHRoYW4gb25lIHNlZ21lbnQgbG9uZ2VyIHRoYW4gdGhlIHF1ZXJ5XG4gICAgICAgICAgICAgICAgLy8gcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnIGNhbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRvY3VtZW50IC9yb29tcy9hYmMvbWVzc2FnZXMveHl4LlxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogd2UnbGwgbmVlZCBhIGRpZmZlcmVudCBzY2FubmVyIHdoZW4gd2UgaW1wbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cbiAgICAgICAgICAgICAgICBpZiAocm93S2V5UGF0aC5sZW5ndGggPT09IGltbWVkaWF0ZUNoaWxkcmVuUGF0aExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChyZWYudGFyZ2V0T3JCYXRjaElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmluZE11dGF0aW9uQmF0Y2hlcyh1bmlxdWVCYXRjaElEcykpO1xuICAgIH1cbiAgICBmaW5kTXV0YXRpb25CYXRjaGVzKGJhdGNoSURzKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBhcnJheSBvZiBtYXRjaGluZyBiYXRjaGVzLCBzb3J0ZWQgYnkgYmF0Y2hJRCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtdXRhdGlvbnMgYWZmZWN0aW5nIHRoZSBzYW1lIGRvY3VtZW50IGtleSBhcmUgYXBwbGllZCBpbiBvcmRlci5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGJhdGNoSURzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCk7XG4gICAgICAgICAgICBpZiAoYmF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgYmF0Y2ggZm9yIHJlbW92YWwuXG4gICAgICAgIGNvbnN0IGJhdGNoSW5kZXggPSB0aGlzLmluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2guYmF0Y2hJZCwgJ3JlbW92ZWQnKTtcbiAgICAgICAgaGFyZEFzc2VydChiYXRjaEluZGV4ID09PSAwKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGxldCByZWZlcmVuY2VzID0gdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGJhdGNoLm11dGF0aW9ucywgKG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKG11dGF0aW9uLmtleSwgYmF0Y2guYmF0Y2hJZCk7XG4gICAgICAgICAgICByZWZlcmVuY2VzID0gcmVmZXJlbmNlcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHRyYW5zYWN0aW9uLCBtdXRhdGlvbi5rZXkpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSByZWZlcmVuY2VzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcbiAgICAgICAgLy8gTm8tb3Agc2luY2UgdGhlIG1lbW9yeSBtdXRhdGlvbiBxdWV1ZSBkb2VzIG5vdCBtYWludGFpbiBhIHNlcGFyYXRlIGNhY2hlLlxuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgMCk7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVmID0gdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5maXJzdEFmdGVyT3JFcXVhbChyZWYpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoa2V5LmlzRXF1YWwoZmlyc3RSZWYgJiYgZmlyc3RSZWYua2V5KSk7XG4gICAgfVxuICAgIHBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikge1xuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkgO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZSBhbmQgYXNzZXJ0cyB0aGF0XG4gICAgICogdGhlIHJlc3VsdGluZyBpbmRleCBpcyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmF0Y2hJZCAtIFRoZSBiYXRjaElkIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBjYWxsZXIgaXMgZG9pbmcsIHBocmFzZWQgaW4gcGFzc2l2ZVxuICAgICAqIGZvcm0gKGUuZy4gXCJhY2tub3dsZWRnZWRcIiBpbiBhIHJvdXRpbmUgdGhhdCBhY2tub3dsZWRnZXMgYmF0Y2hlcykuXG4gICAgICovXG4gICAgaW5kZXhPZkV4aXN0aW5nQmF0Y2hJZChiYXRjaElkLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2ZCYXRjaElkKGJhdGNoSWQpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWUuIFRoaXMgb3BlcmF0aW9uXG4gICAgICogaXMgTygxKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBpbmRleCBvZiB0aGUgYmF0Y2ggd2l0aCB0aGUgZ2l2ZW4gYmF0Y2hJZCwgYmFzZWQgb25cbiAgICAgKiB0aGUgc3RhdGUgb2YgdGhlIHF1ZXVlLiBOb3RlIHRoaXMgaW5kZXggY2FuIGJlIG5lZ2F0aXZlIGlmIHRoZSByZXF1ZXN0ZWRcbiAgICAgKiBiYXRjaElkIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZSBvciBwYXN0IHRoZSBlbmQgb2YgdGhlXG4gICAgICogcXVldWUgaWYgdGhlIGJhdGNoSWQgaXMgbGFyZ2VyIHRoYW4gdGhlIGxhc3QgYWRkZWQgYmF0Y2guXG4gICAgICovXG4gICAgaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCkge1xuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQXMgYW4gaW5kZXggdGhpcyBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGFtaW5lIHRoZSBmcm9udCBvZiB0aGUgcXVldWUgdG8gZmlndXJlIG91dCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZVxuICAgICAgICAvLyBiYXRjaElkIGFuZCBpbmRleGVzIGluIHRoZSBhcnJheS4gTm90ZSB0aGF0IHNpbmNlIHRoZSBxdWV1ZSBpcyBvcmRlcmVkXG4gICAgICAgIC8vIGJ5IGJhdGNoSWQsIGlmIHRoZSBmaXJzdCBiYXRjaCBoYXMgYSBsYXJnZXIgYmF0Y2hJZCB0aGVuIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgLy8gYmF0Y2hJZCBkb2Vzbid0IGV4aXN0IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgY29uc3QgZmlyc3RCYXRjaElkID0gdGhpcy5tdXRhdGlvblF1ZXVlWzBdLmJhdGNoSWQ7XG4gICAgICAgIHJldHVybiBiYXRjaElkIC0gZmlyc3RCYXRjaElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHZlcnNpb24gb2YgbG9va3VwTXV0YXRpb25CYXRjaCB0aGF0IGRvZXNuJ3QgcmV0dXJuIGEgcHJvbWlzZSwgdGhpcyBtYWtlc1xuICAgICAqIG90aGVyIGZ1bmN0aW9ucyB0aGF0IHVzZXMgdGhpcyBjb2RlIGVhc2llciB0byByZWFkIGFuZCBtb3JlIGVmZmljaWVudC5cbiAgICAgKi9cbiAgICBmaW5kTXV0YXRpb25CYXRjaChiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF07XG4gICAgICAgIHJldHVybiBiYXRjaDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBzbWFsbGVzdCB2YWx1ZSByZXByZXNlbnRhYmxlIGJ5IGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyIChsb25nKS5cbiAqL1xuY29uc3QgTUlOX0xPTkdfVkFMVUUgPSAnLTkyMjMzNzIwMzY4NTQ3NzU4MDgnO1xuZnVuY3Rpb24gZG9jdW1lbnRFbnRyeU1hcCgpIHtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbn1cbi8qKlxuICogVGhlIG1lbW9yeS1vbmx5IFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcbiAqIGBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKClgLlxuICovXG5jbGFzcyBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNpemVyIC0gVXNlZCB0byBhc3Nlc3MgdGhlIHNpemUgb2YgYSBkb2N1bWVudC4gRm9yIGVhZ2VyIEdDLCB0aGlzIGlzXG4gICAgICogZXhwZWN0ZWQgdG8ganVzdCByZXR1cm4gMCB0byBhdm9pZCB1bm5lY2Vzc2FyaWx5IGRvaW5nIHRoZSB3b3JrIG9mXG4gICAgICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2l6ZXIpIHtcbiAgICAgICAgdGhpcy5zaXplciA9IHNpemVyO1xuICAgICAgICAvKiogVW5kZXJseWluZyBjYWNoZSBvZiBkb2N1bWVudHMgYW5kIHRoZWlyIHJlYWQgdGltZXMuICovXG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3VtZW50RW50cnlNYXAoKTtcbiAgICAgICAgLyoqIFNpemUgb2YgYWxsIGNhY2hlZCBkb2N1bWVudHMuICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuICAgIHNldEluZGV4TWFuYWdlcihpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHN1cHBsaWVkIGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgY2FjaGUgc2l6ZSBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgYWRkRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxuICAgICAqL1xuICAgIGFkZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZG9jLmtleTtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2l6ZSA9IGVudHJ5ID8gZW50cnkuc2l6ZSA6IDA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplcihkb2MpO1xuICAgICAgICB0aGlzLmRvY3MgPSB0aGlzLmRvY3MuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGRvYy5tdXRhYmxlQ29weSgpLFxuICAgICAgICAgICAgc2l6ZTogY3VycmVudFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjdXJyZW50U2l6ZSAtIHByZXZpb3VzU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBrZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZW50cnkgZnJvbSB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYHJlbW92ZUVudHJ5YCBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5kb2NzID0gdGhpcy5kb2NzLnJlbW92ZShkb2N1bWVudEtleSk7XG4gICAgICAgICAgICB0aGlzLnNpemUgLT0gZW50cnkuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGVudHJ5XG4gICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcbiAgICAgICAgICAgIDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZG9jdW1lbnRLZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudEtleSwgZW50cnlcbiAgICAgICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcbiAgICAgICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgbXV0YXRlZERvY3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvdyBkb3duXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudHMgd2UgbmVlZCB0byBtYXRjaCB0aGUgcXVlcnkgYWdhaW5zdC5cbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBxdWVyeS5wYXRoO1xuICAgICAgICAvLyBEb2N1bWVudCBrZXlzIGFyZSBvcmRlcmVkIGZpcnN0IGJ5IG51bWVyaWMgdmFsdWUgKFwiX19pZDxMb25nPl9fXCIpLFxuICAgICAgICAvLyB0aGVuIGxleGljb2dyYXBoaWNhbGx5IGJ5IHN0cmluZyB2YWx1ZS4gU3RhcnQgdGhlIGl0ZXJhdG9yIGF0IHRoZSBtaW5pbXVtXG4gICAgICAgIC8vIHBvc3NpYmxlIERvY3VtZW50IGtleSB2YWx1ZS5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmV3IERvY3VtZW50S2V5KGNvbGxlY3Rpb25QYXRoLmNoaWxkKCdfX2lkJyArIE1JTl9MT05HX1ZBTFVFICsgJ19fJykpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuZG9jcy5nZXRJdGVyYXRvckZyb20ocHJlZml4KTtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlOiB7IGRvY3VtZW50IH0gfSA9IGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvblBhdGguaXNQcmVmaXhPZihrZXkucGF0aCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkucGF0aC5sZW5ndGggPiBjb2xsZWN0aW9uUGF0aC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBlbnRyaWVzIGZyb20gc3ViY29sbGVjdGlvbnMuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXhPZmZzZXRDb21wYXJhdG9yKG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KSwgb2Zmc2V0KSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IHNvcnRzIGJlZm9yZSB0aGUgb2Zmc2V0LlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtdXRhdGVkRG9jcy5oYXMoZG9jdW1lbnQua2V5KSAmJiAhcXVlcnlNYXRjaGVzKHF1ZXJ5LCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgY2Fubm90IHBvc3NpYmx5IG1hdGNoIHRoZSBxdWVyeS5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50Lm11dGFibGVDb3B5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIHRoZSBJbmRleEJhY2tmaWxsZXIgaWYgcGVyc2lzdGVuY2VcbiAgICAgICAgLy8gaXMgZW5hYmxlZC5cbiAgICAgICAgZmFpbCgpO1xuICAgIH1cbiAgICBmb3JFYWNoRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGYpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMuZG9jcywgKGtleSkgPT4gZihrZXkpKTtcbiAgICB9XG4gICAgbmV3Q2hhbmdlQnVmZmVyKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gYHRyYWNrUmVtb3ZhbHNgIGlzIGlnbm9yZXMgc2luY2UgdGhlIE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUga2VlcHNcbiAgICAgICAgLy8gYSBzZXBhcmF0ZSBjaGFuZ2Vsb2cgYW5kIGRvZXMgbm90IG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVtb3ZhbHMuXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcyk7XG4gICAgfVxuICAgIGdldFNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnNpemUpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZW1vcnktb25seSBSZW1vdGVEb2N1bWVudENhY2hlLlxuICpcbiAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xuICogZXhwZWN0ZWQgdG8ganVzdCByZXR1cm4gMCB0byBhdm9pZCB1bm5lY2Vzc2FyaWx5IGRvaW5nIHRoZSB3b3JrIG9mXG4gKiBjYWxjdWxhdGluZyB0aGUgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZShzaXplcikge1xuICAgIHJldHVybiBuZXcgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZUltcGwoc2l6ZXIpO1xufVxuLyoqXG4gKiBIYW5kbGVzIHRoZSBkZXRhaWxzIG9mIGFkZGluZyBhbmQgdXBkYXRpbmcgZG9jdW1lbnRzIGluIHRoZSBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlLlxuICovXG5jbGFzcyBNZW1vcnlSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciBleHRlbmRzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudENhY2hlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZSA9IGRvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuZm9yRWFjaCgoa2V5LCBkb2MpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZS5nZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xuICAgIH1cbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlLmdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5VGFyZ2V0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYSB0YXJnZXQgdG8gdGhlIGRhdGEgYWJvdXQgdGhhdCB0YXJnZXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IG5ldyBPYmplY3RNYXAodCA9PiBjYW5vbmlmeVRhcmdldCh0KSwgdGFyZ2V0RXF1YWxzKTtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHJlY2VpdmVkIHNuYXBzaG90IHZlcnNpb24uICovXG4gICAgICAgIHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IG51bWJlcmVkIHRhcmdldCBJRCBlbmNvdW50ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSAwO1xuICAgICAgICAvKiogVGhlIGhpZ2hlc3Qgc2VxdWVuY2UgbnVtYmVyIGVuY291bnRlcmVkLiAqL1xuICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG9yZGVyZWQgYmlkaXJlY3Rpb25hbCBtYXBwaW5nIGJldHdlZW4gZG9jdW1lbnRzIGFuZCB0aGUgcmVtb3RlIHRhcmdldFxuICAgICAgICAgKiBJRHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnRhcmdldElkR2VuZXJhdG9yID0gVGFyZ2V0SWRHZW5lcmF0b3IuZm9yVGFyZ2V0Q2FjaGUoKTtcbiAgICB9XG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKF8sIHRhcmdldERhdGEpID0+IGYodGFyZ2V0RGF0YSkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcik7XG4gICAgfVxuICAgIGFsbG9jYXRlVGFyZ2V0SWQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0aGlzLnRhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuaGlnaGVzdFRhcmdldElkKTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0c01ldGFkYXRhKHRyYW5zYWN0aW9uLCBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgaWYgKGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA+IHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSkge1xuICAgICAgICB0aGlzLnRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0LCB0YXJnZXREYXRhKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgICAgICBpZiAodGFyZ2V0SWQgPiB0aGlzLmhpZ2hlc3RUYXJnZXRJZCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcih0YXJnZXRJZCk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyID4gdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyID0gdGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgdGhpcy5zYXZlVGFyZ2V0RGF0YSh0YXJnZXREYXRhKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldCk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgLT0gMTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldHModHJhbnNhY3Rpb24sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCByZW1vdmFscyA9IFtdO1xuICAgICAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoa2V5LCB0YXJnZXREYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzLmdldCh0YXJnZXREYXRhLnRhcmdldElkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICByZW1vdmFscy5wdXNoKHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpKTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHJlbW92YWxzKS5uZXh0KCgpID0+IGNvdW50KTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMudGFyZ2V0Q291bnQpO1xuICAgIH1cbiAgICBnZXRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0cy5nZXQodGFyZ2V0KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGFyZ2V0RGF0YSk7XG4gICAgfVxuICAgIGFkZE1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5hZGRSZWZlcmVuY2VzKGtleXMsIHRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzKGtleXMsIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlRGVsZWdhdGUgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAocmVmZXJlbmNlRGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nS2V5cyA9IHRoaXMucmVmZXJlbmNlcy5yZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobWF0Y2hpbmdLZXlzKTtcbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVmZXJlbmNlcy5jb250YWluc0tleShrZXkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGQgPSAnTWVtb3J5UGVyc2lzdGVuY2UnO1xuLyoqXG4gKiBBIG1lbW9yeS1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIG9ubHkgaW4gUkFNIGFuZFxuICogbm90IHBlcnNpc3RlZCBhY3Jvc3Mgc2Vzc2lvbnMuXG4gKi9cbmNsYXNzIE1lbW9yeVBlcnNpc3RlbmNlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgYWNjZXB0cyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIGEgcmVmZXJlbmNlIGRlbGVnYXRlLiBUaGlzXG4gICAgICogYWxsb3dzIGJvdGggdGhlIGRlbGVnYXRlIGFuZCB0aGlzIGluc3RhbmNlIHRvIGhhdmUgc3Ryb25nIHJlZmVyZW5jZXMgdG9cbiAgICAgKiBlYWNoIG90aGVyIHdpdGhvdXQgaGF2aW5nIG51bGxhYmxlIGZpZWxkcyB0aGF0IHdvdWxkIHRoZW4gbmVlZCB0byBiZVxuICAgICAqIGNoZWNrZWQgb3IgYXNzZXJ0ZWQgb24gZXZlcnkgYWNjZXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlRmFjdG9yeSwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzID0ge307XG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZSgwKTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nbG9iYWxzQ2FjaGUgPSBuZXcgTWVtb3J5R2xvYmFsc0NhY2hlKCk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZUZhY3RvcnkodGhpcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0Q2FjaGUgPSBuZXcgTWVtb3J5VGFyZ2V0Q2FjaGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHNpemVyID0gKGRvYykgPT4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5kb2N1bWVudFNpemUoZG9jKTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBuZXcgTWVtb3J5SW5kZXhNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgTG9jYWxTZXJpYWxpemVyKHNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLmJ1bmRsZUNhY2hlID0gbmV3IE1lbW9yeUJ1bmRsZUNhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICAvLyBObyBkdXJhYmxlIHN0YXRlIHRvIGVuc3VyZSBpcyBjbG9zZWQgb24gc2h1dGRvd24uXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XG4gICAgfVxuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgc2V0TmV0d29ya0VuYWJsZWQoKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICBnZXRJbmRleE1hbmFnZXIodXNlcikge1xuICAgICAgICAvLyBXZSBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgaW5kaWNlcyBmb3IgbWVtb3J5IHBlcnNpc3RlbmNlLCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzYW1lIHNoYXJlZCBpbnN0YW5jZSBvZiB0aGUgbWVtb3J5IGluZGV4IG1hbmFnZXIuXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlcjtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcikge1xuICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMub3ZlcmxheXNbdXNlci50b0tleSgpXTtcbiAgICAgICAgaWYgKCFvdmVybGF5KSB7XG4gICAgICAgICAgICBvdmVybGF5ID0gbmV3IE1lbW9yeURvY3VtZW50T3ZlcmxheUNhY2hlKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV0gPSBvdmVybGF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVybGF5O1xuICAgIH1cbiAgICBnZXRNdXRhdGlvblF1ZXVlKHVzZXIsIGluZGV4TWFuYWdlcikge1xuICAgICAgICBsZXQgcXVldWUgPSB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV07XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gbmV3IE1lbW9yeU11dGF0aW9uUXVldWUoaW5kZXhNYW5hZ2VyLCB0aGlzLnJlZmVyZW5jZURlbGVnYXRlKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZXNbdXNlci50b0tleSgpXSA9IHF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9XG4gICAgZ2V0R2xvYmFsc0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxzQ2FjaGU7XG4gICAgfVxuICAgIGdldFRhcmdldENhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRDYWNoZTtcbiAgICB9XG4gICAgZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZTtcbiAgICB9XG4gICAgZ2V0QnVuZGxlQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1bmRsZUNhY2hlO1xuICAgIH1cbiAgICBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIHRyYW5zYWN0aW9uT3BlcmF0aW9uKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZCwgJ1N0YXJ0aW5nIHRyYW5zYWN0aW9uOicsIGFjdGlvbik7XG4gICAgICAgIGNvbnN0IHR4biA9IG5ldyBNZW1vcnlUcmFuc2FjdGlvbih0aGlzLmxpc3RlblNlcXVlbmNlLm5leHQoKSk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUub25UcmFuc2FjdGlvblN0YXJ0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uT3BlcmF0aW9uKHR4bilcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZVxuICAgICAgICAgICAgICAgIC5vblRyYW5zYWN0aW9uQ29tbWl0dGVkKHR4bilcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRvUHJvbWlzZSgpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgdHhuLnJhaXNlT25Db21taXR0ZWRFdmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11dGF0aW9uUXVldWVzQ29udGFpbktleSh0cmFuc2FjdGlvbiwga2V5KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoT2JqZWN0LnZhbHVlcyh0aGlzLm11dGF0aW9uUXVldWVzKS5tYXAocXVldWUgPT4gKCkgPT4gcXVldWUuY29udGFpbnNLZXkodHJhbnNhY3Rpb24sIGtleSkpKTtcbiAgICB9XG59XG4vKipcbiAqIE1lbW9yeSBwZXJzaXN0ZW5jZSBpcyBub3QgYWN0dWFsbHkgdHJhbnNhY3Rpb25hbCwgYnV0IGZ1dHVyZSBpbXBsZW1lbnRhdGlvbnNcbiAqIG1heSBoYXZlIHRyYW5zYWN0aW9uLXNjb3BlZCBzdGF0ZS5cbiAqL1xuY2xhc3MgTWVtb3J5VHJhbnNhY3Rpb24gZXh0ZW5kcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjdXJyZW50U2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2VOdW1iZXIgPSBjdXJyZW50U2VxdWVuY2VOdW1iZXI7XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5RWFnZXJEZWxlZ2F0ZSB7XG4gICAgY29uc3RydWN0b3IocGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICAvKiogVHJhY2tzIGFsbCBkb2N1bWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIFF1ZXJ5IHZpZXdzLiAqL1xuICAgICAgICB0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiBkb2N1bWVudHMgdGhhdCBhcmUgcG90ZW50aWFsbHkgR0NlZCBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLiAqL1xuICAgICAgICB0aGlzLl9vcnBoYW5lZERvY3VtZW50cyA9IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBmYWN0b3J5KHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5RWFnZXJEZWxlZ2F0ZShwZXJzaXN0ZW5jZSk7XG4gICAgfVxuICAgIGdldCBvcnBoYW5lZERvY3VtZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcnBoYW5lZERvY3VtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLmFkZFJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5kZWxldGUoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICB0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlKGtleSwgdGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBtYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0eG4sIGtleSkge1xuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IG9ycGhhbmVkID0gdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICAgICAgb3JwaGFuZWQuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCk7XG4gICAgICAgIHJldHVybiBjYWNoZVxuICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgIC5uZXh0KGtleXMgPT4ge1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY2FjaGUucmVtb3ZlVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpKTtcbiAgICB9XG4gICAgb25UcmFuc2FjdGlvblN0YXJ0ZWQoKSB7XG4gICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBvblRyYW5zYWN0aW9uQ29tbWl0dGVkKHR4bikge1xuICAgICAgICAvLyBSZW1vdmUgbmV3bHkgb3JwaGFuZWQgZG9jdW1lbnRzLlxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMub3JwaGFuZWREb2N1bWVudHMsIChwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tUGF0aChwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlZCh0eG4sIGtleSkubmV4dChpc1JlZmVyZW5jZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNSZWZlcmVuY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUJ1ZmZlci5hcHBseSh0eG4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWQodHhuLCBrZXkpLm5leHQoaXNSZWZlcmVuY2VkID0+IHtcbiAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmRlbGV0ZShrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb2N1bWVudFNpemUoZG9jKSB7XG4gICAgICAgIC8vIEZvciBlYWdlciBHQywgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZG9jdW1lbnQgc2l6ZSwgdGhlcmUgYXJlIG5vIHNpemUgdGhyZXNob2xkcy5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlzUmVmZXJlbmNlZCh0eG4sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKFtcbiAgICAgICAgICAgICgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5jb250YWluc0tleShrZXkpKSxcbiAgICAgICAgICAgICgpID0+IHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5jb250YWluc0tleSh0eG4sIGtleSksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLm11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGtleSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5THJ1RGVsZWdhdGUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzID0gbmV3IE9iamVjdE1hcChrID0+IGVuY29kZVJlc291cmNlUGF0aChrLnBhdGgpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBscnVQYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZmFjdG9yeShwZXJzaXN0ZW5jZSwgbHJ1UGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5THJ1RGVsZWdhdGUocGVyc2lzdGVuY2UsIGxydVBhcmFtcyk7XG4gICAgfVxuICAgIC8vIE5vLW9wcywgcHJlc2VudCBzbyBtZW1vcnkgcGVyc2lzdGVuY2UgZG9lc24ndCBoYXZlIHRvIGNhcmUgd2hpY2ggZGVsZWdhdGVcbiAgICAvLyBpdCBoYXMuXG4gICAgb25UcmFuc2FjdGlvblN0YXJ0ZWQoKSB7IH1cbiAgICBvblRyYW5zYWN0aW9uQ29tbWl0dGVkKHR4bikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XG4gICAgfVxuICAgIGdldFNlcXVlbmNlTnVtYmVyQ291bnQodHhuKSB7XG4gICAgICAgIGNvbnN0IGRvY0NvdW50UHJvbWlzZSA9IHRoaXMub3JwaGFuZWREb2N1bWVudENvdW50KHR4bik7XG4gICAgICAgIGNvbnN0IHRhcmdldENvdW50UHJvbWlzZSA9IHRoaXMucGVyc2lzdGVuY2VcbiAgICAgICAgICAgIC5nZXRUYXJnZXRDYWNoZSgpXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q291bnQodHhuKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldENvdW50UHJvbWlzZS5uZXh0KHRhcmdldENvdW50ID0+IGRvY0NvdW50UHJvbWlzZS5uZXh0KGRvY0NvdW50ID0+IHRhcmdldENvdW50ICsgZG9jQ291bnQpKTtcbiAgICB9XG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xuICAgICAgICBsZXQgb3JwaGFuZWRDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcbiAgICAgICAgfSkubmV4dCgoKSA9PiBvcnBoYW5lZENvdW50KTtcbiAgICB9XG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMsIChrZXksIHNlcXVlbmNlTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAvLyBQYXNzIGluIHRoZSBleGFjdCBzZXF1ZW5jZSBudW1iZXIgYXMgdGhlIHVwcGVyIGJvdW5kIHNvIHdlIGtub3cgaXQgd29uJ3QgYmUgcGlubmVkIGJ5XG4gICAgICAgICAgICAvLyBiZWluZyB0b28gcmVjZW50LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNQaW5uZWQodHhuLCBrZXksIHNlcXVlbmNlTnVtYmVyKS5uZXh0KGlzUGlubmVkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZVxuICAgICAgICAgICAgLmdldFRhcmdldENhY2hlKClcbiAgICAgICAgICAgIC5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZUJ1ZmZlciA9IGNhY2hlLm5ld0NoYW5nZUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBwID0gY2FjaGUuZm9yRWFjaERvY3VtZW50S2V5KHR4biwga2V5ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKS5uZXh0KGlzUGlubmVkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcC5uZXh0KCgpID0+IGNoYW5nZUJ1ZmZlci5hcHBseSh0eG4pKS5uZXh0KCgpID0+IGNvdW50KTtcbiAgICB9XG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHRhcmdldERhdGEud2l0aFNlcXVlbmNlTnVtYmVyKHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLnVwZGF0ZVRhcmdldERhdGEodHhuLCB1cGRhdGVkKTtcbiAgICB9XG4gICAgYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZG9jdW1lbnRTaXplKGRvY3VtZW50KSB7XG4gICAgICAgIGxldCBkb2N1bWVudFNpemUgPSBkb2N1bWVudC5rZXkudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgZG9jdW1lbnRTaXplICs9IGVzdGltYXRlQnl0ZVNpemUoZG9jdW1lbnQuZGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50U2l6ZTtcbiAgICB9XG4gICAgaXNQaW5uZWQodHhuLCBrZXksIHVwcGVyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5vcihbXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLm11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGtleSksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ycGhhbmVkQXQgPSB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShvcnBoYW5lZEF0ICE9PSB1bmRlZmluZWQgJiYgb3JwaGFuZWRBdCA+IHVwcGVyQm91bmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZ2V0Q2FjaGVTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCkuZ2V0U2l6ZSh0eG4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLiAqL1xuY2xhc3MgU2NoZW1hQ29udmVydGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGRhdGFiYXNlIGNyZWF0aW9uIGFuZCBzY2hlbWEgdXBncmFkZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaW4gcHJvZHVjdGlvbiwgdGhpcyBtZXRob2QgaXMgb25seSBldmVyIHVzZWQgdG8gdXBncmFkZSB0aGUgc2NoZW1hXG4gICAgICogdG8gU0NIRU1BX1ZFUlNJT04uIERpZmZlcmVudCB2YWx1ZXMgb2YgdG9WZXJzaW9uIGFyZSBvbmx5IHVzZWQgZm9yIHRlc3RpbmdcbiAgICAgKiBhbmQgbG9jYWwgZmVhdHVyZSBkZXZlbG9wbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVPclVwZ3JhZGUoZGIsIHR4biwgZnJvbVZlcnNpb24sIHRvVmVyc2lvbikge1xuICAgICAgICBjb25zdCBzaW1wbGVEYlRyYW5zYWN0aW9uID0gbmV3IFNpbXBsZURiVHJhbnNhY3Rpb24oJ2NyZWF0ZU9yVXBncmFkZScsIHR4bik7XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEgJiYgdG9WZXJzaW9uID49IDEpIHtcbiAgICAgICAgICAgIGNyZWF0ZVByaW1hcnlDbGllbnRTdG9yZShkYik7XG4gICAgICAgICAgICBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKTtcbiAgICAgICAgICAgIGNyZWF0ZVF1ZXJ5Q2FjaGUoZGIpO1xuICAgICAgICAgICAgY3JlYXRlTGVnYWN5UmVtb3RlRG9jdW1lbnRDYWNoZShkYik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWlncmF0aW9uIDIgdG8gcG9wdWxhdGUgdGhlIHRhcmdldEdsb2JhbCBvYmplY3Qgbm8gbG9uZ2VyIG5lZWRlZCBzaW5jZVxuICAgICAgICAvLyBtaWdyYXRpb24gMyB1bmNvbmRpdGlvbmFsbHkgY2xlYXJzIGl0LlxuICAgICAgICBsZXQgcCA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDMgJiYgdG9WZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgIC8vIEJyYW5kIG5ldyBjbGllbnRzIGRvbid0IG5lZWQgdG8gZHJvcCBhbmQgcmVjcmVhdGUtLW9ubHkgY2xpZW50cyB0aGF0XG4gICAgICAgICAgICAvLyBwb3RlbnRpYWxseSBoYXZlIGNvcnJ1cHQgZGF0YS5cbiAgICAgICAgICAgIGlmIChmcm9tVmVyc2lvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRyb3BRdWVyeUNhY2hlKGRiKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gd3JpdGVFbXB0eVRhcmdldEdsb2JhbEVudHJ5KHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA0ICYmIHRvVmVyc2lvbiA+PSA0KSB7XG4gICAgICAgICAgICBpZiAoZnJvbVZlcnNpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlbWEgdmVyc2lvbiAzIHVzZXMgYXV0by1nZW5lcmF0ZWQga2V5cyB0byBnZW5lcmF0ZSBnbG9iYWxseSB1bmlxdWVcbiAgICAgICAgICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaCBJRHMgKHRoaXMgd2FzIHByZXZpb3VzbHkgZW5zdXJlZCBpbnRlcm5hbGx5IGJ5IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNsaWVudCkuIFRvIG1pZ3JhdGUgdG8gdGhlIG5ldyBzY2hlbWEsIHdlIGhhdmUgdG8gcmVhZCBhbGwgbXV0YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdyaXRlIHRoZW0gYmFjayBvdXQuIFdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBiYXRjaCBJRHMgdG8gZ3VhcmFudGVlXG4gICAgICAgICAgICAgICAgLy8gY29uc2lzdGVuY3kgd2l0aCBvdGhlciBvYmplY3Qgc3RvcmVzLiBBbnkgZnVydGhlciBtdXRhdGlvbiBiYXRjaCBJRHMgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIGF1dG8tZ2VuZXJhdGVkLlxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdXBncmFkZU11dGF0aW9uQmF0Y2hTY2hlbWFBbmRNaWdyYXRlRGF0YShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ2xpZW50TWV0YWRhdGFTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA1ICYmIHRvVmVyc2lvbiA+PSA1KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMucmVtb3ZlQWNrbm93bGVkZ2VkTXV0YXRpb25zKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA2ICYmIHRvVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEb2N1bWVudEdsb2JhbFN0b3JlKGRiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGREb2N1bWVudEdsb2JhbChzaW1wbGVEYlRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDcgJiYgdG9WZXJzaW9uID49IDcpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5lbnN1cmVTZXF1ZW5jZU51bWJlcnMoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDggJiYgdG9WZXJzaW9uID49IDgpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uUGFyZW50SW5kZXgoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA5ICYmIHRvVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNdWx0aS1UYWIgdXNlZCB0byBtYW5hZ2UgaXRzIG93biBjaGFuZ2Vsb2csIGJ1dCB0aGlzIGhhcyBiZWVuIG1vdmVkXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIERiUmVtb3RlRG9jdW1lbnQgb2JqZWN0IHN0b3JlIGl0c2VsZi4gU2luY2UgdGhlIHByZXZpb3VzIGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGxvZyBvbmx5IGNvbnRhaW5lZCB0cmFuc2llbnQgZGF0YSwgd2UgY2FuIGRyb3AgaXRzIG9iamVjdCBzdG9yZS5cbiAgICAgICAgICAgICAgICBkcm9wUmVtb3RlRG9jdW1lbnRDaGFuZ2VzU3RvcmUoZGIpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFNjaGVtYSB2ZXJzaW9uIDkgdXNlZCB0byBjcmVhdGUgYSByZWFkIHRpbWUgaW5kZXggZm9yIHRoZVxuICAgICAgICAgICAgICAgIC8vIFJlbW90ZURvY3VtZW50Q2FjaGUuIFRoaXMgaXMgbm93IGRvbmUgd2l0aCBzY2hlbWEgdmVyc2lvbiAxMy5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEwICYmIHRvVmVyc2lvbiA+PSAxMCkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLnJld3JpdGVDYW5vbmljYWxJZHMoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDExICYmIHRvVmVyc2lvbiA+PSAxMSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQnVuZGxlc1N0b3JlKGRiKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVOYW1lZFF1ZXJpZXNTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMiAmJiB0b1ZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEzICYmIHRvVmVyc2lvbiA+PSAxMykge1xuICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBjcmVhdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiKSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnJld3JpdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBkYi5kZWxldGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE0ICYmIHRvVmVyc2lvbiA+PSAxNCkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLnJ1bk92ZXJsYXlNaWdyYXRpb24oZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNSAmJiB0b1ZlcnNpb24gPj0gMTUpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gY3JlYXRlRmllbGRJbmRleChkYikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE2ICYmIHRvVmVyc2lvbiA+PSAxNikge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG9iamVjdCBzdG9yZXMgdG8gcmVtb3ZlIHBvc3NpYmx5IGNvcnJ1cHRlZCBpbmRleCBlbnRyaWVzXG4gICAgICAgICAgICBwID0gcFxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFN0YXRlU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoRGJJbmRleFN0YXRlU3RvcmUpO1xuICAgICAgICAgICAgICAgIGluZGV4U3RhdGVTdG9yZS5jbGVhcigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiSW5kZXhFbnRyeVN0b3JlKTtcbiAgICAgICAgICAgICAgICBpbmRleEVudHJ5U3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE3ICYmIHRvVmVyc2lvbiA+PSAxNykge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlR2xvYmFsc1N0b3JlKGRiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBhZGREb2N1bWVudEdsb2JhbCh0eG4pIHtcbiAgICAgICAgbGV0IGJ5dGVTaXplID0gMDtcbiAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKVxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGRvYykgPT4ge1xuICAgICAgICAgICAgYnl0ZVNpemUgKz0gZGJEb2N1bWVudFNpemUoZG9jKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0geyBieXRlU2l6ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpXG4gICAgICAgICAgICAgICAgLnB1dChEYlJlbW90ZURvY3VtZW50R2xvYmFsS2V5LCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVBY2tub3dsZWRnZWRNdXRhdGlvbnModHhuKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25RdWV1ZVN0b3JlKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xuICAgICAgICByZXR1cm4gcXVldWVzU3RvcmUubG9hZEFsbCgpLm5leHQocXVldWVzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChxdWV1ZXMsIChxdWV1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3F1ZXVlLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3F1ZXVlLnVzZXJJZCwgcXVldWUubGFzdEFja25vd2xlZGdlZEJhdGNoSWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLmxvYWRBbGwoRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoZGJCYXRjaGVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGRiQmF0Y2hlcywgKGRiQmF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC51c2VySWQgPT09IHF1ZXVlLnVzZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgcXVldWUudXNlcklkLCBiYXRjaCkubmV4dCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IGV2ZXJ5IGRvY3VtZW50IGluIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgaGFzIGEgY29ycmVzcG9uZGluZyBzZW50aW5lbCByb3dcbiAgICAgKiB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLiBNaXNzaW5nIHJvd3MgYXJlIGdpdmVuIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgc2VxdWVuY2UgbnVtYmVyLlxuICAgICAqL1xuICAgIGVuc3VyZVNlcXVlbmNlTnVtYmVycyh0eG4pIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUpO1xuICAgICAgICBjb25zdCBkb2N1bWVudHNTdG9yZSA9IHR4bi5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG4gICAgICAgIGNvbnN0IGdsb2JhbFRhcmdldFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KS5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlU2VudGluZWxLZXkgPSAocGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlLnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiAwLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCksXG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50c1N0b3JlXG4gICAgICAgICAgICAgICAgLml0ZXJhdGUoKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBSZXNvdXJjZVBhdGgoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NTZW50aW5lbEtleSA9IHNlbnRpbmVsS2V5KHBhdGgpO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZG9jdW1lbnRUYXJnZXRTdG9yZS5nZXQoZG9jU2VudGluZWxLZXkpLm5leHQobWF5YmVTZW50aW5lbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbGxlY3Rpb25QYXJlbnRJbmRleChkYiwgdHhuKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW5kZXguXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiBEYkNvbGxlY3Rpb25QYXJlbnRLZXlQYXRoXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGFyZW50c1N0b3JlID0gdHhuLnN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlKTtcbiAgICAgICAgLy8gSGVscGVyIHRvIGFkZCBhbiBpbmRleCBlbnRyeSBpZmYgd2UgaGF2ZW4ndCBhbHJlYWR5IHdyaXR0ZW4gaXQuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgICAgICBjb25zdCBhZGRFbnRyeSA9IChjb2xsZWN0aW9uUGF0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlLmFkZChjb2xsZWN0aW9uUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUucHV0KHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGVuY29kZVJlc291cmNlUGF0aChwYXJlbnRQYXRoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBJbmRleCBleGlzdGluZyByZW1vdGUgZG9jdW1lbnRzLlxuICAgICAgICByZXR1cm4gdHhuXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGtleXNPbmx5OiB0cnVlIH0sIChwYXRoU2VnbWVudHMsIF8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKHBhdGhTZWdtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gYWRkRW50cnkocGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgbXV0YXRpb25zLlxuICAgICAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgICAgIC5zdG9yZShEYkRvY3VtZW50TXV0YXRpb25TdG9yZSlcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSh7IGtleXNPbmx5OiB0cnVlIH0sIChbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0sIF8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRW50cnkocGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXdyaXRlQ2Fub25pY2FsSWRzKHR4bikge1xuICAgICAgICBjb25zdCB0YXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLml0ZXJhdGUoKGtleSwgb3JpZ2luYWxEYlRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KG9yaWdpbmFsRGJUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERiVGFyZ2V0ID0gdG9EYlRhcmdldCh0aGlzLnNlcmlhbGl6ZXIsIG9yaWdpbmFsVGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0U3RvcmUucHV0KHVwZGF0ZWREYlRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXdyaXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcbiAgICAgICAgY29uc3Qgd3JpdGVzID0gW107XG4gICAgICAgIHJldHVybiBsZWdhY3lSZW1vdGVEb2N1bWVudFN0b3JlXG4gICAgICAgICAgICAuaXRlcmF0ZSgoXywgbGVnYWN5RG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZURvY3VtZW50U3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV4dHJhY3RLZXkobGVnYWN5RG9jdW1lbnQpLnBhdGgudG9BcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgZGJSZW1vdGVEb2N1bWVudCA9IHtcbiAgICAgICAgICAgICAgICBwcmVmaXhQYXRoOiBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMiksXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBwYXRoW3BhdGgubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBsZWdhY3lEb2N1bWVudC5yZWFkVGltZSB8fCBbMCwgMF0sXG4gICAgICAgICAgICAgICAgdW5rbm93bkRvY3VtZW50OiBsZWdhY3lEb2N1bWVudC51bmtub3duRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgbm9Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQubm9Eb2N1bWVudCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogbGVnYWN5RG9jdW1lbnQuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zOiAhIWxlZ2FjeURvY3VtZW50Lmhhc0NvbW1pdHRlZE11dGF0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdyaXRlcy5wdXNoKHJlbW90ZURvY3VtZW50U3RvcmUucHV0KGRiUmVtb3RlRG9jdW1lbnQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHdyaXRlcykpO1xuICAgIH1cbiAgICBydW5PdmVybGF5TWlncmF0aW9uKGRiLCB0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgY29uc3QgcmVtb3RlRG9jdW1lbnRDYWNoZSA9IG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgY29uc3QgbWVtb3J5UGVyc2lzdGVuY2UgPSBuZXcgTWVtb3J5UGVyc2lzdGVuY2UoTWVtb3J5RWFnZXJEZWxlZ2F0ZS5mYWN0b3J5LCB0aGlzLnNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplcik7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZS5sb2FkQWxsKCkubmV4dChkYkJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXNlclRvRG9jdW1lbnRTZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBkYkJhdGNoZXMuZm9yRWFjaChkYkJhdGNoID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IGRvY3VtZW50U2V0ID0gKF9hID0gdXNlclRvRG9jdW1lbnRTZXQuZ2V0KGRiQmF0Y2gudXNlcklkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4gKGRvY3VtZW50U2V0ID0gZG9jdW1lbnRTZXQuYWRkKGtleSkpKTtcbiAgICAgICAgICAgICAgICB1c2VyVG9Eb2N1bWVudFNldC5zZXQoZGJCYXRjaC51c2VySWQsIGRvY3VtZW50U2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHVzZXJUb0RvY3VtZW50U2V0LCAoYWxsRG9jdW1lbnRLZXlzRm9yVXNlciwgdXNlcklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGluZGV4IG1hbmFnZXIgYW5kIHRoZSByZWZlcmVuY2UgZGVsZWdhdGUgYXJlXG4gICAgICAgICAgICAgICAgLy8gaXJyZWxldmFudCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVjYWxjdWxhdGluZyBhbmQgc2F2aW5nXG4gICAgICAgICAgICAgICAgLy8gb3ZlcmxheXMuIFdlIGNhbiB0aGVyZWZvcmUgc2ltcGx5IHVzZSB0aGUgbWVtb3J5XG4gICAgICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhNYW5hZ2VyID0gbWVtb3J5UGVyc2lzdGVuY2UuZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uUXVldWUgPSBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIG1lbW9yeVBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbERvY3VtZW50c1ZpZXcgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHJlbW90ZURvY3VtZW50Q2FjaGUsIG11dGF0aW9uUXVldWUsIGRvY3VtZW50T3ZlcmxheUNhY2hlLCBpbmRleE1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbERvY3VtZW50c1ZpZXdcbiAgICAgICAgICAgICAgICAgICAgLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzRm9yRG9jdW1lbnRLZXlzKG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCksIGFsbERvY3VtZW50S2V5c0ZvclVzZXIpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VudGluZWxLZXkocGF0aCkge1xuICAgIHJldHVybiBbMCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaW1hcnlDbGllbnRTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUHJpbWFyeUNsaWVudFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU11dGF0aW9uUXVldWUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYk11dGF0aW9uUXVldWVLZXlQYXRoXG4gICAgfSk7XG4gICAgY29uc3QgbXV0YXRpb25CYXRjaGVzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYk11dGF0aW9uQmF0Y2hLZXlQYXRoLFxuICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgbXV0YXRpb25CYXRjaGVzU3RvcmUuY3JlYXRlSW5kZXgoRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zS2V5UGF0aCwgeyB1bmlxdWU6IHRydWUgfSk7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xufVxuLyoqXG4gKiBVcGdyYWRlIGZ1bmN0aW9uIHRvIG1pZ3JhdGUgdGhlICdtdXRhdGlvbnMnIHN0b3JlIGZyb20gVjEgdG8gVjMuIExvYWRzXG4gKiBhbmQgcmV3cml0ZXMgYWxsIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHVwZ3JhZGVNdXRhdGlvbkJhdGNoU2NoZW1hQW5kTWlncmF0ZURhdGEoZGIsIHR4bikge1xuICAgIGNvbnN0IHYxTXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xuICAgIHJldHVybiB2MU11dGF0aW9uc1N0b3JlLmxvYWRBbGwoKS5uZXh0KGV4aXN0aW5nTXV0YXRpb25zID0+IHtcbiAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiBEYk11dGF0aW9uQmF0Y2hLZXlQYXRoLFxuICAgICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbXV0YXRpb25zU3RvcmUuY3JlYXRlSW5kZXgoRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zS2V5UGF0aCwgeyB1bmlxdWU6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHYzTXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xuICAgICAgICBjb25zdCB3cml0ZUFsbCA9IGV4aXN0aW5nTXV0YXRpb25zLm1hcChtdXRhdGlvbiA9PiB2M011dGF0aW9uc1N0b3JlLnB1dChtdXRhdGlvbikpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3Iod3JpdGVBbGwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTGVnYWN5UmVtb3RlRG9jdW1lbnRDYWNoZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpIHtcbiAgICBjb25zdCByZW1vdGVEb2N1bWVudFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoXG4gICAgfSk7XG4gICAgcmVtb3RlRG9jdW1lbnRTdG9yZS5jcmVhdGVJbmRleChEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCwgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXhQYXRoKTtcbiAgICByZW1vdGVEb2N1bWVudFN0b3JlLmNyZWF0ZUluZGV4KERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCwgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEdsb2JhbFN0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5Q2FjaGUoZGIpIHtcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudHNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYlRhcmdldERvY3VtZW50S2V5UGF0aFxuICAgIH0pO1xuICAgIHRhcmdldERvY3VtZW50c1N0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCwgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHRhcmdldFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYlRhcmdldEtleVBhdGhcbiAgICB9KTtcbiAgICAvLyBOT1RFOiBUaGlzIGlzIHVuaXF1ZSBvbmx5IGJlY2F1c2UgdGhlIFRhcmdldElkIGlzIHRoZSBzdWZmaXguXG4gICAgdGFyZ2V0U3RvcmUuY3JlYXRlSW5kZXgoRGJUYXJnZXRRdWVyeVRhcmdldHNJbmRleE5hbWUsIERiVGFyZ2V0UXVlcnlUYXJnZXRzS2V5UGF0aCwgeyB1bmlxdWU6IHRydWUgfSk7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRHbG9iYWxTdG9yZSk7XG59XG5mdW5jdGlvbiBkcm9wUXVlcnlDYWNoZShkYikge1xuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XG4gICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRTdG9yZSk7XG4gICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRHbG9iYWxTdG9yZSk7XG59XG5mdW5jdGlvbiBkcm9wUmVtb3RlRG9jdW1lbnRDaGFuZ2VzU3RvcmUoZGIpIHtcbiAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygncmVtb3RlRG9jdW1lbnRDaGFuZ2VzJykpIHtcbiAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgdGFyZ2V0IGdsb2JhbCBzaW5nbGV0b24gcm93LlxuICpcbiAqIEBwYXJhbSB0eG4gLSBUaGUgdmVyc2lvbiB1cGdyYWRlIHRyYW5zYWN0aW9uIGZvciBpbmRleGVkZGJcbiAqL1xuZnVuY3Rpb24gd3JpdGVFbXB0eVRhcmdldEdsb2JhbEVudHJ5KHR4bikge1xuICAgIGNvbnN0IGdsb2JhbFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBoaWdoZXN0VGFyZ2V0SWQ6IDAsXG4gICAgICAgIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgICAgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbjogU25hcHNob3RWZXJzaW9uLm1pbigpLnRvVGltZXN0YW1wKCksXG4gICAgICAgIHRhcmdldENvdW50OiAwXG4gICAgfTtcbiAgICByZXR1cm4gZ2xvYmFsU3RvcmUucHV0KERiVGFyZ2V0R2xvYmFsS2V5LCBtZXRhZGF0YSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRhZGF0YVN0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJDbGllbnRNZXRhZGF0YVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiQ2xpZW50TWV0YWRhdGFLZXlQYXRoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVzU3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkJ1bmRsZVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiQnVuZGxlS2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTmFtZWRRdWVyaWVzU3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk5hbWVkUXVlcnlTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYk5hbWVkUXVlcnlLZXlQYXRoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWVsZEluZGV4KGRiKSB7XG4gICAgY29uc3QgaW5kZXhDb25maWd1cmF0aW9uU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiSW5kZXhDb25maWd1cmF0aW9uS2V5UGF0aCxcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGluZGV4Q29uZmlndXJhdGlvblN0b3JlLmNyZWF0ZUluZGV4KERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXgsIERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleFN0YXRlU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJJbmRleFN0YXRlS2V5UGF0aFxuICAgIH0pO1xuICAgIGluZGV4U3RhdGVTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhFbnRyeVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiSW5kZXhFbnRyeUtleVBhdGhcbiAgICB9KTtcbiAgICBpbmRleEVudHJ5U3RvcmUuY3JlYXRlSW5kZXgoRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCwgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKSB7XG4gICAgY29uc3QgZG9jdW1lbnRPdmVybGF5U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkRvY3VtZW50T3ZlcmxheVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiRG9jdW1lbnRPdmVybGF5S2V5UGF0aFxuICAgIH0pO1xuICAgIGRvY3VtZW50T3ZlcmxheVN0b3JlLmNyZWF0ZUluZGV4KERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgsIERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgsIERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsc1N0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJHbG9iYWxzU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJHbG9iYWxzS2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZXh0cmFjdEtleShyZW1vdGVEb2MpIHtcbiAgICBpZiAocmVtb3RlRG9jLmRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmVtb3RlRG9jLmRvY3VtZW50Lm5hbWUpLnBvcEZpcnN0KDUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLm5vRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2Mubm9Eb2N1bWVudC5wYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQucGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckYyA9ICdJbmRleGVkRGJQZXJzaXN0ZW5jZSc7XG4vKipcbiAqIE9sZGVzdCBhY2NlcHRhYmxlIGFnZSBpbiBtaWxsaXNlY29uZHMgZm9yIGNsaWVudCBtZXRhZGF0YSBiZWZvcmUgdGhlIGNsaWVudFxuICogaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgaXRzIGFzc29jaWF0ZWQgZGF0YSBpcyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqL1xuY29uc3QgTUFYX0NMSUVOVF9BR0VfTVMgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlc1xuLyoqXG4gKiBPbGRlc3QgYWNjZXB0YWJsZSBtZXRhZGF0YSBhZ2UgZm9yIGNsaWVudHMgdGhhdCBtYXkgcGFydGljaXBhdGUgaW4gdGhlXG4gKiBwcmltYXJ5IGxlYXNlIGVsZWN0aW9uLiBDbGllbnRzIHRoYXQgaGF2ZSBub3QgdXBkYXRlZCB0aGVpciBjbGllbnQgbWV0YWRhdGFcbiAqIHdpdGhpbiA1IHNlY29uZHMgYXJlIG5vdCBlbGlnaWJsZSB0byByZWNlaXZlIGEgcHJpbWFyeSBsZWFzZS5cbiAqL1xuY29uc3QgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TID0gNTAwMDtcbi8qKlxuICogVGhlIGludGVydmFsIGF0IHdoaWNoIGNsaWVudHMgd2lsbCB1cGRhdGUgdGhlaXIgbWV0YWRhdGEsIGluY2x1ZGluZ1xuICogcmVmcmVzaGluZyB0aGVpciBwcmltYXJ5IGxlYXNlIGlmIGhlbGQgb3IgcG90ZW50aWFsbHkgdHJ5aW5nIHRvIGFjcXVpcmUgaXQgaWZcbiAqIG5vdCBoZWxkLlxuICpcbiAqIFByaW1hcnkgY2xpZW50cyBtYXkgb3Bwb3J0dW5pc3RpY2FsbHkgcmVmcmVzaCB0aGVpciBtZXRhZGF0YSBlYXJsaWVyXG4gKiBpZiB0aGV5J3JlIGFscmVhZHkgcGVyZm9ybWluZyBhbiBJbmRleGVkREIgb3BlcmF0aW9uLlxuICovXG5jb25zdCBDTElFTlRfTUVUQURBVEFfUkVGUkVTSF9JTlRFUlZBTF9NUyA9IDQwMDA7XG4vKiogVXNlci1mYWNpbmcgZXJyb3Igd2hlbiB0aGUgcHJpbWFyeSBsZWFzZSBpcyByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyA9ICdGYWlsZWQgdG8gb2J0YWluIGV4Y2x1c2l2ZSBhY2Nlc3MgdG8gdGhlIHBlcnNpc3RlbmNlIGxheWVyLiBUbyBhbGxvdyAnICtcbiAgICAnc2hhcmVkIGFjY2VzcywgbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbiBoYXMgdG8gYmUgZW5hYmxlZCBpbiBhbGwgdGFicy4gJyArXG4gICAgJ0lmIHlvdSBhcmUgdXNpbmcgYGV4cGVyaW1lbnRhbEZvcmNlT3duaW5nVGFiOnRydWVgLCBtYWtlIHN1cmUgdGhhdCBvbmx5ICcgK1xuICAgICdvbmUgdGFiIGhhcyBwZXJzaXN0ZW5jZSBlbmFibGVkIGF0IGFueSBnaXZlbiB0aW1lLic7XG5jb25zdCBVTlNVUFBPUlRFRF9QTEFURk9STV9FUlJPUl9NU0cgPSAnVGhpcyBwbGF0Zm9ybSBpcyBlaXRoZXIgbWlzc2luZyBJbmRleGVkREIgb3IgaXMga25vd24gdG8gaGF2ZSAnICtcbiAgICAnYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gT2ZmbGluZSBwZXJzaXN0ZW5jZSBoYXMgYmVlbiBkaXNhYmxlZC4nO1xuLy8gVGhlIGZvcm1hdCBvZiB0aGUgTG9jYWxTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyB6b21iaWVkIGNsaWVudCBpczpcbi8vICAgICBmaXJlc3RvcmVfem9tYmllXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxpbnN0YW5jZV9rZXk+XG5jb25zdCBaT01CSUVEX0NMSUVOVFNfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfem9tYmllJztcbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIG1haW4gKGFuZCBjdXJyZW50bHkgb25seSkgSW5kZXhlZERCIGRhdGFiYXNlLiBUaGlzIG5hbWUgaXNcbiAqIGFwcGVuZGVkIHRvIHRoZSBwcmVmaXggcHJvdmlkZWQgdG8gdGhlIEluZGV4ZWREYlBlcnNpc3RlbmNlIGNvbnN0cnVjdG9yLlxuICovXG5jb25zdCBNQUlOX0RBVEFCQVNFID0gJ21haW4nO1xuLyoqXG4gKiBBbiBJbmRleGVkREItYmFja2VkIGluc3RhbmNlIG9mIFBlcnNpc3RlbmNlLiBEYXRhIGlzIHN0b3JlZCBwZXJzaXN0ZW50bHlcbiAqIGFjcm9zcyBzZXNzaW9ucy5cbiAqXG4gKiBPbiBXZWIgb25seSwgdGhlIEZpcmVzdG9yZSBTREtzIHN1cHBvcnQgc2hhcmVkIGFjY2VzcyB0byBpdHMgcGVyc2lzdGVuY2VcbiAqIGxheWVyLiBUaGlzIGFsbG93cyBtdWx0aXBsZSBicm93c2VyIHRhYnMgdG8gcmVhZCBhbmQgd3JpdGUgdG8gSW5kZXhlZERiIGFuZFxuICogdG8gc3luY2hyb25pemUgc3RhdGUgZXZlbiB3aXRob3V0IG5ldHdvcmsgY29ubmVjdGl2aXR5LiBTaGFyZWQgYWNjZXNzIGlzXG4gKiBjdXJyZW50bHkgb3B0aW9uYWwgYW5kIG5vdCBlbmFibGVkIHVubGVzcyBhbGwgY2xpZW50cyBpbnZva2VcbiAqIGBlbmFibGVQZXJzaXN0ZW5jZSgpYCB3aXRoIGB7c3luY2hyb25pemVUYWJzOnRydWV9YC5cbiAqXG4gKiBJbiBtdWx0aS10YWIgbW9kZSwgaWYgbXVsdGlwbGUgY2xpZW50cyBhcmUgYWN0aXZlIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBTREtcbiAqIHdpbGwgZGVzaWduYXRlIG9uZSBjbGllbnQgYXMgdGhlIOKAnHByaW1hcnkgY2xpZW504oCdLiBBbiBlZmZvcnQgaXMgbWFkZSB0byBwaWNrXG4gKiBhIHZpc2libGUsIG5ldHdvcmstY29ubmVjdGVkIGFuZCBhY3RpdmUgY2xpZW50LCBhbmQgdGhpcyBjbGllbnQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciBsZXR0aW5nIG90aGVyIGNsaWVudHMga25vdyBhYm91dCBpdHMgcHJlc2VuY2UuIFRoZSBwcmltYXJ5XG4gKiBjbGllbnQgd3JpdGVzIGEgdW5pcXVlIGNsaWVudC1nZW5lcmF0ZWQgaWRlbnRpZmllciAodGhlIGNsaWVudCBJRCkgdG9cbiAqIEluZGV4ZWREYuKAmXMg4oCcb3duZXLigJ0gc3RvcmUgZXZlcnkgNCBzZWNvbmRzLiBJZiB0aGUgcHJpbWFyeSBjbGllbnQgZmFpbHMgdG9cbiAqIHVwZGF0ZSB0aGlzIGVudHJ5LCBhbm90aGVyIGNsaWVudCBjYW4gYWNxdWlyZSB0aGUgbGVhc2UgYW5kIHRha2Ugb3ZlciBhc1xuICogcHJpbWFyeS5cbiAqXG4gKiBTb21lIHBlcnNpc3RlbmNlIG9wZXJhdGlvbnMgaW4gdGhlIFNESyBhcmUgZGVzaWduYXRlZCBhcyBwcmltYXJ5LWNsaWVudCBvbmx5XG4gKiBvcGVyYXRpb25zLiBUaGlzIGluY2x1ZGVzIHRoZSBhY2tub3dsZWRnbWVudCBvZiBtdXRhdGlvbnMgYW5kIGFsbCB1cGRhdGVzIG9mXG4gKiByZW1vdGUgZG9jdW1lbnRzLiBUaGUgZWZmZWN0cyBvZiB0aGVzZSBvcGVyYXRpb25zIGFyZSB3cml0dGVuIHRvIHBlcnNpc3RlbmNlXG4gKiBhbmQgdGhlbiBicm9hZGNhc3QgdG8gb3RoZXIgdGFicyB2aWEgTG9jYWxTdG9yYWdlIChzZWVcbiAqIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgKSwgd2hpY2ggdGhlbiByZWZyZXNoIHRoZWlyIHN0YXRlIGZyb21cbiAqIHBlcnNpc3RlbmNlLlxuICpcbiAqIFNpbWlsYXJseSwgdGhlIHByaW1hcnkgY2xpZW50IGxpc3RlbnMgdG8gbm90aWZpY2F0aW9ucyBzZW50IGJ5IHNlY29uZGFyeVxuICogY2xpZW50cyB0byBkaXNjb3ZlciBwZXJzaXN0ZW5jZSBjaGFuZ2VzIHdyaXR0ZW4gYnkgc2Vjb25kYXJ5IGNsaWVudHMsIHN1Y2ggYXNcbiAqIHRoZSBhZGRpdGlvbiBvZiBuZXcgbXV0YXRpb25zIGFuZCBxdWVyeSB0YXJnZXRzLlxuICpcbiAqIElmIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZCBhbmQgYW5vdGhlciB0YWIgYWxyZWFkeSBvYnRhaW5lZCB0aGUgcHJpbWFyeVxuICogbGVhc2UsIEluZGV4ZWREYlBlcnNpc3RlbmNlIGVudGVycyBhIGZhaWxlZCBzdGF0ZSBhbmQgYWxsIHN1YnNlcXVlbnRcbiAqIG9wZXJhdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGZhaWwuXG4gKlxuICogQWRkaXRpb25hbGx5LCB0aGVyZSBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIGEgdGFiIGlzIGNsb3NlZCwgdGhlXG4gKiBwcmltYXJ5IGxlYXNlIGlzIHJlbGVhc2VkIGltbWVkaWF0ZWx5ICh0aGlzIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IHRvIG1ha2VcbiAqIHN1cmUgdGhhdCBhIHJlZnJlc2hlZCB0YWIgaXMgYWJsZSB0byBpbW1lZGlhdGVseSByZS1hY3F1aXJlIHRoZSBwcmltYXJ5XG4gKiBsZWFzZSkuIFVuZm9ydHVuYXRlbHksIEluZGV4ZWREQiBjYW5ub3QgYmUgcmVsaWFibHkgdXNlZCBpbiB3aW5kb3cudW5sb2FkXG4gKiBzaW5jZSBpdCBpcyBhbiBhc3luY2hyb25vdXMgQVBJLiBTbyBpbiBhZGRpdGlvbiB0byBhdHRlbXB0aW5nIHRvIGdpdmUgdXAgdGhlXG4gKiBsZWFzZSwgdGhlIGxlYXNlaG9sZGVyIHdyaXRlcyBpdHMgY2xpZW50IElEIHRvIGEgXCJ6b21iaWVkQ2xpZW50XCIgZW50cnkgaW5cbiAqIExvY2FsU3RvcmFnZSB3aGljaCBhY3RzIGFzIGFuIGluZGljYXRvciB0aGF0IGFub3RoZXIgdGFiIHNob3VsZCBnbyBhaGVhZCBhbmRcbiAqIHRha2UgdGhlIHByaW1hcnkgbGVhc2UgaW1tZWRpYXRlbHkgcmVnYXJkbGVzcyBvZiB0aGUgY3VycmVudCBsZWFzZSB0aW1lc3RhbXAuXG4gKlxuICogVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSBgc3luY2hyb25pemVUYWJzYCBzZWN0aW9uIHdoZW4gbXVsdGktdGFiIGlzIG5vXG4gKiBsb25nZXIgb3B0aW9uYWwuXG4gKi9cbmNsYXNzIEluZGV4ZWREYlBlcnNpc3RlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHN5bmNocm9uaXplIHRoZSBpbi1tZW1vcnkgc3RhdGUgb2YgbXVsdGlwbGUgdGFicyBhbmQgc2hhcmVcbiAgICAgKiBhY2Nlc3MgdG8gbG9jYWwgcGVyc2lzdGVuY2UuXG4gICAgICovXG4gICAgYWxsb3dUYWJTeW5jaHJvbml6YXRpb24sIHBlcnNpc3RlbmNlS2V5LCBjbGllbnRJZCwgbHJ1UGFyYW1zLCBxdWV1ZSwgd2luZG93LCBkb2N1bWVudCwgc2VyaWFsaXplciwgc2VxdWVuY2VOdW1iZXJTeW5jZXIsIFxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBmb3JjZWZ1bGx5IG9idGFpbnMgZGF0YWJhc2UgYWNjZXNzLiBFeGlzdGluZyB0YWJzIHdpbGxcbiAgICAgKiBubyBsb25nZXIgYmUgYWJsZSB0byBhY2Nlc3MgSW5kZXhlZERCLlxuICAgICAqL1xuICAgIGZvcmNlT3duaW5nVGFiLCBzY2hlbWFWZXJzaW9uID0gU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgICAgdGhpcy5hbGxvd1RhYlN5bmNocm9uaXphdGlvbiA9IGFsbG93VGFiU3luY2hyb25pemF0aW9uO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyU3luY2VyID0gc2VxdWVuY2VOdW1iZXJTeW5jZXI7XG4gICAgICAgIHRoaXMuZm9yY2VPd25pbmdUYWIgPSBmb3JjZU93bmluZ1RhYjtcbiAgICAgICAgdGhpcy5zY2hlbWFWZXJzaW9uID0gc2NoZW1hVmVyc2lvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXR3b3JrRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKiBPdXIgd2luZG93LnVubG9hZCBoYW5kbGVyLCBpZiByZWdpc3RlcmVkLiAqL1xuICAgICAgICB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IGZhbHNlO1xuICAgICAgICAvKiogT3VyICd2aXNpYmlsaXR5Y2hhbmdlJyBsaXN0ZW5lciBpZiByZWdpc3RlcmVkLiAqL1xuICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGNsaWVudCBtZXRhZGF0YSByZWZyZXNoIHRhc2suICovXG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGxhc3QgdGltZSB3ZSBnYXJiYWdlIGNvbGxlY3RlZCB0aGUgY2xpZW50IG1ldGFkYXRhIG9iamVjdCBzdG9yZS4gKi9cbiAgICAgICAgdGhpcy5sYXN0R2FyYmFnZUNvbGxlY3Rpb25UaW1lID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAvKiogQSBsaXN0ZW5lciB0byBub3RpZnkgb24gcHJpbWFyeSBzdGF0ZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gXyA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKCFJbmRleGVkRGJQZXJzaXN0ZW5jZS5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCBVTlNVUFBPUlRFRF9QTEFURk9STV9FUlJPUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSBuZXcgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsKHRoaXMsIGxydVBhcmFtcyk7XG4gICAgICAgIHRoaXMuZGJOYW1lID0gcGVyc2lzdGVuY2VLZXkgKyBNQUlOX0RBVEFCQVNFO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgTG9jYWxTZXJpYWxpemVyKHNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnNpbXBsZURiID0gbmV3IFNpbXBsZURiKHRoaXMuZGJOYW1lLCB0aGlzLnNjaGVtYVZlcnNpb24sIG5ldyBTY2hlbWFDb252ZXJ0ZXIodGhpcy5zZXJpYWxpemVyKSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsc0NhY2hlID0gbmV3IEluZGV4ZWREYkdsb2JhbHNDYWNoZSgpO1xuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IEluZGV4ZWREYlRhcmdldENhY2hlKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUsIHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBJbmRleGVkRGJCdW5kbGVDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICB0aGlzLndlYlN0b3JhZ2UgPSB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlN0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGZvcmNlT3duaW5nVGFiID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYywgJ0xvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZS4gQXMgYSByZXN1bHQsIHBlcnNpc3RlbmNlIG1heSBub3Qgd29yayAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JlbGlhYmx5LiBJbiBwYXJ0aWN1bGFyIGVuYWJsZVBlcnNpc3RlbmNlKCkgY291bGQgZmFpbCBpbW1lZGlhdGVseSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FmdGVyIHJlZnJlc2hpbmcgdGhlIHBhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBzdGFydCBJbmRleGVkRGIgcGVyc2lzdGVuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHBlcnNpc3RlbmNlIHdhcyBlbmFibGVkLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGZhaWwgc29tZXRpbWVzIChpbiB0aGUgY2FzZSBvZiBhbm90aGVyIHRhYlxuICAgICAgICAvLyBhbHJlYWR5IGhhdmluZyB0aGUgcGVyc2lzdGVuY2UgbG9jayksIHNvIGl0J3MgdGhlIGZpcnN0IHRoaW5nIHdlIHNob3VsZFxuICAgICAgICAvLyBkby5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ByaW1hcnkgJiYgIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBGYWlsIGBzdGFydCgpYCBpZiBgc3luY2hyb25pemVUYWJzYCBpcyBkaXNhYmxlZCBhbmQgd2UgY2Fubm90XG4gICAgICAgICAgICAgICAgLy8gb2J0YWluIHRoZSBwcmltYXJ5IGxlYXNlLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFZpc2liaWxpdHlIYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFdpbmRvd1VubG9hZEhvb2soKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ2dldEhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcicsICdyZWFkb25seScsIHR4biA9PiB0aGlzLnRhcmdldENhY2hlLmdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0eG4pKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblNlcXVlbmNlID0gbmV3IExpc3RlblNlcXVlbmNlKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgdGhpcy5zZXF1ZW5jZU51bWJlclN5bmNlcik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgdGhpcy5zaW1wbGVEYiAmJiB0aGlzLnNpbXBsZURiLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcHJpbWFyeSBzdGF0ZSBvZiB0aGVcbiAgICAgKiBpbnN0YW5jZSBjaGFuZ2VzLiBVcG9uIHJlZ2lzdGVyaW5nLCB0aGlzIGxpc3RlbmVyIGlzIGludm9rZWQgaW1tZWRpYXRlbHlcbiAgICAgKiB3aXRoIHRoZSBjdXJyZW50IHByaW1hcnkgc3RhdGUuXG4gICAgICpcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxuICAgICAqL1xuICAgIHNldFByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIgPSBhc3luYyAocHJpbWFyeVN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcih0aGlzLmlzUHJpbWFyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgcmVjZWl2ZXMgYVxuICAgICAqIHZlcnNpb24gY2hhbmdlIGV2ZW50IGluZGljYXRpbmcgdGhhdCBpdCBoYXMgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXG4gICAgICovXG4gICAgc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoZGF0YWJhc2VEZWxldGVkTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zaW1wbGVEYi5zZXRWZXJzaW9uQ2hhbmdlTGlzdGVuZXIoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gZGVsZXRlIEluZGV4ZWREQi5cbiAgICAgICAgICAgIGlmIChldmVudC5uZXdWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGN1cnJlbnQgbmV0d29yayBzdGF0ZSBpbiB0aGUgY2xpZW50J3MgbWV0YWRhdGEsIHBvdGVudGlhbGx5XG4gICAgICogYWZmZWN0aW5nIHRoZSBwcmltYXJ5IGxlYXNlLlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBzZXROZXR3b3JrRW5hYmxlZChuZXR3b3JrRW5hYmxlZCkge1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrRW5hYmxlZCAhPT0gbmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSBuZXR3b3JrRW5hYmxlZDtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcHJpbWFyeSBsZWFzZSByZWZyZXNoIGZvciBpbW1lZGlhdGUgZXhlY3V0aW9uLiBUaGUgZXZlbnR1YWxcbiAgICAgICAgICAgIC8vIGxlYXNlIHVwZGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdmlhIGBwcmltYXJ5U3RhdGVMaXN0ZW5lcmAuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjbGllbnQgbWV0YWRhdGEgaW4gSW5kZXhlZERiIGFuZCBhdHRlbXB0cyB0byBlaXRoZXIgb2J0YWluIG9yXG4gICAgICogZXh0ZW5kIHRoZSBwcmltYXJ5IGxlYXNlIGZvciB0aGUgbG9jYWwgY2xpZW50LiBBc3luY2hyb25vdXNseSBub3RpZmllcyB0aGVcbiAgICAgKiBwcmltYXJ5IHN0YXRlIGxpc3RlbmVyIGlmIHRoZSBjbGllbnQgZWl0aGVyIG5ld2x5IG9idGFpbmVkIG9yIHJlbGVhc2VkIGl0c1xuICAgICAqIHByaW1hcnkgbGVhc2UuXG4gICAgICovXG4gICAgdXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbigndXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5JywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmVcbiAgICAgICAgICAgICAgICAucHV0KHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgbmV0d29ya0VuYWJsZWQ6IHRoaXMubmV0d29ya0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgaW5Gb3JlZ3JvdW5kOiB0aGlzLmluRm9yZWdyb3VuZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVByaW1hcnlMZWFzZSh0eG4pLm5leHQoc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5jYW5BY3RBc1ByaW1hcnkodHhuKSlcbiAgICAgICAgICAgICAgICAubmV4dChjYW5BY3RBc1ByaW1hcnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAmJiAhY2FuQWN0QXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKS5uZXh0KCgpID0+IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuQWN0QXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pLm5leHQoKCkgPT4gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyogY2FuQWN0QXNQcmltYXJ5PSAqLyBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdGYWlsZWQgdG8gZXh0ZW5kIG93bmVyIGxlYXNlOiAnLCBlKTtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZWVkIHdpdGggdGhlIGV4aXN0aW5nIHN0YXRlLiBBbnkgc3Vic2VxdWVudCBhY2Nlc3MgdG9cbiAgICAgICAgICAgICAgICAvLyBJbmRleGVkREIgd2lsbCB2ZXJpZnkgdGhlIGxlYXNlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUHJpbWFyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd1RhYlN5bmNocm9uaXphdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdSZWxlYXNpbmcgb3duZXIgbGVhc2UgYWZ0ZXIgZXJyb3IgZHVyaW5nIGxlYXNlIHJlZnJlc2gnLCBlKTtcbiAgICAgICAgICAgIHJldHVybiAvKiBpc1ByaW1hcnk9ICovIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oaXNQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAhPT0gaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoaXNQcmltYXJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGlzUHJpbWFyeTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZlcmlmeVByaW1hcnlMZWFzZSh0eG4pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5pc0xvY2FsQ2xpZW50KHByaW1hcnlDbGllbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNsaWVudE1ldGFkYXRhKHR4bikge1xuICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGFTdG9yZS5kZWxldGUodGhpcy5jbGllbnRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGhyZXNob2xkIGhhcyBwYXNzZWQsIHBydW5lcyB0aGVcbiAgICAgKiBSZW1vdGVEb2N1bWVudENoYW5nZXMgYW5kIHRoZSBDbGllbnRNZXRhZGF0YSBzdG9yZSBiYXNlZCBvbiB0aGUgbGFzdCB1cGRhdGVcbiAgICAgKiB0aW1lIG9mIGFsbCBjbGllbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIG1heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiZcbiAgICAgICAgICAgICF0aGlzLmlzV2l0aGluQWdlKHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSwgTUFYX0NMSUVOVF9BR0VfTVMpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgaW5hY3RpdmVDbGllbnRzID0gYXdhaXQgdGhpcy5ydW5UcmFuc2FjdGlvbignbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhU3RvcmUgPSBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGFTdG9yZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5maWx0ZXJBY3RpdmVDbGllbnRzKGV4aXN0aW5nQ2xpZW50cywgTUFYX0NMSUVOVF9BR0VfTVMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmFjdGl2ZSA9IGV4aXN0aW5nQ2xpZW50cy5maWx0ZXIoY2xpZW50ID0+IGFjdGl2ZS5pbmRleE9mKGNsaWVudCkgPT09IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG1ldGFkYXRhIGZvciBjbGllbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBjb25zaWRlcmVkIGFjdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluYWN0aXZlLCAoaW5hY3RpdmVDbGllbnQpID0+IG1ldGFkYXRhU3RvcmUuZGVsZXRlKGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSkubmV4dCgoKSA9PiBpbmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHByaW1hcnkgbGVhc2UgdmlvbGF0aW9ucyBvciBhbnkgb3RoZXIgdHlwZSBvZiBlcnJvci4gVGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IHdpbGwgcnVuIGBtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZSgpYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgYGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcygpYCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGRlcGVuZFxuICAgICAgICAgICAgICAgIC8vIG9uIExvY2FsU3RvcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBEZWxldGUgcG90ZW50aWFsIGxlZnRvdmVyIGVudHJpZXMgdGhhdCBtYXkgY29udGludWUgdG8gbWFyayB0aGVcbiAgICAgICAgICAgIC8vIGluYWN0aXZlIGNsaWVudHMgYXMgem9tYmllZCBpbiBMb2NhbFN0b3JhZ2UuXG4gICAgICAgICAgICAvLyBJZGVhbGx5IHdlJ2QgZGVsZXRlIHRoZSBJbmRleGVkRGIgYW5kIExvY2FsU3RvcmFnZSB6b21iaWUgZW50cmllcyBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgYXRvbWljYWxseSwgYnV0IHdlIGNhbid0LiBTbyB3ZSBvcHQgdG8gZGVsZXRlIHRoZSBJbmRleGVkRGJcbiAgICAgICAgICAgIC8vIGVudHJpZXMgZmlyc3QgdG8gYXZvaWQgcG90ZW50aWFsbHkgcmV2aXZpbmcgYSB6b21iaWVkIGNsaWVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLndlYlN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluYWN0aXZlQ2xpZW50IG9mIGluYWN0aXZlQ2xpZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYlN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoaW5hY3RpdmVDbGllbnQuY2xpZW50SWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgcmVjdXJyaW5nIHRpbWVyIHRvIHVwZGF0ZSB0aGUgY2xpZW50IG1ldGFkYXRhIGFuZCB0byBlaXRoZXJcbiAgICAgKiBleHRlbmQgb3IgYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSBpZiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlLlxuICAgICAqL1xuICAgIHNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiY2xpZW50X21ldGFkYXRhX3JlZnJlc2hcIiAvKiBUaW1lcklkLkNsaWVudE1ldGFkYXRhUmVmcmVzaCAqLywgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5tYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZSgpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBDaGVja3Mgd2hldGhlciBgY2xpZW50YCBpcyB0aGUgbG9jYWwgY2xpZW50LiAqL1xuICAgIGlzTG9jYWxDbGllbnQoY2xpZW50KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQgPyBjbGllbnQub3duZXJJZCA9PT0gdGhpcy5jbGllbnRJZCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgc3RhdGUgb2YgYWxsIGFjdGl2ZSBjbGllbnRzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGUgbG9jYWxcbiAgICAgKiBjbGllbnQgaXMgb3IgY2FuIGFjdCBhcyB0aGUgaG9sZGVyIG9mIHRoZSBwcmltYXJ5IGxlYXNlLiBSZXR1cm5zIHdoZXRoZXJcbiAgICAgKiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgbGVhc2UsIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBhY3F1aXJlIGl0LlxuICAgICAqIE1heSByZXR1cm4gJ2ZhbHNlJyBldmVuIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBsZWFzZWhvbGRlciBhbmQgYW5vdGhlclxuICAgICAqIChmb3JlZ3JvdW5kKSBjbGllbnQgc2hvdWxkIGJlY29tZSBsZWFzZWhvbGRlciBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGNhbkFjdEFzUHJpbWFyeSh0eG4pIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VPd25pbmdUYWIpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gc3RvcmVcbiAgICAgICAgICAgIC5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KVxuICAgICAgICAgICAgLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExlYXNlSXNWYWxpZCA9IGN1cnJlbnRQcmltYXJ5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xuICAgICAgICAgICAgLy8gQSBjbGllbnQgaXMgZWxpZ2libGUgZm9yIHRoZSBwcmltYXJ5IGxlYXNlIGlmOlxuICAgICAgICAgICAgLy8gLSBpdHMgbmV0d29yayBpcyBlbmFibGVkIGFuZCB0aGUgY2xpZW50J3MgdGFiIGlzIGluIHRoZSBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSBpdHMgbmV0d29yayBpcyBlbmFibGVkIGFuZCBubyBvdGhlciBjbGllbnQncyB0YWIgaXMgaW4gdGhlXG4gICAgICAgICAgICAvLyAgIGZvcmVncm91bmQuXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGVcbiAgICAgICAgICAgIC8vICAgZm9yZWdyb3VuZC5cbiAgICAgICAgICAgIC8vIC0gZXZlcnkgY2xpZW50cyBuZXR3b3JrIGlzIGRpc2FibGVkIGFuZCBubyBvdGhlciBjbGllbnQncyB0YWIgaXMgaW5cbiAgICAgICAgICAgIC8vICAgdGhlIGZvcmVncm91bmQuXG4gICAgICAgICAgICAvLyAtIHRoZSBgZm9yY2VPd25pbmdUYWJgIHNldHRpbmcgd2FzIHBhc3NlZCBpbi5cbiAgICAgICAgICAgIGlmIChjdXJyZW50TGVhc2VJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NhbENsaWVudChjdXJyZW50UHJpbWFyeSkgJiYgdGhpcy5uZXR3b3JrRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhaWwgdGhlIGBjYW5BY3RBc1ByaW1hcnlgIGNoZWNrIGlmIHRoZSBjdXJyZW50IGxlYXNlaG9sZGVyIGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi4gSWYgdGhpcyBoYXBwZW5zIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQgc3RhcnR1cCwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZW5hYmxlUGVyc2lzdGVuY2UoKWAgYW5kIHRoZSB1c2VyIGNhbiBjb250aW51ZSB0byB1c2UgRmlyZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGluLW1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMgZHVyaW5nIGEgbGVhc2UgcmVmcmVzaCwgd2Ugd2lsbCBpbnN0ZWFkIGJsb2NrIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN5bmNRdWV1ZSBmcm9tIGV4ZWN1dGluZyBmdXJ0aGVyIG9wZXJhdGlvbnMuIE5vdGUgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHRhYmxlIHNpbmNlIG1peGluZyAmIG1hdGNoaW5nIGRpZmZlcmVudCBgc3luY2hyb25pemVUYWJzYFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZ3MgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgc3luY2hyb25pemVUYWJzYCBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciBiZSB0dXJuZWQgb2ZmLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgUFJJTUFSWV9MRUFTRV9FWENMVVNJVkVfRVJST1JfTVNHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgJiYgdGhpcy5pbkZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bilcbiAgICAgICAgICAgICAgICAubG9hZEFsbCgpXG4gICAgICAgICAgICAgICAgLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFsbCBleGlzdGluZyBjbGllbnRzIGFuZCBkZXRlcm1pbmUgd2hldGhlciBhdCBsZWFzdCBvbmUgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGlzIGJldHRlciBzdWl0ZWQgdG8gb2J0YWluIHRoZSBwcmltYXJ5IGxlYXNlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZENhbmRpZGF0ZSA9IHRoaXMuZmlsdGVyQWN0aXZlQ2xpZW50cyhleGlzdGluZ0NsaWVudHMsIE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUykuZmluZChvdGhlckNsaWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudElkICE9PSBvdGhlckNsaWVudC5jbGllbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDbGllbnRIYXNCZXR0ZXJOZXR3b3JrU3RhdGUgPSAhdGhpcy5uZXR3b3JrRW5hYmxlZCAmJiBvdGhlckNsaWVudC5uZXR3b3JrRW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyVmlzaWJpbGl0eSA9ICF0aGlzLmluRm9yZWdyb3VuZCAmJiBvdGhlckNsaWVudC5pbkZvcmVncm91bmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc1NhbWVOZXR3b3JrU3RhdGUgPSB0aGlzLm5ldHdvcmtFbmFibGVkID09PSBvdGhlckNsaWVudC5uZXR3b3JrRW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckNsaWVudEhhc0JldHRlck5ldHdvcmtTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZmVycmVkQ2FuZGlkYXRlID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGNhbkFjdEFzUHJpbWFyeSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgIT09IGNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgYENsaWVudCAke2NhbkFjdEFzUHJpbWFyeSA/ICdpcycgOiAnaXMgbm90J30gZWxpZ2libGUgZm9yIGEgcHJpbWFyeSBsZWFzZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5BY3RBc1ByaW1hcnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gVGhlIHNodXRkb3duKCkgb3BlcmF0aW9ucyBhcmUgaWRlbXBvdGVudCBhbmQgY2FuIGJlIGNhbGxlZCBldmVuIHdoZW5cbiAgICAgICAgLy8gc3RhcnQoKSBhYm9ydGVkIChlLmcuIGJlY2F1c2UgaXQgY291bGRuJ3QgYWNxdWlyZSB0aGUgcGVyc2lzdGVuY2UgbGVhc2UpLlxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFya0NsaWVudFpvbWJpZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFjaFZpc2liaWxpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoV2luZG93VW5sb2FkSG9vaygpO1xuICAgICAgICAvLyBVc2UgYFNpbXBsZURiLnJ1blRyYW5zYWN0aW9uYCBkaXJlY3RseSB0byBhdm9pZCBmYWlsaW5nIGlmIGFub3RoZXIgdGFiXG4gICAgICAgIC8vIGhhcyBvYnRhaW5lZCB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgYXdhaXQgdGhpcy5zaW1wbGVEYi5ydW5UcmFuc2FjdGlvbignc2h1dGRvd24nLCAncmVhZHdyaXRlJywgW0RiUHJpbWFyeUNsaWVudFN0b3JlLCBEYkNsaWVudE1ldGFkYXRhU3RvcmVdLCBzaW1wbGVEYlR4biA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uID0gbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHNpbXBsZURiVHhuLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiB0aGlzLnJlbW92ZUNsaWVudE1ldGFkYXRhKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2ltcGxlRGIuY2xvc2UoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBlbnRyeSBtYXJraW5nIHRoZSBjbGllbnQgYXMgem9tYmllZCBmcm9tIExvY2FsU3RvcmFnZSBzaW5jZVxuICAgICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgZGVsZXRlZCBpdHMgbWV0YWRhdGEgZnJvbSBJbmRleGVkRGIuXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xpZW50Wm9tYmllZEVudHJ5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2xpZW50cyB0aGF0IGFyZSBub3Qgem9tYmllZCBhbmQgaGF2ZSBhbiB1cGRhdGVUaW1lIHdpdGhpbiB0aGVcbiAgICAgKiBwcm92aWRlZCB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZmlsdGVyQWN0aXZlQ2xpZW50cyhjbGllbnRzLCBhY3Rpdml0eVRocmVzaG9sZE1zKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRzLmZpbHRlcihjbGllbnQgPT4gdGhpcy5pc1dpdGhpbkFnZShjbGllbnQudXBkYXRlVGltZU1zLCBhY3Rpdml0eVRocmVzaG9sZE1zKSAmJlxuICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGNsaWVudC5jbGllbnRJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIGNsaWVudHMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS4gSWYgbXVsdGktdGFiXG4gICAgICogaXMgbm90IHN1cHBvcnRlZCwgcmV0dXJucyBhbiBhcnJheSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGxvY2FsIGNsaWVudCdzXG4gICAgICogSUQuXG4gICAgICpcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNsaWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRBY3RpdmVDbGllbnRzJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bilcbiAgICAgICAgICAgICAgICAubG9hZEFsbCgpXG4gICAgICAgICAgICAgICAgLm5leHQoY2xpZW50cyA9PiB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgTUFYX0NMSUVOVF9BR0VfTVMpLm1hcChjbGllbnRNZXRhZGF0YSA9PiBjbGllbnRNZXRhZGF0YS5jbGllbnRJZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICAgIH1cbiAgICBnZXRHbG9iYWxzQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbHNDYWNoZTtcbiAgICB9XG4gICAgZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWREYk11dGF0aW9uUXVldWUuZm9yVXNlcih1c2VyLCB0aGlzLnNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgfVxuICAgIGdldFRhcmdldENhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRDYWNoZTtcbiAgICB9XG4gICAgZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZTtcbiAgICB9XG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJJbmRleE1hbmFnZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIuZGF0YWJhc2VJZCk7XG4gICAgfVxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlLmZvclVzZXIodGhpcy5zZXJpYWxpemVyLCB1c2VyKTtcbiAgICB9XG4gICAgZ2V0QnVuZGxlQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1bmRsZUNhY2hlO1xuICAgIH1cbiAgICBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIHRyYW5zYWN0aW9uT3BlcmF0aW9uKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1N0YXJ0aW5nIHRyYW5zYWN0aW9uOicsIGFjdGlvbik7XG4gICAgICAgIGNvbnN0IHNpbXBsZURiTW9kZSA9IG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZG9ubHknIDogJ3JlYWR3cml0ZSc7XG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlcyA9IGdldE9iamVjdFN0b3Jlcyh0aGlzLnNjaGVtYVZlcnNpb24pO1xuICAgICAgICBsZXQgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbjtcbiAgICAgICAgLy8gRG8gYWxsIHRyYW5zYWN0aW9ucyBhcyByZWFkd3JpdGUgYWdhaW5zdCBhbGwgb2JqZWN0IHN0b3Jlcywgc2luY2Ugd2VcbiAgICAgICAgLy8gYXJlIHRoZSBvbmx5IHJlYWRlci93cml0ZXIuXG4gICAgICAgIHJldHVybiB0aGlzLnNpbXBsZURiXG4gICAgICAgICAgICAucnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBzaW1wbGVEYk1vZGUsIG9iamVjdFN0b3Jlcywgc2ltcGxlRGJUeG4gPT4ge1xuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgdGhpcy5saXN0ZW5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgID8gdGhpcy5saXN0ZW5TZXF1ZW5jZS5uZXh0KClcbiAgICAgICAgICAgICAgICA6IExpc3RlblNlcXVlbmNlLklOVkFMSUQpO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUtcHJpbWFyeScpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBtZXJlbHkgdmVyaWZ5IHRoYXQgd2UgaGF2ZSAob3IgY2FuIGFjcXVpcmUpIHRoZSBsZWFzZVxuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5LCB3ZSB3YWl0IHRvIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSB1bnRpbCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGluZyB0cmFuc2FjdGlvbk9wZXJhdGlvbigpLiBUaGlzIGVuc3VyZXMgdGhhdCBldmVuIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uT3BlcmF0aW9uIHRha2VzIGEgbG9uZyB0aW1lLCB3ZSdsbCB1c2UgYSByZWNlbnRcbiAgICAgICAgICAgICAgICAvLyBsZWFzZVRpbWVzdGFtcE1zIGluIHRoZSBleHRlbmRlZCAob3IgbmV3bHkgYWNxdWlyZWQpIGxlYXNlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVByaW1hcnlMZWFzZShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChob2xkc1ByaW1hcnlMZWFzZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkc1ByaW1hcnlMZWFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGhvbGRzUHJpbWFyeUxlYXNlPSAqLyB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbkFjdEFzUHJpbWFyeShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubmV4dChob2xkc1ByaW1hcnlMZWFzZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9sZHNQcmltYXJ5TGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGBGYWlsZWQgdG8gb2J0YWluIHByaW1hcnkgbGVhc2UgZm9yIGFjdGlvbiAnJHthY3Rpb259Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uT3BlcmF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHRyYW5zYWN0aW9uT3BlcmF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uLnJhaXNlT25Db21taXR0ZWRFdmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgdGFiIGlzIHRoZSBwcmltYXJ5IGxlYXNlaG9sZGVyIG9yIGFsdGVybmF0aXZlbHlcbiAgICAgKiB0aGF0IHRoZSBsZWFzZWhvbGRlciBoYXMgb3B0ZWQgaW50byBtdWx0aS10YWIgc3luY2hyb25pemF0aW9uLlxuICAgICAqL1xuICAgIC8vIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgdGhpcyBjaGVjayB3aGVuIGBzeW5jaHJvbml6ZVRhYnNgIGNhbiBubyBsb25nZXJcbiAgICAvLyBiZSB0dXJuZWQgb2ZmLlxuICAgIHZlcmlmeUFsbG93VGFiU3luY2hyb25pemF0aW9uKHR4bikge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KERiUHJpbWFyeUNsaWVudEtleSkubmV4dChjdXJyZW50UHJpbWFyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGVhc2VJc1ZhbGlkID0gY3VycmVudFByaW1hcnkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmlzV2l0aGluQWdlKGN1cnJlbnRQcmltYXJ5LmxlYXNlVGltZXN0YW1wTXMsIE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUykgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0NsaWVudFpvbWJpZWQoY3VycmVudFByaW1hcnkub3duZXJJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCAmJiAhdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZU93bmluZ1RhYiAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50UHJpbWFyeS5hbGxvd1RhYlN5bmNocm9uaXphdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgUFJJTUFSWV9MRUFTRV9FWENMVVNJVkVfRVJST1JfTVNHKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIG9yIGV4dGVuZHMgdGhlIG5ldyBwcmltYXJ5IGxlYXNlIGZvciB0aGUgbG9jYWwgY2xpZW50LiBUaGlzXG4gICAgICogbWV0aG9kIGRvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBjbGllbnQgaXMgZWxpZ2libGUgZm9yIHRoaXMgbGVhc2UuXG4gICAgICovXG4gICAgYWNxdWlyZU9yRXh0ZW5kUHJpbWFyeUxlYXNlKHR4bikge1xuICAgICAgICBjb25zdCBuZXdQcmltYXJ5ID0ge1xuICAgICAgICAgICAgb3duZXJJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uOiB0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uLFxuICAgICAgICAgICAgbGVhc2VUaW1lc3RhbXBNczogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJpbWFyeUNsaWVudFN0b3JlKHR4bikucHV0KERiUHJpbWFyeUNsaWVudEtleSwgbmV3UHJpbWFyeSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFNpbXBsZURiLmlzQXZhaWxhYmxlKCk7XG4gICAgfVxuICAgIC8qKiBDaGVja3MgdGhlIHByaW1hcnkgbGVhc2UgYW5kIHJlbW92ZXMgaXQgaWYgd2UgYXJlIHRoZSBjdXJyZW50IHByaW1hcnkuICovXG4gICAgcmVsZWFzZVByaW1hcnlMZWFzZUlmSGVsZCh0eG4pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvY2FsQ2xpZW50KHByaW1hcnlDbGllbnQpKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIHByaW1hcnkgbGVhc2UuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShEYlByaW1hcnlDbGllbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogVmVyaWZpZXMgdGhhdCBgdXBkYXRlVGltZU1zYCBpcyB3aXRoaW4gYG1heEFnZU1zYC4gKi9cbiAgICBpc1dpdGhpbkFnZSh1cGRhdGVUaW1lTXMsIG1heEFnZU1zKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG1pbkFjY2VwdGFibGUgPSBub3cgLSBtYXhBZ2VNcztcbiAgICAgICAgY29uc3QgbWF4QWNjZXB0YWJsZSA9IG5vdztcbiAgICAgICAgaWYgKHVwZGF0ZVRpbWVNcyA8IG1pbkFjY2VwdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cGRhdGVUaW1lTXMgPiBtYXhBY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihgRGV0ZWN0ZWQgYW4gdXBkYXRlIHRpbWUgdGhhdCBpcyBpbiB0aGUgZnV0dXJlOiAke3VwZGF0ZVRpbWVNc30gPiAke21heEFjY2VwdGFibGV9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGF0dGFjaFZpc2liaWxpdHlIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5Gb3JlZ3JvdW5kID0gdGhpcy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuaW5Gb3JlZ3JvdW5kID0gdGhpcy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSB3aW5kb3cudW5sb2FkIGhhbmRsZXIgdGhhdCB3aWxsIHN5bmNocm9ub3VzbHkgd3JpdGUgb3VyXG4gICAgICogY2xpZW50SWQgdG8gYSBcInpvbWJpZSBjbGllbnQgaWRcIiBsb2NhdGlvbiBpbiBMb2NhbFN0b3JhZ2UuIFRoaXMgY2FuIGJlIHVzZWRcbiAgICAgKiBieSB0YWJzIHRyeWluZyB0byBhY3F1aXJlIHRoZSBwcmltYXJ5IGxlYXNlIHRvIGRldGVybWluZSB0aGF0IHRoZSBsZWFzZVxuICAgICAqIGlzIG5vIGxvbmdlciB2YWxpZCBldmVuIGlmIHRoZSB0aW1lc3RhbXAgaXMgcmVjZW50LiBUaGlzIGlzIHBhcnRpY3VsYXJseVxuICAgICAqIGltcG9ydGFudCBmb3IgdGhlIHJlZnJlc2ggY2FzZSAoc28gdGhlIHRhYiBjb3JyZWN0bHkgcmUtYWNxdWlyZXMgdGhlXG4gICAgICogcHJpbWFyeSBsZWFzZSkuIExvY2FsU3RvcmFnZSBpcyB1c2VkIGZvciB0aGlzIHJhdGhlciB0aGFuIEluZGV4ZWREYiBiZWNhdXNlXG4gICAgICogaXQgaXMgYSBzeW5jaHJvbm91cyBBUEkgYW5kIHNvIGNhbiBiZSB1c2VkIHJlbGlhYmx5IGZyb20gIGFuIHVubG9hZFxuICAgICAqIGhhbmRsZXIuXG4gICAgICovXG4gICAgYXR0YWNoV2luZG93VW5sb2FkSG9vaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodHlwZW9mICgoX2EgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogSW4gdGhlb3J5LCB0aGlzIHNob3VsZCBiZSBzY2hlZHVsZWQgb24gdGhlIEFzeW5jUXVldWUgc2luY2UgaXRcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3NlcyBpbnRlcm5hbCBzdGF0ZS4gV2UgZXhlY3V0ZSB0aGlzIGNvZGUgZGlyZWN0bHkgZHVyaW5nIHNodXRkb3duXG4gICAgICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGl0IGdldHMgYSBjaGFuY2UgdG8gcnVuLlxuICAgICAgICAgICAgICAgIHRoaXMubWFya0NsaWVudFpvbWJpZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZhcmlJbmRleGRiQnVnVmVyc2lvblJlZ2V4ID0gLyg/OlZlcnNpb258TW9iaWxlKVxcLzFbNDU2XS87XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmYXJpKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXgpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbiBTYWZhcmkgMTQsIDE1LCBhbmQgMTYsIHdlIGRvIG5vdCBydW4gYW55IGNsZWFudXAgYWN0aW9ucyBhcyBpdCBtaWdodFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgYnVnIHRoYXQgcHJldmVudHMgU2FmYXJpIGZyb20gcmUtb3BlbmluZyBJbmRleGVkREIgZHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IHBhZ2UgbG9hZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjY1NDdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKC8qIHB1cmdlRXhpc3RpbmdUYXNrcz0gKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd24gKGluY2x1ZGluZyByZWxlYXNpbmcgb3VyIHByaW1hcnkgbGVhc2UpLFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhlcmUncyBubyBndWFyYW50ZWUgaXQgd2lsbCBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMud2luZG93VW5sb2FkSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoV2luZG93VW5sb2FkSG9vaygpIHtcbiAgICAgICAgaWYgKHRoaXMud2luZG93VW5sb2FkSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjbGllbnQgaXMgXCJ6b21iaWVkXCIgYmFzZWQgb24gaXRzIExvY2FsU3RvcmFnZSBlbnRyeS5cbiAgICAgKiBDbGllbnRzIGJlY29tZSB6b21iaWVkIHdoZW4gdGhlaXIgdGFiIGNsb3NlcyB3aXRob3V0IHJ1bm5pbmcgYWxsIG9mIHRoZVxuICAgICAqIGNsZWFudXAgbG9naWMgaW4gYHNodXRkb3duKClgLlxuICAgICAqL1xuICAgIGlzQ2xpZW50Wm9tYmllZChjbGllbnRJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc1pvbWJpZWQgPSAoKF9hID0gdGhpcy53ZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SXRlbSh0aGlzLnpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpKSkgIT09IG51bGw7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJyR7Y2xpZW50SWR9JyAke2lzWm9tYmllZCA/ICdpcycgOiAnaXMgbm90J30gem9tYmllZCBpbiBMb2NhbFN0b3JhZ2VgKTtcbiAgICAgICAgICAgIHJldHVybiBpc1pvbWJpZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGlmIExvY2FsU3RvcmFnZSBpc24ndCB3b3JraW5nLlxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIGdldCB6b21iaWVkIGNsaWVudCBpZC4nLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgY2xpZW50IGFzIHpvbWJpZWQgKGEgY2xpZW50IHRoYXQgaGFkIGl0cyB0YWIgY2xvc2VkKS4gWm9tYmllZFxuICAgICAqIGNsaWVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHByaW1hcnkgdGFiIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBtYXJrQ2xpZW50Wm9tYmllZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlYlN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnNldEl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KHRoaXMuY2xpZW50SWQpLCBTdHJpbmcoRGF0ZS5ub3coKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBpZiBMb2NhbFN0b3JhZ2UgaXNuJ3QgYXZhaWxhYmxlIC8gd29ya2luZy5cbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2V0IHpvbWJpZSBjbGllbnQgaWQuJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgdGhlIHpvbWJpZWQgY2xpZW50IGVudHJ5IGlmIGl0IGV4aXN0cy4gKi9cbiAgICByZW1vdmVDbGllbnRab21iaWVkRW50cnkoKSB7XG4gICAgICAgIGlmICghdGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIHpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGAke1pPTUJJRURfQ0xJRU5UU19LRVlfUFJFRklYfV8ke3RoaXMucGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcHJpbWFyeSBjbGllbnQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJQcmltYXJ5Q2xpZW50U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNsaWVudCBtZXRhZGF0YSBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJDbGllbnRNZXRhZGF0YVN0b3JlKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHVzZWQgYXMgYSBwcmVmaXggd2hlbiBzdG9yaW5nIGRhdGEgaW4gSW5kZXhlZERCIGFuZFxuICogTG9jYWxTdG9yYWdlLlxuICovXG5mdW5jdGlvbiBpbmRleGVkRGJTdG9yYWdlUHJlZml4KGRhdGFiYXNlSWQsIHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgLy8gVXNlIHR3byBkaWZmZXJlbnQgcHJlZml4IGZvcm1hdHM6XG4gICAgLy9cbiAgICAvLyAgICogZmlyZXN0b3JlIC8gcGVyc2lzdGVuY2VLZXkgLyBwcm9qZWN0SUQgLiBkYXRhYmFzZUlEIC8gLi4uXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC8gLi4uXG4gICAgLy9cbiAgICAvLyBwcm9qZWN0SURzIGFyZSBETlMtY29tcGF0aWJsZSBuYW1lcyBhbmQgY2Fubm90IGNvbnRhaW4gZG90c1xuICAgIC8vIHNvIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGNvbGxpc2lvbnMuXG4gICAgbGV0IGRhdGFiYXNlID0gZGF0YWJhc2VJZC5wcm9qZWN0SWQ7XG4gICAgaWYgKCFkYXRhYmFzZUlkLmlzRGVmYXVsdERhdGFiYXNlKSB7XG4gICAgICAgIGRhdGFiYXNlICs9ICcuJyArIGRhdGFiYXNlSWQuZGF0YWJhc2U7XG4gICAgfVxuICAgIHJldHVybiAnZmlyZXN0b3JlLycgKyBwZXJzaXN0ZW5jZUtleSArICcvJyArIGRhdGFiYXNlICsgJy8nO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5kZXhlZERiQ2xlYXJQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZUtleSkge1xuICAgIGlmICghU2ltcGxlRGIuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcbiAgICBhd2FpdCBTaW1wbGVEYi5kZWxldGUoZGJOYW1lKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29tcGFyZXMgdHdvIGFycmF5IGZvciBlcXVhbGl0eSB1c2luZyBjb21wYXJhdG9yLiBUaGUgbWV0aG9kIGNvbXB1dGVzIHRoZVxuICogaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBpbiBgYWZ0ZXJgIGJ1dCBub3RcbiAqIGBiZWZvcmVgLiBgb25SZW1vdmVgIGlzIGludm9rZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gYGJlZm9yZWAgYnV0IG1pc3NpbmdcbiAqIGZyb20gYGFmdGVyYC5cbiAqXG4gKiBUaGUgbWV0aG9kIGNyZWF0ZXMgYSBjb3B5IG9mIGJvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYW5kIHJ1bnMgaW4gTyhuIGxvZ1xuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0gYmVmb3JlIC0gVGhlIGVsZW1lbnRzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIGFmdGVyIC0gVGhlIGVsZW1lbnRzIHRvIGRpZmYgYWdhaW5zdCB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gKiBAcGFyYW0gY29tcGFyYXRvciAtIFRoZSBjb21wYXJhdG9yIGZvciB0aGUgZWxlbWVudHMgaW4gYmVmb3JlIGFuZCBhZnRlci5cbiAqIEBwYXJhbSBvbkFkZCAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBgXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cbiAqIEBwYXJhbSBvblJlbW92ZSAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZlxuICogYGJlZm9yZWAgYnV0IG5vdCBgYWZ0ZXJgLlxuICovXG5mdW5jdGlvbiBkaWZmQXJyYXlzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xuICAgIGJlZm9yZSA9IFsuLi5iZWZvcmVdO1xuICAgIGFmdGVyID0gWy4uLmFmdGVyXTtcbiAgICBiZWZvcmUuc29ydChjb21wYXJhdG9yKTtcbiAgICBhZnRlci5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIGNvbnN0IGJMZW4gPSBiZWZvcmUubGVuZ3RoO1xuICAgIGNvbnN0IGFMZW4gPSBhZnRlci5sZW5ndGg7XG4gICAgbGV0IGEgPSAwO1xuICAgIGxldCBiID0gMDtcbiAgICB3aGlsZSAoYSA8IGFMZW4gJiYgYiA8IGJMZW4pIHtcbiAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihiZWZvcmVbYl0sIGFmdGVyW2FdKTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyByZW1vdmVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWRcbiAgICAgICAgICAgIC8vIHdhbGt0aHJvdWdoIGlzIG9ubHkgaW4gYGJlZm9yZWAuXG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcbiAgICAgICAgICAgIC8vIGlzIG9ubHkgaW4gYGFmdGVyYC5cbiAgICAgICAgICAgIG9uQWRkKGFmdGVyW2ErK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYSsrO1xuICAgICAgICAgICAgYisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChhIDwgYUxlbikge1xuICAgICAgICBvbkFkZChhZnRlclthKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGIgPCBiTGVuKSB7XG4gICAgICAgIG9uUmVtb3ZlKGJlZm9yZVtiKytdKTtcbiAgICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIGVxdWFsaXR5IGZvciBhbiBhcnJheSBvZiBwcmltaXRpdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBsZWZ0IEFycmF5IG9mIHByaW1pdGl2ZXMuXG4gKiBAcGFyYW0gcmlnaHQgQXJyYXkgb2YgcHJpbWl0aXZlcy5cbiAqIEByZXR1cm4gVHJ1ZSBpZiBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZUFycmF5RXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobGVmdFtpXSAhPT0gcmlnaHRbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckYiA9ICdMb2NhbFN0b3JlJztcbi8qKlxuICogVGhlIG1heGltdW0gdGltZSB0byBsZWF2ZSBhIHJlc3VtZSB0b2tlbiBidWZmZXJlZCB3aXRob3V0IHdyaXRpbmcgaXQgb3V0LlxuICogVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnk6IGl0J3MgbG9uZyBlbm91Z2ggdG8gYXZvaWQgc2V2ZXJhbCB3cml0ZXNcbiAqIChwb3NzaWJseSBpbmRlZmluaXRlbHkgaWYgdXBkYXRlcyBjb21lIG1vcmUgZnJlcXVlbnRseSB0aGFuIHRoaXMpIGJ1dFxuICogc2hvcnQgZW5vdWdoIHRoYXQgcmVzdGFydGluZyBhZnRlciBjcmFzaGluZyB3aWxsIHN0aWxsIGhhdmUgYSBwcmV0dHlcbiAqIHJlY2VudCByZXN1bWUgdG9rZW4uXG4gKi9cbmNvbnN0IFJFU1VNRV9UT0tFTl9NQVhfQUdFX01JQ1JPUyA9IDUgKiA2MCAqIDFlNjtcbi8qKlxuICogSW1wbGVtZW50cyBgTG9jYWxTdG9yZWAgaW50ZXJmYWNlLlxuICpcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XG4gKiB0aGUgY2xhc3MgaXMgbm90IGV4cG9ydGVkIHNvIHRoZXkgYXJlIG9ubHkgYWNjZXNzaWJsZSBmcm9tIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyB1c2VmdWwgdG8gaW1wbGVtZW50IG9wdGlvbmFsIGZlYXR1cmVzIChsaWtlIGJ1bmRsZXMpIGluIGZyZWVcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxuICovXG5jbGFzcyBMb2NhbFN0b3JlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIE1hbmFnZXMgb3VyIGluLW1lbW9yeSBvciBkdXJhYmxlIHBlcnNpc3RlbmNlLiAqL1xuICAgIHBlcnNpc3RlbmNlLCBxdWVyeUVuZ2luZSwgaW5pdGlhbFVzZXIsIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICB0aGlzLnF1ZXJ5RW5naW5lID0gcXVlcnlFbmdpbmU7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0SUQgdG8gZGF0YSBhYm91dCBpdHMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBQT1JUSU5HIE5PVEU6IFdlIGFyZSB1c2luZyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgb24gV2ViIHRvIG1ha2UgcmUtcnVuc1xuICAgICAgICAgKiBvZiBgYXBwbHlSZW1vdGVFdmVudCgpYCBpZGVtcG90ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICAvKiogTWFwcyBhIHRhcmdldCB0byBpdHMgdGFyZ2V0SUQuICovXG4gICAgICAgIC8vIFRPRE8od3VhbmR5KTogRXZhbHVhdGUgaWYgVGFyZ2V0SWQgY2FuIGJlIHBhcnQgb2YgVGFyZ2V0LlxuICAgICAgICB0aGlzLnRhcmdldElkQnlUYXJnZXQgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHBlciBjb2xsZWN0aW9uIGdyb3VwIGluZGV4IG9mIHRoZSBsYXN0IHJlYWQgdGltZSBwcm9jZXNzZWQgYnlcbiAgICAgICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwUmVhZFRpbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRzID0gcGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gcGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IHBlcnNpc3RlbmNlLmdldEJ1bmRsZUNhY2hlKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVVzZXJDb21wb25lbnRzKGluaXRpYWxVc2VyKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVVzZXJDb21wb25lbnRzKHVzZXIpIHtcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk6IEFkZCBzcGVjIHRlc3RzIHRoYXQgdGVzdCB0aGVzZSBjb21wb25lbnRzIGNoYW5nZSBhZnRlciBhXG4gICAgICAgIC8vIHVzZXIgY2hhbmdlXG4gICAgICAgIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpO1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpO1xuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldE11dGF0aW9uUXVldWUodXNlciwgdGhpcy5pbmRleE1hbmFnZXIpO1xuICAgICAgICB0aGlzLmxvY2FsRG9jdW1lbnRzID0gbmV3IExvY2FsRG9jdW1lbnRzVmlldyh0aGlzLnJlbW90ZURvY3VtZW50cywgdGhpcy5tdXRhdGlvblF1ZXVlLCB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlLCB0aGlzLmluZGV4TWFuYWdlcik7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRzLnNldEluZGV4TWFuYWdlcih0aGlzLmluZGV4TWFuYWdlcik7XG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUuaW5pdGlhbGl6ZSh0aGlzLmxvY2FsRG9jdW1lbnRzLCB0aGlzLmluZGV4TWFuYWdlcik7XG4gICAgfVxuICAgIGNvbGxlY3RHYXJiYWdlKGdhcmJhZ2VDb2xsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0NvbGxlY3QgZ2FyYmFnZScsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiBnYXJiYWdlQ29sbGVjdG9yLmNvbGxlY3QodHhuLCB0aGlzLnRhcmdldERhdGFCeVRhcmdldCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0xvY2FsU3RvcmUoXG4vKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXG5wZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JlSW1wbChwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKTtcbn1cbi8qKlxuICogVGVsbHMgdGhlIExvY2FsU3RvcmUgdGhhdCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgY2hhbmdlZC5cbiAqXG4gKiBJbiByZXNwb25zZSB0aGUgbG9jYWwgc3RvcmUgc3dpdGNoZXMgdGhlIG11dGF0aW9uIHF1ZXVlIHRvIHRoZSBuZXcgdXNlciBhbmRcbiAqIHJldHVybnMgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IEFuZHJvaWQgYW5kIGlPUyBvbmx5IHJldHVybiB0aGUgZG9jdW1lbnRzIGFmZmVjdGVkIGJ5IHRoZVxuLy8gY2hhbmdlLlxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2UobG9jYWxTdG9yZSwgdXNlcikge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdIYW5kbGUgdXNlciBjaGFuZ2UnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xuICAgICAgICAvLyBTd2FwIG91dCB0aGUgbXV0YXRpb24gcXVldWUsIGdyYWJiaW5nIHRoZSBwZW5kaW5nIG11dGF0aW9uIGJhdGNoZXNcbiAgICAgICAgLy8gYmVmb3JlIGFuZCBhZnRlci5cbiAgICAgICAgbGV0IG9sZEJhdGNoZXM7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlXG4gICAgICAgICAgICAuZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHR4bilcbiAgICAgICAgICAgIC5uZXh0KHByb21pc2VkT2xkQmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICBvbGRCYXRjaGVzID0gcHJvbWlzZWRPbGRCYXRjaGVzO1xuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwuaW5pdGlhbGl6ZVVzZXJDb21wb25lbnRzKHVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHR4bik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChuZXdCYXRjaGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRCYXRjaElkcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkZWRCYXRjaElkcyA9IFtdO1xuICAgICAgICAgICAgLy8gVW5pb24gdGhlIG9sZC9uZXcgY2hhbmdlZCBrZXlzLlxuICAgICAgICAgICAgbGV0IGNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2Ygb2xkQmF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRCYXRjaElkcy5wdXNoKGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRLZXlzID0gY2hhbmdlZEtleXMuYWRkKG11dGF0aW9uLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBuZXdCYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRCYXRjaElkcy5wdXNoKGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRLZXlzID0gY2hhbmdlZEtleXMuYWRkKG11dGF0aW9uLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZXQgb2YgYWxsIChwb3RlbnRpYWxseSkgY2hhbmdlZCBkb2N1bWVudHMgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAvLyBvZiBtdXRhdGlvbiBiYXRjaCBJRHMgdGhhdCB3ZXJlIGFmZmVjdGVkIGJ5IGNoYW5nZS5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50c1xuICAgICAgICAgICAgICAgIC5nZXREb2N1bWVudHModHhuLCBjaGFuZ2VkS2V5cylcbiAgICAgICAgICAgICAgICAubmV4dChhZmZlY3RlZERvY3VtZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWREb2N1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRCYXRjaElkcyxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRCYXRjaElkc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qIEFjY2VwdHMgbG9jYWxseSBnZW5lcmF0ZWQgTXV0YXRpb25zIGFuZCBjb21taXQgdGhlbSB0byBzdG9yYWdlLiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVdyaXRlTG9jYWxseShsb2NhbFN0b3JlLCBtdXRhdGlvbnMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBsb2NhbFdyaXRlVGltZSA9IFRpbWVzdGFtcC5ub3coKTtcbiAgICBjb25zdCBrZXlzID0gbXV0YXRpb25zLnJlZHVjZSgoa2V5cywgbSkgPT4ga2V5cy5hZGQobS5rZXkpLCBkb2N1bWVudEtleVNldCgpKTtcbiAgICBsZXQgb3ZlcmxheWVkRG9jdW1lbnRzO1xuICAgIGxldCBtdXRhdGlvbkJhdGNoO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0xvY2FsbHkgd3JpdGUgbXV0YXRpb25zJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2gga2V5cyBkbyBub3QgaGF2ZSBhIHJlbW90ZSB2ZXJzaW9uIGluIHRoZSBjYWNoZSwgdGhpc1xuICAgICAgICAvLyBpcyBuZWVkZWQgdG8gY3JlYXRlIHRoZSByaWdodCBvdmVybGF5IG11dGF0aW9uOiBpZiBubyByZW1vdGUgdmVyc2lvblxuICAgICAgICAvLyBwcmVzZW50cywgd2UgZG8gbm90IG5lZWQgdG8gY3JlYXRlIG92ZXJsYXlzIGFzIHBhdGNoIG11dGF0aW9ucy5cbiAgICAgICAgLy8gVE9ETyhPdmVybGF5KTogSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRldGVybWluZSB0aGlzPyBVc2luZyB0aGVcbiAgICAgICAgLy8gIGRvY3VtZW50IHZlcnNpb24gZG9lcyBub3Qgd29yayBiZWNhdXNlIGxvY2FsIG11dGF0aW9ucyBzZXQgdGhlbSBiYWNrXG4gICAgICAgIC8vICB0byAwLlxuICAgICAgICBsZXQgcmVtb3RlRG9jcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICBsZXQgZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50c1xuICAgICAgICAgICAgLmdldEVudHJpZXModHhuLCBrZXlzKVxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB7XG4gICAgICAgICAgICByZW1vdGVEb2NzID0gZG9jcztcbiAgICAgICAgICAgIHJlbW90ZURvY3MuZm9yRWFjaCgoa2V5LCBkb2MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvYy5pc1ZhbGlkRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24gPSBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2FkIGFuZCBhcHBseSBhbGwgZXhpc3RpbmcgbXV0YXRpb25zLiBUaGlzIGxldHMgdXMgY29tcHV0ZSB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYmFzZSBzdGF0ZSBmb3IgYWxsIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYmVmb3JlIGFwcGx5aW5nXG4gICAgICAgICAgICAvLyBhbnkgYWRkaXRpb25hbCB1c2VyLXByb3ZpZGVkIHdyaXRlcy5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXRPdmVybGF5ZWREb2N1bWVudHModHhuLCByZW1vdGVEb2NzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KChkb2NzKSA9PiB7XG4gICAgICAgICAgICBvdmVybGF5ZWREb2N1bWVudHMgPSBkb2NzO1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1pZGVtcG90ZW50IG11dGF0aW9ucyAoc3VjaCBhcyBgRmllbGRWYWx1ZS5pbmNyZW1lbnQoKWApLFxuICAgICAgICAgICAgLy8gd2UgcmVjb3JkIHRoZSBiYXNlIHN0YXRlIGluIGEgc2VwYXJhdGUgcGF0Y2ggbXV0YXRpb24uIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGxhdGVyIHVzZWQgdG8gZ3VhcmFudGVlIGNvbnNpc3RlbnQgdmFsdWVzIGFuZCBwcmV2ZW50cyBmbGlja2VyXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBiYWNrZW5kIHNlbmRzIHVzIGFuIHVwZGF0ZSB0aGF0IGFscmVhZHkgaW5jbHVkZXMgb3VyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0uXG4gICAgICAgICAgICBjb25zdCBiYXNlTXV0YXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgb3ZlcmxheWVkRG9jdW1lbnRzLmdldChtdXRhdGlvbi5rZXkpLm92ZXJsYXllZERvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGJhc2Ugc3RhdGUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCBpZiB0aGVyZSdzIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZG9jdW1lbnQgdG8gb3ZlcnJpZGUsIHNvIHVzZSBhIFByZWNvbmRpdGlvbiBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBleGlzdHM9dHJ1ZVxuICAgICAgICAgICAgICAgICAgICBiYXNlTXV0YXRpb25zLnB1c2gobmV3IFBhdGNoTXV0YXRpb24obXV0YXRpb24ua2V5LCBiYXNlVmFsdWUsIGV4dHJhY3RGaWVsZE1hc2soYmFzZVZhbHVlLnZhbHVlLm1hcFZhbHVlKSwgUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmFkZE11dGF0aW9uQmF0Y2godHhuLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGJhdGNoID0+IHtcbiAgICAgICAgICAgIG11dGF0aW9uQmF0Y2ggPSBiYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gYmF0Y2guYXBwbHlUb0xvY2FsRG9jdW1lbnRTZXQob3ZlcmxheWVkRG9jdW1lbnRzLCBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmRvY3VtZW50T3ZlcmxheUNhY2hlLnNhdmVPdmVybGF5cyh0eG4sIGJhdGNoLmJhdGNoSWQsIG92ZXJsYXlzKTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4gKHtcbiAgICAgICAgYmF0Y2hJZDogbXV0YXRpb25CYXRjaC5iYXRjaElkLFxuICAgICAgICBjaGFuZ2VzOiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKG92ZXJsYXllZERvY3VtZW50cylcbiAgICB9KSk7XG59XG4vKipcbiAqIEFja25vd2xlZGdlcyB0aGUgZ2l2ZW4gYmF0Y2guXG4gKlxuICogT24gdGhlIGhhcHB5IHBhdGggd2hlbiBhIGJhdGNoIGlzIGFja25vd2xlZGdlZCwgdGhlIGxvY2FsIHN0b3JlIHdpbGxcbiAqXG4gKiAgKyByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlO1xuICogICsgYXBwbHkgdGhlIGNoYW5nZXMgdG8gdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZTtcbiAqICArIHJlY2FsY3VsYXRlIHRoZSBsYXRlbmN5IGNvbXBlbnNhdGVkIHZpZXcgaW1wbGllZCBieSB0aG9zZSBjaGFuZ2VzICh0aGVyZVxuICogICAgbWF5IGJlIG11dGF0aW9ucyBpbiB0aGUgcXVldWUgdGhhdCBhZmZlY3QgdGhlIGRvY3VtZW50cyBidXQgaGF2ZW4ndCBiZWVuXG4gKiAgICBhY2tub3dsZWRnZWQgeWV0KTsgYW5kXG4gKiAgKyBnaXZlIHRoZSBjaGFuZ2VkIGRvY3VtZW50cyBiYWNrIHRoZSBzeW5jIGVuZ2luZVxuICpcbiAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgKG1vZGlmaWVkKSBkb2N1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKGxvY2FsU3RvcmUsIGJhdGNoUmVzdWx0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdBY2tub3dsZWRnZSBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gYmF0Y2hSZXN1bHQuYmF0Y2gua2V5cygpO1xuICAgICAgICBjb25zdCBkb2N1bWVudEJ1ZmZlciA9IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5uZXdDaGFuZ2VCdWZmZXIoe1xuICAgICAgICAgICAgdHJhY2tSZW1vdmFsczogdHJ1ZSAvLyBNYWtlIHN1cmUgZG9jdW1lbnQgcmVtb3ZhbHMgc2hvdyB1cCBpbiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXBwbHlXcml0ZVRvUmVtb3RlRG9jdW1lbnRzKGxvY2FsU3RvcmVJbXBsLCB0eG4sIGJhdGNoUmVzdWx0LCBkb2N1bWVudEJ1ZmZlcilcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bikpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5yZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHhuLCBhZmZlY3RlZCwgYmF0Y2hSZXN1bHQuYmF0Y2guYmF0Y2hJZCkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyh0eG4sIGdldEtleXNXaXRoVHJhbnNmb3JtUmVzdWx0cyhiYXRjaFJlc3VsdCkpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEtleXNXaXRoVHJhbnNmb3JtUmVzdWx0cyhiYXRjaFJlc3VsdCkge1xuICAgIGxldCByZXN1bHQgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hSZXN1bHQubXV0YXRpb25SZXN1bHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gYmF0Y2hSZXN1bHQubXV0YXRpb25SZXN1bHRzW2ldO1xuICAgICAgICBpZiAobXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGJhdGNoUmVzdWx0LmJhdGNoLm11dGF0aW9uc1tpXS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJlbW92ZXMgbXV0YXRpb25zIGZyb20gdGhlIE11dGF0aW9uUXVldWUgZm9yIHRoZSBzcGVjaWZpZWQgYmF0Y2g7XG4gKiBMb2NhbERvY3VtZW50cyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIG1vZGlmaWVkIGRvY3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVJlamVjdEJhdGNoKGxvY2FsU3RvcmUsIGJhdGNoSWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlamVjdCBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XG4gICAgICAgIGxldCBhZmZlY3RlZEtleXM7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlXG4gICAgICAgICAgICAubG9va3VwTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoSWQpXG4gICAgICAgICAgICAubmV4dCgoYmF0Y2gpID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYmF0Y2ggIT09IG51bGwpO1xuICAgICAgICAgICAgYWZmZWN0ZWRLZXlzID0gYmF0Y2gua2V5cygpO1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmRvY3VtZW50T3ZlcmxheUNhY2hlLnJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0eG4sIGFmZmVjdGVkS2V5cywgYmF0Y2hJZCkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyh0eG4sIGFmZmVjdGVkS2V5cykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBhZmZlY3RlZEtleXMpKTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFyZ2VzdCAobGF0ZXN0KSBiYXRjaCBpZCBpbiBtdXRhdGlvbiBxdWV1ZSB0aGF0IGlzIHBlbmRpbmdcbiAqIHNlcnZlciByZXNwb25zZS5cbiAqXG4gKiBSZXR1cm5zIGBCQVRDSElEX1VOS05PV05gIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQobG9jYWxTdG9yZSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IGhpZ2hlc3QgdW5hY2tub3dsZWRnZWQgYmF0Y2ggaWQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5nZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHR4bikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGNvbnNpc3RlbnQgc25hcHNob3QgcHJvY2Vzc2VkICh1c2VkIGJ5IHRoZSBSZW1vdGVTdG9yZSB0b1xuICogZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYnVmZmVyIGluY29taW5nIHNuYXBzaG90cyBmcm9tIHRoZSBiYWNrZW5kKS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24obG9jYWxTdG9yZSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IGxhc3QgcmVtb3RlIHNuYXBzaG90IHZlcnNpb24nLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbih0eG4pKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgXCJncm91bmQtc3RhdGVcIiAocmVtb3RlKSBkb2N1bWVudHMuIFdlIGFzc3VtZSB0aGF0IHRoZSByZW1vdGVcbiAqIGV2ZW50IHJlZmxlY3RzIGFueSB3cml0ZSBiYXRjaGVzIHRoYXQgaGF2ZSBiZWVuIGFja25vd2xlZGdlZCBvciByZWplY3RlZFxuICogKGkuZS4gd2UgZG8gbm90IHJlLWFwcGx5IGxvY2FsIG11dGF0aW9ucyB0byB1cGRhdGVzIGZyb20gdGhpcyBldmVudCkuXG4gKlxuICogTG9jYWxEb2N1bWVudHMgYXJlIHJlLWNhbGN1bGF0ZWQgaWYgdGhlcmUgYXJlIHJlbWFpbmluZyBtdXRhdGlvbnMgaW4gdGhlXG4gKiBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUFwcGx5UmVtb3RlRXZlbnRUb0xvY2FsQ2FjaGUobG9jYWxTdG9yZSwgcmVtb3RlRXZlbnQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCByZW1vdGVWZXJzaW9uID0gcmVtb3RlRXZlbnQuc25hcHNob3RWZXJzaW9uO1xuICAgIGxldCBuZXdUYXJnZXREYXRhQnlUYXJnZXRNYXAgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQ7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignQXBwbHkgcmVtb3RlIGV2ZW50JywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVzZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwIGluIGNhc2UgdGhpcyB0cmFuc2FjdGlvbiBnZXRzIHJlLXJ1bi5cbiAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSwgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhQnlUYXJnZXRNYXAuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgIGlmICghb2xkVGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSByZW1vdGUga2V5cyBpZiB0aGUgdGFyZ2V0IGlzIHN0aWxsIGFjdGl2ZS4gVGhpc1xuICAgICAgICAgICAgLy8gZW5zdXJlcyB0aGF0IHdlIGNhbiBwZXJzaXN0IHRoZSB1cGRhdGVkIHRhcmdldCBkYXRhIGFsb25nIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSB1cGRhdGVkIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXG4gICAgICAgICAgICAgICAgLnJlbW92ZU1hdGNoaW5nS2V5cyh0eG4sIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLCB0YXJnZXRJZClcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmFkZE1hdGNoaW5nS2V5cyh0eG4sIGNoYW5nZS5hZGRlZERvY3VtZW50cywgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGV0IG5ld1RhcmdldERhdGEgPSBvbGRUYXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC50YXJnZXRNaXNtYXRjaGVzLmdldCh0YXJnZXRJZCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YVxuICAgICAgICAgICAgICAgICAgICAud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFNuYXBzaG90VmVyc2lvbi5taW4oKSlcbiAgICAgICAgICAgICAgICAgICAgLndpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgIG5ld1RhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihjaGFuZ2UucmVzdW1lVG9rZW4sIHJlbW90ZVZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmluc2VydCh0YXJnZXRJZCwgbmV3VGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhcmdldCBkYXRhIGlmIHRoZXJlIGFyZSB0YXJnZXQgY2hhbmdlcyAob3IgaWZcbiAgICAgICAgICAgIC8vIHN1ZmZpY2llbnQgdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuXG4gICAgICAgICAgICBpZiAoc2hvdWxkUGVyc2lzdFRhcmdldERhdGEob2xkVGFyZ2V0RGF0YSwgbmV3VGFyZ2V0RGF0YSwgY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUudXBkYXRlVGFyZ2V0RGF0YSh0eG4sIG5ld1RhcmdldERhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VkRG9jcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICBsZXQgZXhpc3RlbmNlQ2hhbmdlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICByZW1vdGVFdmVudC5kb2N1bWVudFVwZGF0ZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlbW90ZUV2ZW50LnJlc29sdmVkTGltYm9Eb2N1bWVudHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEVhY2ggbG9vcCBpdGVyYXRpb24gb25seSBhZmZlY3RzIGl0cyBcIm93blwiIGRvYywgc28gaXQncyBzYWZlIHRvIGdldCBhbGxcbiAgICAgICAgLy8gdGhlIHJlbW90ZSBkb2N1bWVudHMgaW4gYWR2YW5jZSBpbiBhIHNpbmdsZSBjYWxsLlxuICAgICAgICBwcm9taXNlcy5wdXNoKHBvcHVsYXRlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodHhuLCBkb2N1bWVudEJ1ZmZlciwgcmVtb3RlRXZlbnQuZG9jdW1lbnRVcGRhdGVzKS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VkRG9jcyA9IHJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzO1xuICAgICAgICAgICAgZXhpc3RlbmNlQ2hhbmdlZEtleXMgPSByZXN1bHQuZXhpc3RlbmNlQ2hhbmdlZEtleXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gSEFDSzogVGhlIG9ubHkgcmVhc29uIHdlIGFsbG93IGEgbnVsbCBzbmFwc2hvdCB2ZXJzaW9uIGlzIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gY2FuIHN5bnRoZXNpemUgcmVtb3RlIGV2ZW50cyB3aGVuIHdlIGdldCBwZXJtaXNzaW9uIGRlbmllZCBlcnJvcnMgd2hpbGVcbiAgICAgICAgLy8gdHJ5aW5nIHRvIHJlc29sdmUgdGhlIHN0YXRlIG9mIGEgbG9jYWxseSBjYWNoZWQgZG9jdW1lbnQgdGhhdCBpcyBpblxuICAgICAgICAvLyBsaW1iby5cbiAgICAgICAgaWYgKCFyZW1vdGVWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlUmVtb3RlVmVyc2lvbiA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXG4gICAgICAgICAgICAgICAgLmdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHhuKVxuICAgICAgICAgICAgICAgIC5uZXh0KGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5zZXRUYXJnZXRzTWV0YWRhdGEodHhuLCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyLCByZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh1cGRhdGVSZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHhuLCBjaGFuZ2VkRG9jcywgZXhpc3RlbmNlQ2hhbmdlZEtleXMpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY2hhbmdlZERvY3MpO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGNoYW5nZWREb2NzID0+IHtcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwO1xuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XG4gICAgfSk7XG59XG4vKipcbiAqIFBvcHVsYXRlcyBkb2N1bWVudCBjaGFuZ2UgYnVmZmVyIHdpdGggZG9jdW1lbnRzIGZyb20gYmFja2VuZCBvciBhIGJ1bmRsZS5cbiAqIFJldHVybnMgdGhlIGRvY3VtZW50IGNoYW5nZXMgcmVzdWx0aW5nIGZyb20gYXBwbHlpbmcgdGhvc2UgZG9jdW1lbnRzLCBhbmRcbiAqIGFsc28gYSBzZXQgb2YgZG9jdW1lbnRzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZSBhcmUgY2hhbmdlZCBhcyBhIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gdHhuIC0gVHJhbnNhY3Rpb24gdG8gdXNlIHRvIHJlYWQgZXhpc3RpbmcgZG9jdW1lbnRzIGZyb20gc3RvcmFnZS5cbiAqIEBwYXJhbSBkb2N1bWVudEJ1ZmZlciAtIERvY3VtZW50IGJ1ZmZlciB0byBjb2xsZWN0IHRoZSByZXN1bHRlZCBjaGFuZ2VzIHRvIGJlXG4gKiAgICAgICAgYXBwbGllZCB0byBzdG9yYWdlLlxuICogQHBhcmFtIGRvY3VtZW50cyAtIERvY3VtZW50cyB0byBiZSBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50cykge1xuICAgIGxldCB1cGRhdGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICBkb2N1bWVudHMuZm9yRWFjaChrID0+ICh1cGRhdGVkS2V5cyA9IHVwZGF0ZWRLZXlzLmFkZChrKSkpO1xuICAgIHJldHVybiBkb2N1bWVudEJ1ZmZlci5nZXRFbnRyaWVzKHR4biwgdXBkYXRlZEtleXMpLm5leHQoZXhpc3RpbmdEb2NzID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZWREb2N1bWVudHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0RvYyA9IGV4aXN0aW5nRG9jcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlZSBpZiB0aGVyZSBpcyBhIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2UgZm9yIHRoaXMgZG9jdW1lbnQuXG4gICAgICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpICE9PSBleGlzdGluZ0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZXhpc3RlbmNlQ2hhbmdlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgb3JkZXIgb2YgdGhlIHN0ZXBzIGJlbG93IGlzIGltcG9ydGFudCwgc2luY2Ugd2Ugd2FudFxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgcmVqZWN0ZWQgbGltYm8gcmVzb2x1dGlvbnMgKHdoaWNoIGZhYnJpY2F0ZVxuICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkpIG5ldmVyIGFkZCBkb2N1bWVudHMgdG9cbiAgICAgICAgICAgIC8vIGNhY2hlLlxuICAgICAgICAgICAgaWYgKGRvYy5pc05vRG9jdW1lbnQoKSAmJiBkb2MudmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb0RvY3VtZW50cyB3aXRoIFNuYXBzaG90VmVyc2lvbi5taW4oKSBhcmUgdXNlZCBpbiBtYW51ZmFjdHVyZWRcbiAgICAgICAgICAgICAgICAvLyBldmVudHMuIFdlIHJlbW92ZSB0aGVzZSBkb2N1bWVudHMgZnJvbSBjYWNoZSBzaW5jZSB3ZSBsb3N0XG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzLlxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLnJlbW92ZUVudHJ5KGtleSwgZG9jLnJlYWRUaW1lKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nRG9jLmlzVmFsaWREb2N1bWVudCgpIHx8XG4gICAgICAgICAgICAgICAgZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID4gMCB8fFxuICAgICAgICAgICAgICAgIChkb2MudmVyc2lvbi5jb21wYXJlVG8oZXhpc3RpbmdEb2MudmVyc2lvbikgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEb2MuaGFzUGVuZGluZ1dyaXRlcykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5hZGRFbnRyeShkb2MpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWREb2N1bWVudHMgPSBjaGFuZ2VkRG9jdW1lbnRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdJZ25vcmluZyBvdXRkYXRlZCB3YXRjaCB1cGRhdGUgZm9yICcsIGtleSwgJy4gQ3VycmVudCB2ZXJzaW9uOicsIGV4aXN0aW5nRG9jLnZlcnNpb24sICcgV2F0Y2ggdmVyc2lvbjonLCBkb2MudmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VkRG9jdW1lbnRzLCBleGlzdGVuY2VDaGFuZ2VkS2V5cyB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG5ld1RhcmdldERhdGEgc2hvdWxkIGJlIHBlcnNpc3RlZCBkdXJpbmcgYW4gdXBkYXRlIG9mXG4gKiBhbiBhY3RpdmUgdGFyZ2V0LiBUYXJnZXREYXRhIHNob3VsZCBhbHdheXMgYmUgcGVyc2lzdGVkIHdoZW4gYSB0YXJnZXQgaXNcbiAqIGJlaW5nIHJlbGVhc2VkIGFuZCBzaG91bGQgbm90IGNhbGwgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBXaGlsZSB0aGUgdGFyZ2V0IGlzIGFjdGl2ZSwgVGFyZ2V0RGF0YSB1cGRhdGVzIGNhbiBiZSBvbWl0dGVkIHdoZW4gbm90aGluZ1xuICogYWJvdXQgdGhlIHRhcmdldCBoYXMgY2hhbmdlZCBleGNlcHQgbWV0YWRhdGEgbGlrZSB0aGUgcmVzdW1lIHRva2VuIG9yXG4gKiBzbmFwc2hvdCB2ZXJzaW9uLiBPY2Nhc2lvbmFsbHkgaXQncyB3b3J0aCB0aGUgZXh0cmEgd3JpdGUgdG8gcHJldmVudCB0aGVzZVxuICogdmFsdWVzIGZyb20gZ2V0dGluZyB0b28gc3RhbGUgYWZ0ZXIgYSBjcmFzaCwgYnV0IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlXG4gKiB0b28gZnJlcXVlbnQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkge1xuICAgIC8vIEFsd2F5cyBwZXJzaXN0IHRhcmdldCBkYXRhIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIHJlc3VtZSB0b2tlbi5cbiAgICBpZiAob2xkVGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERvbid0IGFsbG93IHJlc3VtZSB0b2tlbiBjaGFuZ2VzIHRvIGJlIGJ1ZmZlcmVkIGluZGVmaW5pdGVseS4gVGhpc1xuICAgIC8vIGFsbG93cyB1cyB0byBiZSByZWFzb25hYmx5IHVwLXRvLWRhdGUgYWZ0ZXIgYSBjcmFzaCBhbmQgYXZvaWRzIG5lZWRpbmdcbiAgICAvLyB0byBsb29wIG92ZXIgYWxsIGFjdGl2ZSBxdWVyaWVzIG9uIHNodXRkb3duLiBFc3BlY2lhbGx5IGluIHRoZSBicm93c2VyXG4gICAgLy8gd2UgbWF5IG5vdCBnZXQgdGltZSB0byBkbyBhbnl0aGluZyBpbnRlcmVzdGluZyB3aGlsZSB0aGUgY3VycmVudCB0YWIgaXNcbiAgICAvLyBjbG9zaW5nLlxuICAgIGNvbnN0IHRpbWVEZWx0YSA9IG5ld1RhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLnRvTWljcm9zZWNvbmRzKCkgLVxuICAgICAgICBvbGRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpO1xuICAgIGlmICh0aW1lRGVsdGEgPj0gUkVTVU1FX1RPS0VOX01BWF9BR0VfTUlDUk9TKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBoYXMgY2hhbmdlZCBhYm91dCBhIHRhcmdldCBpcyBpdHMgcmVzdW1lXG4gICAgLy8gdG9rZW4gaXQncyBub3Qgd29ydGggcGVyc2lzdGluZy4gTm90ZSB0aGF0IHRoZSBSZW1vdGVTdG9yZSBrZWVwcyBhblxuICAgIC8vIGluLW1lbW9yeSB2aWV3IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhcmdldHMgd2hpY2ggaW5jbHVkZXMgdGhlIGN1cnJlbnRcbiAgICAvLyByZXN1bWUgdG9rZW4sIHNvIHN0cmVhbSBmYWlsdXJlIG9yIHVzZXIgY2hhbmdlcyB3aWxsIHN0aWxsIHVzZSBhblxuICAgIC8vIHVwLXRvLWRhdGUgcmVzdW1lIHRva2VuIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBkbyBoZXJlLlxuICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXG4gICAgICAgIGNoYW5nZS5tb2RpZmllZERvY3VtZW50cy5zaXplICtcbiAgICAgICAgY2hhbmdlLnJlbW92ZWREb2N1bWVudHMuc2l6ZTtcbiAgICByZXR1cm4gY2hhbmdlcyA+IDA7XG59XG4vKipcbiAqIE5vdGlmaWVzIGxvY2FsIHN0b3JlIG9mIHRoZSBjaGFuZ2VkIHZpZXdzIHRvIGxvY2FsbHkgcGluIGRvY3VtZW50cy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZU5vdGlmeUxvY2FsVmlld0NoYW5nZXMobG9jYWxTdG9yZSwgdmlld0NoYW5nZXMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignbm90aWZ5TG9jYWxWaWV3Q2hhbmdlcycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2VzLCAodmlld0NoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlLmFkZGVkS2V5cywgKGtleSkgPT4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuYWRkUmVmZXJlbmNlKHR4biwgdmlld0NoYW5nZS50YXJnZXRJZCwga2V5KSkubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlLnJlbW92ZWRLZXlzLCAoa2V5KSA9PiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB2aWV3Q2hhbmdlLnRhcmdldElkLCBrZXkpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIC8vIElmIGBub3RpZnlMb2NhbFZpZXdDaGFuZ2VzYCBmYWlscywgd2UgZGlkIG5vdCBhZHZhbmNlIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gbnVtYmVyIGZvciB0aGUgZG9jdW1lbnRzIHRoYXQgd2VyZSBpbmNsdWRlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gVGhpcyBtaWdodCB0cmlnZ2VyIHRoZW0gdG8gYmUgZGVsZXRlZCBlYXJsaWVyIHRoYW4gdGhleSBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUsIGJ1dCBpdCBzaG91bGQgbm90IGludmFsaWRhdGUgdGhlIGludGVncml0eSBvZiB0aGUgZGF0YS5cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYiwgJ0ZhaWxlZCB0byB1cGRhdGUgc2VxdWVuY2UgbnVtYmVyczogJyArIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZpZXdDaGFuZ2Ugb2Ygdmlld0NoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB2aWV3Q2hhbmdlLnRhcmdldElkO1xuICAgICAgICBpZiAoIXZpZXdDaGFuZ2UuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBsYXN0IGxpbWJvIGZyZWUgc25hcHNob3QgdmVyc2lvblxuICAgICAgICAgICAgY29uc3QgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pO1xuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KHRhcmdldElkLCB1cGRhdGVkVGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICAvLyBUT0RPKGIvMjcyNTY0MzE2KTogQXBwbHkgdGhlIG9wdGltaXphdGlvbiBkb25lIG9uIG90aGVyIHBsYXRmb3Jtcy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcm9ibGVtIGZvciB3ZWIgYmVjYXVzZSBzYXZpbmcgdGhlIHVwZGF0ZWQgdGFyZ2V0RGF0YSBmcm9tXG4gICAgICAgICAgICAvLyBub24tcHJpbWFyeSBjbGllbnQgY29uZmxpY3RzIHdpdGggd2hhdCBwcmltYXJ5IGNsaWVudCBzYXZlZC5cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgbXV0YXRpb24gYmF0Y2ggYWZ0ZXIgdGhlIHBhc3NlZCBpbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZVxuICogb3IgbnVsbCBpZiBlbXB0eS5cbiAqIEBwYXJhbSBhZnRlckJhdGNoSWQgLSBJZiBwcm92aWRlZCwgdGhlIGJhdGNoIHRvIHNlYXJjaCBhZnRlci5cbiAqIEByZXR1cm5zIFRoZSBuZXh0IG11dGF0aW9uIG9yIG51bGwgaWYgdGhlcmUgd2Fzbid0IG9uZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUdldE5leHRNdXRhdGlvbkJhdGNoKGxvY2FsU3RvcmUsIGFmdGVyQmF0Y2hJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IG5leHQgbXV0YXRpb24gYmF0Y2gnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xuICAgICAgICBpZiAoYWZ0ZXJCYXRjaElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFmdGVyQmF0Y2hJZCA9IEJBVENISURfVU5LTk9XTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5nZXROZXh0TXV0YXRpb25CYXRjaEFmdGVyQmF0Y2hJZCh0eG4sIGFmdGVyQmF0Y2hJZCk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJlYWRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgRG9jdW1lbnQgd2l0aCBhIGdpdmVuIGtleSBvciBudWxsIGlmIG5vdFxuICogZm91bmQgLSB1c2VkIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGtleSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbigncmVhZCBkb2N1bWVudCcsICdyZWFkb25seScsIHR4biA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudCh0eG4sIGtleSkpO1xufVxuLyoqXG4gKiBBc3NpZ25zIHRoZSBnaXZlbiB0YXJnZXQgYW4gaW50ZXJuYWwgSUQgc28gdGhhdCBpdHMgcmVzdWx0cyBjYW4gYmUgcGlubmVkIHNvXG4gKiB0aGV5IGRvbid0IGdldCBHQydkLiBBIHRhcmdldCBtdXN0IGJlIGFsbG9jYXRlZCBpbiB0aGUgbG9jYWwgc3RvcmUgYmVmb3JlXG4gKiB0aGUgc3RvcmUgY2FuIGJlIHVzZWQgdG8gbWFuYWdlIGl0cyB2aWV3LlxuICpcbiAqIEFsbG9jYXRpbmcgYW4gYWxyZWFkeSBhbGxvY2F0ZWQgYFRhcmdldGAgd2lsbCByZXR1cm4gdGhlIGV4aXN0aW5nIGBUYXJnZXREYXRhYFxuICogZm9yIHRoYXQgYFRhcmdldGAuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdBbGxvY2F0ZSB0YXJnZXQnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcbiAgICAgICAgbGV0IHRhcmdldERhdGE7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgLmdldFRhcmdldERhdGEodHhuLCB0YXJnZXQpXG4gICAgICAgICAgICAubmV4dCgoY2FjaGVkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0YXJnZXQgaGFzIGJlZW4gbGlzdGVuZWQgdG8gcHJldmlvdXNseSwgc28gcmV1c2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgdGFyZ2V0SUQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiBmcmVzaGVuIGxhc3QgYWNjZXNzZWQgZGF0ZT9cbiAgICAgICAgICAgICAgICB0YXJnZXREYXRhID0gY2FjaGVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAuYWxsb2NhdGVUYXJnZXRJZCh0eG4pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHRhcmdldElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IG5ldyBUYXJnZXREYXRhKHRhcmdldCwgdGFyZ2V0SWQsIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovLCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4odGFyZ2V0RGF0YSA9PiB7XG4gICAgICAgIC8vIElmIE11bHRpLVRhYiBpcyBlbmFibGVkLCB0aGUgZXhpc3RpbmcgdGFyZ2V0IGRhdGEgbWF5IGJlIG5ld2VyIHRoYW5cbiAgICAgICAgLy8gdGhlIGluLW1lbW9yeSBkYXRhXG4gICAgICAgIGNvbnN0IGNhY2hlZFRhcmdldERhdGEgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpO1xuICAgICAgICBpZiAoY2FjaGVkVGFyZ2V0RGF0YSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKGNhY2hlZFRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uKSA+XG4gICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5zZXQodGFyZ2V0LCB0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0RGF0YTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgVGFyZ2V0RGF0YSBhcyBzZWVuIGJ5IHRoZSBMb2NhbFN0b3JlLCBpbmNsdWRpbmcgdXBkYXRlcyB0aGF0IG1heVxuICogaGF2ZSBub3QgeWV0IGJlZW4gcGVyc2lzdGVkIHRvIHRoZSBUYXJnZXRDYWNoZS5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRUYXJnZXREYXRhKGxvY2FsU3RvcmUsIHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZ2V0KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5nZXRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXQpO1xuICAgIH1cbn1cbi8qKlxuICogVW5waW5zIGFsbCB0aGUgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0LiBJZlxuICogYGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhYCBpcyBzZXQgdG8gZmFsc2UgYW5kIEVhZ2VyIEdDIGVuYWJsZWQsIHRoZSBtZXRob2RcbiAqIGRpcmVjdGx5IHJlbW92ZXMgdGhlIGFzc29jaWF0ZWQgdGFyZ2V0IGRhdGEgZnJvbSB0aGUgdGFyZ2V0IGNhY2hlLlxuICpcbiAqIFJlbGVhc2luZyBhIG5vbi1leGlzdGluZyBgVGFyZ2V0YCBpcyBhIG5vLW9wLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgbXVsdGktdGFiIG9ubHkuXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXRJZCwga2VlcFBlcnNpc3RlZFRhcmdldERhdGEpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgY29uc3QgbW9kZSA9IGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhID8gJ3JlYWR3cml0ZScgOiAncmVhZHdyaXRlLXByaW1hcnknO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICgha2VlcFBlcnNpc3RlZFRhcmdldERhdGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdSZWxlYXNlIHRhcmdldCcsIG1vZGUsIHR4biA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgLy8gQWxsIGByZWxlYXNlVGFyZ2V0YCBkb2VzIGlzIHJlY29yZCB0aGUgZmluYWwgbWV0YWRhdGEgc3RhdGUgZm9yIHRoZVxuICAgICAgICAgICAgLy8gdGFyZ2V0LCBidXQgd2UndmUgYmVlbiByZWNvcmRpbmcgdGhpcyBwZXJpb2RpY2FsbHkgZHVyaW5nIHRhcmdldFxuICAgICAgICAgICAgLy8gYWN0aXZpdHkuIElmIHdlIGxvc2UgdGhpcyB3cml0ZSB0aGlzIGNvdWxkIGNhdXNlIGEgdmVyeSBzbGlnaHRcbiAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gdGhlIG9yZGVyIG9mIHRhcmdldCBkZWxldGlvbiBkdXJpbmcgR0MsIGJ1dCB3ZVxuICAgICAgICAgICAgLy8gZG9uJ3QgZGVmaW5lIGV4YWN0IExSVSBzZW1hbnRpY3Mgc28gdGhpcyBpcyBhY2NlcHRhYmxlLlxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCBgRmFpbGVkIHRvIHVwZGF0ZSBzZXF1ZW5jZSBudW1iZXJzIGZvciB0YXJnZXQgJHt0YXJnZXRJZH06ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LnJlbW92ZSh0YXJnZXRJZCk7XG4gICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xufVxuLyoqXG4gKiBSdW5zIHRoZSBzcGVjaWZpZWQgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgc3RvcmUgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMsXG4gKiBwb3RlbnRpYWxseSB0YWtpbmcgYWR2YW50YWdlIG9mIHF1ZXJ5IGRhdGEgZnJvbSBwcmV2aW91cyBleGVjdXRpb25zIChzdWNoXG4gKiBhcyB0aGUgc2V0IG9mIHJlbW90ZSBrZXlzKS5cbiAqXG4gKiBAcGFyYW0gdXNlUHJldmlvdXNSZXN1bHRzIC0gV2hldGhlciByZXN1bHRzIGZyb20gcHJldmlvdXMgZXhlY3V0aW9ucyBjYW5cbiAqIGJlIHVzZWQgdG8gb3B0aW1pemUgdGhpcyBxdWVyeSBleGVjdXRpb24uXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIHVzZVByZXZpb3VzUmVzdWx0cykge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGxldCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGxldCByZW1vdGVLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0V4ZWN1dGUgcXVlcnknLCAncmVhZHdyaXRlJywgLy8gVXNlIHJlYWR3cml0ZSBpbnN0ZWFkIG9mIHJlYWRvbmx5IHNvIGluZGV4ZXMgY2FuIGJlIGNyZWF0ZWRcbiAgICAvLyBVc2UgcmVhZHdyaXRlIGluc3RlYWQgb2YgcmVhZG9ubHkgc28gaW5kZXhlcyBjYW4gYmUgY3JlYXRlZFxuICAgIHR4biA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlSW1wbCwgdHhuLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSlcbiAgICAgICAgICAgIC5uZXh0KHRhcmdldERhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXREYXRhLnRhcmdldElkKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVLZXlzID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwucXVlcnlFbmdpbmUuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0eG4sIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHNcbiAgICAgICAgICAgID8gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvblxuICAgICAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCksIHVzZVByZXZpb3VzUmVzdWx0cyA/IHJlbW90ZUtleXMgOiBkb2N1bWVudEtleVNldCgpKSlcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50cyA9PiB7XG4gICAgICAgICAgICBzZXRNYXhSZWFkVGltZShsb2NhbFN0b3JlSW1wbCwgcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnkpLCBkb2N1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9jdW1lbnRzLCByZW1vdGVLZXlzIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXBwbHlXcml0ZVRvUmVtb3RlRG9jdW1lbnRzKGxvY2FsU3RvcmVJbXBsLCB0eG4sIGJhdGNoUmVzdWx0LCBkb2N1bWVudEJ1ZmZlcikge1xuICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hSZXN1bHQuYmF0Y2g7XG4gICAgY29uc3QgZG9jS2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICBsZXQgcHJvbWlzZUNoYWluID0gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICBkb2NLZXlzLmZvckVhY2goZG9jS2V5ID0+IHtcbiAgICAgICAgcHJvbWlzZUNoYWluID0gcHJvbWlzZUNoYWluXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5nZXRFbnRyeSh0eG4sIGRvY0tleSkpXG4gICAgICAgICAgICAubmV4dChkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWNrVmVyc2lvbiA9IGJhdGNoUmVzdWx0LmRvY1ZlcnNpb25zLmdldChkb2NLZXkpO1xuICAgICAgICAgICAgaGFyZEFzc2VydChhY2tWZXJzaW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChkb2MudmVyc2lvbi5jb21wYXJlVG8oYWNrVmVyc2lvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2guYXBwbHlUb1JlbW90ZURvY3VtZW50KGRvYywgYmF0Y2hSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBjb21taXRWZXJzaW9uIGFzIHRoZSByZWFkVGltZSByYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9jdW1lbnQncyB1cGRhdGVUaW1lIHNpbmNlIHRoZSB1cGRhdGVUaW1lIGlzIG5vdCBhZHZhbmNlZFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdXBkYXRlcyB0aGF0IGRvIG5vdCBtb2RpZnkgdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRSZWFkVGltZShiYXRjaFJlc3VsdC5jb21taXRWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYWRkRW50cnkoZG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2hhaW4ubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCkpO1xufVxuLyoqIFJldHVybnMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSBhIG11dGF0aW9uIGJhdGNoLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVMb29rdXBNdXRhdGlvbkRvY3VtZW50cyhsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdMb29rdXAgbXV0YXRpb24gZG9jdW1lbnRzJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVJbXBsLmxvb2t1cE11dGF0aW9uS2V5cyh0eG4sIGJhdGNoSWQpLm5leHQoa2V5cyA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZVJlbW92ZUNhY2hlZE11dGF0aW9uQmF0Y2hNZXRhZGF0YShsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5tdXRhdGlvblF1ZXVlKTtcbiAgICBtdXRhdGlvblF1ZXVlSW1wbC5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2hJZCk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEFjdGl2ZUNsaWVudHMobG9jYWxTdG9yZSkge1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlSW1wbCA9IGRlYnVnQ2FzdChkZWJ1Z0Nhc3QobG9jYWxTdG9yZSwgTG9jYWxTdG9yZUltcGwpLnBlcnNpc3RlbmNlKTtcbiAgICByZXR1cm4gcGVyc2lzdGVuY2VJbXBsLmdldEFjdGl2ZUNsaWVudHMoKTtcbn1cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0Q2FjaGVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKGNhY2hlZFRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWRUYXJnZXREYXRhLnRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCB0YXJnZXQgZGF0YScsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q2FjaGVJbXBsXG4gICAgICAgICAgICAgICAgLmdldFRhcmdldERhdGFGb3JUYXJnZXQodHhuLCB0YXJnZXRJZClcbiAgICAgICAgICAgICAgICAubmV4dCh0YXJnZXREYXRhID0+ICh0YXJnZXREYXRhID8gdGFyZ2V0RGF0YS50YXJnZXQgOiBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCByZXR1cm5zIHRoZSBzZXQgb2YgY2hhbmdlcyBzaW5jZSBjbGllbnRcbiAqIGluaXRpYWxpemF0aW9uLiBGdXJ0aGVyIGludm9jYXRpb25zIHdpbGwgcmV0dXJuIGRvY3VtZW50IHRoYXQgaGF2ZSBjaGFuZ2VkXG4gKiBzaW5jZSB0aGUgcHJpb3IgY2FsbC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMobG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IG1heGltdW0gcmVhZCB0aW1lIGZvciB0aGUgY29sbGVjdGlvbi4gVGhpcyBzaG91bGQgYWx3YXlzXG4gICAgLy8gZXhpc3QsIGJ1dCB0byByZWR1Y2UgdGhlIGNoYW5jZSBmb3IgcmVncmVzc2lvbnMgd2UgZGVmYXVsdCB0b1xuICAgIC8vIFNuYXBzaG90VmVyc2lvbi5NaW4oKVxuICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBDb25zaWRlciByZW1vdmluZyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICBjb25zdCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XG4gICAgICAgIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV3IGRvY3VtZW50IGNoYW5nZXMnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHhuLCBjb2xsZWN0aW9uR3JvdXAsIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKHJlYWRUaW1lLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpLCBcbiAgICAvKiBsaW1pdD0gKi8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKVxuICAgICAgICAudGhlbihjaGFuZ2VkRG9jcyA9PiB7XG4gICAgICAgIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xuICAgIH0pO1xufVxuLyoqIFNldHMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAncyBtYXhpbXVtIHJlYWQgdGltZSBmcm9tIHRoZSBnaXZlbiBkb2N1bWVudHMuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIGNvbGxlY3Rpb25Hcm91cCwgY2hhbmdlZERvY3MpIHtcbiAgICBsZXQgcmVhZFRpbWUgPSBsb2NhbFN0b3JlSW1wbC5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZS5nZXQoY29sbGVjdGlvbkdyb3VwKSB8fFxuICAgICAgICBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY2hhbmdlZERvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XG4gICAgICAgIGlmIChkb2MucmVhZFRpbWUuY29tcGFyZVRvKHJlYWRUaW1lKSA+IDApIHtcbiAgICAgICAgICAgIHJlYWRUaW1lID0gZG9jLnJlYWRUaW1lO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbG9jYWxTdG9yZUltcGwuY29sbGVjdGlvbkdyb3VwUmVhZFRpbWUuc2V0KGNvbGxlY3Rpb25Hcm91cCwgcmVhZFRpbWUpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhcmdldCB1c2luZyB0aGUgZ2l2ZW4gYnVuZGxlIG5hbWUsIHdoaWNoIHdpbGwgYmUgdXNlZCB0b1xuICogaG9sZCB0aGUga2V5cyBvZiBhbGwgZG9jdW1lbnRzIGZyb20gdGhlIGJ1bmRsZSBpbiBxdWVyeS1kb2N1bWVudCBtYXBwaW5ncy5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBsb2FkZWQgZG9jdW1lbnRzIGRvIG5vdCBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIHJpZ2h0IGF3YXkuXG4gKi9cbmZ1bmN0aW9uIHVtYnJlbGxhVGFyZ2V0KGJ1bmRsZU5hbWUpIHtcbiAgICAvLyBJdCBpcyBPSyB0aGF0IHRoZSBwYXRoIHVzZWQgZm9yIHRoZSBxdWVyeSBpcyBub3QgdmFsaWQsIGJlY2F1c2UgdGhpcyB3aWxsXG4gICAgLy8gbm90IGJlIHJlYWQgYW5kIHF1ZXJpZWQuXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGBfX2J1bmRsZV9fL2RvY3MvJHtidW5kbGVOYW1lfWApKSk7XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGRvY3VtZW50cyBmcm9tIGEgYnVuZGxlIHRvIHRoZSBcImdyb3VuZC1zdGF0ZVwiIChyZW1vdGUpXG4gKiBkb2N1bWVudHMuXG4gKlxuICogTG9jYWxEb2N1bWVudHMgYXJlIHJlLWNhbGN1bGF0ZWQgaWYgdGhlcmUgYXJlIHJlbWFpbmluZyBtdXRhdGlvbnMgaW4gdGhlXG4gKiBxdWV1ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUFwcGx5QnVuZGxlZERvY3VtZW50cyhsb2NhbFN0b3JlLCBidW5kbGVDb252ZXJ0ZXIsIGRvY3VtZW50cywgYnVuZGxlTmFtZSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGxldCBkb2N1bWVudEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGxldCBkb2N1bWVudE1hcCA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgaWYgKGJ1bmRsZURvYy5kb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnRLZXlzID0gZG9jdW1lbnRLZXlzLmFkZChkb2N1bWVudEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gYnVuZGxlQ29udmVydGVyLnRvTXV0YWJsZURvY3VtZW50KGJ1bmRsZURvYyk7XG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShidW5kbGVDb252ZXJ0ZXIudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlRG9jLm1ldGFkYXRhLnJlYWRUaW1lKSk7XG4gICAgICAgIGRvY3VtZW50TWFwID0gZG9jdW1lbnRNYXAuaW5zZXJ0KGRvY3VtZW50S2V5LCBkb2MpO1xuICAgIH1cbiAgICBjb25zdCBkb2N1bWVudEJ1ZmZlciA9IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5uZXdDaGFuZ2VCdWZmZXIoe1xuICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICB9KTtcbiAgICAvLyBBbGxvY2F0ZXMgYSB0YXJnZXQgdG8gaG9sZCBhbGwgZG9jdW1lbnQga2V5cyBmcm9tIHRoZSBidW5kbGUsIHN1Y2ggdGhhdFxuICAgIC8vIHRoZXkgd2lsbCBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkIHJpZ2h0IGF3YXkuXG4gICAgY29uc3QgdW1icmVsbGFUYXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KGxvY2FsU3RvcmVJbXBsLCB1bWJyZWxsYVRhcmdldChidW5kbGVOYW1lKSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdBcHBseSBidW5kbGUgZG9jdW1lbnRzJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIHJldHVybiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50TWFwKVxuICAgICAgICAgICAgLm5leHQoZG9jdW1lbnRDaGFuZ2VSZXN1bHQgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudENoYW5nZVJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50Q2hhbmdlUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHVtYnJlbGxhVGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBkb2N1bWVudEtleXMsIHVtYnJlbGxhVGFyZ2V0RGF0YS50YXJnZXRJZCkpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHhuLCBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzLCBkb2N1bWVudENoYW5nZVJlc3VsdC5leGlzdGVuY2VDaGFuZ2VkS2V5cykpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRDaGFuZ2VSZXN1bHQuY2hhbmdlZERvY3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGdpdmVuIGJ1bmRsZSBoYXMgYWxyZWFkeVxuICogYmVlbiBsb2FkZWQgYW5kIHRoZSBjcmVhdGUgdGltZSBpcyBuZXdlciB0aGFuIHRoZSBjdXJyZW50IGxvYWRpbmcgYnVuZGxlLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlSGFzTmV3ZXJCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBjdXJyZW50UmVhZFRpbWUgPSBmcm9tVmVyc2lvbihidW5kbGVNZXRhZGF0YS5jcmVhdGVUaW1lKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdoYXNOZXdlckJ1bmRsZScsICdyZWFkb25seScsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YS5pZCk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oY2FjaGVkID0+IHtcbiAgICAgICAgcmV0dXJuICEhY2FjaGVkICYmIGNhY2hlZC5jcmVhdGVUaW1lLmNvbXBhcmVUbyhjdXJyZW50UmVhZFRpbWUpID49IDA7XG4gICAgfSk7XG59XG4vKipcbiAqIFNhdmVzIHRoZSBnaXZlbiBgQnVuZGxlTWV0YWRhdGFgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlU2F2ZUJ1bmRsZShsb2NhbFN0b3JlLCBidW5kbGVNZXRhZGF0YSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBidW5kbGUnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIG9mIGEgYE5hbWVkUXVlcnlgIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBxdWVyeSBuYW1lLiBQcm9taXNlXG4gKiByZXNvbHZlcyB0byB1bmRlZmluZWQgaWYgbm8gcGVyc2lzdGVkIGRhdGEgY2FuIGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeU5hbWUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuYW1lZCBxdWVyeScsICdyZWFkb25seScsIHRyYW5zYWN0aW9uID0+IGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkpO1xufVxuLyoqXG4gKiBTYXZlcyB0aGUgZ2l2ZW4gYE5hbWVkUXVlcnlgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlU2F2ZU5hbWVkUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIGRvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkpIHtcbiAgICAvLyBBbGxvY2F0ZSBhIHRhcmdldCBmb3IgdGhlIG5hbWVkIHF1ZXJ5IHN1Y2ggdGhhdCBpdCBjYW4gYmUgcmVzdW1lZFxuICAgIC8vIGZyb20gYXNzb2NpYXRlZCByZWFkIHRpbWUgaWYgdXNlcnMgdXNlIGl0IHRvIGxpc3Rlbi5cbiAgICAvLyBOT1RFOiB0aGlzIGFsc28gbWVhbnMgaWYgbm8gY29ycmVzcG9uZGluZyB0YXJnZXQgZXhpc3RzLCB0aGUgbmV3IHRhcmdldFxuICAgIC8vIHdpbGwgcmVtYWluIGFjdGl2ZSBhbmQgd2lsbCBub3QgZ2V0IGNvbGxlY3RlZCwgdW5sZXNzIHVzZXJzIGhhcHBlbiB0b1xuICAgIC8vIHVubGlzdGVuIHRoZSBxdWVyeSBzb21laG93LlxuICAgIGNvbnN0IGFsbG9jYXRlZCA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlLCBxdWVyeVRvVGFyZ2V0KGZyb21CdW5kbGVkUXVlcnkocXVlcnkuYnVuZGxlZFF1ZXJ5KSkpO1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBuYW1lZCBxdWVyeScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRUaW1lID0gZnJvbVZlcnNpb24ocXVlcnkucmVhZFRpbWUpO1xuICAgICAgICAvLyBTaW1wbHkgc2F2ZSB0aGUgcXVlcnkgaXRzZWxmIGlmIGl0IGlzIG9sZGVyIHRoYW4gd2hhdCB0aGUgU0RLIGFscmVhZHlcbiAgICAgICAgLy8gaGFzLlxuICAgICAgICBpZiAoYWxsb2NhdGVkLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8ocmVhZFRpbWUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5zYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyB0YXJnZXQgZGF0YSBiZWNhdXNlIHRoZSBxdWVyeSBmcm9tIHRoZSBidW5kbGUgaXMgbmV3ZXIuXG4gICAgICAgIGNvbnN0IG5ld1RhcmdldERhdGEgPSBhbGxvY2F0ZWQud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIHJlYWRUaW1lKTtcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5pbnNlcnQobmV3VGFyZ2V0RGF0YS50YXJnZXRJZCwgbmV3VGFyZ2V0RGF0YSk7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgLnVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIG5ld1RhcmdldERhdGEpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgYWxsb2NhdGVkLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmFkZE1hdGNoaW5nS2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzLCBhbGxvY2F0ZWQudGFyZ2V0SWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGxvY2FsU3RvcmUsIG5ld0ZpZWxkSW5kZXhlcykge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IGxvY2FsU3RvcmVJbXBsLmluZGV4TWFuYWdlcjtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQ29uZmlndXJlIGluZGV4ZXMnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4gaW5kZXhNYW5hZ2VyXG4gICAgICAgIC5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pXG4gICAgICAgIC5uZXh0KG9sZEZpZWxkSW5kZXhlcyA9PiBkaWZmQXJyYXlzKG9sZEZpZWxkSW5kZXhlcywgbmV3RmllbGRJbmRleGVzLCBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yLCBmaWVsZEluZGV4ID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbmRleE1hbmFnZXIuYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCkpO1xuICAgIH0sIGZpZWxkSW5kZXggPT4ge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5kZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XG4gICAgfSkpXG4gICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSkpO1xufVxuZnVuY3Rpb24gbG9jYWxTdG9yZVNldEluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChsb2NhbFN0b3JlLCBpc0VuYWJsZWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsb2NhbFN0b3JlSW1wbC5xdWVyeUVuZ2luZS5pbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQgPSBpc0VuYWJsZWQ7XG59XG5mdW5jdGlvbiBsb2NhbFN0b3JlRGVsZXRlQWxsRmllbGRJbmRleGVzKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdEZWxldGUgQWxsIEluZGV4ZXMnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4gaW5kZXhNYW5hZ2VyLmRlbGV0ZUFsbEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbikpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlscyBkdXJpbmcgZGF0YWJhc2UgbG9jYWwgcXVlcnlcbiAqIGV4ZWN1dGlvbi5cbiAqL1xuY2xhc3MgUXVlcnlDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwYXNzZWQgdGhyb3VnaCBkdXJpbmcgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnRSZWFkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudFJlYWRDb3VudDtcbiAgICB9XG4gICAgaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVhZENvdW50ICs9IGFtb3VudDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0lOREVYX0FVVE9fQ1JFQVRJT05fTUlOX0NPTExFQ1RJT05fU0laRSA9IDEwMDtcbi8qKlxuICogVGhpcyBjb3N0IHJlcHJlc2VudHMgdGhlIGV2YWx1YXRpb24gcmVzdWx0IG9mXG4gKiAoKFtpbmRleCwgZG9jS2V5XSArIFtkb2NLZXksIGRvY0NvbnRlbnRdKSBwZXIgZG9jdW1lbnQgaW4gdGhlIHJlc3VsdCBzZXQpXG4gKiAvIChbZG9jS2V5LCBkb2NDb250ZW50XSBwZXIgZG9jdW1lbnRzIGluIGZ1bGwgY29sbGVjdGlvbiBzY2FuKSBjb21pbmcgZnJvbVxuICogZXhwZXJpbWVudCBbZW50ZXIgUFIgZXhwZXJpbWVudCBVUkwgaGVyZV0uXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRSZWxhdGl2ZUluZGV4UmVhZENvc3RQZXJEb2N1bWVudCgpIHtcbiAgICAvLyBUaGVzZSB2YWx1ZXMgd2VyZSBkZXJpdmVkIGZyb20gYW4gZXhwZXJpbWVudCB3aGVyZSBzZXZlcmFsIG1lbWJlcnMgb2YgdGhlXG4gICAgLy8gRmlyZXN0b3JlIFNESyB0ZWFtIHJhbiBhIHBlcmZvcm1hbmNlIHRlc3QgaW4gdmFyaW91cyBlbnZpcm9ubWVudHMuXG4gICAgLy8gR29vZ2xlcnMgY2FuIHNlZSBiLzI5OTI4NDI4NyBmb3IgZGV0YWlscy5cbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2V0QW5kcm9pZFZlcnNpb24oZ2V0VUEoKSkgPiAwKSB7XG4gICAgICAgIHJldHVybiA2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgRmlyZXN0b3JlIHF1ZXJ5IGVuZ2luZS5cbiAqXG4gKiBGaXJlc3RvcmUgcXVlcmllcyBjYW4gYmUgZXhlY3V0ZWQgaW4gdGhyZWUgbW9kZXMuIFRoZSBRdWVyeSBFbmdpbmUgZGV0ZXJtaW5lc1xuICogd2hhdCBtb2RlIHRvIHVzZSBiYXNlZCBvbiB3aGF0IGRhdGEgaXMgcGVyc2lzdGVkLiBUaGUgbW9kZSBvbmx5IGRldGVybWluZXNcbiAqIHRoZSBydW50aW1lIGNvbXBsZXhpdHkgb2YgdGhlIHF1ZXJ5IC0gdGhlIHJlc3VsdCBzZXQgaXMgZXF1aXZhbGVudCBhY3Jvc3MgYWxsXG4gKiBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlIFF1ZXJ5IGVuZ2luZSB3aWxsIHVzZSBpbmRleGVkLWJhc2VkIGV4ZWN1dGlvbiBpZiBhIHVzZXIgaGFzIGNvbmZpZ3VyZWRcbiAqIGFueSBpbmRleCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgcXVlcnkgKHZpYSBgc2V0SW5kZXhDb25maWd1cmF0aW9uKClgKS5cbiAqIE90aGVyd2lzZSwgdGhlIGVuZ2luZSB3aWxsIHRyeSB0byBvcHRpbWl6ZSB0aGUgcXVlcnkgYnkgcmUtdXNpbmcgYSBwcmV2aW91c2x5XG4gKiBwZXJzaXN0ZWQgcXVlcnkgcmVzdWx0LiBJZiB0aGF0IGlzIG5vdCBwb3NzaWJsZSwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWRcbiAqIHZpYSBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuLlxuICpcbiAqIEluZGV4LWJhc2VkIGV4ZWN1dGlvbiBpcyB0aGUgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZS4gVGhlIHF1ZXJ5IGVuZ2luZVxuICogc3VwcG9ydHMgcGFydGlhbCBpbmRleGVkIGV4ZWN1dGlvbiBhbmQgbWVyZ2VzIHRoZSByZXN1bHQgZnJvbSB0aGUgaW5kZXhcbiAqIGxvb2t1cCB3aXRoIGRvY3VtZW50cyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIGluZGV4ZWQuIFRoZSBpbmRleCBldmFsdWF0aW9uXG4gKiBtYXRjaGVzIHRoZSBiYWNrZW5kJ3MgZm9ybWF0IGFuZCBhcyBzdWNoLCB0aGUgU0RLIGNhbiB1c2UgaW5kZXhpbmcgZm9yIGFsbFxuICogcXVlcmllcyB0aGF0IHRoZSBiYWNrZW5kIHN1cHBvcnRzLlxuICpcbiAqIElmIG5vIGluZGV4IGV4aXN0cywgdGhlIHF1ZXJ5IGVuZ2luZSB0cmllcyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGUgdGFyZ2V0XG4gKiBkb2N1bWVudCBtYXBwaW5nIGluIHRoZSBUYXJnZXRDYWNoZS4gVGhlc2UgbWFwcGluZ3MgZXhpc3RzIGZvciBhbGwgcXVlcmllc1xuICogdGhhdCBoYXZlIGJlZW4gc3luY2VkIHdpdGggdGhlIGJhY2tlbmQgYXQgbGVhc3Qgb25jZSBhbmQgYWxsb3cgdGhlIHF1ZXJ5XG4gKiBlbmdpbmUgdG8gb25seSByZWFkIGRvY3VtZW50cyB0aGF0IHByZXZpb3VzbHkgbWF0Y2hlZCBhIHF1ZXJ5IHBsdXMgYW55XG4gKiBkb2N1bWVudHMgdGhhdCB3ZXJlIGVkaXRlZCBhZnRlciB0aGUgcXVlcnkgd2FzIGxhc3QgbGlzdGVuZWQgdG8uXG4gKlxuICogVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlbiB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBwcm9kdWNlXG4gKiB0aGUgc2FtZSByZXN1bHRzIGFzIGZ1bGwgY29sbGVjdGlvbiBzY2Fucy4gSW4gdGhlc2UgY2FzZXMsIHF1ZXJ5XG4gKiBwcm9jZXNzaW5nIGZhbGxzIGJhY2sgdG8gZnVsbCBzY2Fucy4gVGhlc2UgY2FzZXMgYXJlOlxuICpcbiAqIC0gTGltaXQgcXVlcmllcyB3aGVyZSBhIGRvY3VtZW50IHRoYXQgbWF0Y2hlZCB0aGUgcXVlcnkgcHJldmlvdXNseSBubyBsb25nZXJcbiAqICAgbWF0Y2hlcyB0aGUgcXVlcnkuXG4gKlxuICogLSBMaW1pdCBxdWVyaWVzIHdoZXJlIGEgZG9jdW1lbnQgZWRpdCBtYXkgY2F1c2UgdGhlIGRvY3VtZW50IHRvIHNvcnQgYmVsb3dcbiAqICAgYW5vdGhlciBkb2N1bWVudCB0aGF0IGlzIGluIHRoZSBsb2NhbCBjYWNoZS5cbiAqXG4gKiAtIFF1ZXJpZXMgdGhhdCBoYXZlIG5ldmVyIGJlZW4gQ1VSUkVOVCBvciBmcmVlIG9mIGxpbWJvIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgUXVlcnlFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTREsgb25seSBkZWNpZGVzIHdoZXRoZXIgaXQgc2hvdWxkIGNyZWF0ZSBpbmRleCB3aGVuIGNvbGxlY3Rpb24gc2l6ZSBpc1xuICAgICAgICAgKiBsYXJnZXIgdGhhbiB0aGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplID0gREVGQVVMVF9JTkRFWF9BVVRPX0NSRUFUSU9OX01JTl9DT0xMRUNUSU9OX1NJWkU7XG4gICAgICAgIHRoaXMucmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQgPSBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKTtcbiAgICB9XG4gICAgLyoqIFNldHMgdGhlIGRvY3VtZW50IHZpZXcgdG8gcXVlcnkgYWdhaW5zdC4gKi9cbiAgICBpbml0aWFsaXplKGxvY2FsRG9jdW1lbnRzLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcgPSBsb2NhbERvY3VtZW50cztcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbGwgbG9jYWwgZG9jdW1lbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcXVlcnkuICovXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlbW90ZUtleXMpIHtcbiAgICAgICAgLy8gU3RvcmVzIHRoZSByZXN1bHQgZnJvbSBleGVjdXRpbmcgdGhlIHF1ZXJ5OyB1c2luZyB0aGlzIG9iamVjdCBpcyBtb3JlXG4gICAgICAgIC8vIGNvbnZlbmllbnQgdGhhbiBwYXNzaW5nIHRoZSByZXN1bHQgYmV0d2VlbiBzdGVwcyBvZiB0aGUgcGVyc2lzdGVuY2VcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gYW5kIGltcHJvdmVzIHJlYWRhYmlsaXR5IGNvbXBhcmF0aXZlbHkuXG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0geyByZXN1bHQ6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5UmVzdWx0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nUmVtb3RlS2V5cyh0cmFuc2FjdGlvbiwgcXVlcnksIHJlbW90ZUtleXMsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFF1ZXJ5Q29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bGxDb2xsZWN0aW9uU2Nhbih0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQpLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhY2hlSW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQsIHJlc3VsdC5zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHF1ZXJ5UmVzdWx0LnJlc3VsdCk7XG4gICAgfVxuICAgIGNyZWF0ZUNhY2hlSW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQsIHJlc3VsdFNpemUpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPCB0aGlzLmluZGV4QXV0b0NyZWF0aW9uTWluQ29sbGVjdGlvblNpemUpIHtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1NESyB3aWxsIG5vdCBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnc2luY2UgaXQgb25seSBjcmVhdGVzIGNhY2hlIGluZGV4ZXMgZm9yIGNvbGxlY3Rpb24gY29udGFpbnMnLCAnbW9yZSB0aGFuIG9yIGVxdWFsIHRvJywgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplLCAnZG9jdW1lbnRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1F1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NjYW5zJywgY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCwgJ2xvY2FsIGRvY3VtZW50cyBhbmQgcmV0dXJucycsIHJlc3VsdFNpemUsICdkb2N1bWVudHMgYXMgcmVzdWx0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCA+XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ICogcmVzdWx0U2l6ZSkge1xuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnVGhlIFNESyBkZWNpZGVzIHRvIGNyZWF0ZSBjYWNoZSBpbmRleGVzIGZvciBxdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdhcyB1c2luZyBjYWNoZSBpbmRleGVzIG1heSBoZWxwIGltcHJvdmUgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXIuY3JlYXRlVGFyZ2V0SW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnlUb1RhcmdldChxdWVyeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBpbmRleGVkIHF1ZXJ5IHRoYXQgZXZhbHVhdGVzIHRoZSBxdWVyeSBiYXNlZCBvbiBhIGNvbGxlY3Rpb24nc1xuICAgICAqIHBlcnNpc3RlZCBpbmRleCB2YWx1ZXMuIFJldHVybnMgYG51bGxgIGlmIGFuIGluZGV4IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlc0FsbERvY3VtZW50cyhxdWVyeSkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBtYXRjaCBhbGwgZG9jdW1lbnRzIGRvbid0IGJlbmVmaXQgZnJvbSB1c2luZ1xuICAgICAgICAgICAgLy8ga2V5LWJhc2VkIGxvb2t1cHMuIEl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHNjYW4gYWxsIGRvY3VtZW50cyBpbiBhXG4gICAgICAgICAgICAvLyBjb2xsZWN0aW9uLCByYXRoZXIgdGhhbiB0byBwZXJmb3JtIGluZGl2aWR1YWwgbG9va3Vwcy5cbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxuICAgICAgICAgICAgLm5leHQoaW5kZXhUeXBlID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleFR5cGUgPT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhbm5vdCBiZSBzZXJ2ZWQgZnJvbSBhbnkgaW5kZXguXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkubGltaXQgIT09IG51bGwgJiYgaW5kZXhUeXBlID09PSAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFwcGx5IGEgbGltaXQgZm9yIHRhcmdldHMgdGhhdCBhcmUgc2VydmVkIHVzaW5nIGEgcGFydGlhbFxuICAgICAgICAgICAgICAgIC8vIGluZGV4LiBJZiBhIHBhcnRpYWwgaW5kZXggd2lsbCBiZSB1c2VkIHRvIHNlcnZlIHRoZSB0YXJnZXQsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IG1heSByZXR1cm4gYSBzdXBlcnNldCBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gaWYgdGhlIGluZGV4IGRvZXNuJ3QgaW5jbHVkZSBhbGwgdGhlIHRhcmdldCdzIGZpbHRlcnMpLCBvclxuICAgICAgICAgICAgICAgIC8vIG1heSByZXR1cm4gdGhlIGNvcnJlY3Qgc2V0IG9mIGRvY3VtZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIgKGUuZy4gaWZcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGEgc2VnbWVudCBmb3Igb25lIG9mIHRoZSBvcmRlckJ5cykuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBhIGxpbWl0IHNob3VsZCBub3QgYmUgYXBwbGllZCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgICAgICAubmV4dChrZXlzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAgICAgICAgIC5nZXREb2N1bWVudHModHJhbnNhY3Rpb24sIHNvcnRlZEtleXMpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGluZGV4ZWREb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRNaW5PZmZzZXQodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KG9mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGluZGV4ZWREb2N1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZWZpbGwocXVlcnksIHByZXZpb3VzUmVzdWx0cywgc29ydGVkS2V5cywgb2Zmc2V0LnJlYWRUaW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbGltaXQgcXVlcnkgd2hvc2UgYm91bmRhcmllcyBjaGFuZ2UgZHVlIHRvIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWRpdHMgY2FuIGJlIHJlLXJ1biBhZ2FpbnN0IHRoZSBjYWNoZSBieSBleGNsdWRpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGltaXQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxdWVyeSdzIGZpbHRlcnMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBUaGUgU0RLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHRoZW4gYXBwbHkgdGhlIGxpbWl0IG9uY2UgYWxsIGxvY2FsIGVkaXRzIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY29ycG9yYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUXVlcnlVc2luZ0luZGV4KHRyYW5zYWN0aW9uLCBxdWVyeVdpdGhMaW1pdChxdWVyeSwgbnVsbCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBwcmV2aW91c1Jlc3VsdHMsIHF1ZXJ5LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgcGVyc2lzdGVkIHF1ZXJ5IG1hcHBpbmcuIFJldHVybnNcbiAgICAgKiBgbnVsbGAgaWYgdGhlIG1hcHBpbmcgaXMgbm90IGF2YWlsYWJsZSBvciBjYW5ub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBwZXJmb3JtUXVlcnlVc2luZ1JlbW90ZUtleXModHJhbnNhY3Rpb24sIHF1ZXJ5LCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcbiAgICAgICAgICAgIC8vIGtleS1iYXNlZCBsb29rdXBzLiBJdCBpcyBtb3JlIGVmZmljaWVudCB0byBzY2FuIGFsbCBkb2N1bWVudHMgaW4gYVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgc2VlbiBhIHNuYXBzaG90IHdpdGhvdXQgbGltYm8gZnJlZSBkb2N1bWVudHNcbiAgICAgICAgLy8gc2hvdWxkIGFsc28gYmUgcnVuIGFzIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4uXG4gICAgICAgIGlmIChsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlldy5nZXREb2N1bWVudHModHJhbnNhY3Rpb24sIHJlbW90ZUtleXMpLm5leHQoZG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IHRoaXMuYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVmaWxsKHF1ZXJ5LCBwcmV2aW91c1Jlc3VsdHMsIHJlbW90ZUtleXMsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnUmUtdXNpbmcgcHJldmlvdXMgcmVzdWx0IGZyb20gJXMgdG8gZXhlY3V0ZSBxdWVyeTogJXMnLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLnRvU3RyaW5nKCksIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgcmVzdWx0cyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgICAgICAvLyBsaW1iby1kb2N1bWVudCBmcmVlIHJlbW90ZSBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCkpLm5leHQocmVzdWx0cyA9PiByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBBcHBsaWVzIHRoZSBxdWVyeSBmaWx0ZXIgYW5kIHNvcnRpbmcgdG8gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gICovXG4gICAgYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIFNvcnQgdGhlIGRvY3VtZW50cyBhbmQgcmUtYXBwbHkgdGhlIHF1ZXJ5IGZpbHRlciBzaW5jZSBwcmV2aW91c2x5XG4gICAgICAgIC8vIG1hdGNoaW5nIGRvY3VtZW50cyBkbyBub3QgbmVjZXNzYXJpbHkgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5LlxuICAgICAgICBsZXQgcXVlcnlSZXN1bHRzID0gbmV3IFNvcnRlZFNldChuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpKTtcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goKF8sIG1heWJlRG9jKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBtYXliZURvYykpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMgPSBxdWVyeVJlc3VsdHMuYWRkKG1heWJlRG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWVyeVJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBsaW1pdCBxdWVyeSBuZWVkcyB0byBiZSByZWZpbGxlZCBmcm9tIGNhY2hlLCBtYWtpbmcgaXRcbiAgICAgKiBpbmVsaWdpYmxlIGZvciBpbmRleC1mcmVlIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeS5cbiAgICAgKiBAcGFyYW0gc29ydGVkUHJldmlvdXNSZXN1bHRzIC0gVGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHdoZW4gaXRcbiAgICAgKiB3YXMgbGFzdCBzeW5jaHJvbml6ZWQsIHNvcnRlZCBieSB0aGUgcXVlcnkncyBjb21wYXJhdG9yLlxuICAgICAqIEBwYXJhbSByZW1vdGVLZXlzIC0gVGhlIGRvY3VtZW50IGtleXMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSBhdCB0aGUgbGFzdFxuICAgICAqIHNuYXBzaG90LlxuICAgICAqIEBwYXJhbSBsaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgc25hcHNob3Qgd2hlbiB0aGVcbiAgICAgKiBxdWVyeSB3YXMgbGFzdCBzeW5jaHJvbml6ZWQuXG4gICAgICovXG4gICAgbmVlZHNSZWZpbGwocXVlcnksIHNvcnRlZFByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeS5saW1pdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUXVlcmllcyB3aXRob3V0IGxpbWl0cyBkbyBub3QgbmVlZCB0byBiZSByZWZpbGxlZC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3RlS2V5cy5zaXplICE9PSBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGlmIGEgcHJldmlvdXNseSBtYXRjaGluZyBkb2N1bWVudCBub1xuICAgICAgICAgICAgLy8gbG9uZ2VyIG1hdGNoZXMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaW1pdCBxdWVyaWVzIGFyZSBub3QgZWxpZ2libGUgZm9yIGluZGV4LWZyZWUgcXVlcnkgZXhlY3V0aW9uIGlmIHRoZXJlIGlzXG4gICAgICAgIC8vIGEgcG90ZW50aWFsIHRoYXQgYW4gb2xkZXIgZG9jdW1lbnQgZnJvbSBjYWNoZSBub3cgc29ydHMgYmVmb3JlIGEgZG9jdW1lbnRcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSBwYXJ0IG9mIHRoZSBsaW1pdC4gVGhpcywgaG93ZXZlciwgY2FuIG9ubHkgaGFwcGVuIGlmXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCBhdCB0aGUgZWRnZSBvZiB0aGUgbGltaXQgZ29lcyBvdXQgb2YgbGltaXQuXG4gICAgICAgIC8vIElmIGEgZG9jdW1lbnQgdGhhdCBpcyBub3QgdGhlIGxpbWl0IGJvdW5kYXJ5IHNvcnRzIGRpZmZlcmVudGx5LFxuICAgICAgICAvLyB0aGUgYm91bmRhcnkgb2YgdGhlIGxpbWl0IGl0c2VsZiBkaWQgbm90IGNoYW5nZSBhbmQgZG9jdW1lbnRzIGZyb20gY2FjaGVcbiAgICAgICAgLy8gd2lsbCBjb250aW51ZSB0byBiZSBcInJlamVjdGVkXCIgYnkgdGhpcyBib3VuZGFyeS4gVGhlcmVmb3JlLCB3ZSBjYW4gaWdub3JlXG4gICAgICAgIC8vIGFueSBtb2RpZmljYXRpb25zIHRoYXQgZG9uJ3QgYWZmZWN0IHRoZSBsYXN0IGRvY3VtZW50LlxuICAgICAgICBjb25zdCBkb2NBdExpbWl0RWRnZSA9IHF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXG4gICAgICAgICAgICA/IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5sYXN0KClcbiAgICAgICAgICAgIDogc29ydGVkUHJldmlvdXNSZXN1bHRzLmZpcnN0KCk7XG4gICAgICAgIGlmICghZG9jQXRMaW1pdEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVmaWxsIHRoZSBxdWVyeSBpZiB0aGVyZSB3ZXJlIGFscmVhZHkgbm8gZG9jdW1lbnRzLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZG9jQXRMaW1pdEVkZ2UuaGFzUGVuZGluZ1dyaXRlcyB8fFxuICAgICAgICAgICAgZG9jQXRMaW1pdEVkZ2UudmVyc2lvbi5jb21wYXJlVG8obGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSA+IDApO1xuICAgIH1cbiAgICBleGVjdXRlRnVsbENvbGxlY3Rpb25TY2FuKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCkge1xuICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1VzaW5nIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHRvIGV4ZWN1dGUgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIEluZGV4T2Zmc2V0Lm1pbigpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdGhlIHJlc3VsdHMgZnJvbSBhbiBpbmRleGVkIGV4ZWN1dGlvbiB3aXRoIHRoZSByZW1haW5pbmcgZG9jdW1lbnRzXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLlxuICAgICAqL1xuICAgIGFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIGluZGV4ZWRSZXN1bHRzLCBxdWVyeSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIG9mZnNldC5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldClcbiAgICAgICAgICAgIC5uZXh0KHJlbWFpbmluZ1Jlc3VsdHMgPT4ge1xuICAgICAgICAgICAgLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyByZXN1bHRzXG4gICAgICAgICAgICBpbmRleGVkUmVzdWx0cy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1Jlc3VsdHMgPSByZW1haW5pbmdSZXN1bHRzLmluc2VydChkLmtleSwgZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmdSZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBjbGllbnQgc3RhdGUgaXM6XG4vLyAgICAgZmlyZXN0b3JlX2NsaWVudHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGluc3RhbmNlX2tleT5cbmNvbnN0IENMSUVOVF9TVEFURV9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9jbGllbnRzJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBjbGllbnQgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KHBlcnNpc3RlbmNlS2V5LCBjbGllbnRJZCkge1xuICAgIHJldHVybiBgJHtDTElFTlRfU1RBVEVfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xufVxuLy8gVGhlIGZvcm1hdCBvZiB0aGUgV2ViU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgdGhlIG11dGF0aW9uIHN0YXRlIGlzOlxuLy8gICAgIGZpcmVzdG9yZV9tdXRhdGlvbnNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGJhdGNoX2lkPlxuLy8gICAgIChmb3IgdW5hdXRoZW50aWNhdGVkIHVzZXJzKVxuLy8gb3I6IGZpcmVzdG9yZV9tdXRhdGlvbnNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGJhdGNoX2lkPl88dXNlcl91aWQ+XG4vL1xuLy8gJ3VzZXJfdWlkJyBpcyBsYXN0IHRvIGF2b2lkIG5lZWRpbmcgdG8gZXNjYXBlICdfJyBjaGFyYWN0ZXJzIHRoYXQgaXQgbWlnaHRcbi8vIGNvbnRhaW4uXG5jb25zdCBNVVRBVElPTl9CQVRDSF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9tdXRhdGlvbnMnO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciBhIG11dGF0aW9uIGJhdGNoIGluIFdlYlN0b3JhZ2UgKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHBlcnNpc3RlbmNlS2V5LCB1c2VyLCBiYXRjaElkKSB7XG4gICAgbGV0IG11dGF0aW9uS2V5ID0gYCR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtiYXRjaElkfWA7XG4gICAgaWYgKHVzZXIuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgbXV0YXRpb25LZXkgKz0gYF8ke3VzZXIudWlkfWA7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbktleTtcbn1cbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIGEgcXVlcnkgdGFyZ2V0J3MgbWV0YWRhdGEgaXM6XG4vLyAgICAgZmlyZXN0b3JlX3RhcmdldHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPHRhcmdldF9pZD5cbmNvbnN0IFFVRVJZX1RBUkdFVF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV90YXJnZXRzJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBxdWVyeSBzdGF0ZSBpbiBXZWJTdG9yYWdlICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleShwZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpIHtcbiAgICByZXR1cm4gYCR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7dGFyZ2V0SWR9YDtcbn1cbi8vIFRoZSBXZWJTdG9yYWdlIHByZWZpeCB0aGF0IHN0b3JlcyB0aGUgcHJpbWFyeSB0YWIncyBvbmxpbmUgc3RhdGUuIFRoZVxuLy8gZm9ybWF0IG9mIHRoZSBrZXkgaXM6XG4vLyAgICAgZmlyZXN0b3JlX29ubGluZV9zdGF0ZV88cGVyc2lzdGVuY2VfcHJlZml4PlxuY29uc3QgT05MSU5FX1NUQVRFX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX29ubGluZV9zdGF0ZSc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIHRoZSBvbmxpbmUgc3RhdGUgb2YgdGhlIHByaW1hcnkgdGFiLiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke09OTElORV9TVEFURV9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XG59XG4vLyBUaGUgV2ViU3RvcmFnZSBwcmVmaXggdGhhdCBwbGF5cyBhcyBhIGV2ZW50IHRvIGluZGljYXRlIHRoZSByZW1vdGUgZG9jdW1lbnRzXG4vLyBtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIHNvbWUgc2Vjb25kYXJ5IHRhYnMgbG9hZGluZyBhIGJ1bmRsZS5cbi8vIGZvcm1hdCBvZiB0aGUga2V5IGlzOlxuLy8gICAgIGZpcmVzdG9yZV9idW5kbGVfbG9hZGVkX3YyXzxwZXJzaXN0ZW5jZUtleT5cbi8vIFRoZSB2ZXJzaW9uIGVuZGluZyB3aXRoIFwidjJcIiBzdG9yZXMgdGhlIGxpc3Qgb2YgbW9kaWZpZWQgY29sbGVjdGlvbiBncm91cHMuXG5jb25zdCBCVU5ETEVfTE9BREVEX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX2J1bmRsZV9sb2FkZWRfdjInO1xuZnVuY3Rpb24gY3JlYXRlQnVuZGxlTG9hZGVkS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke0JVTkRMRV9MT0FERURfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xufVxuLy8gVGhlIFdlYlN0b3JhZ2Uga2V5IHByZWZpeCBmb3IgdGhlIGtleSB0aGF0IHN0b3JlcyB0aGUgbGFzdCBzZXF1ZW5jZSBudW1iZXIgYWxsb2NhdGVkLiBUaGUga2V5XG4vLyBsb29rcyBsaWtlICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Jy5cbmNvbnN0IFNFUVVFTkNFX05VTUJFUl9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9zZXF1ZW5jZV9udW1iZXInO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgY3VycmVudCBzZXF1ZW5jZSBudW1iZXIuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkocGVyc2lzdGVuY2VLZXkpIHtcbiAgICByZXR1cm4gYCR7U0VRVUVOQ0VfTlVNQkVSX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckYSA9ICdTaGFyZWRDbGllbnRTdGF0ZSc7XG4vKipcbiAqIEhvbGRzIHRoZSBzdGF0ZSBvZiBhIG11dGF0aW9uIGJhdGNoLCBpbmNsdWRpbmcgaXRzIHVzZXIgSUQsIGJhdGNoIElEIGFuZFxuICogd2hldGhlciB0aGUgYmF0Y2ggaXMgJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJyBvciAncmVqZWN0ZWQnLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jbGFzcyBNdXRhdGlvbk1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy5iYXRjaElkID0gYmF0Y2hJZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIE11dGF0aW9uTWV0YWRhdGEgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodXNlciwgYmF0Y2hJZCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25CYXRjaCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIG11dGF0aW9uQmF0Y2ggPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBbJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJywgJ3JlamVjdGVkJ10uaW5kZXhPZihtdXRhdGlvbkJhdGNoLnN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgICAtMSAmJlxuICAgICAgICAgICAgKG11dGF0aW9uQmF0Y2guZXJyb3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yID09PSAnb2JqZWN0Jyk7XG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbGlkRGF0YSAmJiBtdXRhdGlvbkJhdGNoLmVycm9yKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLmNvZGUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSwgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uTWV0YWRhdGEodXNlciwgYmF0Y2hJZCwgbXV0YXRpb25CYXRjaC5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIG11dGF0aW9uIHN0YXRlIGZvciBJRCAnJHtiYXRjaElkfSc6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCBiYXRjaE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIGJhdGNoTWV0YWRhdGEuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogdGhpcy5lcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYmF0Y2hNZXRhZGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBxdWVyeSB0YXJnZXQsIGluY2x1ZGluZyBpdHMgdGFyZ2V0IElEIGFuZCB3aGV0aGVyIHRoZVxuICogdGFyZ2V0IGlzICdub3QtY3VycmVudCcsICdjdXJyZW50JyBvciAncmVqZWN0ZWQnLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jbGFzcyBRdWVyeVRhcmdldE1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgdGFyZ2V0U3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBbJ25vdC1jdXJyZW50JywgJ2N1cnJlbnQnLCAncmVqZWN0ZWQnXS5pbmRleE9mKHRhcmdldFN0YXRlLnN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgICAtMSAmJlxuICAgICAgICAgICAgKHRhcmdldFN0YXRlLmVycm9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IgPT09ICdvYmplY3QnKTtcbiAgICAgICAgbGV0IGZpcmVzdG9yZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmFsaWREYXRhICYmIHRhcmdldFN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICAgICAgZmlyZXN0b3JlRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IuY29kZSwgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCB0YXJnZXRTdGF0ZS5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIHRhcmdldCBzdGF0ZSBmb3IgSUQgJyR7dGFyZ2V0SWR9JzogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvV2ViU3RvcmFnZUpTT04oKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRhcmdldFN0YXRlLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRhcmdldFN0YXRlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgaW1tdXRhYmxlIENsaWVudFN0YXRlIGZvciBhIGNsaWVudCByZWFkIGZyb21cbiAqIFdlYlN0b3JhZ2UsIGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2YgYWN0aXZlIHF1ZXJ5IHRhcmdldHMuXG4gKi9cbmNsYXNzIFJlbW90ZUNsaWVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSBhY3RpdmVUYXJnZXRJZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFJlbW90ZUNsaWVudFN0YXRlIGZyb20gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIGNsaWVudFN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRJZHNTZXQgPSB0YXJnZXRJZFNldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgdmFsaWREYXRhICYmIGkgPCBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhbGlkRGF0YSA9IGlzU2FmZUludGVnZXIoY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzW2ldKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkc1NldCA9IGFjdGl2ZVRhcmdldElkc1NldC5hZGQoY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUNsaWVudFN0YXRlKGNsaWVudElkLCBhY3RpdmVUYXJnZXRJZHNTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBkYXRhIGZvciBpbnN0YW5jZSAnJHtjbGllbnRJZH0nOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgb25saW5lIHN0YXRlIGZvciBhbGwgY2xpZW50cyBwYXJ0aWNpcGF0aW5nIGluXG4gKiBtdWx0aS10YWIuIFRoZSBvbmxpbmUgc3RhdGUgaXMgb25seSB3cml0dGVuIHRvIGJ5IHRoZSBwcmltYXJ5IGNsaWVudCwgYW5kXG4gKiB1c2VkIGluIHNlY29uZGFyeSBjbGllbnRzIHRvIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3cy5cbiAqL1xuY2xhc3MgU2hhcmVkT25saW5lU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCBvbmxpbmVTdGF0ZSkge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgU2hhcmVkT25saW5lU3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsaWREYXRhID0gdHlwZW9mIG9ubGluZVN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydVbmtub3duJywgJ09ubGluZScsICdPZmZsaW5lJ10uaW5kZXhPZihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvbmxpbmVTdGF0ZS5jbGllbnRJZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVkT25saW5lU3RhdGUob25saW5lU3RhdGUuY2xpZW50SWQsIG9ubGluZVN0YXRlLm9ubGluZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBvbmxpbmUgc3RhdGU6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWV0YWRhdGEgc3RhdGUgb2YgdGhlIGxvY2FsIGNsaWVudC4gVW5saWtlIGBSZW1vdGVDbGllbnRTdGF0ZWAsIHRoaXMgY2xhc3MgaXNcbiAqIG11dGFibGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFsbCBwZW5kaW5nIG11dGF0aW9ucywgd2hpY2ggYWxsb3dzIHVzIHRvXG4gKiB1cGRhdGUgdGhlIHJhbmdlIG9mIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2ggSURzIGFzIG5ldyBtdXRhdGlvbnMgYXJlIGFkZGVkIG9yXG4gKiByZW1vdmVkLlxuICpcbiAqIFRoZSBkYXRhIGluIGBMb2NhbENsaWVudFN0YXRlYCBpcyBub3QgcmVhZCBmcm9tIFdlYlN0b3JhZ2UgYW5kIGluc3RlYWRcbiAqIHVwZGF0ZWQgdmlhIGl0cyBpbnN0YW5jZSBtZXRob2RzLiBUaGUgdXBkYXRlZCBzdGF0ZSBjYW4gYmUgc2VyaWFsaXplZCB2aWFcbiAqIGB0b1dlYlN0b3JhZ2VKU09OKClgLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuY2xhc3MgTG9jYWxDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGFyZ2V0SWRTZXQoKTtcbiAgICB9XG4gICAgYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0aGlzLmFjdGl2ZVRhcmdldElkcy5hZGQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICByZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRoaXMuYWN0aXZlVGFyZ2V0SWRzLmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgZW50cnkgaW50byBhIEpTT04tZW5jb2RlZCBmb3JtYXQgd2UgY2FuIHVzZSBmb3IgV2ViU3RvcmFnZS5cbiAgICAgKiBEb2VzIG5vdCBlbmNvZGUgYGNsaWVudElkYCBhcyBpdCBpcyBwYXJ0IG9mIHRoZSBrZXkgaW4gV2ViU3RvcmFnZS5cbiAgICAgKi9cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzOiB0aGlzLmFjdGl2ZVRhcmdldElkcy50b0FycmF5KCksXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogYFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZWAgdXNlcyBXZWJTdG9yYWdlICh3aW5kb3cubG9jYWxTdG9yYWdlKSBhcyB0aGVcbiAqIGJhY2tpbmcgc3RvcmUgZm9yIHRoZSBTaGFyZWRDbGllbnRTdGF0ZS4gSXQga2VlcHMgdHJhY2sgb2YgYWxsIGFjdGl2ZVxuICogY2xpZW50cyBhbmQgc3VwcG9ydHMgbW9kaWZpY2F0aW9ucyBvZiB0aGUgbG9jYWwgY2xpZW50J3MgZGF0YS5cbiAqL1xuY2xhc3MgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aW5kb3csIHF1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgbG9jYWxDbGllbnRJZCwgaW5pdGlhbFVzZXIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50SWQgPSBsb2NhbENsaWVudElkO1xuICAgICAgICB0aGlzLnN5bmNFbmdpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yYWdlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHR1cmVzIFdlYlN0b3JhZ2UgZXZlbnRzIHRoYXQgb2NjdXIgYmVmb3JlIGBzdGFydCgpYCBpcyBjYWxsZWQuIFRoZXNlXG4gICAgICAgICAqIGV2ZW50cyBhcmUgcmVwbGF5ZWQgb25jZSBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCBpcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xuICAgICAgICAvLyBFc2NhcGUgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyBtZW50aW9uZWQgaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXG4gICAgICAgIGNvbnN0IGVzY2FwZWRQZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMud2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IGluaXRpYWxVc2VyO1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmxvY2FsQ2xpZW50SWQpO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5ID0gY3JlYXRlV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KHRoaXMubG9jYWxDbGllbnRJZCwgbmV3IExvY2FsQ2xpZW50U3RhdGUoKSk7XG4gICAgICAgIHRoaXMuY2xpZW50U3RhdGVLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke0NMSUVOVF9TVEFURV9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFteX10qKSRgKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtNVVRBVElPTl9CQVRDSF9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFxcXFxkKykoPzpfKC4qKSk/JGApO1xuICAgICAgICB0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspJGApO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICB0aGlzLmJ1bmRsZUxvYWRlZEtleSA9IGNyZWF0ZUJ1bmRsZUxvYWRlZEtleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gYWRkaW5nIHRoZSBzdG9yYWdlIG9ic2VydmVyIGR1cmluZyBzdGFydCgpLCB3ZSBhZGQgdGhlXG4gICAgICAgIC8vIHN0b3JhZ2Ugb2JzZXJ2ZXIgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBjb2xsZWN0XG4gICAgICAgIC8vIGV2ZW50cyBiZWZvcmUgb3RoZXIgY29tcG9uZW50cyBwb3B1bGF0ZSB0aGVpciBpbml0aWFsIHN0YXRlIChkdXJpbmcgdGhlaXJcbiAgICAgICAgLy8gcmVzcGVjdGl2ZSBzdGFydCgpIGNhbGxzKS4gT3RoZXJ3aXNlLCB3ZSBtaWdodCBmb3IgZXhhbXBsZSBtaXNzIGFcbiAgICAgICAgLy8gbXV0YXRpb24gdGhhdCBpcyBhZGRlZCBhZnRlciBMb2NhbFN0b3JlJ3Mgc3RhcnQoKSBwcm9jZXNzZWQgdGhlIGV4aXN0aW5nXG4gICAgICAgIC8vIG11dGF0aW9ucyBidXQgYmVmb3JlIHdlIG9ic2VydmUgV2ViU3RvcmFnZSBldmVudHMuXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCB0aGlzLnN0b3JhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiBXZWJTdG9yYWdlIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUod2luZG93KSB7XG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjbGllbnRzIHRvIGJhY2tmaWxsIHRoZSBkYXRhIGluXG4gICAgICAgIC8vIFNoYXJlZENsaWVudFN0YXRlLlxuICAgICAgICBjb25zdCBleGlzdGluZ0NsaWVudHMgPSBhd2FpdCB0aGlzLnN5bmNFbmdpbmUuZ2V0QWN0aXZlQ2xpZW50cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElkIG9mIGV4aXN0aW5nQ2xpZW50cykge1xuICAgICAgICAgICAgaWYgKGNsaWVudElkID09PSB0aGlzLmxvY2FsQ2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gdGhpcy5nZXRJdGVtKGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCBjbGllbnRJZCkpO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCBzdG9yYWdlSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHRoaXMuYWN0aXZlQ2xpZW50cy5pbnNlcnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgb25saW5lIHN0YXRlIGFuZCBjYWxsIHRoZSBjYWxsYmFjayBoYW5kbGVyXG4gICAgICAgIC8vIGlmIGFwcGxpY2FibGUuXG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlSlNPTiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXkpO1xuICAgICAgICBpZiAob25saW5lU3RhdGVKU09OKSB7XG4gICAgICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZUpTT04pO1xuICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuZWFybHlFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2ViU3RvcmFnZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhcmx5RXZlbnRzID0gW107XG4gICAgICAgIC8vIFJlZ2lzdGVyIGEgd2luZG93IHVubG9hZCBob29rIHRvIHJlbW92ZSB0aGUgY2xpZW50IG1ldGFkYXRhIGVudHJ5IGZyb21cbiAgICAgICAgLy8gV2ViU3RvcmFnZSBldmVuIGlmIGBzaHV0ZG93bigpYCB3YXMgbm90IGNhbGxlZC5cbiAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCAoKSA9PiB0aGlzLnNodXRkb3duKCkpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLnNlcXVlbmNlTnVtYmVyS2V5LCBKU09OLnN0cmluZ2lmeShzZXF1ZW5jZU51bWJlcikpO1xuICAgIH1cbiAgICBnZXRBbGxBY3RpdmVRdWVyeVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcbiAgICB9XG4gICAgaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgYWRkUGVuZGluZ011dGF0aW9uKGJhdGNoSWQpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCAncGVuZGluZycpO1xuICAgIH1cbiAgICB1cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnBlcnNpc3RNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcik7XG4gICAgICAgIC8vIE9uY2UgYSBmaW5hbCBtdXRhdGlvbiByZXN1bHQgaXMgb2JzZXJ2ZWQgYnkgb3RoZXIgY2xpZW50cywgdGhleSBubyBsb25nZXJcbiAgICAgICAgLy8gYWNjZXNzIHRoZSBtdXRhdGlvbidzIG1ldGFkYXRhIGVudHJ5LiBTaW5jZSBXZWJTdG9yYWdlIHJlcGxheXMgZXZlbnRzXG4gICAgICAgIC8vIGluIG9yZGVyLCBpdCBpcyBzYWZlIHRvIGRlbGV0ZSB0aGUgZW50cnkgcmlnaHQgYWZ0ZXIgdXBkYXRpbmcgaXQuXG4gICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcbiAgICB9XG4gICAgYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgYWRkVG9BY3RpdmVUYXJnZXRJZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBxdWVyeVN0YXRlID0gJ25vdC1jdXJyZW50JztcbiAgICAgICAgLy8gTG9va3VwIGFuIGV4aXN0aW5nIHF1ZXJ5IHN0YXRlIGlmIHRoZSB0YXJnZXQgSUQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgICAvLyBieSBhbm90aGVyIHRhYlxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHN0b3JhZ2VJdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlTdGF0ZSA9IG1ldGFkYXRhLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcXVlcnkgaXMgbGlzdGVuaW5nIHRvIGNhY2hlIG9ubHksIHRoZSB0YXJnZXQgSUQgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIHdpdGggdGhlXG4gICAgICAgIC8vIGxvY2FsIEZpcmVzdG9yZSBjbGllbnQgYXMgYW4gYWN0aXZlIHdhdGNoIHRhcmdldC5cbiAgICAgICAgaWYgKGFkZFRvQWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xuICAgIH1cbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5yZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgfVxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbENsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xuICAgIH1cbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKSk7XG4gICAgfVxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnBlcnNpc3RRdWVyeVRhcmdldFN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xuICAgICAgICByZW1vdmVkQmF0Y2hJZHMuZm9yRWFjaChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICBhZGRlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcbiAgICB9XG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoY29sbGVjdGlvbkdyb3Vwcyk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnUkVBRCcsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdTRVQnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1JFTU9WRScsIGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuICAgIGhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCkge1xuICAgICAgICAvLyBOb3RlOiBUaGUgZnVuY3Rpb24gaXMgdHlwZWQgdG8gdGFrZSBFdmVudCB0byBiZSBpbnRlcmZhY2UtY29tcGF0aWJsZSB3aXRoXG4gICAgICAgIC8vIGBXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VFdmVudCA9IGV2ZW50O1xuICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LnN0b3JhZ2VBcmVhID09PSB0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ0VWRU5UJywgc3RvcmFnZUV2ZW50LmtleSwgc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdSZWNlaXZlZCBXZWJTdG9yYWdlIG5vdGlmaWNhdGlvbiBmb3IgbG9jYWwgY2hhbmdlLiBBbm90aGVyIGNsaWVudCBtaWdodCBoYXZlICcgK1xuICAgICAgICAgICAgICAgICAgICAnZ2FyYmFnZS1jb2xsZWN0ZWQgb3VyIHN0YXRlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RXZlbnRzLnB1c2goc3RvcmFnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFN0YXRlS2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShzdG9yYWdlRXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50SWQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV0YXRpb25CYXRjaEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25NZXRhZGF0YSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VNdXRhdGlvbk1ldGFkYXRhKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU11dGF0aW9uQmF0Y2hFdmVudChtdXRhdGlvbk1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVRhcmdldE1ldGFkYXRhID0gdGhpcy5mcm9tV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGEoc3RvcmFnZUV2ZW50LmtleSwgc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeVRhcmdldE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUXVlcnlUYXJnZXRFdmVudChxdWVyeVRhcmdldE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLm9ubGluZVN0YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25saW5lU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZnJvbVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcihzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IExpc3RlblNlcXVlbmNlLklOVkFMSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmJ1bmRsZUxvYWRlZEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXBzID0gdGhpcy5mcm9tV2ViU3RvcmVCdW5kbGVMb2FkZWRTdGF0ZShzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb2xsZWN0aW9uR3JvdXBzLm1hcChjZyA9PiB0aGlzLnN5bmNFbmdpbmUuc3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cyhjZykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbG9jYWxDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ2xpZW50cy5nZXQodGhpcy5sb2NhbENsaWVudElkKTtcbiAgICB9XG4gICAgcGVyc2lzdENsaWVudFN0YXRlKCkge1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXksIHRoaXMubG9jYWxDbGllbnRTdGF0ZS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICBwZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdGF0ZSA9IG5ldyBNdXRhdGlvbk1ldGFkYXRhKHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQsIHN0YXRlLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XG4gICAgICAgIHRoaXMuc2V0SXRlbShtdXRhdGlvbktleSwgbXV0YXRpb25TdGF0ZS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICByZW1vdmVNdXRhdGlvblN0YXRlKGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25LZXkgPSBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKG11dGF0aW9uS2V5KTtcbiAgICB9XG4gICAgcGVyc2lzdE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMubG9jYWxDbGllbnRJZCxcbiAgICAgICAgICAgIG9ubGluZVN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXksIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XG4gICAgfVxuICAgIHBlcnNpc3RRdWVyeVRhcmdldFN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldEl0ZW0odGFyZ2V0S2V5LCB0YXJnZXRNZXRhZGF0YS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICBwZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoY29sbGVjdGlvbkdyb3Vwcykge1xuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjb2xsZWN0aW9uR3JvdXBzKSk7XG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLmJ1bmRsZUxvYWRlZEtleSwganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBrZXkgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyBudWxsIGlmIHRoZSBrZXkgZG9lcyBub3RcbiAgICAgKiBtYXRjaCB0aGUgZXhwZWN0ZWQga2V5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2xpZW50U3RhdGVLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgY2xpZW50IHN0YXRlIGluIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZSBjb3VsZCBub3RcbiAgICAgKiBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSk7XG4gICAgICAgIHJldHVybiBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIG11dGF0aW9uIGJhdGNoIHN0YXRlIGluIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VNdXRhdGlvbk1ldGFkYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIGNvbnN0IGJhdGNoSWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBtYXRjaFsyXSAhPT0gdW5kZWZpbmVkID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgICByZXR1cm4gTXV0YXRpb25NZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KG5ldyBVc2VyKHVzZXJJZCksIGJhdGNoSWQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgcXVlcnkgdGFyZ2V0IHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMucXVlcnlUYXJnZXRLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgcmV0dXJuIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeSh0YXJnZXRJZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gb25saW5lIHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTaGFyZWRPbmxpbmVTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKTtcbiAgICB9XG4gICAgZnJvbVdlYlN0b3JlQnVuZGxlTG9hZGVkU3RhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVNdXRhdGlvbkJhdGNoRXZlbnQobXV0YXRpb25CYXRjaCkge1xuICAgICAgICBpZiAobXV0YXRpb25CYXRjaC51c2VyLnVpZCAhPT0gdGhpcy5jdXJyZW50VXNlci51aWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgYElnbm9yaW5nIG11dGF0aW9uIGZvciBub24tYWN0aXZlIHVzZXIgJHttdXRhdGlvbkJhdGNoLnVzZXIudWlkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlCYXRjaFN0YXRlKG11dGF0aW9uQmF0Y2guYmF0Y2hJZCwgbXV0YXRpb25CYXRjaC5zdGF0ZSwgbXV0YXRpb25CYXRjaC5lcnJvcik7XG4gICAgfVxuICAgIGhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQodGFyZ2V0TWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseVRhcmdldFN0YXRlKHRhcmdldE1ldGFkYXRhLnRhcmdldElkLCB0YXJnZXRNZXRhZGF0YS5zdGF0ZSwgdGFyZ2V0TWV0YWRhdGEuZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBjbGllbnRTdGF0ZSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkQ2xpZW50cyA9IGNsaWVudFN0YXRlXG4gICAgICAgICAgICA/IHRoaXMuYWN0aXZlQ2xpZW50cy5pbnNlcnQoY2xpZW50SWQsIGNsaWVudFN0YXRlKVxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsaWVudHMucmVtb3ZlKGNsaWVudElkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XG4gICAgICAgIGNvbnN0IG5ld1RhcmdldHMgPSB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModXBkYXRlZENsaWVudHMpO1xuICAgICAgICBjb25zdCBhZGRlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgbmV3VGFyZ2V0cy5mb3JFYWNoKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICBhZGRlZFRhcmdldHMucHVzaCh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleGlzdGluZ1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld1RhcmdldHMuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UoYWRkZWRUYXJnZXRzLCByZW1vdmVkVGFyZ2V0cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB1cGRhdGVkQ2xpZW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZU9ubGluZVN0YXRlRXZlbnQob25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gV2UgY2hlY2sgd2hldGhlciB0aGUgY2xpZW50IHRoYXQgd3JvdGUgdGhpcyBvbmxpbmUgc3RhdGUgaXMgc3RpbGwgYWN0aXZlXG4gICAgICAgIC8vIGJ5IGNvbXBhcmluZyBpdHMgY2xpZW50IElEIHRvIHRoZSBsaXN0IG9mIGNsaWVudHMga2VwdCBhY3RpdmUgaW5cbiAgICAgICAgLy8gSW5kZXhlZERiLiBJZiBhIGNsaWVudCBkb2VzIG5vdCB1cGRhdGUgdGhlaXIgSW5kZXhlZERiIGNsaWVudCBzdGF0ZVxuICAgICAgICAvLyB3aXRoaW4gNSBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIGluYWN0aXZlIGFuZCB3ZSBkb24ndCBlbWl0IGFuIG9ubGluZVxuICAgICAgICAvLyBzdGF0ZSBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2xpZW50cy5nZXQob25saW5lU3RhdGUuY2xpZW50SWQpKSB7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdEFjdGl2ZVF1ZXJ5VGFyZ2V0cyhjbGllbnRzKSB7XG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRzID0gdGFyZ2V0SWRTZXQoKTtcbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKChrZXYsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRzID0gYWN0aXZlVGFyZ2V0cy51bmlvbldpdGgodmFsdWUuYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhY3RpdmVUYXJnZXRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21XZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXIoc2VxU3RyaW5nKSB7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICBpZiAoc2VxU3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VxU3RyaW5nKTtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicpO1xuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXIgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgJ0ZhaWxlZCB0byByZWFkIHNlcXVlbmNlIG51bWJlciBmcm9tIFdlYlN0b3JhZ2UnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxdWVuY2VOdW1iZXI7XG59XG4vKipcbiAqIGBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZWAgaXMgYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgU2hhcmVkQ2xpZW50U3RhdGUgZm9yXG4gKiBjbGllbnRzIHVzaW5nIG1lbW9yeSBwZXJzaXN0ZW5jZS4gVGhlIHN0YXRlIGluIHRoaXMgY2xhc3MgcmVtYWlucyBmdWxseVxuICogaXNvbGF0ZWQgYW5kIG5vIHN5bmNocm9uaXphdGlvbiBpcyBwZXJmb3JtZWQuXG4gKi9cbmNsYXNzIE1lbW9yeVNoYXJlZENsaWVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcbiAgICAgICAgdGhpcy5xdWVyeVN0YXRlID0ge307XG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlckhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQsIGFkZFRvQWN0aXZlVGFyZ2V0SWRzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoYWRkVG9BY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdGF0ZS5hZGRRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTdGF0ZVt0YXJnZXRJZF0gfHwgJ25vdC1jdXJyZW50JztcbiAgICB9XG4gICAgdXBkYXRlUXVlcnlTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZVt0YXJnZXRJZF0gPSBzdGF0ZTtcbiAgICB9XG4gICAgcmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUucmVtb3ZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKTtcbiAgICB9XG4gICAgY2xlYXJRdWVyeVN0YXRlKHRhcmdldElkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdO1xuICAgIH1cbiAgICBnZXRBbGxBY3RpdmVRdWVyeVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzO1xuICAgIH1cbiAgICBpc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxDbGllbnRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJDaGFuZ2UodXNlciwgcmVtb3ZlZEJhdGNoSWRzLCBhZGRlZEJhdGNoSWRzKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICBzZXRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgc2h1dGRvd24oKSB7IH1cbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7IH1cbiAgICBub3RpZnlCdW5kbGVMb2FkZWQoY29sbGVjdGlvbkdyb3Vwcykge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBOb29wQ29ubmVjdGl2aXR5TW9uaXRvciB7XG4gICAgYWRkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgLy8gTm8tb3AuXG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICAvLyBOby1vcC5cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGEgc2ltcGxlIGhlbHBlciBjbGFzcyB0aGF0IGltcGxlbWVudHMgdGhlIFN0cmVhbSBpbnRlcmZhY2UgdG9cbiAqIGJyaWRnZSB0byBvdGhlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmUgc3RyZWFtcyBidXQgZG8gbm90IGltcGxlbWVudCB0aGVcbiAqIGludGVyZmFjZS4gVGhlIHN0cmVhbSBjYWxsYmFja3MgYXJlIGludm9rZWQgd2l0aCB0aGUgY2FsbE9uLi4uIG1ldGhvZHMuXG4gKi9cbmNsYXNzIFN0cmVhbUJyaWRnZSB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLnNlbmRGbiA9IGFyZ3Muc2VuZEZuO1xuICAgICAgICB0aGlzLmNsb3NlRm4gPSBhcmdzLmNsb3NlRm47XG4gICAgfVxuICAgIG9uQ29ubmVjdGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uT3BlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbk9wZW4gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNsb3NlID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uTWVzc2FnZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VGbigpO1xuICAgIH1cbiAgICBzZW5kKG1zZykge1xuICAgICAgICB0aGlzLnNlbmRGbihtc2cpO1xuICAgIH1cbiAgICBjYWxsT25Db25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkKCk7XG4gICAgfVxuICAgIGNhbGxPbk9wZW4oKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbigpO1xuICAgIH1cbiAgICBjYWxsT25DbG9zZShlcnIpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZShlcnIpO1xuICAgIH1cbiAgICBjYWxsT25NZXNzYWdlKG1zZykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UobXNnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBtb3N0IHJlY2VudCBpbnZvY2F0aW9uIG9mXG4gKiBgZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKClgLCBvciBudWxsIGlmIGl0IGhhcyBuZXZlciBiZWVuIGludm9rZWQuXG4gKi9cbmxldCBsYXN0VW5pcXVlRGVidWdJZCA9IG51bGw7XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBpbml0aWFsIHZhbHVlIGZvciBgbGFzdFVuaXF1ZURlYnVnSWRgLlxuICpcbiAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyByYW5kb21seSBzZWxlY3RlZCBmcm9tIGEgcmFuZ2Ugb2YgaW50ZWdlcnMgdGhhdCBhcmVcbiAqIHJlcHJlc2VudGVkIGFzIDggaGV4YWRlY2ltYWwgZGlnaXRzLiBUaGlzIG1lYW5zIHRoYXQgKHdpdGhpbiByZWFzb24pIGFueVxuICogbnVtYmVycyBnZW5lcmF0ZWQgYnkgaW5jcmVtZW50aW5nIHRoZSByZXR1cm5lZCBudW1iZXIgYnkgMSB3aWxsIGFsc28gYmVcbiAqIHJlcHJlc2VudGVkIGJ5IDggaGV4YWRlY2ltYWwgZGlnaXRzLiBUaGlzIGxlYWRzIHRvIGFsbCBcIklEc1wiIGhhdmluZyB0aGUgc2FtZVxuICogbGVuZ3RoIHdoZW4gY29udmVydGVkIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBtYWtpbmcgcmVhZGluZyBsb2dzIGNvbnRhaW5pbmdcbiAqIHRoZXNlIElEcyBlYXNpZXIgdG8gZm9sbG93LiBBbmQgc2luY2UgdGhlIHJldHVybiB2YWx1ZSBpcyByYW5kb21seSBzZWxlY3RlZFxuICogaXQgd2lsbCBoZWxwIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsb2dzIGZyb20gZGlmZmVyZW50IGV4ZWN1dGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSW5pdGlhbFVuaXF1ZURlYnVnSWQoKSB7XG4gICAgY29uc3QgbWluUmVzdWx0ID0gMHgxMDAwMDAwMDtcbiAgICBjb25zdCBtYXhSZXN1bHQgPSAweDkwMDAwMDAwO1xuICAgIGNvbnN0IHJlc3VsdFJhbmdlID0gbWF4UmVzdWx0IC0gbWluUmVzdWx0O1xuICAgIGNvbnN0IHJlc3VsdE9mZnNldCA9IE1hdGgucm91bmQocmVzdWx0UmFuZ2UgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICByZXR1cm4gbWluUmVzdWx0ICsgcmVzdWx0T2Zmc2V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB1bmlxdWUgSUQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogVGhlIHJldHVybmVkIElEIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gZGVidWcgbG9nZ2luZyBtZXNzYWdlcyB0byBoZWxwXG4gKiBjb3JyZWxhdGUgbG9nIG1lc3NhZ2VzIHRoYXQgbWF5IGJlIHNwYXRpYWxseSBzZXBhcmF0ZWQgaW4gdGhlIGxvZ3MsIGJ1dFxuICogbG9naWNhbGx5IHJlbGF0ZWQuIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgY29ubmVjdGlvbiBjb3VsZCBpbmNsdWRlIHRoZSBzYW1lXG4gKiBcImRlYnVnIElEXCIgc3RyaW5nIGluIGFsbCBvZiBpdHMgbG9nIG1lc3NhZ2VzIHRvIGhlbHAgdHJhY2UgYSBzcGVjaWZpY1xuICogY29ubmVjdGlvbiBvdmVyIHRpbWUuXG4gKlxuICogQHJldHVybiB0aGUgMTAtY2hhcmFjdGVyIGdlbmVyYXRlZCBJRCAoZS5nLiBcIjB4YTFiMmMzZDRcIikuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpIHtcbiAgICBpZiAobGFzdFVuaXF1ZURlYnVnSWQgPT09IG51bGwpIHtcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQgPSBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsYXN0VW5pcXVlRGVidWdJZCsrO1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIGxhc3RVbmlxdWVEZWJ1Z0lkLnRvU3RyaW5nKDE2KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qXG4gKiBVdGlsaXRpZXMgZm9yIGRlYWxpbmcgd2l0aCBub2RlLmpzLXN0eWxlIEFQSXMuIFNlZSBub2RlUHJvbWlzZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYSBuZXcgUHJvbWlzZS4gVGhlXG4gKiBjYWxsYmFjayBpcyBwYXNzZWQgdG8gdGhlIGdpdmVuIGFjdGlvbiB3aGljaCBjYW4gdGhlbiB1c2UgdGhlIGNhbGxiYWNrIGFzXG4gKiBhIHBhcmFtZXRlciB0byBhIG5vZGUtc3R5bGUgZnVuY3Rpb24uXG4gKlxuICogVGhlIGludGVudCBpcyB0byBkaXJlY3RseSBicmlkZ2UgYSBub2RlLXN0eWxlIGZ1bmN0aW9uICh3aGljaCB0YWtlcyBhXG4gKiBjYWxsYmFjaykgaW50byBhIFByb21pc2Ugd2l0aG91dCBtYW51YWxseSBjb252ZXJ0aW5nIGJldHdlZW4gdGhlIG5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIGFuZCB0aGUgcHJvbWlzZSBhdCBlYWNoIGNhbGwuXG4gKlxuICogSW4gZWZmZWN0IGl0IGFsbG93cyB5b3UgdG8gY29udmVydDpcbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IFByb21pc2UoKHJlc29sdmU6ICh2YWx1ZT86IGZzLlN0YXRzKSA9PiB2b2lkLFxuICogICAgICAgICAgICAgIHJlamVjdDogKGVycm9yPzogYW55KSA9PiB2b2lkKSA9PiB7XG4gKiAgIGZzLnN0YXQocGF0aCwgKGVycm9yPzogYW55LCBzdGF0PzogZnMuU3RhdHMpID0+IHtcbiAqICAgICBpZiAoZXJyb3IpIHtcbiAqICAgICAgIHJlamVjdChlcnJvcik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIHJlc29sdmUoc3RhdCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIEludG9cbiAqIEBleGFtcGxlXG4gKiBub2RlUHJvbWlzZSgoY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxmcy5TdGF0cz4pID0+IHtcbiAqICAgZnMuc3RhdChwYXRoLCBjYWxsYmFjayk7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0gYWN0aW9uIC0gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudFxuICogICAgIGFuZCB0aGVuIHVzZXMgdGhhdCBjYWxsYmFjayB0byBpbnZva2Ugc29tZSBub2RlLXN0eWxlIEFQSS5cbiAqIEByZXR1cm5zIGEgbmV3IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZWplY3RlZCBpZiB0aGUgY2FsbGJhY2sgaXMgZ2l2ZW4gdGhlXG4gKiAgICAgZmlyc3QgRXJyb3IgcGFyYW1ldGVyIG9yIHdpbGwgcmVzb2x2ZSB0byB0aGUgdmFsdWUgZ2l2ZW4gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBub2RlUHJvbWlzZShhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhY3Rpb24oKGVycm9yLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFRPRE86IEZldGNoIHJ1bnRpbWUgdmVyc2lvbiBmcm9tIGdycGMtanMvcGFja2FnZS5qc29uIGluc3RlYWRcbi8vIHdoZW4gdGhlcmUncyBhIGNsZWFuZXIgd2F5IHRvIGR5bmFtaWMgcmVxdWlyZSBKU09OIGluIGJvdGggTm9kZSBFU00gYW5kIENKU1xuY29uc3QgZ3JwY1ZlcnNpb24gPSAnMS45LjE1JztcbmNvbnN0IExPR19UQUckOSA9ICdHcnBjQ29ubmVjdGlvbic7XG5jb25zdCBYX0dPT0dfQVBJX0NMSUVOVF9WQUxVRSA9IGBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSBmaXJlLyR7U0RLX1ZFUlNJT059IGdycGMvJHtncnBjVmVyc2lvbn1gO1xuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGEoZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGFwcElkKSB7XG4gICAgaGFyZEFzc2VydChhdXRoVG9rZW4gPT09IG51bGwgfHwgYXV0aFRva2VuLnR5cGUgPT09ICdPQXV0aCcpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IGdycGMuTWV0YWRhdGEoKTtcbiAgICBpZiAoYXV0aFRva2VuKSB7XG4gICAgICAgIGF1dGhUb2tlbi5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IG1ldGFkYXRhLnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIGFwcENoZWNrVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoYXBwSWQpIHtcbiAgICAgICAgbWV0YWRhdGEuc2V0KCdYLUZpcmViYXNlLUdNUElEJywgYXBwSWQpO1xuICAgIH1cbiAgICBtZXRhZGF0YS5zZXQoJ1gtR29vZy1BcGktQ2xpZW50JywgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUpO1xuICAgIC8vIFRoZXNlIGhlYWRlcnMgYXJlIHVzZWQgdG8gaW1wcm92ZSByb3V0aW5nIGFuZCBwcm9qZWN0IGlzb2xhdGlvbiBieSB0aGVcbiAgICAvLyBiYWNrZW5kLlxuICAgIC8vIFRPRE8oYi8xOTk3Njc3MTIpOiBXZSBhcmUga2VlcGluZyAnR29vZ2xlLUNsb3VkLVJlc291cmNlLVByZWZpeCcgdW50aWwgRW11bGF0b3JzIGNhbiBiZVxuICAgIC8vIHJlbGVhc2VkIHdpdGggY2wvNDI4ODIwMDQ2LiBDdXJyZW50bHkgYmxvY2tlZCBiZWNhdXNlIEVtdWxhdG9ycyBhcmUgbm93IGJ1aWx0IHdpdGggSmF2YVxuICAgIC8vIDExIGZyb20gR29vZ2xlMy5cbiAgICBtZXRhZGF0YS5zZXQoJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnLCBkYXRhYmFzZVBhdGgpO1xuICAgIG1ldGFkYXRhLnNldCgneC1nb29nLXJlcXVlc3QtcGFyYW1zJywgZGF0YWJhc2VQYXRoKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG59XG4vKipcbiAqIEEgQ29ubmVjdGlvbiBpbXBsZW1lbnRlZCBieSBHUlBDLU5vZGUuXG4gKi9cbmNsYXNzIEdycGNDb25uZWN0aW9uIHtcbiAgICBnZXQgc2hvdWxkUmVzb3VyY2VQYXRoQmVJbmNsdWRlZEluUmVxdWVzdCgpIHtcbiAgICAgICAgLy8gQm90aCBgaW52b2tlUlBDKClgIGFuZCBgaW52b2tlU3RyZWFtaW5nUlBDKClgIGlnbm9yZSB0aGVpciBgcGF0aGAgYXJndW1lbnRzLCBhbmQgZXhwZWN0XG4gICAgICAgIC8vIHRoZSBcInBhdGhcIiB0byBiZSBwYXJ0IG9mIHRoZSBnaXZlbiBgcmVxdWVzdGAuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm90b3MsIGRhdGFiYXNlSW5mbykge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSW5mbyA9IGRhdGFiYXNlSW5mbztcbiAgICAgICAgLy8gV2UgY2FjaGUgc3R1YnMgZm9yIHRoZSBtb3N0LXJlY2VudGx5LXVzZWQgdG9rZW4uXG4gICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IG51bGw7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gcHJvdG9zWydnb29nbGUnXVsnZmlyZXN0b3JlJ11bJ3YxJ107XG4gICAgICAgIHRoaXMuZGF0YWJhc2VQYXRoID0gYHByb2plY3RzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQucHJvamVjdElkfS9kYXRhYmFzZXMvJHtkYXRhYmFzZUluZm8uZGF0YWJhc2VJZC5kYXRhYmFzZX1gO1xuICAgIH1cbiAgICBlbnN1cmVBY3RpdmVTdHViKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkU3R1Yikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnQ3JlYXRpbmcgRmlyZXN0b3JlIHN0dWIuJyk7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuZGF0YWJhc2VJbmZvLnNzbFxuICAgICAgICAgICAgICAgID8gZ3JwYy5jcmVkZW50aWFscy5jcmVhdGVTc2woKVxuICAgICAgICAgICAgICAgIDogZ3JwYy5jcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gbmV3IHRoaXMuZmlyZXN0b3JlLkZpcmVzdG9yZSh0aGlzLmRhdGFiYXNlSW5mby5ob3N0LCBjcmVkZW50aWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU3R1YjtcbiAgICB9XG4gICAgaW52b2tlUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oeyBkYXRhYmFzZTogdGhpcy5kYXRhYmFzZVBhdGggfSwgcmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gaW52b2tlZCB3aXRoIHJlcXVlc3Q6YCwgcmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEsIChncnBjRXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGZhaWxlZCB3aXRoIGVycm9yOmAsIGdycGNFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBGaXJlc3RvcmVFcnJvcihtYXBDb2RlRnJvbVJwY0NvZGUoZ3JwY0Vycm9yLmNvZGUpLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBjb21wbGV0ZWQgd2l0aCByZXNwb25zZTpgLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgKHN0cmVhbWluZykgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0pO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBzdHViW3JwY05hbWVdKGpzb25SZXF1ZXN0LCBtZXRhZGF0YSk7XG4gICAgICAgIGxldCBjYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICR7cnBjTmFtZX0gJHtzdHJlYW1JZH0gcmVjZWl2ZWQgcmVzdWx0OmAsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXN1bHRzLmxlbmd0aCA9PT0gZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGNvbXBsZXRlZC5gKTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2tGaXJlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZ3JwY0Vycm9yKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGZhaWxlZCB3aXRoIGVycm9yOmAsIGdycGNFcnJvcik7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gbWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIFwibWV0aG9kXCIgaXMgYSBtb25zdGVyLiBTaG91bGQgYmUgcmVmYWN0b3JlZC5cbiAgICBvcGVuU3RyZWFtKHJwY05hbWUsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xuICAgICAgICBjb25zdCBncnBjU3RyZWFtID0gc3R1YltycGNOYW1lXShtZXRhZGF0YSk7XG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbkNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgZ3JwY1N0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbUJyaWRnZSh7XG4gICAgICAgICAgICBzZW5kRm46IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBzZW5kaW5nOmAsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncnBjU3RyZWFtLndyaXRlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvYmFibHkgbWVhbnMgd2UgZGlkbid0IGNvbmZvcm0gdG8gdGhlIHByb3RvLiAgTWFrZSBzdXJlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2cgdGhlIG1lc3NhZ2Ugd2Ugc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsdXJlIHNlbmRpbmc6JywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdFcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBjbG9zZWQgbG9jYWxseSB2aWEgY2xvc2UoKS5gKTtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9uQ29ubmVjdGVkU2VudCA9IGZhbHNlO1xuICAgICAgICBncnBjU3RyZWFtLm9uKCdkYXRhJywgKG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSByZWNlaXZlZDpgLCBtc2cpO1xuICAgICAgICAgICAgICAgIC8vIEVtdWxhdGUgdGhlIFwib25Db25uZWN0ZWRcIiBldmVudCB0aGF0IFdlYkNoYW5uZWxDb25uZWN0aW9uIHNlbmRzLlxuICAgICAgICAgICAgICAgIGlmICghb25Db25uZWN0ZWRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0ZWRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVuZGVkLmApO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVycm9yLiBDb2RlOmAsIGdycGNFcnJvci5jb2RlLCAnTWVzc2FnZTonLCBncnBjRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XG4gICAgICAgICAgICAgICAgY2xvc2UobmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIGdycGNFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBPcGVuaW5nIFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgYHRvICR7dGhpcy5kYXRhYmFzZUluZm8uaG9zdH1gKTtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTaW5jZSBncnBjIGhhcyBubyBleHBsaWNpdCBvcGVuIHN0YXR1cyAob3IgZG9lcyBpdD8pIHdlXG4gICAgICAgIC8vIHNpbXVsYXRlIGFuIG9uT3BlbiBpbiB0aGUgbmV4dCBsb29wIGFmdGVyIHRoZSBzdHJlYW0gaGFkIGl0J3MgbGlzdGVuZXJzXG4gICAgICAgIC8vIHJlZ2lzdGVyZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uY2FsbE9uT3BlbigpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFuZCBjbGVhbnMgdXAgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEdycGNDb25uZWN0aW9uLlxuICAgICAqIElmIGEgZ1JQQyBjbGllbnQgaGFzIGJlZW4gZ2VuZXJhdGVkIGZvciB0aGlzIGNvbm5lY3Rpb24sIHRoZSBnUlBDIGNsaWVudFxuICAgICAqIGlzIGNsb3NlZC4gRmFpbHVyZSB0byBjYWxsIHRlcm1pbmF0ZSBvbiBhIEdycGNDb25uZWN0aW9uIGNhbiByZXN1bHRcbiAgICAgKiBpbiBsZWFrZWQgcmVzb3VyY2VzIG9mIHRoZSBnUlBDIGNsaWVudC5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN0dWIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1Yi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBuZXN0ZWQgPSB7XG5cdGdvb2dsZToge1xuXHRcdG5lc3RlZDoge1xuXHRcdFx0cHJvdG9idWY6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNzaGFycF9uYW1lc3BhY2U6IFwiR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzXCIsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnaXRodWIuY29tL2dvbGFuZy9wcm90b2J1Zi9wdHlwZXMvd3JhcHBlcnNcIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5wcm90b2J1ZlwiLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyYXBwZXJzUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdQQlwiLFxuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0b3B0aW1pemVfZm9yOiBcIlNQRUVEXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0VGltZXN0YW1wOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0c2Vjb25kczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRuYW5vczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWxlRGVzY3JpcHRvclNldDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWxlRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwicGFja2FnZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5OiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHVibGljRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHdlYWtEZXBlbmRlbmN5OiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFja2VkOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRlbnVtVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1EZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzZXJ2aWNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmljZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzb3VyY2VDb2RlSW5mbzoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU291cmNlQ29kZUluZm9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzeW50YXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHREZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGREZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRuZXN0ZWRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25SYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9uZW9mRGVjbDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9uZW9mRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWVzc2FnZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUmVzZXJ2ZWRSYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHJlc2VydmVkTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdEV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJlc2VydmVkUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGREZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRudW1iZXI6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHlwZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGVOYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbmRlZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkluZGV4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzb25OYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0RPVUJMRTogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRkxPQVQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0lOVDY0OiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9VSU5UNjQ6IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0lOVDMyOiA1LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9GSVhFRDY0OiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9GSVhFRDMyOiA3LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CT09MOiA4LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TVFJJTkc6IDksXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0dST1VQOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfTUVTU0FHRTogMTEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0JZVEVTOiAxMixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDMyOiAxMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRU5VTTogMTQsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDMyOiAxNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0ZJWEVENjQ6IDE2LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TSU5UMzI6IDE3LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TSU5UNjQ6IDE4XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMYWJlbDoge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfT1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVFVSVJFRDogMixcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX1JFUEVBVEVEOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZkRlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9uZW9mT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1EZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1WYWx1ZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWV0aG9kRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmljZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2REZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpbnB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG91dHB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZE9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjbGllbnRTdHJlYW1pbmc6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzZXJ2ZXJTdHJlYW1pbmc6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWxlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGphdmFQYWNrYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhT3V0ZXJDbGFzc25hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFNdWx0aXBsZUZpbGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmF0ZUVxdWFsc0FuZEhhc2g6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjAsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YVN0cmluZ0NoZWNrVXRmODoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpbWl6ZUZvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3B0aW1pemVNb2RlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDksXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1BFRURcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Z29QYWNrYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2NHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YUdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRweUdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjRW5hYmxlQXJlbmFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDMxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9iamNDbGFzc1ByZWZpeDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNzaGFycE5hbWVzcGFjZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQzOCxcblx0XHRcdFx0XHRcdFx0XHQzOFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE9wdGltaXplTW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0U1BFRUQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRDT0RFX1NJWkU6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMSVRFX1JVTlRJTUU6IDNcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE1lc3NhZ2VPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZVNldFdpcmVGb3JtYXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRub1N0YW5kYXJkRGVzY3JpcHRvckFjY2Vzc29yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1hcEVudHJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXJ2ZWQ6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDgsXG5cdFx0XHRcdFx0XHRcdFx0OFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGaWVsZE9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRjdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ1R5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCJTVFJJTkdcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGFja2VkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0anN0eXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJKU1R5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNixcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCJKU19OT1JNQUxcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGF6eToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ0LFxuXHRcdFx0XHRcdFx0XHRcdDRcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRDVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0U1RSSU5HOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09SRDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklOR19QSUVDRTogMlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0SlNUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRKU19OT1JNQUw6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRKU19TVFJJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRKU19OVU1CRVI6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE9uZW9mT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbGxvd0FsaWFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNlcnZpY2VPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE1ldGhvZE9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDMzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJOYW1lUGFydFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGlkZW50aWZpZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVJbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVJbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkb3VibGVWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0YWdncmVnYXRlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TmFtZVBhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVxdWlyZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpc0V4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxvY2F0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRMb2NhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzcGFuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxlYWRpbmdDb21tZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYWlsaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nRGV0YWNoZWRDb21tZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRHZW5lcmF0ZWRDb2RlSW5mbzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGFubm90YXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBbm5vdGF0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRBbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNvdXJjZUZpbGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWdpbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFN0cnVjdDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0a2luZDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcIm51bGxWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJudW1iZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJib29sVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibGlzdFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bnVsbFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJOdWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRudW1iZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cnVjdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3RcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRsaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkxpc3RWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdE51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdE5VTExfVkFMVUU6IDBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdExpc3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW1wdHk6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmxvYXRWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJmbG9hdFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRVSW50NjRWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJ1aW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDMyVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qm9vbFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJpbmdWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRCeXRlc1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0QW55OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dHlwZVVybDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcmVzdG9yZToge1xuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHR2MToge1xuXHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5DbG91ZC5GaXJlc3RvcmUuVjFcIixcblx0XHRcdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL2ZpcmVzdG9yZS92MTtmaXJlc3RvcmVcIixcblx0XHRcdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiV3JpdGVQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5maXJlc3RvcmUudjFcIixcblx0XHRcdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR0NGU1wiLFxuXHRcdFx0XHRcdFx0XHRwaHBfbmFtZXNwYWNlOiBcIkdvb2dsZVxcXFxDbG91ZFxcXFxGaXJlc3RvcmVcXFxcVjFcIixcblx0XHRcdFx0XHRcdFx0cnVieV9wYWNrYWdlOiBcIkdvb2dsZTo6Q2xvdWQ6OkZpcmVzdG9yZTo6VjFcIlxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRBZ2dyZWdhdGlvblJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWdncmVnYXRlRmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJpdFNlcXVlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRtYXA6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZGRpbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Qmxvb21GaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGJpdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJCaXRTZXF1ZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGhhc2hDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudE1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UHJlY29uZGl0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25kaXRpb25UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJleGlzdHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVwZGF0ZVRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VHJhbnNhY3Rpb25PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFdyaXRlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRPbmx5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUmVhZFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXRyeVRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRPbmx5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImJvb2xlYW5WYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiaW50ZWdlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb3VibGVWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGltZXN0YW1wVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cmluZ1ZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJieXRlc1ZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWZlcmVuY2VWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZ2VvUG9pbnRWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWFwVmFsdWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ym9vbGVhblZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGludGVnZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0aW1lc3RhbXBWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDE3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ynl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZmVyZW5jZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvUG9pbnRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS50eXBlLkxhdExuZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA5XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFwVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNYXBWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QXJyYXlWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TWFwVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRGaXJlc3RvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmRlZmF1bHRfaG9zdClcIjogXCJmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb21cIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkub2F1dGhfc2NvcGVzKVwiOiBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0saHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kYXRhc3RvcmVcIlxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bWV0aG9kczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiR2V0RG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5nZXRcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdldDogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3REb2N1bWVudHNSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5nZXRcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfS97Y29sbGVjdGlvbl9pZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdldDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfS97Y29sbGVjdGlvbl9pZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVwZGF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlVwZGF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucGF0Y2hcIjogXCIvdjEve2RvY3VtZW50Lm5hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0Y2g6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRvY3VtZW50LHVwZGF0ZV9tYXNrXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHREZWxldGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJEZWxldGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcImdvb2dsZS5wcm90b2J1Zi5FbXB0eVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5kZWxldGVcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwibmFtZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjogXCIvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoR2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmVnaW5UcmFuc2FjdGlvblJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmVnaW5UcmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2VcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmVnaW5UcmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRDb21taXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQ29tbWl0UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQ29tbWl0UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmNvbW1pdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2Usd3JpdGVzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmNvbW1pdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Um9sbGJhY2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUm9sbGJhY2tSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOnJvbGxiYWNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHRyYW5zYWN0aW9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJSdW5RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlJ1blF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJ1bkFnZ3JlZ2F0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpydW5BZ2dyZWdhdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlBhcnRpdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0V3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiV3JpdGVSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6d3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdGVuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3RlblJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RlblJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpsaXN0ZW5cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaFdyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmF0Y2hXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q3JlYXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQ3JlYXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKip9L3tjb2xsZWN0aW9uX2lkfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRHZXREb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNob3dNaXNzaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZU1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREZWxldGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZvdW5kXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaXNzaW5nXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3VuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENvbW1pdFJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJvbGxiYWNrUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRza2lwcGVkUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25SZXN1bHRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnRpdGlvbkNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmVhbVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYWRkVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVUYXJnZXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhZGRUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdGVuUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGFyZ2V0Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnREZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50UmVtb3ZlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4aXN0ZW5jZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJxdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlc3VtZVRva2VuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJRdWVyeVRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50c1RhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9uY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhwZWN0ZWRDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHREb2N1bWVudHNUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRRdWVyeVRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZFF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0Q2hhbmdlVHlwZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXVzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5ycGMuU3RhdHVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdW1lVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRUYXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE5PX0NIQU5HRTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBREQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVNT1ZFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENVUlJFTlQ6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVTRVQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VTaXplOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0U3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcm9qZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnJvbToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ29sbGVjdGlvblNlbGVjdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d2hlcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmRlckJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcmRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0QXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRBdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1cnNvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGltaXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRDb2xsZWN0aW9uU2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFsbERlc2NlbmRhbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlclR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY29tcG9zaXRlRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmllbGRGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1bmFyeUZpbHRlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21wb3NpdGVGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ29tcG9zaXRlRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmFyeUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmFyeUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRDb21wb3NpdGVGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3A6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3BlcmF0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1BFUkFUT1JfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFORDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1I6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRGaWVsZEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU46IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdExFU1NfVEhBTl9PUl9FUVVBTDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRHUkVBVEVSX1RIQU5fT1JfRVFVQUw6IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEVRVUFMOiA1LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT1RfRVFVQUw6IDYsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TOiA3LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJTjogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0QVJSQVlfQ09OVEFJTlNfQU5ZOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT1RfSU46IDEwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0VW5hcnlGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlcmFuZFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmllbGRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3A6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3BlcmF0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1BFUkFUT1JfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05BTjogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTlVMTDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTk9UX05BTjogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTk9UX05VTEw6IDVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRPcmRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEaXJlY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRSZWZlcmVuY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRQYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRQcm9qZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHREaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0RElSRUNUSU9OX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFTQ0VORElORzogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRERVNDRU5ESU5HOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZFF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YWdncmVnYXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBZ2dyZWdhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRBZ2dyZWdhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJjb3VudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN1bVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImF2Z1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb3VudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN1bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXZnXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWxpYXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Q291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1cFRvOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFN1bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEF2Zzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEN1cnNvcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJlZm9yZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVwZGF0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ2ZXJpZnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRyYW5zZm9ybVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dmVyaWZ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVHJhbnNmb3Jtczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRUcmFuc2Zvcm0uRmllbGRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50VHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkVHJhbnNmb3Jtczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRUcmFuc2Zvcm1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRUcmFuc2Zvcm06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzZXRUb1NlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiaW5jcmVtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWF4aW11bVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1pbmltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJhcHBlbmRNaXNzaW5nRWxlbWVudHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVBbGxGcm9tQXJyYXlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRQYXRoOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRvU2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhpbXVtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWluaW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFwcGVuZE1pc3NpbmdFbGVtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlQWxsRnJvbUFycmF5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTZXJ2ZXJWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFNFUlZFUl9WQUxVRV9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVRVUVTVF9USU1FOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1SZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50RGVsZXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFJlbW92ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RXhpc3RlbmNlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVuY2hhbmdlZE5hbWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQmxvb21GaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhcGk6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9hcGkvYW5ub3RhdGlvbnM7YW5ub3RhdGlvbnNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkh0dHBQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLmFwaVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdBUElcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdGh0dHA6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdGlkOiA3MjI5NTcyOCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9uc1wiXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0cnVsZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEh0dHBSdWxlOiB7XG5cdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcImdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJwdXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicG9zdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicGF0Y2hcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Z2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwdXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjdXN0b206IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1c3RvbUh0dHBQYXR0ZXJuXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxCaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEN1c3RvbUh0dHBQYXR0ZXJuOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0a2luZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWV0aG9kU2lnbmF0dXJlOiB7XG5cdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTEsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGVmYXVsdEhvc3Q6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA0OSxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b2F1dGhTY29wZXM6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1MCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUuYXBpLkZpZWxkQmVoYXZpb3JcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUyLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdEZJRUxEX0JFSEFWSU9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRPUFRJT05BTDogMSxcblx0XHRcdFx0XHRcdFx0UkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdE9VVFBVVF9PTkxZOiAzLFxuXHRcdFx0XHRcdFx0XHRJTlBVVF9PTkxZOiA0LFxuXHRcdFx0XHRcdFx0XHRJTU1VVEFCTEU6IDUsXG5cdFx0XHRcdFx0XHRcdFVOT1JERVJFRF9MSVNUOiA2LFxuXHRcdFx0XHRcdFx0XHROT05fRU1QVFlfREVGQVVMVDogN1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHR5cGU6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3R5cGUvbGF0bG5nO2xhdGxuZ1wiLFxuXHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiTGF0TG5nUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS50eXBlXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR1RQXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0TGF0TG5nOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bGF0aXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxvbmdpdHVkZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJwYzoge1xuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZSxcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvcnBjL3N0YXR1cztzdGF0dXNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIlN0YXR1c1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucnBjXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiUlBDXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0U3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y29kZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkFueVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG52YXIgcHJvdG9zID0ge1xuXHRuZXN0ZWQ6IG5lc3RlZFxufTtcblxudmFyIHByb3RvcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5lc3RlZDogbmVzdGVkLFxuICAnZGVmYXVsdCc6IHByb3Rvc1xufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVXNlZCBieSB0ZXN0cyBzbyB3ZSBjYW4gbWF0Y2ggQGdycGMvcHJvdG8tbG9hZGVyIGJlaGF2aW9yLiAqL1xuY29uc3QgcHJvdG9Mb2FkZXJPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICBvbmVvZnM6IGZhbHNlXG59O1xuLyoqXG4gKiBMb2FkcyB0aGUgcHJvdG9jb2wgYnVmZmVyIGRlZmluaXRpb25zIGZvciBGaXJlc3RvcmUuXG4gKlxuICogQHJldHVybnMgVGhlIEdycGNPYmplY3QgcmVwcmVzZW50aW5nIG91ciBwcm90b3MuXG4gKi9cbmZ1bmN0aW9uIGxvYWRQcm90b3MoKSB7XG4gICAgY29uc3QgcGFja2FnZURlZmluaXRpb24gPSBwcm90b0xvYWRlci5mcm9tSlNPTihwcm90b3MkMSwgcHJvdG9Mb2FkZXJPcHRpb25zKTtcbiAgICByZXR1cm4gZ3JwYy5sb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZmluaXRpb24pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIExvYWRzIHRoZSBHUlBDIHN0YWNrICovXG5mdW5jdGlvbiBuZXdDb25uZWN0aW9uKGRhdGFiYXNlSW5mbykge1xuICAgIGNvbnN0IHByb3RvcyA9IGxvYWRQcm90b3MoKTtcbiAgICByZXR1cm4gbmV3IEdycGNDb25uZWN0aW9uKHByb3RvcywgZGF0YWJhc2VJbmZvKTtcbn1cbi8qKiBSZXR1cm4gdGhlIFBsYXRmb3JtLXNwZWNpZmljIGNvbm5lY3Rpdml0eSBtb25pdG9yLiAqL1xuZnVuY3Rpb24gbmV3Q29ubmVjdGl2aXR5TW9uaXRvcigpIHtcbiAgICByZXR1cm4gbmV3IE5vb3BDb25uZWN0aXZpdHlNb25pdG9yKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVGhlIFBsYXRmb3JtJ3MgJ3dpbmRvdycgaW1wbGVtZW50YXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5VU0VfTU9DS19QRVJTSVNURU5DRSA9PT0gJ1lFUycpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKiBUaGUgUGxhdGZvcm0ncyAnZG9jdW1lbnQnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBKc29uUHJvdG9TZXJpYWxpemVyKGRhdGFiYXNlSWQsIC8qIHVzZVByb3RvM0pzb249ICovIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckOCA9ICdFeHBvbmVudGlhbEJhY2tvZmYnO1xuLyoqXG4gKiBJbml0aWFsIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgYW4gZXJyb3IuXG4gKiBTZXQgdG8gMXMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9hcGlzL2Rlc2lnbi9lcnJvcnMuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAxLjU7XG4vKiogTWF4aW11bSBiYWNrb2ZmIHRpbWUgaW4gbWlsbGlzZWNvbmRzICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TID0gNjAgKiAxMDAwO1xuLyoqXG4gKiBBIGhlbHBlciBmb3IgcnVubmluZyBkZWxheWVkIHRhc2tzIGZvbGxvd2luZyBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGN1cnZlXG4gKiBiZXR3ZWVuIGF0dGVtcHRzLlxuICpcbiAqIEVhY2ggZGVsYXkgaXMgbWFkZSB1cCBvZiBhIFwiYmFzZVwiIGRlbGF5IHdoaWNoIGZvbGxvd3MgdGhlIGV4cG9uZW50aWFsXG4gKiBiYWNrb2ZmIGN1cnZlLCBhbmQgYSArLy0gNTAlIFwiaml0dGVyXCIgdGhhdCBpcyBjYWxjdWxhdGVkIGFuZCBhZGRlZCB0byB0aGVcbiAqIGJhc2UgZGVsYXkuIFRoaXMgcHJldmVudHMgY2xpZW50cyBmcm9tIGFjY2lkZW50YWxseSBzeW5jaHJvbml6aW5nIHRoZWlyXG4gKiBkZWxheXMgY2F1c2luZyBzcGlrZXMgb2YgbG9hZCB0byB0aGUgYmFja2VuZC5cbiAqL1xuY2xhc3MgRXhwb25lbnRpYWxCYWNrb2ZmIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgQXN5bmNRdWV1ZSB0byBydW4gYmFja29mZiBvcGVyYXRpb25zIG9uLlxuICAgICAqL1xuICAgIHF1ZXVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdG8gdXNlIHdoZW4gc2NoZWR1bGluZyBiYWNrb2ZmIG9wZXJhdGlvbnMgb24gdGhlIEFzeW5jUXVldWUuXG4gICAgICovXG4gICAgdGltZXJJZCwgXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZGVsYXkgKHVzZWQgYXMgdGhlIGJhc2UgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5IGF0dGVtcHQpLlxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXG4gICAgICogbGl0dGxlIGFzIDAuNSppbml0aWFsRGVsYXlNcy5cbiAgICAgKi9cbiAgICBpbml0aWFsRGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbGllciB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBleHRlbmRlZCBiYXNlIGRlbGF5IGFmdGVyIGVhY2hcbiAgICAgKiBhdHRlbXB0LlxuICAgICAqL1xuICAgIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBiYXNlIGRlbGF5IGFmdGVyIHdoaWNoIG5vIGZ1cnRoZXIgYmFja29mZiBpcyBwZXJmb3JtZWQuXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcbiAgICAgKiBtdWNoIGFzIDEuNSptYXhEZWxheU1zLlxuICAgICAqL1xuICAgIG1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IGluaXRpYWxEZWxheU1zO1xuICAgICAgICB0aGlzLmJhY2tvZmZGYWN0b3IgPSBiYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLm1heERlbGF5TXMgPSBtYXhEZWxheU1zO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgbGFzdCBiYWNrb2ZmIGF0dGVtcHQsIGFzIGVwb2NoIG1pbGxpc2Vjb25kcy4gKi9cbiAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheS5cbiAgICAgKlxuICAgICAqIFRoZSB2ZXJ5IG5leHQgYmFja29mZkFuZFdhaXQoKSB3aWxsIGhhdmUgbm8gZGVsYXkuIElmIGl0IGlzIGNhbGxlZCBhZ2FpblxuICAgICAqIChpLmUuIGR1ZSB0byBhbiBlcnJvciksIGluaXRpYWxEZWxheU1zIChwbHVzIGppdHRlcikgd2lsbCBiZSB1c2VkLCBhbmRcbiAgICAgKiBzdWJzZXF1ZW50IG9uZXMgd2lsbCBpbmNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIGJhY2tvZmZGYWN0b3IuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byB0aGUgbWF4aW11bSBkZWxheSAoZS5nLiBmb3IgdXNlIGFmdGVyIGFcbiAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IpLlxuICAgICAqL1xuICAgIHJlc2V0VG9NYXgoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBjdXJyZW50RGVsYXlNcywgYW5kIGluY3JlYXNlcyB0aGVcbiAgICAgKiBkZWxheSBmb3IgYW55IHN1YnNlcXVlbnQgYXR0ZW1wdHMuIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgYmFja29mZiBvcGVyYXRpb25cbiAgICAgKiBhbHJlYWR5LCBpdCB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGJhY2tvZmZBbmRSdW4ob3ApIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uLlxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAvLyBGaXJzdCBzY2hlZHVsZSB1c2luZyB0aGUgY3VycmVudCBiYXNlICh3aGljaCBtYXkgYmUgMCBhbmQgc2hvdWxkIGJlXG4gICAgICAgIC8vIGhvbm9yZWQgYXMgc3VjaCkuXG4gICAgICAgIGNvbnN0IGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyA9IE1hdGguZmxvb3IodGhpcy5jdXJyZW50QmFzZU1zICsgdGhpcy5qaXR0ZXJEZWxheU1zKCkpO1xuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IGxhc3RBdHRlbXB0VGltZSBiZWluZyBpbiB0aGUgZnV0dXJlIGR1ZSB0byBhIGNsb2NrIGNoYW5nZS5cbiAgICAgICAgY29uc3QgZGVsYXlTb0Zhck1zID0gTWF0aC5tYXgoMCwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdEF0dGVtcHRUaW1lKTtcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgYmFja29mZiBkZWxheSBhbHJlYWR5IGJlaW5nIHBhc3QuXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RlbGF5TXMgPSBNYXRoLm1heCgwLCBkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMgLSBkZWxheVNvRmFyTXMpO1xuICAgICAgICBpZiAocmVtYWluaW5nRGVsYXlNcyA+IDApIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOCwgYEJhY2tpbmcgb2ZmIGZvciAke3JlbWFpbmluZ0RlbGF5TXN9IG1zIGAgK1xuICAgICAgICAgICAgICAgIGAoYmFzZSBkZWxheTogJHt0aGlzLmN1cnJlbnRCYXNlTXN9IG1zLCBgICtcbiAgICAgICAgICAgICAgICBgZGVsYXkgd2l0aCBqaXR0ZXI6ICR7ZGVzaXJlZERlbGF5V2l0aEppdHRlck1zfSBtcywgYCArXG4gICAgICAgICAgICAgICAgYGxhc3QgYXR0ZW1wdDogJHtkZWxheVNvRmFyTXN9IG1zIGFnbylgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy50aW1lcklkLCByZW1haW5pbmdEZWxheU1zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gb3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFwcGx5IGJhY2tvZmYgZmFjdG9yIHRvIGRldGVybWluZSBuZXh0IGRlbGF5IGFuZCBlbnN1cmUgaXQgaXMgd2l0aGluXG4gICAgICAgIC8vIGJvdW5kcy5cbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zICo9IHRoaXMuYmFja29mZkZhY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA8IHRoaXMuaW5pdGlhbERlbGF5TXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMuaW5pdGlhbERlbGF5TXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA+IHRoaXMubWF4RGVsYXlNcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5tYXhEZWxheU1zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNraXBCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lclByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLnNraXBEZWxheSgpO1xuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWy1jdXJyZW50QmFzZU1zLzIsIGN1cnJlbnRCYXNlTXMvMl0gKi9cbiAgICBqaXR0ZXJEZWxheU1zKCkge1xuICAgICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5jdXJyZW50QmFzZU1zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNyA9ICdQZXJzaXN0ZW50U3RyZWFtJztcbi8qKiBUaGUgdGltZSBhIHN0cmVhbSBzdGF5cyBvcGVuIGFmdGVyIGl0IGlzIG1hcmtlZCBpZGxlLiAqL1xuY29uc3QgSURMRV9USU1FT1VUX01TID0gNjAgKiAxMDAwO1xuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gdW50aWwgd2UgY29uc2lkZXIgaXQgaGVhbHRoeS4gKi9cbmNvbnN0IEhFQUxUSFlfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcbi8qKlxuICogQSBQZXJzaXN0ZW50U3RyZWFtIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc3RyZWFtaW5nIFJQQ1xuICogdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLiBJdCdzIGJ1aWx0IG9uIHRvcCBvZiB0aGUgY29ubmVjdGlvbnMgb3duIHN1cHBvcnRcbiAqIGZvciBzdHJlYW1pbmcgUlBDcywgYW5kIGFkZHMgc2V2ZXJhbCBjcml0aWNhbCBmZWF0dXJlcyBmb3Igb3VyIGNsaWVudHM6XG4gKlxuICogICAtIEV4cG9uZW50aWFsIGJhY2tvZmYgb24gZmFpbHVyZVxuICogICAtIEF1dGhlbnRpY2F0aW9uIHZpYSBDcmVkZW50aWFsc1Byb3ZpZGVyXG4gKiAgIC0gRGlzcGF0Y2hpbmcgYWxsIGNhbGxiYWNrcyBpbnRvIHRoZSBzaGFyZWQgd29ya2VyIHF1ZXVlXG4gKiAgIC0gQ2xvc2luZyBpZGxlIHN0cmVhbXMgYWZ0ZXIgNjAgc2Vjb25kcyBvZiBpbmFjdGl2aXR5XG4gKlxuICogU3ViY2xhc3NlcyBvZiBQZXJzaXN0ZW50U3RyZWFtIGltcGxlbWVudCBzZXJpYWxpemF0aW9uIG9mIG1vZGVscyB0byBhbmRcbiAqIGZyb20gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3RvY29sIGJ1ZmZlcnMgZm9yIGEgc3BlY2lmaWNcbiAqIHN0cmVhbWluZyBSUEMuXG4gKlxuICogIyMgU3RhcnRpbmcgYW5kIFN0b3BwaW5nXG4gKlxuICogU3RyZWFtaW5nIFJQQ3MgYXJlIHN0YXRlZnVsIGFuZCBuZWVkIHRvIGJlIHN0YXJ0KCllZCBiZWZvcmUgbWVzc2FnZXMgY2FuXG4gKiBiZSBzZW50IGFuZCByZWNlaXZlZC4gVGhlIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSBvbk9wZW4oKSBmdW5jdGlvblxuICogb2YgdGhlIGxpc3RlbmVyIG9uY2UgdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgcmVxdWVzdHMuXG4gKlxuICogU2hvdWxkIGEgc3RhcnQoKSBmYWlsLCBQZXJzaXN0ZW50U3RyZWFtIHdpbGwgY2FsbCB0aGUgcmVnaXN0ZXJlZCBvbkNsb3NlKClcbiAqIGxpc3RlbmVyIHdpdGggYSBGaXJlc3RvcmVFcnJvciBpbmRpY2F0aW5nIHdoYXQgd2VudCB3cm9uZy5cbiAqXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gY2FuIGJlIHN0YXJ0ZWQgYW5kIHN0b3BwZWQgcmVwZWF0ZWRseS5cbiAqXG4gKiBHZW5lcmljIHR5cGVzOlxuICogIFNlbmRUeXBlOiBUaGUgdHlwZSBvZiB0aGUgb3V0Z29pbmcgbWVzc2FnZSBvZiB0aGUgdW5kZXJseWluZ1xuICogICAgY29ubmVjdGlvbiBzdHJlYW1cbiAqICBSZWNlaXZlVHlwZTogVGhlIHR5cGUgb2YgdGhlIGluY29taW5nIG1lc3NhZ2Ugb2YgdGhlIHVuZGVybHlpbmdcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXG4gKiAgTGlzdGVuZXJUeXBlOiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNhbGxiYWNrc1xuICovXG5jbGFzcyBQZXJzaXN0ZW50U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQsIGlkbGVUaW1lcklkLCBoZWFsdGhUaW1lcklkLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVySWQgPSBpZGxlVGltZXJJZDtcbiAgICAgICAgdGhpcy5oZWFsdGhUaW1lcklkID0gaGVhbHRoVGltZXJJZDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlciA9IGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciA9IGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2xvc2UgY291bnQgdGhhdCdzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgdGhlIHN0cmVhbSBpcyBjbG9zZWQ7IHVzZWQgYnlcbiAgICAgICAgICogZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcigpIHRvIGludmFsaWRhdGUgY2FsbGJhY2tzIHRoYXQgaGFwcGVuIGFmdGVyXG4gICAgICAgICAqIGNsb3NlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgcmVzcG9uc2UgbWVzc2FnZXMgcmVjZWl2ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHF1ZXVlLCBjb25uZWN0aW9uVGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBzdGFydCgpIGhhcyBiZWVuIGNhbGxlZCBhbmQgbm8gZXJyb3IgaGFzIG9jY3VycmVkLiBUcnVlXG4gICAgICogaW5kaWNhdGVzIHRoZSBzdHJlYW0gaXMgb3BlbiBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nICh3aGljaFxuICAgICAqIGVuY29tcGFzc2VzIHJlc3BlY3RpbmcgYmFja29mZiwgZ2V0dGluZyBhdXRoIHRva2VucywgYW5kIHN0YXJ0aW5nIHRoZVxuICAgICAqIGFjdHVhbCBSUEMpLiBVc2UgaXNPcGVuKCkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzdHJlYW0gaXMgb3BlbiBhbmQgcmVhZHkgZm9yXG4gICAgICogb3V0Ym91bmQgcmVxdWVzdHMuXG4gICAgICovXG4gICAgaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSA1IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5CYWNrb2ZmICovIHx8XG4gICAgICAgICAgICB0aGlzLmlzT3BlbigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIFJQQyBpcyBvcGVuICh0aGUgb25PcGVuKCkgbGlzdGVuZXIgaGFzIGJlZW5cbiAgICAgKiBjYWxsZWQpIGFuZCB0aGUgc3RyZWFtIGlzIHJlYWR5IGZvciBvdXRib3VuZCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gMyAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSGVhbHRoeSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgUlBDLiBPbmx5IGFsbG93ZWQgaWYgaXNTdGFydGVkKCkgcmV0dXJucyBmYWxzZS4gVGhlIHN0cmVhbSBpc1xuICAgICAqIG5vdCBpbW1lZGlhdGVseSByZWFkeSBmb3IgdXNlOiBvbk9wZW4oKSB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgUlBDIGlzXG4gICAgICogcmVhZHkgZm9yIG91dGJvdW5kIHJlcXVlc3RzLCBhdCB3aGljaCBwb2ludCBpc09wZW4oKSB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqXG4gICAgICogV2hlbiBzdGFydCByZXR1cm5zLCBpc1N0YXJ0ZWQoKSB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ291bnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gNCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuRXJyb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybUJhY2tvZmYoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIFJQQy4gVGhpcyBjYWxsIGlzIGlkZW1wb3RlbnQgYW5kIGFsbG93ZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IGlzU3RhcnRlZCgpIHN0YXRlLlxuICAgICAqXG4gICAgICogV2hlbiBzdG9wIHJldHVybnMsIGlzU3RhcnRlZCgpIGFuZCBpc09wZW4oKSB3aWxsIGJvdGggcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFmdGVyIGFuIGVycm9yIHRoZSBzdHJlYW0gd2lsbCB1c3VhbGx5IGJhY2sgb2ZmIG9uIHRoZSBuZXh0IGF0dGVtcHQgdG9cbiAgICAgKiBzdGFydCBpdC4gSWYgdGhlIGVycm9yIHdhcnJhbnRzIGFuIGltbWVkaWF0ZSByZXN0YXJ0IG9mIHRoZSBzdHJlYW0sIHRoZVxuICAgICAqIHNlbmRlciBjYW4gdXNlIHRoaXMgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVjZWl2ZXIgc2hvdWxkIG5vdCBiYWNrIG9mZi5cbiAgICAgKlxuICAgICAqIEVhY2ggZXJyb3Igd2lsbCBjYWxsIHRoZSBvbkNsb3NlKCkgbGlzdGVuZXIuIFRoYXQgZnVuY3Rpb24gY2FuIGRlY2lkZSB0b1xuICAgICAqIGluaGliaXQgYmFja29mZiBpZiByZXF1aXJlZC5cbiAgICAgKi9cbiAgICBpbmhpYml0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGlzIHN0cmVhbSBhcyBpZGxlLiBJZiBubyBmdXJ0aGVyIGFjdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiB0aGVcbiAgICAgKiBzdHJlYW0gZm9yIG9uZSBtaW51dGUsIHRoZSBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlIGl0c2VsZiBhbmRcbiAgICAgKiBub3RpZnkgdGhlIHN0cmVhbSdzIG9uQ2xvc2UoKSBoYW5kbGVyIHdpdGggU3RhdHVzLk9LLiBUaGUgc3RyZWFtIHdpbGwgdGhlblxuICAgICAqIGJlIGluIGEgIWlzU3RhcnRlZCgpIHN0YXRlLCByZXF1aXJpbmcgdGhlIGNhbGxlciB0byBzdGFydCB0aGUgc3RyZWFtIGFnYWluXG4gICAgICogYmVmb3JlIGZ1cnRoZXIgdXNlLlxuICAgICAqXG4gICAgICogT25seSBzdHJlYW1zIHRoYXQgYXJlIGluIHN0YXRlICdPcGVuJyBjYW4gYmUgbWFya2VkIGlkbGUsIGFzIGFsbCBvdGhlclxuICAgICAqIHN0YXRlcyBpbXBseSBwZW5kaW5nIG5ldHdvcmsgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBtYXJrSWRsZSgpIHtcbiAgICAgICAgLy8gU3RhcnRzIHRoZSBpZGxlIHRpbWUgaWYgd2UgYXJlIGluIHN0YXRlICdPcGVuJyBhbmQgYXJlIG5vdCB5ZXQgYWxyZWFkeVxuICAgICAgICAvLyBydW5uaW5nIGEgdGltZXIgKGluIHdoaWNoIGNhc2UgdGhlIHByZXZpb3VzIGlkbGUgdGltZW91dCBzdGlsbCBhcHBsaWVzKS5cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkgJiYgdGhpcy5pZGxlVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLmlkbGVUaW1lcklkLCBJRExFX1RJTUVPVVRfTVMsICgpID0+IHRoaXMuaGFuZGxlSWRsZUNsb3NlVGltZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uICovXG4gICAgc2VuZFJlcXVlc3QobXNnKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsSWRsZUNoZWNrKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnNlbmQobXNnKTtcbiAgICB9XG4gICAgLyoqIENhbGxlZCBieSB0aGUgaWRsZSB0aW1lciB3aGVuIHRoZSBzdHJlYW0gc2hvdWxkIGNsb3NlIGR1ZSB0byBpbmFjdGl2aXR5LiAqL1xuICAgIGFzeW5jIGhhbmRsZUlkbGVDbG9zZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aW1pbmcgb3V0IGFuIGlkbGUgc3RyZWFtIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGZvcmNlIHRoZSBzdHJlYW0gaW50byBiYWNrb2ZmIHdoZW5cbiAgICAgICAgICAgIC8vIGl0IHJlc3RhcnRzIHNvIHNldCB0aGUgc3RyZWFtIHN0YXRlIHRvIEluaXRpYWwgaW5zdGVhZCBvZiBFcnJvci5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNYXJrcyB0aGUgc3RyZWFtIGFzIGFjdGl2ZSBhZ2Fpbi4gKi9cbiAgICBjYW5jZWxJZGxlQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbmNlbHMgdGhlIGhlYWx0aCBjaGVjayBkZWxheWVkIG9wZXJhdGlvbi4gKi9cbiAgICBjYW5jZWxIZWFsdGhDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2spIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwIGFzIG5lY2Vzc2FyeTpcbiAgICAgKlxuICAgICAqICogY2xvc2VzIHRoZSB1bmRlcmx5aW5nIEdSUEMgc3RyZWFtO1xuICAgICAqICogY2FsbHMgdGhlIG9uQ2xvc2UgaGFuZGxlciB3aXRoIHRoZSBnaXZlbiAnZXJyb3InO1xuICAgICAqICogc2V0cyBpbnRlcm5hbCBzdHJlYW0gc3RhdGUgdG8gJ2ZpbmFsU3RhdGUnO1xuICAgICAqICogYWRqdXN0cyB0aGUgYmFja29mZiB0aW1lciBiYXNlZCBvbiB0aGUgZXJyb3JcbiAgICAgKlxuICAgICAqIEEgbmV3IHN0cmVhbSBjYW4gYmUgb3BlbmVkIGJ5IGNhbGxpbmcgc3RhcnQoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaW5hbFN0YXRlIC0gdGhlIGludGVuZGVkIHN0YXRlIG9mIHRoZSBzdHJlYW0gYWZ0ZXIgY2xvc2luZy5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSB0aGUgZXJyb3IgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCB3aXRoLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKGZpbmFsU3RhdGUsIGVycm9yKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgb3V0c3RhbmRpbmcgdGltZXJzICh0aGV5J3JlIGd1YXJhbnRlZWQgbm90IHRvIGV4ZWN1dGUpLlxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xuICAgICAgICB0aGlzLmNhbmNlbEhlYWx0aENoZWNrKCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5jYW5jZWwoKTtcbiAgICAgICAgLy8gSW52YWxpZGF0ZXMgYW55IHN0cmVhbS1yZWxhdGVkIGNhbGxiYWNrcyAoZS5nLiBmcm9tIGF1dGggb3IgdGhlXG4gICAgICAgIC8vIHVuZGVybHlpbmcgc3RyZWFtKSwgZ3VhcmFudGVlaW5nIHRoZXkgd29uJ3QgZXhlY3V0ZS5cbiAgICAgICAgdGhpcy5jbG9zZUNvdW50Kys7XG4gICAgICAgIGlmIChmaW5hbFN0YXRlICE9PSA0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLykge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBjbG9zZSBlbnN1cmUgd2UgZG9uJ3QgZGVsYXkgb3VyIG5leHQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQpIHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgZXJyb3IuIChQcm9iYWJseSBlaXRoZXIgJ3F1b3RhIGV4Y2VlZGVkJyBvciAnbWF4IHF1ZXVlIGxlbmd0aCByZWFjaGVkJy4pXG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdVc2luZyBtYXhpbXVtIGJhY2tvZmYgZGVsYXkgdG8gcHJldmVudCBvdmVybG9hZGluZyB0aGUgYmFja2VuZC4nKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldFRvTWF4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiZcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKSB7XG4gICAgICAgICAgICAvLyBcInVuYXV0aGVudGljYXRlZFwiIGVycm9yIG1lYW5zIHRoZSB0b2tlbiB3YXMgcmVqZWN0ZWQuIFRoaXMgc2hvdWxkIHJhcmVseVxuICAgICAgICAgICAgLy8gaGFwcGVuIHNpbmNlIGJvdGggQXV0aCBhbmQgQXBwQ2hlY2sgZW5zdXJlIGEgc3VmZmljaWVudCBUVEwgd2hlbiB3ZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhIHRva2VuLiBJZiBhIHVzZXIgbWFudWFsbHkgcmVzZXRzIHRoZWlyIHN5c3RlbSBjbG9jayB0aGlzIGNhblxuICAgICAgICAgICAgLy8gZmFpbCwgaG93ZXZlci4gSW4gdGhpcyBjYXNlLCB3ZSBzaG91bGQgZ2V0IGEgQ29kZS5VTkFVVEhFTlRJQ0FURUQgZXJyb3JcbiAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSByZWNlaXZlZCB0aGUgZmlyc3QgbWVzc2FnZSBhbmQgd2UgbmVlZCB0byBpbnZhbGlkYXRlIHRoZSB0b2tlblxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgd2UgZmV0Y2ggYSBuZXcgdG9rZW4uXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGJlY2F1c2Ugd2UgYXJlIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIGV2ZW50cy5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc3RhdGUgbXVzdCBiZSBhc3NpZ25lZCBiZWZvcmUgY2FsbGluZyBvbkNsb3NlKCkgdG8gYWxsb3cgdGhlIGNhbGxiYWNrIHRvXG4gICAgICAgIC8vIGluaGliaXQgYmFja29mZiBvciBvdGhlcndpc2UgbWFuaXB1bGF0ZSB0aGUgc3RhdGUgaW4gaXRzIG5vbi1zdGFydGVkIHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXRlID0gZmluYWxTdGF0ZTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBsaXN0ZW5lciB0aGF0IHRoZSBzdHJlYW0gY2xvc2VkLlxuICAgICAgICBhd2FpdCB0aGlzLmxpc3RlbmVyLm9uQ2xvc2UoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtIGFkZGl0aW9uYWwgY2xlYW51cCBiZWZvcmUgdGhlIHN0cmVhbSBpcyBjbG9zZWQuXG4gICAgICogQ2FsbGluZyBzdXBlci50ZWFyRG93bigpIGlzIG5vdCByZXF1aXJlZC5cbiAgICAgKi9cbiAgICB0ZWFyRG93bigpIHsgfVxuICAgIGF1dGgoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5TdGFydGluZyAqLztcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hJZk5vdENsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcih0aGlzLmNsb3NlQ291bnQpO1xuICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWQsIGJ1dCBzZWUgVE9ETyBiZWxvdy5cbiAgICAgICAgY29uc3QgY2xvc2VDb3VudCA9IHRoaXMuY2xvc2VDb3VudDtcbiAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpLFxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0VG9rZW4oKVxuICAgICAgICBdKS50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xuICAgICAgICAgICAgLy8gU3RyZWFtIGNhbiBiZSBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBXZSByZWFsbHkgc2hvdWxkIGp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWRcbiAgICAgICAgICAgIC8vIGFuZCBsZXQgdGhpcyBkaXNwYXRjaCBvbnRvIHRoZSBxdWV1ZSwgYnV0IHRoYXQgb3BlbmVkIGEgc3BlYyB0ZXN0IGNhblxuICAgICAgICAgICAgLy8gb2Ygd29ybXMgdGhhdCBJIGRvbid0IHdhbnQgdG8gZGVhbCB3aXRoIGluIHRoaXMgUFIuXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBjbG9zZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBoYXZlIHRvIHNjaGVkdWxlIHRoZSBjYWxsYmFjayBvbiB0aGUgQXN5bmNRdWV1ZS5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgZm9sbG93aW5nIGNhbGxzIGFyZSBzYWZlIHRvIGJlIGNhbGxlZCBvdXRzaWRlIHRoZVxuICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgc2luY2UgdGhleSBkb24ndCBjaGFpbiBhc3luY2hyb25vdXMgY2FsbHNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3RyZWFtKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnBjRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCAnRmV0Y2hpbmcgYXV0aCB0b2tlbiBmYWlsZWQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DbG9zZShycGNFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0U3RyZWFtKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbkNvbm5lY3RlZCgoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHRoaXMubGlzdGVuZXIub25Db25uZWN0ZWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbk9wZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLk9wZW4gKi87XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy5oZWFsdGhUaW1lcklkLCBIRUFMVEhZX1RJTUVPVVRfTVMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk9wZW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25DbG9zZSgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUNsb3NlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25NZXNzYWdlKChtc2cpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgrK3RoaXMucmVzcG9uc2VDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkZpcnN0KG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbk5leHQobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1CYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gNSAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuQmFja29mZiAqLztcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmJhY2tvZmZBbmRSdW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0c1xuICAgIGhhbmRsZVN0cmVhbUNsb3NlKGVycm9yKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgYGNsb3NlIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZSBzdHJlYW0gY291bGQgY2xvc2UgY2xlYW5seSwgaG93ZXZlciwgaW4gb3VyIGN1cnJlbnQgbW9kZWxcbiAgICAgICAgLy8gd2UgbmV2ZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlY2F1c2UgaWYgd2Ugc3RvcCBhIHN0cmVhbSBvdXJzZWx2ZXMsXG4gICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgd2lsbCBuZXZlciBiZSBjYWxsZWQuIFRvIHByZXZlbnQgY2FzZXMgd2hlcmUgd2UgcmV0cnlcbiAgICAgICAgLy8gd2l0aG91dCBhIGJhY2tvZmYgYWNjaWRlbnRhbGx5LCB3ZSBzZXQgdGhlIHN0cmVhbSB0byBlcnJvciBpbiBhbGwgY2FzZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBcImRpc3BhdGNoZXJcIiBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb3BlcmF0aW9ucyBvbnRvIHRoZVxuICAgICAqIEFzeW5jUXVldWUgYnV0IG9ubHkgcnVucyB0aGVtIGlmIGNsb3NlQ291bnQgcmVtYWlucyB1bmNoYW5nZWQuIFRoaXMgYWxsb3dzXG4gICAgICogdXMgdG8gdHVybiBhdXRoIC8gc3RyZWFtIGNhbGxiYWNrcyBpbnRvIG5vLW9wcyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCAvXG4gICAgICogcmUtb3BlbmVkLCBldGMuXG4gICAgICovXG4gICAgZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcihzdGFydENsb3NlQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChmbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBzdGFydENsb3NlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDcsICdzdHJlYW0gY2FsbGJhY2sgc2tpcHBlZCBieSBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gdGhhdCBpbXBsZW1lbnRzIHRoZSBMaXN0ZW4gUlBDLlxuICpcbiAqIE9uY2UgdGhlIExpc3RlbiBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgb25PcGVuKCkgbGlzdGVuZXIsIGFueSBudW1iZXIgb2ZcbiAqIGxpc3RlbigpIGFuZCB1bmxpc3RlbigpIGNhbGxzIGNhbiBiZSBtYWRlIHRvIGNvbnRyb2wgd2hhdCBjaGFuZ2VzIHdpbGwgYmVcbiAqIHNlbnQgZnJvbSB0aGUgc2VydmVyIGZvciBMaXN0ZW5SZXNwb25zZXMuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0gZXh0ZW5kcyBQZXJzaXN0ZW50U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlcihxdWV1ZSwgXCJsaXN0ZW5fc3RyZWFtX2Nvbm5lY3Rpb25fYmFja29mZlwiIC8qIFRpbWVySWQuTGlzdGVuU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwibGlzdGVuX3N0cmVhbV9pZGxlXCIgLyogVGltZXJJZC5MaXN0ZW5TdHJlYW1JZGxlICovLCBcImhlYWx0aF9jaGVja190aW1lb3V0XCIgLyogVGltZXJJZC5IZWFsdGhDaGVja1RpbWVvdXQgKi8sIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICBzdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5vcGVuU3RyZWFtKCdMaXN0ZW4nLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgIH1cbiAgICBvbkZpcnN0KHdhdGNoQ2hhbmdlUHJvdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25OZXh0KHdhdGNoQ2hhbmdlUHJvdG8pO1xuICAgIH1cbiAgICBvbk5leHQod2F0Y2hDaGFuZ2VQcm90bykge1xuICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgbWVhbnMgdGhlIHN0cmVhbSBpcyBoZWFsdGh5XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICBjb25zdCB3YXRjaENoYW5nZSA9IGZyb21XYXRjaENoYW5nZSh0aGlzLnNlcmlhbGl6ZXIsIHdhdGNoQ2hhbmdlUHJvdG8pO1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHZlcnNpb25Gcm9tTGlzdGVuUmVzcG9uc2Uod2F0Y2hDaGFuZ2VQcm90byk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2Uod2F0Y2hDaGFuZ2UsIHNuYXBzaG90KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSBnaXZlbiB0YXJnZXQuIElmIHRoZSB0YXJnZXRcbiAgICAgKiBpbmNsdWRlcyBhIHJlc3VtZVRva2VuIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuIFJlc3VsdHMgdGhhdFxuICAgICAqIGFmZmVjdCB0aGUgdGFyZ2V0IHdpbGwgYmUgc3RyZWFtZWQgYmFjayBhcyBXYXRjaENoYW5nZSBtZXNzYWdlcyB0aGF0XG4gICAgICogcmVmZXJlbmNlIHRoZSB0YXJnZXRJZC5cbiAgICAgKi9cbiAgICB3YXRjaCh0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdC5kYXRhYmFzZSA9IGdldEVuY29kZWREYXRhYmFzZUlkKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHJlcXVlc3QuYWRkVGFyZ2V0ID0gdG9UYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGlmIChsYWJlbHMpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqIGdpdmVuIHRhcmdldElkLlxuICAgICAqL1xuICAgIHVud2F0Y2godGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVUYXJnZXQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG59XG4vKipcbiAqIEEgU3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgV3JpdGUgUlBDLlxuICpcbiAqIFRoZSBXcml0ZSBSUEMgcmVxdWlyZXMgdGhlIGNhbGxlciB0byBtYWludGFpbiBzcGVjaWFsIHN0cmVhbVRva2VuXG4gKiBzdGF0ZSBpbiBiZXR3ZWVuIGNhbGxzLCB0byBoZWxwIHRoZSBzZXJ2ZXIgdW5kZXJzdGFuZCB3aGljaCByZXNwb25zZXMgdGhlXG4gKiBjbGllbnQgaGFzIHByb2Nlc3NlZCBieSB0aGUgdGltZSB0aGUgbmV4dCByZXF1ZXN0IGlzIG1hZGUuIEV2ZXJ5IHJlc3BvbnNlXG4gKiB3aWxsIGNvbnRhaW4gYSBzdHJlYW1Ub2tlbjsgdGhpcyB2YWx1ZSBtdXN0IGJlIHBhc3NlZCB0byB0aGUgbmV4dFxuICogcmVxdWVzdC5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIHN0YXJ0KCkgb24gdGhpcyBzdHJlYW0sIHRoZSBuZXh0IHJlcXVlc3QgbXVzdCBiZSBhIGhhbmRzaGFrZSxcbiAqIGNvbnRhaW5pbmcgd2hhdGV2ZXIgc3RyZWFtVG9rZW4gaXMgb24gaGFuZC4gT25jZSBhIHJlc3BvbnNlIHRvIHRoaXNcbiAqIHJlcXVlc3QgaXMgcmVjZWl2ZWQsIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBtYXkgYmUgc3VibWl0dGVkLiBXaGVuXG4gKiBzdWJtaXR0aW5nIG11bHRpcGxlIGJhdGNoZXMgb2YgbXV0YXRpb25zIGF0IHRoZSBzYW1lIHRpbWUsIGl0J3NcbiAqIG9rYXkgdG8gdXNlIHRoZSBzYW1lIHN0cmVhbVRva2VuIGZvciB0aGUgY2FsbHMgdG8gd3JpdGVNdXRhdGlvbnMuXG4gKlxuICogVE9ETyhiLzMzMjcxMjM1KTogVXNlIHByb3RvIHR5cGVzXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRXcml0ZVN0cmVhbSBleHRlbmRzIFBlcnNpc3RlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIHNlcmlhbGl6ZXIsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcIndyaXRlX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwid3JpdGVfc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtSWRsZSAqLywgXCJoZWFsdGhfY2hlY2tfdGltZW91dFwiIC8qIFRpbWVySWQuSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2tzIHdoZXRoZXIgb3Igbm90IGEgaGFuZHNoYWtlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGNoYW5nZWQgYW5kXG4gICAgICogdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgbXV0YXRpb25zLlxuICAgICAqL1xuICAgIGdldCBoYW5kc2hha2VDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VDb3VudCA+IDA7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIG9mIFBlcnNpc3RlbnRTdHJlYW0uc3RhcnRcbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5sYXN0U3RyZWFtVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHRlYXJEb3duKCkge1xuICAgICAgICBpZiAodGhpcy5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZU11dGF0aW9ucyhbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnV3JpdGUnLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgIH1cbiAgICBvbkZpcnN0KHJlc3BvbnNlUHJvdG8pIHtcbiAgICAgICAgLy8gQWx3YXlzIGNhcHR1cmUgdGhlIGxhc3Qgc3RyZWFtIHRva2VuLlxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbik7XG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHJlc3BvbnNlIGlzIGFsd2F5cyB0aGUgaGFuZHNoYWtlIHJlc3BvbnNlXG4gICAgICAgIGhhcmRBc3NlcnQoIXJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzIHx8IHJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uSGFuZHNoYWtlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgb25OZXh0KHJlc3BvbnNlUHJvdG8pIHtcbiAgICAgICAgLy8gQWx3YXlzIGNhcHR1cmUgdGhlIGxhc3Qgc3RyZWFtIHRva2VuLlxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbik7XG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcbiAgICAgICAgLy8gQSBzdWNjZXNzZnVsIGZpcnN0IHdyaXRlIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSxcbiAgICAgICAgLy8gTm90ZSwgdGhhdCB3ZSBjb3VsZCBjb25zaWRlciBhIHN1Y2Nlc3NmdWwgaGFuZHNoYWtlIGhlYWx0aHksIGhvd2V2ZXIsXG4gICAgICAgIC8vIHRoZSB3cml0ZSBpdHNlbGYgbWlnaHQgYmUgY2F1c2luZyBhbiBlcnJvciB3ZSB3YW50IHRvIGJhY2sgb2ZmIGZyb20uXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gZnJvbVdyaXRlUmVzdWx0cyhyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cywgcmVzcG9uc2VQcm90by5jb21taXRUaW1lKTtcbiAgICAgICAgY29uc3QgY29tbWl0VmVyc2lvbiA9IGZyb21WZXJzaW9uKHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uTXV0YXRpb25SZXN1bHQoY29tbWl0VmVyc2lvbiwgcmVzdWx0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGluaXRpYWwgc3RyZWFtVG9rZW4gdG8gdGhlIHNlcnZlciwgcGVyZm9ybWluZyB0aGUgaGFuZHNoYWtlXG4gICAgICogcmVxdWlyZWQgdG8gbWFrZSB0aGUgU3RyZWFtaW5nV3JpdGUgUlBDIHdvcmsuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyBzaG91bGQgd2FpdCB1bnRpbCBvbkhhbmRzaGFrZUNvbXBsZXRlIHdhcyBjYWxsZWQuXG4gICAgICovXG4gICAgd3JpdGVIYW5kc2hha2UoKSB7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU3VwcG9ydCBzdHJlYW0gcmVzdW1wdGlvbi4gV2UgaW50ZW50aW9uYWxseSBkbyBub3Qgc2V0IHRoZVxuICAgICAgICAvLyBzdHJlYW0gdG9rZW4gb24gdGhlIGhhbmRzaGFrZSwgaWdub3JpbmcgYW55IHN0cmVhbSB0b2tlbiB3ZSBtaWdodCBoYXZlLlxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogU2VuZHMgYSBncm91cCBvZiBtdXRhdGlvbnMgdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kIHRvIGFwcGx5LiAqL1xuICAgIHdyaXRlTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgc3RyZWFtVG9rZW46IHRoaXMubGFzdFN0cmVhbVRva2VuLFxuICAgICAgICAgICAgd3JpdGVzOiBtdXRhdGlvbnMubWFwKG11dGF0aW9uID0+IHRvTXV0YXRpb24odGhpcy5zZXJpYWxpemVyLCBtdXRhdGlvbikpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEYXRhc3RvcmUgYW5kIGl0cyByZWxhdGVkIG1ldGhvZHMgYXJlIGEgd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIEdvb2dsZVxuICogQ2xvdWQgRGF0YXN0b3JlIGdycGMgQVBJLCB3aGljaCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBpcyBtb3JlIGNvbnZlbmllbnRcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUgdG8gY29uc3VtZS5cbiAqL1xuY2xhc3MgRGF0YXN0b3JlIHtcbn1cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGF0YXN0b3JlIHRoYXQgZXhwb3NlcyBhZGRpdGlvbmFsIHN0YXRlIGZvciBpbnRlcm5hbFxuICogY29uc3VtcHRpb24uXG4gKi9cbmNsYXNzIERhdGFzdG9yZUltcGwgZXh0ZW5kcyBEYXRhc3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZlcmlmeUluaXRpYWxpemVkKCkge1xuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIGF1dGggYW5kIEFwcENoZWNrIHRva2Vucy4gKi9cbiAgICBpbnZva2VSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmdldFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOS05PV04sIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXG4gICAgaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmdldFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGV4cGVjdGVkUmVzcG9uc2VDb3VudCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5LTk9XTiwgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi50ZXJtaW5hdGUoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZXhwKTogTWFrZSBzdXJlIHRoZXJlIGlzIG9ubHkgb25lIERhdGFzdG9yZSBpbnN0YW5jZSBwZXJcbi8vIGZpcmVzdG9yZS1leHAgY2xpZW50LlxuZnVuY3Rpb24gbmV3RGF0YXN0b3JlKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgRGF0YXN0b3JlSW1wbChhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBtKSlcbiAgICB9O1xuICAgIGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlUlBDKCdDb21taXQnLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKGRhdGFzdG9yZSwga2V5cykge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBkb2N1bWVudHM6IGtleXMubWFwKGsgPT4gdG9OYW1lKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgaykpXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QsIGtleXMubGVuZ3RoKTtcbiAgICBjb25zdCBkb2NzID0gbmV3IE1hcCgpO1xuICAgIHJlc3BvbnNlLmZvckVhY2gocHJvdG8gPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvKTtcbiAgICAgICAgZG9jcy5zZXQoZG9jLmtleS50b1N0cmluZygpLCBkb2MpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBkb2NzLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGhhcmRBc3NlcnQoISFkb2MpO1xuICAgICAgICByZXN1bHQucHVzaChkb2MpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBpbnZva2VSdW5BZ2dyZWdhdGlvblF1ZXJ5UnBjKGRhdGFzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGNvbnN0IHsgcmVxdWVzdCwgYWxpYXNNYXAsIHBhcmVudCB9ID0gdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdChkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHF1ZXJ5VG9BZ2dyZWdhdGVUYXJnZXQocXVlcnkpLCBhZ2dyZWdhdGVzKTtcbiAgICBpZiAoIWRhdGFzdG9yZUltcGwuY29ubmVjdGlvbi5zaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0LnBhcmVudDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuQWdncmVnYXRpb25RdWVyeScsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXJlbnQsIHJlcXVlc3QsIFxuICAgIC8qZXhwZWN0ZWRSZXNwb25zZUNvdW50PSovIDEpO1xuICAgIC8vIE9taXQgUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlIHRoYXQgb25seSBjb250YWluIHJlYWRUaW1lcy5cbiAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IHJlc3BvbnNlLmZpbHRlcihwcm90byA9PiAhIXByb3RvLnJlc3VsdCk7XG4gICAgaGFyZEFzc2VydChmaWx0ZXJlZFJlc3VsdC5sZW5ndGggPT09IDEpO1xuICAgIC8vIFJlbWFwIHRoZSBzaG9ydC1mb3JtIGFsaWFzZXMgdGhhdCB3ZXJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgIC8vIHRvIHRoZSBjbGllbnQtc2lkZSBhbGlhc2VzLiBVc2VycyB3aWxsIGFjY2VzcyB0aGUgcmVzdWx0c1xuICAgIC8vIHVzaW5nIHRoZSBjbGllbnQtc2lkZSBhbGlhcy5cbiAgICBjb25zdCB1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkcyA9IChfYSA9IGZpbHRlcmVkUmVzdWx0WzBdLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFnZ3JlZ2F0ZUZpZWxkcztcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcbiAgICAgICAgYWNjdW11bGF0b3JbYWxpYXNNYXBba2V5XV0gPSB1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkc1trZXldO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfSwge30pO1xuICAgIHJldHVybiByZW1hcHBlZEZpZWxkcztcbn1cbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBkYXRhc3RvcmVJbXBsLnZlcmlmeUluaXRpYWxpemVkKCk7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0oZGF0YXN0b3JlLCBxdWV1ZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVudExpc3RlblN0cmVhbShxdWV1ZSwgZGF0YXN0b3JlSW1wbC5jb25uZWN0aW9uLCBkYXRhc3RvcmVJbXBsLmF1dGhDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5hcHBDaGVja0NyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNiA9ICdPbmxpbmVTdGF0ZVRyYWNrZXInO1xuLy8gVG8gZGVhbCB3aXRoIHRyYW5zaWVudCBmYWlsdXJlcywgd2UgYWxsb3cgbXVsdGlwbGUgc3RyZWFtIGF0dGVtcHRzIGJlZm9yZVxuLy8gZ2l2aW5nIHVwIGFuZCB0cmFuc2l0aW9uaW5nIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPZmZsaW5lLlxuLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIHVzZWQgdG8gYmUgc2V0IHRvIDIgYXMgYSBtaXRpZ2F0aW9uIGZvciBiLzY2MjI4Mzk0LlxuLy8gQGpkaW1vbmQgdGhpbmtzIHRoYXQgYnVnIGlzIHN1ZmZpY2llbnRseSBmaXhlZCBzbyB0aGF0IHdlIGNhbiBzZXQgdGhpcyBiYWNrXG4vLyB0byAxLiBJZiB0aGF0IHdvcmtzIG9rYXksIHdlIGNvdWxkIHBvdGVudGlhbGx5IHJlbW92ZSB0aGlzIGxvZ2ljIGVudGlyZWx5LlxuY29uc3QgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUyA9IDE7XG4vLyBUbyBkZWFsIHdpdGggc3RyZWFtIGF0dGVtcHRzIHRoYXQgZG9uJ3Qgc3VjY2VlZCBvciBmYWlsIGluIGEgdGltZWx5IG1hbm5lcixcbi8vIHdlIGhhdmUgYSB0aW1lb3V0IGZvciBPbmxpbmVTdGF0ZSB0byByZWFjaCBPbmxpbmUgb3IgT2ZmbGluZS5cbi8vIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHdlIHRyYW5zaXRpb24gdG8gT2ZmbGluZSByYXRoZXIgdGhhbiB3YWl0aW5nXG4vLyBpbmRlZmluaXRlbHkuXG5jb25zdCBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG8gdHJhY2sgdGhlIE9ubGluZVN0YXRlICh0aGF0IGlzLFxuICogd2hldGhlciBvciBub3QgdGhlIGNsaWVudCBhcyBhIHdob2xlIHNob3VsZCBiZSBjb25zaWRlcmVkIHRvIGJlIG9ubGluZSBvclxuICogb2ZmbGluZSksIGltcGxlbWVudGluZyB0aGUgYXBwcm9wcmlhdGUgaGV1cmlzdGljcy5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aGVuIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHdlXG4gKiBhbGxvdyB1cCB0byBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHdpdGhpbiBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyBmb3JcbiAqIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkLiBJZiB3ZSBoYXZlIHRvbyBtYW55IGZhaWx1cmVzIG9yIHRoZSB0aW1lb3V0IGVsYXBzZXMsXG4gKiB0aGVuIHdlIHNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSwgYW5kIHRoZSBjbGllbnQgd2lsbCBiZWhhdmUgYXMgaWZcbiAqIGl0IGlzIG9mZmxpbmUgKGdldCgpcyB3aWxsIHJldHVybiBjYWNoZWQgZGF0YSwgZXRjLikuXG4gKi9cbmNsYXNzIE9ubGluZVN0YXRlVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGVIYW5kbGVyO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgT25saW5lU3RhdGUuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb3VudCBvZiBjb25zZWN1dGl2ZSBmYWlsdXJlcyB0byBvcGVuIHRoZSBzdHJlYW0uIElmIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAqIG1heGltdW0gZGVmaW5lZCBieSBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTLCB3ZSdsbCBzZXQgdGhlIE9ubGluZVN0YXRlIHRvXG4gICAgICAgICAqIE9mZmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lciB0aGF0IGVsYXBzZXMgYWZ0ZXIgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsIGF0IHdoaWNoIHBvaW50IHdlXG4gICAgICAgICAqIHRyYW5zaXRpb24gZnJvbSBPbmxpbmVTdGF0ZS5Vbmtub3duIHRvIE9ubGluZVN0YXRlLk9mZmxpbmUgd2l0aG91dCB3YWl0aW5nXG4gICAgICAgICAqIGZvciB0aGUgc3RyZWFtIHRvIGFjdHVhbGx5IGZhaWwgKE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgdGltZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBzaG91bGQgbG9nIGEgd2FybmluZyBtZXNzYWdlIGlmIGl0IGZhaWxzIHRvIGNvbm5lY3QgdG9cbiAgICAgICAgICogdGhlIGJhY2tlbmQgKGluaXRpYWxseSB0cnVlLCBjbGVhcmVkIGFmdGVyIGEgc3VjY2Vzc2Z1bCBzdHJlYW0sIG9yIGlmIHdlJ3ZlXG4gICAgICAgICAqIGxvZ2dlZCB0aGUgbWVzc2FnZSBhbHJlYWR5KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBSZW1vdGVTdG9yZSB3aGVuIGEgd2F0Y2ggc3RyZWFtIGlzIHN0YXJ0ZWQgKGluY2x1ZGluZyBvbiBlYWNoXG4gICAgICogYmFja29mZiBhdHRlbXB0KS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHNldHMgdGhlIE9ubGluZVN0YXRlIHRvIFVua25vd24gYW5kIHN0YXJ0c1xuICAgICAqIHRoZSBvbmxpbmVTdGF0ZVRpbWVyLlxuICAgICAqL1xuICAgIGhhbmRsZVdhdGNoU3RyZWFtU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwib25saW5lX3N0YXRlX3RpbWVvdXRcIiAvKiBUaW1lcklkLk9ubGluZVN0YXRlVGltZW91dCAqLywgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShgQmFja2VuZCBkaWRuJ3QgcmVzcG9uZCB3aXRoaW4gJHtPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyAvIDEwMDB9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2Vjb25kcy5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKSB3aWxsIGNvbnRpbnVlIHRvIGluY3JlbWVudFxuICAgICAgICAgICAgICAgIC8vIHdhdGNoU3RyZWFtRmFpbHVyZXMgZXZlbiB0aG91Z2ggd2UgYXJlIGFscmVhZHkgbWFya2VkIE9mZmxpbmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm9uLWhhcm1mdWwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvdXIgT25saW5lU3RhdGUgYXMgYXBwcm9wcmlhdGUgYWZ0ZXIgdGhlIHdhdGNoIHN0cmVhbSByZXBvcnRzIGFcbiAgICAgKiBmYWlsdXJlLiBUaGUgZmlyc3QgZmFpbHVyZSBtb3ZlcyB1cyB0byB0aGUgJ1Vua25vd24nIHN0YXRlLiBXZSB0aGVuIG1heVxuICAgICAqIGFsbG93IG11bHRpcGxlIGZhaWx1cmVzIChiYXNlZCBvbiBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTKSBiZWZvcmUgd2VcbiAgICAgKiBhY3R1YWxseSB0cmFuc2l0aW9uIHRvIHRoZSAnT2ZmbGluZScgc3RhdGUuXG4gICAgICovXG4gICAgaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMrKztcbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPj0gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGBDb25uZWN0aW9uIGZhaWxlZCAke01BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVN9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGltZXMuIE1vc3QgcmVjZW50IGVycm9yOiAke2Vycm9yLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHN0YXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcmVzZXRzIG91ciB0aW1lcnMgLyBmYWlsdXJlIGNvdW50ZXJzLCBldGMuIHVzZWQgYnkgb3VyXG4gICAgICogT2ZmbGluZSBoZXVyaXN0aWNzLCBzbyBtdXN0IG5vdCBiZSB1c2VkIGluIHBsYWNlIG9mXG4gICAgICogaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIGFuZCBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKS5cbiAgICAgKi9cbiAgICBzZXQobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgLy8gV2UndmUgY29ubmVjdGVkIHRvIHdhdGNoIGF0IGxlYXN0IG9uY2UuIERvbid0IHdhcm4gdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgLy8gYWJvdXQgYmVpbmcgb2ZmbGluZSBnb2luZyBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpO1xuICAgIH1cbiAgICBzZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ291bGQgbm90IHJlYWNoIENsb3VkIEZpcmVzdG9yZSBiYWNrZW5kLiAke2RldGFpbHN9XFxuYCArXG4gICAgICAgICAgICBgVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgeW91ciBkZXZpY2UgZG9lcyBub3QgaGF2ZSBhIGhlYWx0aHkgYCArXG4gICAgICAgICAgICBgSW50ZXJuZXQgY29ubmVjdGlvbiBhdCB0aGUgbW9tZW50LiBUaGUgY2xpZW50IHdpbGwgb3BlcmF0ZSBpbiBvZmZsaW5lIGAgK1xuICAgICAgICAgICAgYG1vZGUgdW50aWwgaXQgaXMgYWJsZSB0byBzdWNjZXNzZnVsbHkgY29ubmVjdCB0byB0aGUgYmFja2VuZC5gO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ2LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhck9ubGluZVN0YXRlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ubGluZVN0YXRlVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDUgPSAnUmVtb3RlU3RvcmUnO1xuLy8gVE9ETyhiLzM1ODUzNDAyKTogTmVnb3RpYXRlIHRoaXMgd2l0aCB0aGUgc3RyZWFtLlxuY29uc3QgTUFYX1BFTkRJTkdfV1JJVEVTID0gMTA7XG5jbGFzcyBSZW1vdGVTdG9yZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBzdG9yZSwgdXNlZCB0byBmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoIG91dGJvdW5kIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBsb2NhbFN0b3JlLCBcbiAgICAvKiogVGhlIGNsaWVudC1zaWRlIHByb3h5IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kLiAqL1xuICAgIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLnJlbW90ZVN5bmNlciA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHVwIHRvIE1BWF9QRU5ESU5HX1dSSVRFUyB3cml0ZXMgdGhhdCB3ZSBoYXZlIGZldGNoZWQgZnJvbSB0aGVcbiAgICAgICAgICogTG9jYWxTdG9yZSB2aWEgZmlsbFdyaXRlUGlwZWxpbmUoKSBhbmQgaGF2ZSBvciB3aWxsIHNlbmQgdG8gdGhlIHdyaXRlXG4gICAgICAgICAqIHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbmV2ZXIgd3JpdGVQaXBlbGluZS5sZW5ndGggPiAwIHRoZSBSZW1vdGVTdG9yZSB3aWxsIGF0dGVtcHQgdG8gc3RhcnQgb3JcbiAgICAgICAgICogcmVzdGFydCB0aGUgd3JpdGUgc3RyZWFtLiBXaGVuIHRoZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQgdGhlIHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICogcGlwZWxpbmUgd2lsbCBiZSBzZW50IGluIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZXMgcmVtYWluIGluIHdyaXRlUGlwZWxpbmUgdW50aWwgdGhleSBhcmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kXG4gICAgICAgICAqIGFuZCB0aHVzIHdpbGwgYXV0b21hdGljYWxseSBiZSByZS1zZW50IGlmIHRoZSBzdHJlYW0gaXMgaW50ZXJydXB0ZWQgL1xuICAgICAgICAgKiByZXN0YXJ0ZWQgYmVmb3JlIHRoZXkncmUgYWNrbm93bGVkZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZSByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZCBhcmUgbGlua2VkIHRvIHRoZWlyIG9yaWdpbmF0aW5nIHJlcXVlc3RcbiAgICAgICAgICogcHVyZWx5IGJhc2VkIG9uIG9yZGVyLCBhbmQgc28gd2UgY2FuIGp1c3Qgc2hpZnQoKSB3cml0ZXMgZnJvbSB0aGUgZnJvbnQgb2ZcbiAgICAgICAgICogdGhlIHdyaXRlUGlwZWxpbmUgYXMgd2UgcmVjZWl2ZSByZXNwb25zZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXRlUGlwZWxpbmUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB3YXRjaGVkIHRhcmdldHMgdGhhdCB0aGUgY2xpZW50IGNhcmVzIGFib3V0IHRyYWNraW5nIGFuZCB0aGVcbiAgICAgICAgICogdXNlciBoYXMgZXhwbGljaXRseSBjYWxsZWQgYSAnbGlzdGVuJyBmb3IgdGhpcyB0YXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXNlIHRhcmdldHMgbWF5IG9yIG1heSBub3QgaGF2ZSBiZWVuIHNlbnQgdG8gb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZVxuICAgICAgICAgKiBzZXJ2ZXIuIE9uIHJlLWVzdGFibGlzaGluZyB0aGUgbGlzdGVuIHN0cmVhbSwgdGhlc2UgdGFyZ2V0cyBzaG91bGQgYmUgc2VudFxuICAgICAgICAgKiB0byB0aGUgc2VydmVyLiBUaGUgdGFyZ2V0cyByZW1vdmVkIHdpdGggdW5saXN0ZW5zIGFyZSByZW1vdmVkIGVhZ2VybHlcbiAgICAgICAgICogd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb24gZnJvbSB0aGUgbGlzdGVuIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdGVuVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIHJlYXNvbnMgZm9yIHdoeSB0aGUgUmVtb3RlU3RvcmUgbWF5IGJlIG9mZmxpbmUuIElmIGVtcHR5LCB0aGVcbiAgICAgICAgICogUmVtb3RlU3RvcmUgbWF5IHN0YXJ0IGl0cyBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZsaW5lQ2F1c2VzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgdGhhdCBnZXQgY2FsbGVkIHdoZW4gdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgb24gdGhlIFdlYiBjbGllbnQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbXMgKHRvIHN1cHBvcnQgdHJlZS1zaGFrZWFibGUgc3RyZWFtcykuIE9uIEFuZHJvaWQgYW5kIGlPUyxcbiAgICAgICAgICogdGhlIHN0cmVhbXMgYXJlIGNyZWF0ZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiBvZiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvciA9IGNvbm5lY3Rpdml0eU1vbml0b3I7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvci5hZGRDYWxsYmFjaygoXykgPT4ge1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0aW5nIE5vdGU6IFVubGlrZSBpT1MsIGByZXN0YXJ0TmV0d29yaygpYCBpcyBjYWxsZWQgZXZlbiB3aGVuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgYmVjb21lcyB1bnJlYWNoYWJsZSBhcyB3ZSBkb24ndCBoYXZlIGFueSBvdGhlciB3YXkgdG8gdGVhclxuICAgICAgICAgICAgICAgIC8vIGRvd24gb3VyIHN0cmVhbXMuXG4gICAgICAgICAgICAgICAgaWYgKGNhblVzZU5ldHdvcmsodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVzdGFydGluZyBzdHJlYW1zIGZvciBuZXR3b3JrIHJlYWNoYWJpbGl0eSBjaGFuZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3RhcnROZXR3b3JrKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRyYWNrZXIgPSBuZXcgT25saW5lU3RhdGVUcmFja2VyKGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlcik7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3UmVtb3RlU3RvcmUobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVN0b3JlSW1wbChsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcik7XG59XG4vKiogUmUtZW5hYmxlcyB0aGUgbmV0d29yay4gSWRlbXBvdGVudC4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDAgLyogT2ZmbGluZUNhdXNlLlVzZXJEaXNhYmxlZCAqLyk7XG4gICAgcmV0dXJuIGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrU3RhdHVzSGFuZGxlciBvZiByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZXMgdGhlIG5ldHdvcmsuIFRoZSBuZXR3b3JrIGNhbiBiZSByZS1lbmFibGVkIHVzaW5nXG4gKiBlbmFibGVOZXR3b3JrKCkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgwIC8qIE9mZmxpbmVDYXVzZS5Vc2VyRGlzYWJsZWQgKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZXQgdGhlIE9ubGluZVN0YXRlIHRvIE9mZmxpbmUgc28gZ2V0KClzIHJldHVybiBmcm9tIGNhY2hlLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG59XG5hc3luYyBmdW5jdGlvbiBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGZvciAoY29uc3QgbmV0d29ya1N0YXR1c0hhbmRsZXIgb2YgcmVtb3RlU3RvcmVJbXBsLm9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVtb3RlU3RvcmUgc2h1dHRpbmcgZG93bi4nKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBPZmZsaW5lQ2F1c2UuU2h1dGRvd24gKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICByZW1vdGVTdG9yZUltcGwuY29ubmVjdGl2aXR5TW9uaXRvci5zaHV0ZG93bigpO1xuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biAocmF0aGVyIHRoYW4gT2ZmbGluZSkgdG8gYXZvaWQgcG90ZW50aWFsbHlcbiAgICAvLyB0cmlnZ2VyaW5nIHNwdXJpb3VzIGxpc3RlbmVyIGV2ZW50cyB3aXRoIGNhY2hlZCBkYXRhLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG59XG4vKipcbiAqIFN0YXJ0cyBuZXcgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LiBVc2VzIHJlc3VtZSB0b2tlbiBpZiBwcm92aWRlZC4gSXRcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIHRhcmdldCBvZiBnaXZlbiBgVGFyZ2V0RGF0YWAgaXMgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCB0by5cbiAqL1xuZnVuY3Rpb24gcmVtb3RlU3RvcmVMaXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0RGF0YS50YXJnZXRJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgYXMgc29tZXRoaW5nIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGxpc3RlbmluZyBmb3IuXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgLy8gVGhlIGxpc3RlbiB3aWxsIGJlIHNlbnQgaW4gb25XYXRjaFN0cmVhbU9wZW5cbiAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbiBmcm9tIHNlcnZlci4gSXQgaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IGlkIGlzXG4gKiBub3QgYmVpbmcgbGlzdGVuZWQgdG8uXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlVW5saXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldElkKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBjb25zdCB3YXRjaFN0cmVhbSA9IGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIHdhdGNoU3RyZWFtLm1hcmtJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAvLyBSZXZlcnQgdG8gT25saW5lU3RhdGUuVW5rbm93biBpZiB0aGUgd2F0Y2ggc3RyZWFtIGlzIG5vdCBvcGVuIGFuZCB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSBubyBsaXN0ZW5lcnMsIHNpbmNlIHdpdGhvdXQgYW55IGxpc3RlbnMgdG8gc2VuZCB3ZSBjYW5ub3RcbiAgICAgICAgICAgIC8vIGNvbmZpcm0gaWYgdGhlIHN0cmVhbSBpcyBoZWFsdGh5IGFuZCB1cGdyYWRlIHRvIE9ubGluZVN0YXRlLk9ubGluZS5cbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgYWNrIHRvIHByb2Nlc3MgYW55IG1lc3NhZ2VzIGZyb20gdGhpcyB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwIHx8XG4gICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhTbmFwc2hvdFZlcnNpb24ubWluKCkpID4gMCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpLnNpemU7XG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpO1xuICAgIH1cbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLndhdGNoKHRhcmdldERhdGEpO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgcmVtb3ZhbCBvbiB0aGUgc2VydmVyIGJlZm9yZSB3ZSBwcm9jZXNzIGFueVxuICogbWVzc2FnZXMgZnJvbSB0aGlzIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnVud2F0Y2godGFyZ2V0SWQpO1xufVxuZnVuY3Rpb24gc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gbmV3IFdhdGNoQ2hhbmdlQWdncmVnYXRvcih7XG4gICAgICAgIGdldFJlbW90ZUtleXNGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCksXG4gICAgICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmdldCh0YXJnZXRJZCkgfHwgbnVsbCxcbiAgICAgICAgZ2V0RGF0YWJhc2VJZDogKCkgPT4gcmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZS5zZXJpYWxpemVyLmRhdGFiYXNlSWRcbiAgICB9KTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnN0YXJ0KCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgd2F0Y2ggc3RyZWFtIHNob3VsZCBiZSBzdGFydGVkIGJlY2F1c2UgaXQncyBuZWNlc3NhcnlcbiAqIGFuZCBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcbiAgICAgICAgIWVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNTdGFydGVkKCkgJiZcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA+IDApO1xufVxuZnVuY3Rpb24gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLnNpemUgPT09IDA7XG59XG5mdW5jdGlvbiBjbGVhblVwV2F0Y2hTdHJlYW1TdGF0ZShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gdW5kZWZpbmVkO1xufVxuYXN5bmMgZnVuY3Rpb24gb25XYXRjaFN0cmVhbUNvbm5lY3RlZChyZW1vdGVTdG9yZUltcGwpIHtcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIFwiY29ubmVjdGVkXCIgbm90aWZpY2F0aW9uLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT25saW5lXCIgLyogT25saW5lU3RhdGUuT25saW5lICovKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmZvckVhY2goKHRhcmdldERhdGEsIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBJZiB3ZSBzdGlsbCBuZWVkIHRoZSB3YXRjaCBzdHJlYW0sIHJldHJ5IHRoZSBjb25uZWN0aW9uLlxuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoZXJyb3IpO1xuICAgICAgICBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RhcnQgd2F0Y2ggc3RyZWFtIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAgICAvLyBUaGUgb25saW5lIHN0YXRlIGlzIHNldCB0byB1bmtub3duIGJlY2F1c2UgdGhlcmUgaXMgbm8gYWN0aXZlIGF0dGVtcHRcbiAgICAgICAgLy8gYXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvblxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2hhbmdlKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIC8vIE1hcmsgdGhlIGNsaWVudCBhcyBvbmxpbmUgc2luY2Ugd2UgZ290IGEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XG4gICAgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgV2F0Y2hUYXJnZXRDaGFuZ2UgJiZcbiAgICAgICAgd2F0Y2hDaGFuZ2Uuc3RhdGUgPT09IDIgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZW1vdmVkICovICYmXG4gICAgICAgIHdhdGNoQ2hhbmdlLmNhdXNlKSB7XG4gICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBvbiBhIHRhcmdldCwgZG9uJ3Qgd2FpdCBmb3IgYSBjb25zaXN0ZW50IHNuYXBzaG90XG4gICAgICAgIC8vIHRvIHJhaXNlIGV2ZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlVGFyZ2V0RXJyb3IocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByZW1vdmUgdGFyZ2V0cyAlczogJXMgJywgd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzLmpvaW4oJywnKSwgZSk7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIERvY3VtZW50V2F0Y2hDaGFuZ2UpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVEb2N1bWVudENoYW5nZSh3YXRjaENoYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlVGFyZ2V0Q2hhbmdlKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKCFzbmFwc2hvdFZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0gYXdhaXQgbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8obGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSB0YXJnZXQgY2hhbmdlIHdpdGggYSBnbG9iYWwgc25hcHNob3QgaWYgdGhlIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBpcyBub3QgZXF1YWwgdG8gU25hcHNob3RWZXJzaW9uLm1pbigpLlxuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByYWlzZSBzbmFwc2hvdDonLCBlKTtcbiAgICAgICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrVW50aWxSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvdmVyeSBsb2dpYyBmb3IgSW5kZXhlZERCIGVycm9ycyB0aGF0IHRha2VzIHRoZSBuZXR3b3JrIG9mZmxpbmUgdW50aWxcbiAqIGBvcGAgc3VjY2VlZHMuIFJldHJpZXMgYXJlIHNjaGVkdWxlZCB3aXRoIGJhY2tvZmYgdXNpbmdcbiAqIGBlbnF1ZXVlUmV0cnlhYmxlKClgLiBJZiBgb3AoKWAgaXMgbm90IHByb3ZpZGVkLCBJbmRleGVkREIgYWNjZXNzIGlzXG4gKiB2YWxpZGF0ZWQgdmlhIGEgZ2VuZXJpYyBvcGVyYXRpb24uXG4gKlxuICogVGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgYmVmb3JlXG4gKiBhbnkgcmV0cnkgYXR0ZW1wdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApIHtcbiAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgxIC8qIE9mZmxpbmVDYXVzZS5JbmRleGVkRGJGYWlsZWQgKi8pO1xuICAgICAgICAvLyBEaXNhYmxlIG5ldHdvcmsgYW5kIHJhaXNlIG9mZmxpbmUgc25hcHNob3RzXG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHNpbXBsZSByZWFkIG9wZXJhdGlvbiB0byBkZXRlcm1pbmUgaWYgSW5kZXhlZERCIHJlY292ZXJlZC5cbiAgICAgICAgICAgIC8vIElkZWFsbHksIHdlIHdvdWxkIGV4cG9zZSBhIGhlYWx0aCBjaGVjayBkaXJlY3RseSBvbiBTaW1wbGVEYiwgYnV0XG4gICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBvbmx5IGhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVuY2UgdGhyb3VnaCBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgb3AgPSAoKSA9PiBsb2NhbFN0b3JlR2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbihyZW1vdGVTdG9yZUltcGwubG9jYWxTdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvYmUgSW5kZXhlZERCIHBlcmlvZGljYWxseSBhbmQgcmUtZW5hYmxlIG5ldHdvcmtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZXRyeWluZyBJbmRleGVkREIgYWNjZXNzJyk7XG4gICAgICAgICAgICBhd2FpdCBvcCgpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDEgLyogT2ZmbGluZUNhdXNlLkluZGV4ZWREYkZhaWxlZCAqLyk7XG4gICAgICAgICAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgYG9wYC4gSWYgYG9wYCBmYWlscywgdGFrZXMgdGhlIG5ldHdvcmsgb2ZmbGluZSB1bnRpbCBgb3BgXG4gKiBzdWNjZWVkcy4gUmV0dXJucyBhZnRlciB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIG9wKSB7XG4gICAgcmV0dXJuIG9wKCkuY2F0Y2goZSA9PiBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlLCBvcCkpO1xufVxuLyoqXG4gKiBUYWtlcyBhIGJhdGNoIG9mIGNoYW5nZXMgZnJvbSB0aGUgRGF0YXN0b3JlLCByZXBhY2thZ2VzIHRoZW0gYXMgYVxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcbiAqIFN5bmNFbmdpbmUuXG4gKi9cbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5jcmVhdGVSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24pO1xuICAgIC8vIFVwZGF0ZSBpbi1tZW1vcnkgcmVzdW1lIHRva2Vucy4gTG9jYWxTdG9yZSB3aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxuICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgoY2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBSZS1lc3RhYmxpc2ggbGlzdGVucyBmb3IgdGhlIHRhcmdldHMgdGhhdCBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYnlcbiAgICAvLyBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKCh0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCF0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlc3VtZSB0b2tlbiBmb3IgdGhlIHRhcmdldCwgc2luY2Ugd2UncmUgaW4gYSBrbm93biBtaXNtYXRjaFxuICAgICAgICAvLyBzdGF0ZS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldElkLCB0YXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICAvLyBDYXVzZSBhIGhhcmQgcmVzZXQgYnkgdW53YXRjaGluZyBhbmQgcmV3YXRjaGluZyBpbW1lZGlhdGVseSwgYnV0XG4gICAgICAgIC8vIGRlbGliZXJhdGVseSBkb24ndCBzZW5kIGEgcmVzdW1lIHRva2VuIHNvIHRoYXQgd2UgZ2V0IGEgZnVsbCB1cGRhdGUuXG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcbiAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdlIHNlbmQgYXMgYmVpbmcgb24gYmVoYWxmIG9mIGFuIGV4aXN0ZW5jZSBmaWx0ZXJcbiAgICAgICAgLy8gbWlzbWF0Y2gsIGJ1dCBkb24ndCBhY3R1YWxseSByZXRhaW4gdGhhdCBpbiBsaXN0ZW5UYXJnZXRzLiBUaGlzIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCB3ZSBmbGFnIHRoZSBmaXJzdCByZS1saXN0ZW4gdGhpcyB3YXkgd2l0aG91dCBpbXBhY3RpbmcgZnV0dXJlXG4gICAgICAgIC8vIGxpc3RlbnMgb2YgdGhpcyB0YXJnZXQgKHRoYXQgbWlnaHQgaGFwcGVuIGUuZy4gb24gcmVjb25uZWN0KS5cbiAgICAgICAgY29uc3QgcmVxdWVzdFRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0SWQsIHRhcmdldFB1cnBvc2UsIHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgcmVxdWVzdFRhcmdldERhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQocmVtb3RlRXZlbnQpO1xufVxuLyoqIEhhbmRsZXMgYW4gZXJyb3Igb24gYSB0YXJnZXQgKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHdhdGNoQ2hhbmdlLmNhdXNlO1xuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2Ygd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzKSB7XG4gICAgICAgIC8vIEEgd2F0Y2hlZCB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuKHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5kZWxldGUodGFyZ2V0SWQpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBmaWxsIG91ciB3cml0ZSBwaXBlbGluZSB3aXRoIHdyaXRlcyBmcm9tIHRoZSBMb2NhbFN0b3JlLlxuICpcbiAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGJvb3RzdHJhcCBvciByZWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIGFuZCBieVxuICogU3luY0VuZ2luZSB3aGVuZXZlciB0aGVyZSBhcmUgbmV3IG11dGF0aW9ucyB0byBwcm9jZXNzLlxuICpcbiAqIFN0YXJ0cyB0aGUgd3JpdGUgc3RyZWFtIGlmIG5lY2Vzc2FyeS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICBsZXQgbGFzdEJhdGNoSWRSZXRyaWV2ZWQgPSByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwXG4gICAgICAgID8gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmVbcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIC5iYXRjaElkXG4gICAgICAgIDogQkFUQ0hJRF9VTktOT1dOO1xuICAgIHdoaWxlIChjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCBsb2NhbFN0b3JlR2V0TmV4dE11dGF0aW9uQmF0Y2gocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUsIGxhc3RCYXRjaElkUmV0cmlldmVkKTtcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHJlYW0ubWFya0lkbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0QmF0Y2hJZFJldHJpZXZlZCA9IGJhdGNoLmJhdGNoSWQ7XG4gICAgICAgICAgICAgICAgYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBjYW4gYWRkIHRvIHRoZSB3cml0ZSBwaXBlbGluZSAoaS5lLiB0aGUgbmV0d29yayBpc1xuICogZW5hYmxlZCBhbmQgdGhlIHdyaXRlIHBpcGVsaW5lIGlzIG5vdCBmdWxsKS5cbiAqL1xuZnVuY3Rpb24gY2FuQWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA8IE1BWF9QRU5ESU5HX1dSSVRFUyk7XG59XG4vKipcbiAqIFF1ZXVlcyBhZGRpdGlvbmFsIHdyaXRlcyB0byBiZSBzZW50IHRvIHRoZSB3cml0ZSBzdHJlYW0sIHNlbmRpbmcgdGhlbVxuICogaW1tZWRpYXRlbHkgaWYgdGhlIHdyaXRlIHN0cmVhbSBpcyBlc3RhYmxpc2hlZC5cbiAqL1xuZnVuY3Rpb24gYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5wdXNoKGJhdGNoKTtcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgaWYgKHdyaXRlU3RyZWFtLmlzT3BlbigpICYmIHdyaXRlU3RyZWFtLmhhbmRzaGFrZUNvbXBsZXRlKSB7XG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxuICAgICAgICAhZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5zdGFydCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbU9wZW4ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53cml0ZUhhbmRzaGFrZSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZW5kIHRoZSB3cml0ZSBwaXBlbGluZSBub3cgdGhhdCB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxuICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUpIHtcbiAgICAgICAgd3JpdGVTdHJlYW0ud3JpdGVNdXRhdGlvbnMoYmF0Y2gubXV0YXRpb25zKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbk11dGF0aW9uUmVzdWx0KHJlbW90ZVN0b3JlSW1wbCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xuICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICBjb25zdCBzdWNjZXNzID0gTXV0YXRpb25CYXRjaFJlc3VsdC5mcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKTtcbiAgICBhd2FpdCBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgKCkgPT4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5hcHBseVN1Y2Nlc3NmdWxXcml0ZShzdWNjZXNzKSk7XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvbiBhbm90aGVyXG4gICAgLy8gc2xvdCBoYXMgZnJlZWQgdXAuXG4gICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHdyaXRlIHN0cmVhbSBjbG9zZWQgYWZ0ZXIgdGhlIHdyaXRlIGhhbmRzaGFrZSBjb21wbGV0ZXMsIGEgd3JpdGVcbiAgICAvLyBvcGVyYXRpb24gZmFpbGVkIGFuZCB3ZSBmYWlsIHRoZSBwZW5kaW5nIG9wZXJhdGlvbi5cbiAgICBpZiAoZXJyb3IgJiYgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIGFmZmVjdHMgdGhlIGFjdHVhbCB3cml0ZS5cbiAgICAgICAgYXdhaXQgaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gVGhlIHdyaXRlIHN0cmVhbSBtaWdodCBoYXZlIGJlZW4gc3RhcnRlZCBieSByZWZpbGxpbmcgdGhlIHdyaXRlXG4gICAgLy8gcGlwZWxpbmUgZm9yIGZhaWxlZCB3cml0ZXNcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXcml0ZUVycm9yKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcbiAgICAvLyBPbmx5IGhhbmRsZSBwZXJtYW5lbnQgZXJyb3JzIGhlcmUuIElmIGl0J3MgdHJhbnNpZW50LCBqdXN0IGxldCB0aGUgcmV0cnlcbiAgICAvLyBsb2dpYyBraWNrIGluLlxuICAgIGlmIChpc1Blcm1hbmVudFdyaXRlRXJyb3IoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBwZXJtYW5lbnQgZXJyb3IsIHRoZSByZXF1ZXN0IGl0c2VsZiB3YXMgdGhlIHByb2JsZW1cbiAgICAgICAgLy8gc28gaXQncyBub3QgZ29pbmcgdG8gc3VjY2VlZCBpZiB3ZSByZXNlbmQgaXQuXG4gICAgICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGl0J3MgYWxzbyB1bmxpa2VseSB0aGF0IHRoZSBzZXJ2ZXIgaXRzZWxmIGlzIG1lbHRpbmdcbiAgICAgICAgLy8gZG93biAtLSB0aGlzIHdhcyBqdXN0IGEgYmFkIHJlcXVlc3Qgc28gaW5oaWJpdCBiYWNrb2ZmIG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIHJlc3RhcnQuXG4gICAgICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUoYmF0Y2guYmF0Y2hJZCwgZXJyb3IpKTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvblxuICAgICAgICAvLyBhbm90aGVyIHNsb3QgaGFzIGZyZWVkIHVwLlxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc3RhcnROZXR3b3JrKHJlbW90ZVN0b3JlKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNCAvKiBPZmZsaW5lQ2F1c2UuQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UocmVtb3RlU3RvcmUsIHVzZXIpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZW1vdGVTdG9yZSByZWNlaXZlZCBuZXcgY3JlZGVudGlhbHMnKTtcbiAgICBjb25zdCB1c2VzTmV0d29yayA9IGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBUZWFyIGRvd24gYW5kIHJlLWNyZWF0ZSBvdXIgbmV0d29yayBzdHJlYW1zLiBUaGlzIHdpbGwgZW5zdXJlIHdlIGdldCBhXG4gICAgLy8gZnJlc2ggYXV0aCB0b2tlbiBmb3IgdGhlIG5ldyB1c2VyIGFuZCByZS1maWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoXG4gICAgLy8gbmV3IG11dGF0aW9ucyBmcm9tIHRoZSBMb2NhbFN0b3JlIChzaW5jZSBtdXRhdGlvbnMgYXJlIHBlci11c2VyKS5cbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMyAvKiBPZmZsaW5lQ2F1c2UuQ3JlZGVudGlhbENoYW5nZSAqLyk7XG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIGlmICh1c2VzTmV0d29yaykge1xuICAgICAgICAvLyBEb24ndCBzZXQgdGhlIG5ldHdvcmsgc3RhdHVzIHRvIFVua25vd24gaWYgd2UgYXJlIG9mZmxpbmUuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgIH1cbiAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UodXNlcik7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xuICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuLyoqXG4gKiBUb2dnbGVzIHRoZSBuZXR3b3JrIHN0YXRlIHdoZW4gdGhlIGNsaWVudCBnYWlucyBvciBsb3NlcyBpdHMgcHJpbWFyeSBsZWFzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBpZiAoaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiBub3QgeWV0IGluaXRpYWxpemVkLCByZWdpc3RlcnMgdGhlIFdhdGNoU3RyZWFtIGFuZCBpdHMgbmV0d29yayBzdGF0ZVxuICogY2FsbGJhY2sgd2l0aCBgcmVtb3RlU3RvcmVJbXBsYC4gUmV0dXJucyB0aGUgZXhpc3Rpbmcgc3RyZWFtIGlmIG9uZSBpc1xuICogYWxyZWFkeSBhdmFpbGFibGUuXG4gKlxuICogUE9SVElORyBOT1RFOiBPbiBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXYXRjaFN0cmVhbSBnZXRzIHJlZ2lzdGVyZWQgb24gc3RhcnR1cC5cbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxuICovXG5mdW5jdGlvbiBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSkge1xuICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIChidXQgbm90ZSB0aGF0IGl0IGlzIG5vdCBzdGFydGVkIHlldCkuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSA9IG5ld1BlcnNpc3RlbnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwuZGF0YXN0b3JlLCByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZSwge1xuICAgICAgICAgICAgb25Db25uZWN0ZWQ6IG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25PcGVuOiBvbldhdGNoU3RyZWFtT3Blbi5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkNsb3NlOiBvbldhdGNoU3RyZWFtQ2xvc2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25XYXRjaENoYW5nZTogb25XYXRjaFN0cmVhbUNoYW5nZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW07XG59XG4vKipcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV3JpdGVTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXG4gKiBjYWxsYmFjayB3aXRoIGByZW1vdGVTdG9yZUltcGxgLiBSZXR1cm5zIHRoZSBleGlzdGluZyBzdHJlYW0gaWYgb25lIGlzXG4gKiBhbHJlYWR5IGF2YWlsYWJsZS5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IE9uIGlPUyBhbmQgQW5kcm9pZCwgdGhlIFdyaXRlU3RyZWFtIGdldHMgcmVnaXN0ZXJlZCBvbiBzdGFydHVwLlxuICogVGhpcyBpcyBub3QgZG9uZSBvbiBXZWIgdG8gYWxsb3cgaXQgdG8gYmUgdHJlZS1zaGFrZW4uXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmICghcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtKSB7XG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtID0gbmV3UGVyc2lzdGVudFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUsIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLCB7XG4gICAgICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IG9uV3JpdGVTdHJlYW1DbG9zZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkhhbmRzaGFrZUNvbXBsZXRlOiBvbldyaXRlSGFuZHNoYWtlQ29tcGxldGUuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RhcnQgdGhlIHdyaXRlIHN0cmVhbSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCBgU3RvcHBpbmcgd3JpdGUgc3RyZWFtIHdpdGggJHtyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGh9IHBlbmRpbmcgd3JpdGVzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNCA9ICdBc3luY1F1ZXVlJztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXG4gKlxuICogSXQgaXMgY3JlYXRlZCB2aWEgRGVsYXllZE9wZXJhdGlvbi5jcmVhdGVBbmRTY2hlZHVsZSgpLlxuICpcbiAqIFN1cHBvcnRzIGNhbmNlbGxhdGlvbiAodmlhIGNhbmNlbCgpKSBhbmQgZWFybHkgZXhlY3V0aW9uICh2aWEgc2tpcERlbGF5KCkpLlxuICpcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcbiAqIGluIG5ld2VyIHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgZGVmaW5lcyBgZmluYWxseWAsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW5cbiAqIElFLlxuICovXG5jbGFzcyBEZWxheWVkT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lTXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcbiAgICAgICAgdGhpcy50YXJnZXRUaW1lTXMgPSB0YXJnZXRUaW1lTXM7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sgPSByZW1vdmFsQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xuICAgICAgICAvLyBJdCdzIG5vcm1hbCBmb3IgdGhlIGRlZmVycmVkIHByb21pc2UgdG8gYmUgY2FuY2VsZWQgKGR1ZSB0byBjYW5jZWxsYXRpb24pXG4gICAgICAgIC8vIGFuZCBzbyB3ZSBhdHRhY2ggYSBkdW1teSBjYXRjaCBjYWxsYmFjayB0byBhdm9pZFxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxuICAgICAgICB0aGlzLmRlZmVycmVkLnByb21pc2UuY2F0Y2goZXJyID0+IHsgfSk7XG4gICAgfVxuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgRGVsYXllZE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIHNjaGVkdWxlZCB0byBiZVxuICAgICAqIGV4ZWN1dGVkIG9uIHRoZSBwcm92aWRlZCBhc3luY1F1ZXVlIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheU1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jUXVldWUgLSBUaGUgcXVldWUgdG8gc2NoZWR1bGUgdGhlIG9wZXJhdGlvbiBvbi5cbiAgICAgKiBAcGFyYW0gaWQgLSBBIFRpbWVyIElEIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB0aGlzIGlzLlxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cbiAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHJ1bi5cbiAgICAgKiBAcGFyYW0gcmVtb3ZhbENhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBvbmNlIHRoZVxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XG4gICAgICogICBmcm9tIGl0cyBkZWxheWVkT3BlcmF0aW9ucyBsaXN0LlxuICAgICAqICAgUE9SVElORyBOT1RFOiBUaGlzIGV4aXN0cyB0byBwcmV2ZW50IG1ha2luZyByZW1vdmVEZWxheWVkT3BlcmF0aW9uKCkgYW5kXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFuZFNjaGVkdWxlKGFzeW5jUXVldWUsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IERhdGUubm93KCkgKyBkZWxheU1zO1xuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBuZXcgRGVsYXllZE9wZXJhdGlvbihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lLCBvcCwgcmVtb3ZhbENhbGxiYWNrKTtcbiAgICAgICAgZGVsYXllZE9wLnN0YXJ0KGRlbGF5TXMpO1xuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24gYnlcbiAgICAgKiBjcmVhdGVBbmRTY2hlZHVsZSgpLlxuICAgICAqL1xuICAgIHN0YXJ0KGRlbGF5TXMpIHtcbiAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKSwgZGVsYXlNcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgb3BlcmF0aW9uIHRvIHJ1biBpbW1lZGlhdGVseSAoaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBydW4gb3JcbiAgICAgKiBjYW5jZWxlZCkuXG4gICAgICovXG4gICAgc2tpcERlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgb3BlcmF0aW9uIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgb3IgY2FuY2VsZWQuIFRoZVxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEFzIGxvbmcgYXMgdGhlIG9wZXJhdGlvbiBoYXMgbm90IHlldCBiZWVuIHJ1biwgY2FsbGluZyBjYW5jZWwoKSBwcm92aWRlcyBhXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXG4gICAgICovXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgJ09wZXJhdGlvbiBjYW5jZWxsZWQnICsgKHJlYXNvbiA/ICc6ICcgKyByZWFzb24gOiAnJykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEZWxheUVsYXBzZWQoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEZpcmVzdG9yZUVycm9yIHRoYXQgY2FuIGJlIHN1cmZhY2VkIHRvIHRoZSB1c2VyIGlmIHRoZSBwcm92aWRlZFxuICogZXJyb3IgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gUmUtdGhyb3dzIHRoZSBlcnJvciBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgbXNnKSB7XG4gICAgbG9nRXJyb3IoTE9HX1RBRyQ0LCBgJHttc2d9OiAke2V9YCk7XG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsIGAke21zZ306ICR7ZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudFNldCBpcyBhbiBpbW11dGFibGUgKGNvcHktb24td3JpdGUpIGNvbGxlY3Rpb24gdGhhdCBob2xkcyBkb2N1bWVudHNcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gV2UgYWx3YXlzIGFkZCBhIGRvY3VtZW50IGtleVxuICogY29tcGFyYXRvciBvbiB0b3Agb2Ygd2hhdCBpcyBwcm92aWRlZCB0byBndWFyYW50ZWUgZG9jdW1lbnQgZXF1YWxpdHkgYmFzZWQgb25cbiAqIHRoZSBrZXkuXG4gKi9cbmNsYXNzIERvY3VtZW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IGNvcHkgb2YgdGhlIGV4aXN0aW5nIERvY3VtZW50U2V0LCB1c2luZyB0aGUgc2FtZVxuICAgICAqIGNvbXBhcmF0b3IuXG4gICAgICovXG4gICAgc3RhdGljIGVtcHR5U2V0KG9sZFNldCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U2V0KG9sZFNldC5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqIFRoZSBkZWZhdWx0IG9yZGVyaW5nIGlzIGJ5IGtleSBpZiB0aGUgY29tcGFyYXRvciBpcyBvbWl0dGVkICovXG4gICAgY29uc3RydWN0b3IoY29tcCkge1xuICAgICAgICAvLyBXZSBhcmUgYWRkaW5nIGRvY3VtZW50IGtleSBjb21wYXJhdG9yIHRvIHRoZSBlbmQgYXMgaXQncyB0aGUgb25seVxuICAgICAgICAvLyBndWFyYW50ZWVkIHVuaXF1ZSBwcm9wZXJ0eSBvZiBhIGRvY3VtZW50LlxuICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gY29tcChkMSwgZDIpIHx8IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXllZE1hcCA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMuc29ydGVkU2V0ID0gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleWVkTWFwLmdldChrZXkpICE9IG51bGw7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ZWRNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQubWluS2V5KCk7XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5tYXhLZXkoKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByb3ZpZGVkIGtleSBpbiB0aGUgZG9jdW1lbnQgc2V0LCBvciAtMSBpZiB0aGVcbiAgICAgKiBkb2N1bWVudCBrZXkgaXMgbm90IHByZXNlbnQgaW4gdGhlIHNldDtcbiAgICAgKi9cbiAgICBpbmRleE9mKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gZG9jID8gdGhpcy5zb3J0ZWRTZXQuaW5kZXhPZihkb2MpIDogLTE7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuc2l6ZTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGRvY3VtZW50cyBpbiBvcmRlciBkZWZpbmVkIGJ5IFwiY29tcGFyYXRvclwiICovXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgICB0aGlzLnNvcnRlZFNldC5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGtleSAqL1xuICAgIGFkZChkb2MpIHtcbiAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoZSBlbGVtZW50IGlmIHdlIGhhdmUgaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuZGVsZXRlKGRvYy5rZXkpO1xuICAgICAgICByZXR1cm4gc2V0LmNvcHkoc2V0LmtleWVkTWFwLmluc2VydChkb2Mua2V5LCBkb2MpLCBzZXQuc29ydGVkU2V0Lmluc2VydChkb2MsIG51bGwpKTtcbiAgICB9XG4gICAgLyoqIERlbGV0ZXMgYSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5ICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmtleWVkTWFwLnJlbW92ZShrZXkpLCB0aGlzLnNvcnRlZFNldC5yZW1vdmUoZG9jKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEb2N1bWVudFNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdCA9IG90aGVyLnNvcnRlZFNldC5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAodGhpc0l0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0RvYyA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJEb2MgPSBvdGhlckl0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBpZiAoIXRoaXNEb2MuaXNFcXVhbChvdGhlckRvYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkb2NTdHJpbmdzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgZG9jU3RyaW5ncy5wdXNoKGRvYy50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2NTdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RvY3VtZW50U2V0IChcXG4gICcgKyBkb2NTdHJpbmdzLmpvaW4oJyAgXFxuJykgKyAnXFxuKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShrZXllZE1hcCwgc29ydGVkU2V0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBEb2N1bWVudFNldCgpO1xuICAgICAgICBuZXdTZXQuY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgICAgbmV3U2V0LmtleWVkTWFwID0ga2V5ZWRNYXA7XG4gICAgICAgIG5ld1NldC5zb3J0ZWRTZXQgPSBzb3J0ZWRTZXQ7XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudENoYW5nZVNldCBrZWVwcyB0cmFjayBvZiBhIHNldCBvZiBjaGFuZ2VzIHRvIGRvY3MgaW4gYSBxdWVyeSwgbWVyZ2luZ1xuICogZHVwbGljYXRlIGV2ZW50cyBmb3IgdGhlIHNhbWUgZG9jLlxuICovXG5jbGFzcyBEb2N1bWVudENoYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgdHJhY2soY2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGNoYW5nZS5kb2Mua2V5O1xuICAgICAgICBjb25zdCBvbGRDaGFuZ2UgPSB0aGlzLmNoYW5nZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFvbGRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwgY2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXJnZSB0aGUgbmV3IGNoYW5nZSB3aXRoIHRoZSBleGlzdGluZyBjaGFuZ2UuXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovLFxuICAgICAgICAgICAgICAgIGRvYzogb2xkQ2hhbmdlLmRvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlc2UgY2FzZXMsIHdoaWNoIGRvbid0IG1ha2Ugc2Vuc2U6XG4gICAgICAgICAgICAvLyBBZGRlZC0+QWRkZWRcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPlJlbW92ZWRcbiAgICAgICAgICAgIC8vIE1vZGlmaWVkLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TW9kaWZpZWRcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TWV0YWRhdGFcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwLmlub3JkZXJUcmF2ZXJzYWwoKGtleSwgY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdTbmFwc2hvdCB7XG4gICAgY29uc3RydWN0b3IocXVlcnksIGRvY3MsIG9sZERvY3MsIGRvY0NoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIHN5bmNTdGF0ZUNoYW5nZWQsIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzLCBoYXNDYWNoZWRSZXN1bHRzKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5vbGREb2NzID0gb2xkRG9jcztcbiAgICAgICAgdGhpcy5kb2NDaGFuZ2VzID0gZG9jQ2hhbmdlcztcbiAgICAgICAgdGhpcy5tdXRhdGVkS2V5cyA9IG11dGF0ZWRLZXlzO1xuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkID0gc3luY1N0YXRlQ2hhbmdlZDtcbiAgICAgICAgdGhpcy5leGNsdWRlc01ldGFkYXRhQ2hhbmdlcyA9IGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzO1xuICAgICAgICB0aGlzLmhhc0NhY2hlZFJlc3VsdHMgPSBoYXNDYWNoZWRSZXN1bHRzO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHZpZXcgc25hcHNob3QgYXMgaWYgYWxsIGRvY3VtZW50cyBpbiB0aGUgc25hcHNob3Qgd2VyZSBhZGRlZC4gKi9cbiAgICBzdGF0aWMgZnJvbUluaXRpYWxEb2N1bWVudHMocXVlcnksIGRvY3VtZW50cywgbXV0YXRlZEtleXMsIGZyb21DYWNoZSwgaGFzQ2FjaGVkUmVzdWx0cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyB0eXBlOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8sIGRvYyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1NuYXBzaG90KHF1ZXJ5LCBkb2N1bWVudHMsIERvY3VtZW50U2V0LmVtcHR5U2V0KGRvY3VtZW50cyksIGNoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIFxuICAgICAgICAvKiBzeW5jU3RhdGVDaGFuZ2VkPSAqLyB0cnVlLCBcbiAgICAgICAgLyogZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM9ICovIGZhbHNlLCBoYXNDYWNoZWRSZXN1bHRzKTtcbiAgICB9XG4gICAgZ2V0IGhhc1BlbmRpbmdXcml0ZXMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5tdXRhdGVkS2V5cy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbUNhY2hlICE9PSBvdGhlci5mcm9tQ2FjaGUgfHxcbiAgICAgICAgICAgIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyAhPT0gb3RoZXIuaGFzQ2FjaGVkUmVzdWx0cyB8fFxuICAgICAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkICE9PSBvdGhlci5zeW5jU3RhdGVDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhdGhpcy5tdXRhdGVkS2V5cy5pc0VxdWFsKG90aGVyLm11dGF0ZWRLZXlzKSB8fFxuICAgICAgICAgICAgIXF1ZXJ5RXF1YWxzKHRoaXMucXVlcnksIG90aGVyLnF1ZXJ5KSB8fFxuICAgICAgICAgICAgIXRoaXMuZG9jcy5pc0VxdWFsKG90aGVyLmRvY3MpIHx8XG4gICAgICAgICAgICAhdGhpcy5vbGREb2NzLmlzRXF1YWwob3RoZXIub2xkRG9jcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kb2NDaGFuZ2VzO1xuICAgICAgICBjb25zdCBvdGhlckNoYW5nZXMgPSBvdGhlci5kb2NDaGFuZ2VzO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggIT09IG90aGVyQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLnR5cGUgIT09IG90aGVyQ2hhbmdlc1tpXS50eXBlIHx8XG4gICAgICAgICAgICAgICAgIWNoYW5nZXNbaV0uZG9jLmlzRXF1YWwob3RoZXJDaGFuZ2VzW2ldLmRvYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIb2xkcyB0aGUgbGlzdGVuZXJzIGFuZCB0aGUgbGFzdCByZWNlaXZlZCBWaWV3U25hcHNob3QgZm9yIGEgcXVlcnkgYmVpbmdcbiAqIHRyYWNrZWQgYnkgRXZlbnRNYW5hZ2VyLlxuICovXG5jbGFzcyBRdWVyeUxpc3RlbmVyc0luZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpZXdTbmFwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgbWV0aG9kcyB0aGF0IGNoZWNrcyBpZiB0aGUgcXVlcnkgaGFzIGxpc3RlbmVycyB0aGF0IGxpc3RlbmluZyB0byByZW1vdGUgc3RvcmVcbiAgICBoYXNSZW1vdGVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zb21lKGxpc3RlbmVyID0+IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0V2ZW50TWFuYWdlcigpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50TWFuYWdlckltcGwoKTtcbn1cbmNsYXNzIEV2ZW50TWFuYWdlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXdRdWVyaWVzT2JqZWN0TWFwKCk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICB0aGlzLnNuYXBzaG90c0luU3luY0xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICBlcnJvckFsbFRhcmdldHModGhpcywgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0ZpcmVzdG9yZSBzaHV0dGluZyBkb3duJykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1F1ZXJpZXNPYmplY3RNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RNYXAocSA9PiBjYW5vbmlmeVF1ZXJ5KHEpLCBxdWVyeUVxdWFscyk7XG59XG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBsZXQgbGlzdGVuZXJBY3Rpb24gPSAzIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlbmVyLnF1ZXJ5O1xuICAgIGxldCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5SW5mbykge1xuICAgICAgICBxdWVyeUluZm8gPSBuZXcgUXVlcnlMaXN0ZW5lcnNJbmZvKCk7XG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxuICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuT25seSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxuICAgICAgICBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgIC8vIFF1ZXJ5IGhhcyBiZWVuIGxpc3RlbmluZyB0byBsb2NhbCBjYWNoZSwgYW5kIHRyaWVzIHRvIGFkZCBhIG5ldyBsaXN0ZW5lciBzb3VyY2VkIGZyb20gd2F0Y2guXG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLlJlcXVpcmVXYXRjaENvbm5lY3Rpb25Pbmx5ICovO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RlbmVyQWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5Jbml0aWFsaXplTG9jYWxMaXN0ZW5BbmRSZXF1aXJlV2F0Y2hDb25uZWN0aW9uICovOlxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby52aWV3U25hcCA9IGF3YWl0IGV2ZW50TWFuYWdlckltcGwub25MaXN0ZW4ocXVlcnksIFxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuT25seSAqLzpcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgICAgICAvKiogZW5hYmxlUmVtb3RlTGlzdGVuPSAqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uRmlyc3RSZW1vdGVTdG9yZUxpc3RlbihxdWVyeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgSW5pdGlhbGl6YXRpb24gb2YgcXVlcnkgJyR7c3RyaW5naWZ5UXVlcnkobGlzdGVuZXIucXVlcnkpfScgZmFpbGVkYCk7XG4gICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5zZXQocXVlcnksIHF1ZXJ5SW5mbyk7XG4gICAgcXVlcnlJbmZvLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cbiAgICBsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUpO1xuICAgIGlmIChxdWVyeUluZm8udmlld1NuYXApIHtcbiAgICAgICAgY29uc3QgcmFpc2VkRXZlbnQgPSBsaXN0ZW5lci5vblZpZXdTbmFwc2hvdChxdWVyeUluZm8udmlld1NuYXApO1xuICAgICAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuZXIucXVlcnk7XG4gICAgbGV0IGxpc3RlbmVyQWN0aW9uID0gMyAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcbiAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICBpZiAocXVlcnlJbmZvKSB7XG4gICAgICAgIGNvbnN0IGkgPSBxdWVyeUluZm8ubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICBxdWVyeUluZm8ubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWVyeUluZm8ubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxuICAgICAgICAgICAgICAgICAgICA/IDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDEgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuT25seSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFxdWVyeUluZm8uaGFzUmVtb3RlTGlzdGVuZXJzKCkgJiZcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgbGlzdGVuZXIgaXMgdGhlIGxhc3Qgb25lIHRoYXQgc291cmNlZCBmcm9tIHdhdGNoLlxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbk9ubHkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChsaXN0ZW5lckFjdGlvbikge1xuICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqLzpcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25Vbmxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gdHJ1ZSk7XG4gICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uVGVybWluYXRlTG9jYWxMaXN0ZW5Pbmx5ICovOlxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vblVubGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgIC8qKiBkaXNhYmxlUmVtb3RlTGlzdGVuPSAqLyBmYWxzZSk7XG4gICAgICAgIGNhc2UgMiAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbk9ubHkgKi86XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vbkxhc3RSZW1vdGVTdG9yZVVubGlzdGVuKHF1ZXJ5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlKGV2ZW50TWFuYWdlciwgdmlld1NuYXBzKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgdmlld1NuYXAgb2Ygdmlld1NuYXBzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdmlld1NuYXAucXVlcnk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xuICAgICAgICBpZiAocXVlcnlJbmZvKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25WaWV3U25hcHNob3Qodmlld1NuYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSB2aWV3U25hcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoRXJyb3IoZXZlbnRNYW5hZ2VyLCBxdWVyeSwgZXJyb3IpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLiBOT1RFOiBXZSBkb24ndCBuZWVkIHRvIGNhbGwgc3luY0VuZ2luZS51bmxpc3RlbigpXG4gICAgLy8gYWZ0ZXIgYW4gZXJyb3IuXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XG59XG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5mb3JFYWNoKChfLCBxdWVyeUluZm8pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyYWlzZWRFdmVudCkge1xuICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuYWRkKG9ic2VydmVyKTtcbiAgICAvLyBJbW1lZGlhdGVseSBmaXJlIGFuIGluaXRpYWwgZXZlbnQsIGluZGljYXRpbmcgYWxsIGV4aXN0aW5nIGxpc3RlbmVyc1xuICAgIC8vIGFyZSBpbi1zeW5jLlxuICAgIG9ic2VydmVyLm5leHQoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyKTtcbn1cbmZ1bmN0aW9uIGVycm9yQWxsVGFyZ2V0cyhldmVudE1hbmFnZXIsIGVycm9yKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXM7XG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIGFjY2VzcyBieSBjbGVhcmluZyBPYmplY3RNYXAuXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzID0gbmV3UXVlcmllc09iamVjdE1hcCgpO1xuICAgIHF1ZXJpZXMuZm9yRWFjaCgoXywgcXVlcnlJbmZvKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIub25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIENhbGwgYWxsIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxuZnVuY3Rpb24gcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKSB7XG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoKTtcbiAgICB9KTtcbn1cbnZhciBMaXN0ZW5lckRhdGFTb3VyY2U7XG4oZnVuY3Rpb24gKExpc3RlbmVyRGF0YVNvdXJjZSkge1xuICAgIC8qKiBMaXN0ZW4gdG8gYm90aCBjYWNoZSBhbmQgc2VydmVyIGNoYW5nZXMgKi9cbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XG4gICAgLyoqIExpc3RlbiB0byBjaGFuZ2VzIGluIGNhY2hlIG9ubHkgKi9cbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJDYWNoZVwiXSA9IFwiY2FjaGVcIjtcbn0pKExpc3RlbmVyRGF0YVNvdXJjZSB8fCAoTGlzdGVuZXJEYXRhU291cmNlID0ge30pKTtcbi8qKlxuICogUXVlcnlMaXN0ZW5lciB0YWtlcyBhIHNlcmllcyBvZiBpbnRlcm5hbCB2aWV3IHNuYXBzaG90cyBhbmQgZGV0ZXJtaW5lc1xuICogd2hlbiB0byByYWlzZSB0aGUgZXZlbnQuXG4gKlxuICogSXQgdXNlcyBhbiBPYnNlcnZlciB0byBkaXNwYXRjaCBldmVudHMuXG4gKi9cbmNsYXNzIFF1ZXJ5TGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBxdWVyeU9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyID0gcXVlcnlPYnNlcnZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWwgc25hcHNob3RzIChlLmcuIGZyb20gY2FjaGUpIG1heSBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgd3JhcHBlZFxuICAgICAgICAgKiBvYnNlcnZlci4gVGhpcyBmbGFnIGlzIHNldCB0byB0cnVlIG9uY2Ugd2UndmUgYWN0dWFsbHkgcmFpc2VkIGFuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zbmFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi87XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIG5ldyBWaWV3U25hcHNob3QgdG8gdGhpcyBsaXN0ZW5lciwgcmFpc2luZyBhIHVzZXItZmFjaW5nIGV2ZW50XG4gICAgICogaWYgYXBwbGljYWJsZSAoZGVwZW5kaW5nIG9uIHdoYXQgY2hhbmdlZCwgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW50b1xuICAgICAqIG1ldGFkYXRhLW9ubHkgY2hhbmdlcywgZXRjLikuIFJldHVybnMgdHJ1ZSBpZiBhIHVzZXItZmFjaW5nIGV2ZW50IHdhc1xuICAgICAqIGluZGVlZCByYWlzZWQuXG4gICAgICovXG4gICAgb25WaWV3U25hcHNob3Qoc25hcCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1ldGFkYXRhIG9ubHkgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHNuYXAuZG9jQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChkb2NDaGFuZ2UudHlwZSAhPT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoYW5nZXMucHVzaChkb2NDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHNuYXAucXVlcnksIHNuYXAuZG9jcywgc25hcC5vbGREb2NzLCBkb2NDaGFuZ2VzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5zeW5jU3RhdGVDaGFuZ2VkLCBcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyB0cnVlLCBzbmFwLmhhc0NhY2hlZFJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCB0aGlzLm9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VJbml0aWFsRXZlbnQoc25hcCk7XG4gICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2hvdWxkUmFpc2VFdmVudChzbmFwKSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcbiAgICAgICAgcmV0dXJuIHJhaXNlZEV2ZW50O1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgYSBzbmFwc2hvdCB3YXMgcmFpc2VkLiAqL1xuICAgIGFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpIHtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc25hcCAmJlxuICAgICAgICAgICAgIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ICYmXG4gICAgICAgICAgICB0aGlzLnNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHRoaXMuc25hcCwgb25saW5lU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHRoaXMuc25hcCk7XG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhaXNlZEV2ZW50O1xuICAgIH1cbiAgICBzaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCBvbmxpbmVTdGF0ZSkge1xuICAgICAgICAvLyBBbHdheXMgcmFpc2UgdGhlIGZpcnN0IGV2ZW50IHdoZW4gd2UncmUgc3luY2VkXG4gICAgICAgIGlmICghc25hcC5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByYWlzZSBldmVudCBpZiBsaXN0ZW5pbmcgdG8gY2FjaGVcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IFdlIGNvbnNpZGVyIE9ubGluZVN0YXRlLlVua25vd24gYXMgb25saW5lIChpdCBzaG91bGQgYmVjb21lIE9mZmxpbmVcbiAgICAgICAgLy8gb3IgT25saW5lIGlmIHdlIHdhaXQgbG9uZyBlbm91Z2gpLlxuICAgICAgICBjb25zdCBtYXliZU9ubGluZSA9IG9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovO1xuICAgICAgICAvLyBEb24ndCByYWlzZSB0aGUgZXZlbnQgaWYgd2UncmUgb25saW5lLCBhcmVuJ3Qgc3luY2VkIHlldCAoY2hlY2tlZFxuICAgICAgICAvLyBhYm92ZSkgYW5kIGFyZSB3YWl0aW5nIGZvciBhIHN5bmMuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FpdEZvclN5bmNXaGVuT25saW5lICYmIG1heWJlT25saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmFpc2UgZGF0YSBmcm9tIGNhY2hlIGlmIHdlIGhhdmUgYW55IGRvY3VtZW50cywgaGF2ZSBjYWNoZWQgcmVzdWx0cyBiZWZvcmUsXG4gICAgICAgIC8vIG9yIHdlIGFyZSBvZmZsaW5lLlxuICAgICAgICByZXR1cm4gKCFzbmFwLmRvY3MuaXNFbXB0eSgpIHx8XG4gICAgICAgICAgICBzbmFwLmhhc0NhY2hlZFJlc3VsdHMgfHxcbiAgICAgICAgICAgIG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcbiAgICB9XG4gICAgc2hvdWxkUmFpc2VFdmVudChzbmFwKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gaGFuZGxlIGluY2x1ZGVEb2N1bWVudE1ldGFkYXRhQ2hhbmdlcyBoZXJlIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIE1ldGFkYXRhIG9ubHkgY2hhbmdlcyBoYXZlIGFscmVhZHkgYmVlbiBzdHJpcHBlZCBvdXQgaWYgbmVlZGVkLlxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBvbmx5IGNoYW5nZXMgd2Ugd2lsbCBzZWUgYXJlIHRoZSBvbmVzIHdlIHNob3VsZFxuICAgICAgICAvLyBwcm9wYWdhdGUuXG4gICAgICAgIGlmIChzbmFwLmRvY0NoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUGVuZGluZ1dyaXRlc0NoYW5nZWQgPSB0aGlzLnNuYXAgJiYgdGhpcy5zbmFwLmhhc1BlbmRpbmdXcml0ZXMgIT09IHNuYXAuaGFzUGVuZGluZ1dyaXRlcztcbiAgICAgICAgaWYgKHNuYXAuc3luY1N0YXRlQ2hhbmdlZCB8fCBoYXNQZW5kaW5nV3JpdGVzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYWxseSB3ZSBzaG91bGQgaGF2ZSBoaXQgb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgYnV0IGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdG8gZ2V0IGhlcmUgaWYgdGhlcmUgd2VyZSBvbmx5IG1ldGFkYXRhIGRvY0NoYW5nZXMgYW5kIHRoZXkgZ290XG4gICAgICAgIC8vIHN0cmlwcGVkIG91dC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByYWlzZUluaXRpYWxFdmVudChzbmFwKSB7XG4gICAgICAgIHNuYXAgPSBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHMoc25hcC5xdWVyeSwgc25hcC5kb2NzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIubmV4dChzbmFwKTtcbiAgICB9XG4gICAgbGlzdGVuc1RvUmVtb3RlU3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc291cmNlICE9PSBMaXN0ZW5lckRhdGFTb3VyY2UuQ2FjaGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHNldCBvZiBjaGFuZ2VzIHRvIHdoYXQgZG9jdW1lbnRzIGFyZSBjdXJyZW50bHkgaW4gdmlldyBhbmQgb3V0IG9mIHZpZXcgZm9yXG4gKiBhIGdpdmVuIHF1ZXJ5LiBUaGVzZSBjaGFuZ2VzIGFyZSBzZW50IHRvIHRoZSBMb2NhbFN0b3JlIGJ5IHRoZSBWaWV3ICh2aWFcbiAqIHRoZSBTeW5jRW5naW5lKSBhbmQgYXJlIHVzZWQgdG8gcGluIC8gdW5waW4gZG9jdW1lbnRzIGFzIGFwcHJvcHJpYXRlLlxuICovXG5jbGFzcyBMb2NhbFZpZXdDaGFuZ2VzIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgZnJvbUNhY2hlLCBhZGRlZEtleXMsIHJlbW92ZWRLZXlzKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XG4gICAgICAgIHRoaXMuYWRkZWRLZXlzID0gYWRkZWRLZXlzO1xuICAgICAgICB0aGlzLnJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU25hcHNob3QodGFyZ2V0SWQsIHZpZXdTbmFwc2hvdCkge1xuICAgICAgICBsZXQgYWRkZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgbGV0IHJlbW92ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBkb2NDaGFuZ2Ugb2Ygdmlld1NuYXBzaG90LmRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jQ2hhbmdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRLZXlzID0gYWRkZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXMuYWRkKGRvY0NoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxWaWV3Q2hhbmdlcyh0YXJnZXRJZCwgdmlld1NuYXBzaG90LmZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIZWxwZXIgdG8gY29udmVydCBvYmplY3RzIGZyb20gYnVuZGxlcyB0byBtb2RlbCBvYmplY3RzIGluIHRoZSBTREsuXG4gKi9cbmNsYXNzIEJ1bmRsZUNvbnZlcnRlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgdG9Eb2N1bWVudEtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiBmcm9tTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJ1bmRsZURvY3VtZW50IHRvIGEgTXV0YWJsZURvY3VtZW50LlxuICAgICAqL1xuICAgIHRvTXV0YWJsZURvY3VtZW50KGJ1bmRsZWREb2MpIHtcbiAgICAgICAgaWYgKGJ1bmRsZWREb2MubWV0YWRhdGEuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbURvY3VtZW50KHRoaXMuc2VyaWFsaXplciwgYnVuZGxlZERvYy5kb2N1bWVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KHRoaXMudG9Eb2N1bWVudEtleShidW5kbGVkRG9jLm1ldGFkYXRhLm5hbWUpLCB0aGlzLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZWREb2MubWV0YWRhdGEucmVhZFRpbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1NuYXBzaG90VmVyc2lvbih0aW1lKSB7XG4gICAgICAgIHJldHVybiBmcm9tVmVyc2lvbih0aW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdG8gcHJvY2VzcyB0aGUgZWxlbWVudHMgZnJvbSBhIGJ1bmRsZSwgbG9hZCB0aGVtIGludG8gbG9jYWxcbiAqIHN0b3JhZ2UgYW5kIHByb3ZpZGUgcHJvZ3Jlc3MgdXBkYXRlIHdoaWxlIGxvYWRpbmcuXG4gKi9cbmNsYXNzIEJ1bmRsZUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVuZGxlTWV0YWRhdGEsIGxvY2FsU3RvcmUsIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5idW5kbGVNZXRhZGF0YSA9IGJ1bmRsZU1ldGFkYXRhO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKiogQmF0Y2hlZCBxdWVyaWVzIHRvIGJlIHNhdmVkIGludG8gc3RvcmFnZSAqL1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcbiAgICAgICAgLyoqIEJhdGNoZWQgZG9jdW1lbnRzIHRvIGJlIHNhdmVkIGludG8gc3RvcmFnZSAqL1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuICAgICAgICAvKiogVGhlIGNvbGxlY3Rpb24gZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoaXMgYnVuZGxlLiAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBidW5kbGVJbml0aWFsUHJvZ3Jlc3MoYnVuZGxlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgZnJvbSB0aGUgYnVuZGxlIHRvIHRoZSBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHByb2dyZXNzIGlmIGFkZGluZyB0aGUgZWxlbWVudCBsZWFkcyB0byBhIG5ldyBwcm9ncmVzcyxcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIGFkZFNpemVkRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MuYnl0ZXNMb2FkZWQgKz0gZWxlbWVudC5ieXRlTGVuZ3RoO1xuICAgICAgICBsZXQgZG9jdW1lbnRzTG9hZGVkID0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgIGlmIChlbGVtZW50LnBheWxvYWQubmFtZWRRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyaWVzLnB1c2goZWxlbWVudC5wYXlsb2FkLm5hbWVkUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50cy5wdXNoKHsgbWV0YWRhdGE6IGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudE1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICArK2RvY3VtZW50c0xvYWRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3Vwcy5hZGQocGF0aC5nZXQocGF0aC5sZW5ndGggLSAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1t0aGlzLmRvY3VtZW50cy5sZW5ndGggLSAxXS5kb2N1bWVudCA9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50O1xuICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50c0xvYWRlZCAhPT0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkID0gZG9jdW1lbnRzTG9hZGVkO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRRdWVyeURvY3VtZW50TWFwcGluZyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlEb2N1bWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYnVuZGxlQ29udmVydGVyID0gbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgZm9yIChjb25zdCBidW5kbGVEb2Mgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5TmFtZSBvZiBidW5kbGVEb2MubWV0YWRhdGEucXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleXMgPSAocXVlcnlEb2N1bWVudE1hcC5nZXQocXVlcnlOYW1lKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeURvY3VtZW50TWFwLnNldChxdWVyeU5hbWUsIGRvY3VtZW50S2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeURvY3VtZW50TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIHRvICdTdWNjZXNzJyBhbmQgcmV0dXJuIHRoZSB1cGRhdGVkIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbXBsZXRlKCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VkRG9jcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseUJ1bmRsZWREb2N1bWVudHModGhpcy5sb2NhbFN0b3JlLCBuZXcgQnVuZGxlQ29udmVydGVySW1wbCh0aGlzLnNlcmlhbGl6ZXIpLCB0aGlzLmRvY3VtZW50cywgdGhpcy5idW5kbGVNZXRhZGF0YS5pZCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSB0aGlzLmdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKHRoaXMuZG9jdW1lbnRzKTtcbiAgICAgICAgZm9yIChjb25zdCBxIG9mIHRoaXMucXVlcmllcykge1xuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVNhdmVOYW1lZFF1ZXJ5KHRoaXMubG9jYWxTdG9yZSwgcSwgcXVlcnlEb2N1bWVudE1hcC5nZXQocS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzcy50YXNrU3RhdGUgPSAnU3VjY2Vzcyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzcyxcbiAgICAgICAgICAgIGNoYW5nZWRDb2xsZWN0aW9uR3JvdXBzOiB0aGlzLmNvbGxlY3Rpb25Hcm91cHMsXG4gICAgICAgICAgICBjaGFuZ2VkRG9jc1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWwgcHJvZ3Jlc3Mgb2ZcbiAqIGxvYWRpbmcgYSBidW5kbGUuXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDAsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3MgdGhhdCB0aGUgbG9hZGluZ1xuICogaGFzIHN1Y2NlZWRlZC5cbiAqL1xuZnVuY3Rpb24gYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFza1N0YXRlOiAnU3VjY2VzcycsXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQWRkZWRMaW1ib0RvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuY2xhc3MgUmVtb3ZlZExpbWJvRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG59XG4vKipcbiAqIFZpZXcgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgZmluYWwgbWVyZ2VkIHRydXRoIG9mIHdoYXQgZG9jcyBhcmUgaW5cbiAqIGEgcXVlcnkuIEl0IGdldHMgbm90aWZpZWQgb2YgbG9jYWwgYW5kIHJlbW90ZSBjaGFuZ2VzIHRvIGRvY3MsIGFuZCBhcHBsaWVzXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcbiAgICAvKiogRG9jdW1lbnRzIGluY2x1ZGVkIGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXG4gICAgX3N5bmNlZERvY3VtZW50cykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IF9zeW5jZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgd2hldGhlciB0aGUgdmlldyBpcyBjdXJyZW50IHdpdGggdGhlIGJhY2tlbmQuIEEgdmlldyBpcyBjb25zaWRlcmVkXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XG4gICAgICAgICAqIGxvc2UgY29uc2lzdGVuY3kgd2l0aGluIHRoZSB3YXRjaCBzdHJlYW0gKGUuZy4gYmVjYXVzZSBvZiBhbiBleGlzdGVuY2VcbiAgICAgICAgICogZmlsdGVyIG1pc21hdGNoKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKiogRG9jdW1lbnRzIGluIHRoZSB2aWV3IGJ1dCBub3QgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIC8qKiBEb2N1bWVudCBLZXlzIHRoYXQgaGF2ZSBsb2NhbCBjaGFuZ2VzICovXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U2V0ID0gbmV3IERvY3VtZW50U2V0KHRoaXMuZG9jQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgcmVtb3RlIGRvY3VtZW50cyB0aGF0IHRoZSBzZXJ2ZXIgaGFzIHRvbGQgdXMgYmVsb25ncyB0byB0aGUgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgc3luY2VkRG9jdW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3luY2VkRG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIGRvYyBjaGFuZ2VzLCBhcHBsaWVzIHRoZSBxdWVyeSBsaW1pdCwgYW5kIGNvbXB1dGVzXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxuICAgICAqIG5lZWQgdG8gZ28gYmFjayB0byB0aGUgbG9jYWwgY2FjaGUgZm9yIG1vcmUgcmVzdWx0cy4gRG9lcyBub3QgbWFrZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cbiAgICAgKiBAcGFyYW0gcHJldmlvdXNDaGFuZ2VzIC0gSWYgdGhpcyBpcyBiZWluZyBjYWxsZWQgd2l0aCBhIHJlZmlsbCwgdGhlbiBzdGFydFxuICAgICAqICAgICAgICB3aXRoIHRoaXMgc2V0IG9mIGRvY3MgYW5kIGNoYW5nZXMgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXG4gICAgICovXG4gICAgY29tcHV0ZURvY0NoYW5nZXMoZG9jQ2hhbmdlcywgcHJldmlvdXNDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuY2hhbmdlU2V0XG4gICAgICAgICAgICA6IG5ldyBEb2N1bWVudENoYW5nZVNldCgpO1xuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuZG9jdW1lbnRTZXRcbiAgICAgICAgICAgIDogdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5tdXRhdGVkS2V5c1xuICAgICAgICAgICAgOiB0aGlzLm11dGF0ZWRLZXlzO1xuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5lZWRzUmVmaWxsID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBsYXN0IGRvYyBpbiBhIChmdWxsKSBsaW1pdC4gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugc29tZVxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcbiAgICAgICAgLy8gbWVhbiB0aGVyZSBpcyBzb21lIG90aGVyIGRvY3VtZW50IGluIHRoZSBsb2NhbCBjYWNoZSB0aGF0IGVpdGhlciBzaG91bGRcbiAgICAgICAgLy8gY29tZSAoMSkgYmV0d2VlbiB0aGUgb2xkIGxhc3QgbGltaXQgZG9jIGFuZCB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZVxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIGRlbGV0ZXMuIFNvIHdlIGtlZXAgdGhpcyBkb2MgYXQgdGhlIG9sZCBsaW1pdCB0byBjb21wYXJlIHRoZSB1cGRhdGVzIHRvLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXG4gICAgICAgIC8vIHNldCksIGJlY2F1c2UgdGhlcmUgd2lsbCBvbmx5IGJlIGFkZHMgLS0gbm8gZGVsZXRlcyBvciB1cGRhdGVzLlxuICAgICAgICBjb25zdCBsYXN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8gJiZcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGZpcnN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxuICAgICAgICAgICAgb2xkRG9jdW1lbnRTZXQuc2l6ZSA9PT0gdGhpcy5xdWVyeS5saW1pdFxuICAgICAgICAgICAgPyBvbGREb2N1bWVudFNldC5maXJzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGRvY0NoYW5nZXMuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jID0gb2xkRG9jdW1lbnRTZXQuZ2V0KGtleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBxdWVyeU1hdGNoZXModGhpcy5xdWVyeSwgZW50cnkpID8gZW50cnkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyA9IG9sZERvY1xuICAgICAgICAgICAgICAgID8gdGhpcy5tdXRhdGVkS2V5cy5oYXMob2xkRG9jLmtleSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucyA9IG5ld0RvY1xuICAgICAgICAgICAgICAgID8gbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY29uc2lkZXIgY29tbWl0dGVkIG11dGF0aW9ucyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZVxuICAgICAgICAgICAgICAgICAgICAvLyBtdXRhdGVkIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhlIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm11dGF0ZWRLZXlzLmhhcyhuZXdEb2Mua2V5KSAmJiBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hhbmdlQXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZVxuICAgICAgICAgICAgaWYgKG9sZERvYyAmJiBuZXdEb2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NzRXF1YWwgPSBvbGREb2MuZGF0YS5pc0VxdWFsKG5ld0RvYy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3NFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jOiBuZXdEb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NDb21wYXJhdG9yKG5ld0RvYywgbGFzdERvY0luTGltaXQpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGZpcnN0RG9jSW5MaW1pdCkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9jIG1vdmVkIGZyb20gaW5zaWRlIHRoZSBsaW1pdCB0byBvdXRzaWRlIHRoZSBsaW1pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZXJlIG1heSBiZSBzb21lIG90aGVyIGRvYyBpbiB0aGUgbG9jYWwgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVmaWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zICE9PSBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvbGREb2MgJiYgbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2M6IG5ld0RvYyB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZERvYyAmJiAhbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RG9jSW5MaW1pdCB8fCBmaXJzdERvY0luTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkb2Mgd2FzIHJlbW92ZWQgZnJvbSBhIGZ1bGwgbGltaXQgcXVlcnkuIFdlJ2xsIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVyeSBmcm9tIHRoZSBsb2NhbCBjYWNoZSB0byBzZWUgaWYgd2Uga25vdyBhYm91dCBzb21lIG90aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvYyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VBcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RvYykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmFkZChuZXdEb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJvcCBkb2N1bWVudHMgb3V0IHRvIG1lZXQgbGltaXQvbGltaXRUb0xhc3QgcmVxdWlyZW1lbnQuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmxpbWl0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV3RG9jdW1lbnRTZXQuc2l6ZSA+IHRoaXMucXVlcnkubGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREb2MgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXG4gICAgICAgICAgICAgICAgICAgID8gbmV3RG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2V0OiBuZXdEb2N1bWVudFNldCxcbiAgICAgICAgICAgIGNoYW5nZVNldCxcbiAgICAgICAgICAgIG5lZWRzUmVmaWxsLFxuICAgICAgICAgICAgbXV0YXRlZEtleXM6IG5ld011dGF0ZWRLZXlzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykge1xuICAgICAgICAvLyBXZSBzdXBwcmVzcyB0aGUgaW5pdGlhbCBjaGFuZ2UgZXZlbnQgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiBhIHdyaXRlIGFja25vd2xlZGdtZW50IChlLmcuIHdoZW4gdGhlIHZhbHVlIG9mIGEgc2VydmVyIHRyYW5zZm9ybVxuICAgICAgICAvLyBpcyBhcHBsaWVkKSBhcyBXYXRjaCB3aWxsIHNlbmQgdXMgdGhlIHNhbWUgZG9jdW1lbnQgYWdhaW4uXG4gICAgICAgIC8vIEJ5IHN1cHByZXNzaW5nIHRoZSBldmVudCwgd2Ugb25seSByYWlzZSB0d28gdXNlciB2aXNpYmxlIGV2ZW50cyAob25lIHdpdGhcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KSBpbnN0ZWFkIG9mIHRocmVlXG4gICAgICAgIC8vIChvbmUgd2l0aCBgaGFzUGVuZGluZ1dyaXRlc2AsIHRoZSBtb2RpZmllZCBkb2N1bWVudCB3aXRoXG4gICAgICAgIC8vIGBoYXNQZW5kaW5nV3JpdGVzYCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIHJldHVybiAob2xkRG9jLmhhc0xvY2FsTXV0YXRpb25zICYmXG4gICAgICAgICAgICBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zICYmXG4gICAgICAgICAgICAhbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBWaWV3RG9jdW1lbnRDaGFuZ2VzIGFuZCBvcHRpb25hbGx5IHVwZGF0ZXNcbiAgICAgKiBsaW1ibyBkb2NzIGFuZCBzeW5jIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIHRhcmdldCBjaGFuZ2UuXG4gICAgICogQHBhcmFtIGRvY0NoYW5nZXMgLSBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gbWFrZSB0byB0aGUgdmlldydzIGRvY3MuXG4gICAgICogQHBhcmFtIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQgLSBXaGV0aGVyIHRvIHVwZGF0ZSBsaW1ibyBkb2N1bWVudHMgYmFzZWQgb25cbiAgICAgKiAgICAgICAgdGhpcyBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHRhcmdldENoYW5nZSAtIEEgdGFyZ2V0IGNoYW5nZSB0byBhcHBseSBmb3IgY29tcHV0aW5nIGxpbWJvIGRvY3MgYW5kXG4gICAgICogICAgICAgIHN5bmMgc3RhdGUuXG4gICAgICogQHBhcmFtIHRhcmdldElzUGVuZGluZ1Jlc2V0IC0gV2hldGhlciB0aGUgdGFyZ2V0IGlzIHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvXG4gICAgICogICAgICAgIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guIElmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgaXQgaXMgdHJlYXRlZFxuICAgICAqICAgICAgICBlcXVpdmFsZW50bHkgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIGlPUy9BbmRyb2lkIGNsaWVudHMgYWx3YXlzIGNvbXB1dGUgbGltYm8gZG9jdW1lbnQgY2hhbmdlcy5cbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgbGltYm9SZXNvbHV0aW9uRW5hYmxlZCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCkge1xuICAgICAgICBjb25zdCBvbGREb2NzID0gdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgdGhpcy5kb2N1bWVudFNldCA9IGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQ7XG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xuICAgICAgICAvLyBTb3J0IGNoYW5nZXMgYmFzZWQgb24gdHlwZSBhbmQgcXVlcnkgY29tcGFyYXRvclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZG9jQ2hhbmdlcy5jaGFuZ2VTZXQuZ2V0Q2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlQ2hhbmdlVHlwZShjMS50eXBlLCBjMi50eXBlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihjMS5kb2MsIGMyLmRvYykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpO1xuICAgICAgICB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHRhcmdldElzUGVuZGluZ1Jlc2V0ICE9PSBudWxsICYmIHRhcmdldElzUGVuZGluZ1Jlc2V0ICE9PSB2b2lkIDAgPyB0YXJnZXRJc1BlbmRpbmdSZXNldCA6IGZhbHNlO1xuICAgICAgICBjb25zdCBsaW1ib0NoYW5nZXMgPSBsaW1ib1Jlc29sdXRpb25FbmFibGVkICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldFxuICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZUxpbWJvRG9jdW1lbnRzKClcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIC8vIFdlIGFyZSBhdCBzeW5jZWQgc3RhdGUgaWYgdGhlcmUgaXMgbm8gbGltYm8gZG9jcyBhcmUgd2FpdGluZyB0byBiZSByZXNvbHZlZCwgdmlldyBpcyBjdXJyZW50XG4gICAgICAgIC8vIHdpdGggdGhlIGJhY2tlbmQsIGFuZCB0aGUgcXVlcnkgaXMgbm90IHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guXG4gICAgICAgIGNvbnN0IHN5bmNlZCA9IHRoaXMubGltYm9Eb2N1bWVudHMuc2l6ZSA9PT0gMCAmJiB0aGlzLmN1cnJlbnQgJiYgIXRhcmdldElzUGVuZGluZ1Jlc2V0O1xuICAgICAgICBjb25zdCBuZXdTeW5jU3RhdGUgPSBzeW5jZWQgPyAxIC8qIFN5bmNTdGF0ZS5TeW5jZWQgKi8gOiAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLztcbiAgICAgICAgY29uc3Qgc3luY1N0YXRlQ2hhbmdlZCA9IG5ld1N5bmNTdGF0ZSAhPT0gdGhpcy5zeW5jU3RhdGU7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbmV3U3luY1N0YXRlO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZXNcbiAgICAgICAgICAgIHJldHVybiB7IGxpbWJvQ2hhbmdlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc25hcCA9IG5ldyBWaWV3U25hcHNob3QodGhpcy5xdWVyeSwgZG9jQ2hhbmdlcy5kb2N1bWVudFNldCwgb2xkRG9jcywgY2hhbmdlcywgZG9jQ2hhbmdlcy5tdXRhdGVkS2V5cywgbmV3U3luY1N0YXRlID09PSAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLywgc3luY1N0YXRlQ2hhbmdlZCwgXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gZmFsc2UsIHRhcmdldENoYW5nZVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDBcbiAgICAgICAgICAgICAgICA6IGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHNuYXAsXG4gICAgICAgICAgICAgICAgbGltYm9DaGFuZ2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gT25saW5lU3RhdGUgY2hhbmdlIHRvIHRoZSB2aWV3LCBwb3RlbnRpYWxseSBnZW5lcmF0aW5nIGFcbiAgICAgKiBWaWV3Q2hhbmdlIGlmIHRoZSB2aWV3J3Mgc3luY1N0YXRlIGNoYW5nZXMgYXMgYSByZXN1bHQuXG4gICAgICovXG4gICAgYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50ICYmIG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcbiAgICAgICAgICAgIC8vIHRvIHJlZnJlc2ggb3VyIHN5bmNTdGF0ZSBhbmQgZ2VuZXJhdGUgYSBWaWV3Q2hhbmdlIGFzIGFwcHJvcHJpYXRlLiBXZVxuICAgICAgICAgICAgLy8gYXJlIGd1YXJhbnRlZWQgdG8gZ2V0IGEgbmV3IFRhcmdldENoYW5nZSB0aGF0IHNldHMgYGN1cnJlbnRgIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxuICAgICAgICAgICAgICAgIGNoYW5nZVNldDogbmV3IERvY3VtZW50Q2hhbmdlU2V0KCksXG4gICAgICAgICAgICAgICAgbXV0YXRlZEtleXM6IHRoaXMubXV0YXRlZEtleXMsXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGVmZmVjdCwganVzdCByZXR1cm4gYSBuby1vcCBWaWV3Q2hhbmdlLlxuICAgICAgICAgICAgcmV0dXJuIHsgbGltYm9DaGFuZ2VzOiBbXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZG9jIGZvciB0aGUgZ2l2ZW4ga2V5IHNob3VsZCBiZSBpbiBsaW1iby5cbiAgICAgKi9cbiAgICBzaG91bGRCZUluTGltYm8oa2V5KSB7XG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgZW5kIHNheXMgaXQncyBwYXJ0IG9mIHRoaXMgcXVlcnksIGl0J3Mgbm90IGluIGxpbWJvLlxuICAgICAgICBpZiAodGhpcy5fc3luY2VkRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIGRvZXNuJ3QgdGhpbmsgaXQncyBhIHJlc3VsdCwgc28gaXQgc2hvdWxkbid0IGJlIGluIGxpbWJvLlxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWwgY2hhbmdlcyB0byB0aGUgZG9jLCB0aGV5IG1pZ2h0IGV4cGxhaW4gd2h5IHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gZG9lc24ndCBrbm93IHRoYXQgaXQncyBwYXJ0IG9mIHRoZSBxdWVyeS4gU28gZG9uJ3QgcHV0IGl0IGluIGxpbWJvLlxuICAgICAgICAvLyBUT0RPKGtsaW10KTogSWRlYWxseSwgd2Ugd291bGQgb25seSBjb25zaWRlciBjaGFuZ2VzIHRoYXQgbWlnaHQgYWN0dWFsbHlcbiAgICAgICAgLy8gYWZmZWN0IHRoaXMgc3BlY2lmaWMgcXVlcnkuXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50U2V0LmdldChrZXkpLmhhc0xvY2FsTXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGluIGxpbWJvLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzeW5jZWREb2N1bWVudHMsIGN1cnJlbnQsIGFuZCBsaW1ibyBkb2NzIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFuZ2UuXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHdoaWNoIGRvY3MgYXJlIGluIGxpbWJvLlxuICAgICAqL1xuICAgIGFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSkge1xuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5kZWxldGUoa2V5KSkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGFyZ2V0Q2hhbmdlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudHMoKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRldGVybWluZSBsaW1ibyBkb2N1bWVudHMgd2hlbiB3ZSdyZSBpbi1zeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGtsaW10KTogRG8gdGhpcyBpbmNyZW1lbnRhbGx5IHNvIHRoYXQgaXQncyBub3QgcXVhZHJhdGljIHdoZW5cbiAgICAgICAgLy8gdXBkYXRpbmcgbWFueSBkb2N1bWVudHMuXG4gICAgICAgIGNvbnN0IG9sZExpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cztcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQmVJbkxpbWJvKGRvYy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHMuYWRkKGRvYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGlmZiB0aGUgbmV3IGxpbWJvIGRvY3Mgd2l0aCB0aGUgb2xkIGxpbWJvIGRvY3MuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgb2xkTGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKG5ldyBSZW1vdmVkTGltYm9Eb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvbGRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgQWRkZWRMaW1ib0RvY3VtZW50KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcgd2l0aCB0aGUgc3RhdGUgcmVhZCBmcm9tXG4gICAgICogcGVyc2lzdGVuY2UuXG4gICAgICpcbiAgICAgKiBXZSB1cGRhdGUgdGhlIHF1ZXJ5IHZpZXcgd2hlbmV2ZXIgYSBjbGllbnQncyBwcmltYXJ5IHN0YXR1cyBjaGFuZ2VzOlxuICAgICAqIC0gV2hlbiBhIGNsaWVudCB0cmFuc2l0aW9ucyBmcm9tIHByaW1hcnkgdG8gc2Vjb25kYXJ5LCBpdCBjYW4gbWlzc1xuICAgICAqICAgTG9jYWxTdG9yYWdlIHVwZGF0ZXMgYW5kIGl0cyBxdWVyeSB2aWV3cyBtYXkgdGVtcG9yYXJpbHkgbm90IGJlXG4gICAgICogICBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgKiAtIEZvciBzZWNvbmRhcnkgdG8gcHJpbWFyeSB0cmFuc2l0aW9ucywgdGhlIGNsaWVudCBuZWVkcyB0byB1cGRhdGUgdGhlIGxpc3RcbiAgICAgKiAgIG9mIGBzeW5jZWREb2N1bWVudHNgIHNpbmNlIHNlY29uZGFyeSBjbGllbnRzIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3c1xuICAgICAqICAgYmFzZWQgcHVyZWx5IG9uIHN5bnRoZXNpemVkIFJlbW90ZUV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5kb2N1bWVudHMgLSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBMb2NhbFN0b3JlLlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZVxuICAgICAqIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBWaWV3Q2hhbmdlIHRoYXQgcmVzdWx0ZWQgZnJvbSB0aGlzIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNocm9uaXplV2l0aFBlcnNpc3RlZFN0YXRlKHF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXM7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdGhpcy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXG4gICAgICogYSBkb2N1bWVudCBhZGQgZm9yIGV2ZXJ5IGV4aXN0aW5nIGRvY3VtZW50IGFuZCB0aGUgYGZyb21DYWNoZWAgYW5kXG4gICAgICogYGhhc1BlbmRpbmdXcml0ZXNgIHN0YXR1cyBvZiB0aGUgYWxyZWFkeSBlc3RhYmxpc2hlZCB2aWV3LlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XG4gICAgY29uc3Qgb3JkZXIgPSAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2hhbmdlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XG4gICAgICAgICAgICAgICAgLy8gQSBtZXRhZGF0YSBjaGFuZ2UgaXMgY29udmVydGVkIHRvIGEgbW9kaWZpZWQgY2hhbmdlIGF0IHRoZSBwdWJsaWNcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcbiAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YSBhbmQgbW9kaWZpZWQgY2hhbmdlcyBtdXN0IGJlIHNvcnRlZCBlcXVpdmFsZW50bHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb3JkZXIoYzEpIC0gb3JkZXIoYzIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQzID0gJ1N5bmNFbmdpbmUnO1xuLyoqXG4gKiBRdWVyeVZpZXcgY29udGFpbnMgYWxsIG9mIHRoZSBkYXRhIHRoYXQgU3luY0VuZ2luZSBuZWVkcyB0byBrZWVwIHRyYWNrIG9mIGZvclxuICogYSBwYXJ0aWN1bGFyIHF1ZXJ5LlxuICovXG5jbGFzcyBRdWVyeVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBpdHNlbGYuXG4gICAgICovXG4gICAgcXVlcnksIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgbnVtYmVyIGNyZWF0ZWQgYnkgdGhlIGNsaWVudCB0aGF0IGlzIHVzZWQgaW4gdGhlIHdhdGNoXG4gICAgICogc3RyZWFtIHRvIGlkZW50aWZ5IHRoaXMgcXVlcnkuXG4gICAgICovXG4gICAgdGFyZ2V0SWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRpbmcgdGhlIGZpbmFsIG1lcmdlZCB0cnV0aCBvZiB3aGF0XG4gICAgICogZG9jcyBhcmUgaW4gdGhlIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyxcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0XG4gICAgICogcG9zc2libGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH1cbn1cbi8qKiBUcmFja3MgYSBsaW1ibyByZXNvbHV0aW9uLiAqL1xuY2xhc3MgTGltYm9SZXNvbHV0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIHJlY2VpdmVkIGEgZG9jdW1lbnQuIFRoaXMgaXMgdXNlZCBpblxuICAgICAgICAgKiBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KCkgYW5kIHVsdGltYXRlbHkgdXNlZCBieSBXYXRjaENoYW5nZUFnZ3JlZ2F0b3IgdG9cbiAgICAgICAgICogZGVjaWRlIHdoZXRoZXIgaXQgbmVlZHMgdG8gbWFudWZhY3R1cmUgYSBkZWxldGUgZXZlbnQgZm9yIHRoZSB0YXJnZXQgb25jZVxuICAgICAgICAgKiB0aGUgdGFyZ2V0IGlzIENVUlJFTlQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBTeW5jRW5naW5lYCBjb29yZGluYXRpbmcgd2l0aCBvdGhlciBwYXJ0cyBvZiBTREsuXG4gKlxuICogVGhlIHBhcnRzIG9mIFN5bmNFbmdpbmUgdGhhdCBhY3QgYXMgYSBjYWxsYmFjayB0byBSZW1vdGVTdG9yZSBuZWVkIHRvIGJlXG4gKiByZWdpc3RlcmVkIGluZGl2aWR1YWxseS4gVGhpcyBpcyBkb25lIGluIGBzeW5jRW5naW5lV3JpdGUoKWAgYW5kXG4gKiBgc3luY0VuZ2luZUxpc3RlbigpYCAoYXMgd2VsbCBhcyBgYXBwbHlQcmltYXJ5U3RhdGUoKWApIGFzIHRoZXNlIG1ldGhvZHNcbiAqIHNlcnZlIGFzIGVudHJ5IHBvaW50cyB0byBSZW1vdGVTdG9yZSdzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBpbXBsZW1lbnQgb3B0aW9uYWwgZmVhdHVyZXMgKGxpa2UgYnVuZGxlcykgaW4gZnJlZVxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmNsYXNzIFN5bmNFbmdpbmVJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG4gICAgc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucykge1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gcmVtb3RlU3RvcmU7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gc2hhcmVkQ2xpZW50U3RhdGU7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucyA9IG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zO1xuICAgICAgICB0aGlzLnN5bmNFbmdpbmVMaXN0ZW5lciA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5Vmlld3NCeVF1ZXJ5ID0gbmV3IE9iamVjdE1hcChxID0+IGNhbm9uaWZ5UXVlcnkocSksIHF1ZXJ5RXF1YWxzKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5cyBvZiBkb2N1bWVudHMgdGhhdCBhcmUgaW4gbGltYm8gZm9yIHdoaWNoIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYVxuICAgICAgICAgKiBsaW1ibyByZXNvbHV0aW9uIHF1ZXJ5LiBUaGUgc3RyaW5ncyBpbiB0aGlzIHNldCBhcmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICAgICAqIGBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKWAgd2hlcmUgYGtleWAgaXMgYSBgRG9jdW1lbnRLZXlgIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBTZXRgIHR5cGUgd2FzIGNob3NlbiBiZWNhdXNlIGl0IHByb3ZpZGVzIGVmZmljaWVudCBsb29rdXAgYW5kIHJlbW92YWxcbiAgICAgICAgICogb2YgYXJiaXRyYXJ5IGVsZW1lbnRzIGFuZCBpdCBhbHNvIG1haW50YWlucyBpbnNlcnRpb24gb3JkZXIsIHByb3ZpZGluZyB0aGVcbiAgICAgICAgICogZGVzaXJlZCBxdWV1ZS1saWtlIEZJRk8gc2VtYW50aWNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgdGFyZ2V0IElEIGZvciBlYWNoIGRvY3VtZW50IHRoYXQgaXMgaW4gbGltYm8gd2l0aCBhblxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gYWN0aXZlIGxpbWJvIHJlc29sdXRpb24gZm9yIGVhY2hcbiAgICAgICAgICogYWN0aXZlIHRhcmdldCBJRCB0aGF0IHdhcyBzdGFydGVkIGZvciB0aGUgcHVycG9zZSBvZiBsaW1ibyByZXNvbHV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudFJlZnMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjb21wbGV0aW9uIGhhbmRsZXJzLCBpbmRleGVkIGJ5IFVzZXIgYW5kIEJhdGNoSWQuICovXG4gICAgICAgIHRoaXMubXV0YXRpb25Vc2VyQ2FsbGJhY2tzID0ge307XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjYWxsYmFja3Mgd2FpdGluZyBmb3IgYWxsIHBlbmRpbmcgd3JpdGVzIHRvIGJlIGFja25vd2xlZGdlZC4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IgPSBUYXJnZXRJZEdlbmVyYXRvci5mb3JTeW5jRW5naW5lKCk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvLyBUaGUgcHJpbWFyeSBzdGF0ZSBpcyBzZXQgdG8gYHRydWVgIG9yIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgRmlyZXN0b3JlXG4gICAgICAgIC8vIHN0YXJ0dXAuIEluIHRoZSBpbnRlcmltLCBhIGNsaWVudCBzaG91bGQgb25seSBiZSBjb25zaWRlcmVkIHByaW1hcnkgaWZcbiAgICAgICAgLy8gYGlzUHJpbWFyeWAgaXMgdHJ1ZS5cbiAgICAgICAgdGhpcy5faXNQcmltYXJ5Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaXNQcmltYXJ5Q2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQcmltYXJ5Q2xpZW50ID09PSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1N5bmNFbmdpbmUobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXG4vLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG5zaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zLCBpc1ByaW1hcnkpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lID0gbmV3IFN5bmNFbmdpbmVJbXBsKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpO1xuICAgIGlmIChpc1ByaW1hcnkpIHtcbiAgICAgICAgc3luY0VuZ2luZS5faXNQcmltYXJ5Q2xpZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNFbmdpbmU7XG59XG4vKipcbiAqIEluaXRpYXRlcyB0aGUgbmV3IGxpc3RlbiwgcmVzb2x2ZXMgcHJvbWlzZSB3aGVuIGxpc3RlbiBlbnF1ZXVlZCB0byB0aGVcbiAqIHNlcnZlci4gQWxsIHRoZSBzdWJzZXF1ZW50IHZpZXcgc25hcHNob3RzIG9yIGVycm9ycyBhcmUgc2VudCB0byB0aGVcbiAqIHN1YnNjcmliZWQgaGFuZGxlcnMuIFJldHVybnMgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVMaXN0ZW4oc3luY0VuZ2luZSwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgIGlmIChxdWVyeVZpZXcpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBXaXRoIE11bHRpLVRhYiBXZWIsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBxdWVyeSB2aWV3XG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3RzIHdoZW4gRXZlbnRNYW5hZ2VyIGNhbGxzIHVzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpc1xuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gdGhlIHByaW1hcnkgdGFiIGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHRoaXMgcXVlcnkgb25cbiAgICAgICAgLy8gYmVoYWxmIG9mIGFub3RoZXIgdGFiIGFuZCB0aGUgdXNlciBvZiB0aGUgcHJpbWFyeSBhbHNvIHN0YXJ0cyBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gdGhlIHF1ZXJ5LiBFdmVudE1hbmFnZXIgd2lsbCBub3QgaGF2ZSBhbiBhc3NpZ25lZCB0YXJnZXQgSUQgaW4gdGhpc1xuICAgICAgICAvLyBjYXNlIGFuZCBjYWxscyBgbGlzdGVuYCB0byBvYnRhaW4gdGhpcyBJRC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5jb21wdXRlSW5pdGlhbFNuYXBzaG90KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIFxuICAgICAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqIFF1ZXJ5IGhhcyBiZWVuIGxpc3RlbmluZyB0byB0aGUgY2FjaGUsIGFuZCB0cmllcyB0byBpbml0aWF0ZSB0aGUgcmVtb3RlIHN0b3JlIGxpc3RlbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcbiAgICBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgXG4gICAgLyoqIHNob3VsZExpc3RlblRvUmVtb3RlPSAqLyB0cnVlLCBcbiAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIGZhbHNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFsbG9jYXRlVGFyZ2V0QW5kTWF5YmVMaXN0ZW4oc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSwgc2hvdWxkSW5pdGlhbGl6ZVZpZXcpIHtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XG4gICAgLy8gUE9SVElORyBOT1RFOiBXaGVuIHRoZSBxdWVyeSBpcyBsaXN0ZW5pbmcgdG8gY2FjaGUgb25seSwgd2Ugc2tpcCBzZW5kaW5nIGl0IG92ZXIgdG8gV2F0Y2ggYnlcbiAgICAvLyBub3QgcmVnaXN0ZXJpbmcgaXQgaW4gc2hhcmVkIGNsaWVudCBzdGF0ZSwgYW5kIGRpcmVjdGx5IGNhbGN1bGF0ZSBpbml0aWFsIHNuYXBzaG90cyBhbmRcbiAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMgZnJvbSBjYWNoZS4gT3RoZXJ3aXNlLCByZWdpc3RlciB0aGUgdGFyZ2V0IElEIHdpdGggbG9jYWwgRmlyZXN0b3JlIGNsaWVudFxuICAgIC8vIGFzIGFjdGl2ZSB3YXRjaCB0YXJnZXQuXG4gICAgY29uc3Qgc3RhdHVzID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgXG4gICAgLyogYWRkVG9BY3RpdmVUYXJnZXRJZHM9ICovIHNob3VsZExpc3RlblRvUmVtb3RlKTtcbiAgICBsZXQgdmlld1NuYXBzaG90O1xuICAgIGlmIChzaG91bGRJbml0aWFsaXplVmlldykge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBzdGF0dXMgPT09ICdjdXJyZW50JywgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgfVxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgc2hvdWxkTGlzdGVuVG9SZW1vdGUpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcbiAqIHNuYXBzaG90LlxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgIC8vIFBPUlRJTkcgTk9URTogT24gV2ViIG9ubHksIHdlIGluamVjdCB0aGUgY29kZSB0aGF0IHJlZ2lzdGVycyBuZXcgTGltYm9cbiAgICAvLyB0YXJnZXRzIGJhc2VkIG9uIHZpZXcgY2hhbmdlcy4gVGhpcyBhbGxvd3MgdXMgdG8gb25seSBkZXBlbmQgb24gTGltYm9cbiAgICAvLyBjaGFuZ2VzIHdoZW4gdXNlciBjb2RlIGluY2x1ZGVzIHF1ZXJpZXMuXG4gICAgc3luY0VuZ2luZUltcGwuYXBwbHlEb2NDaGFuZ2VzID0gKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpID0+IGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5LCBcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgY29uc3Qgdmlld0RvY0NoYW5nZXMgPSB2aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKHF1ZXJ5UmVzdWx0LmRvY3VtZW50cyk7XG4gICAgY29uc3Qgc3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2UgPSBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50ICYmIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovLCByZXN1bWVUb2tlbik7XG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlKTtcbiAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgUXVlcnlWaWV3KHF1ZXJ5LCB0YXJnZXRJZCwgdmlldyk7XG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuc2V0KHF1ZXJ5LCBkYXRhKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkucHVzaChxdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuc2V0KHRhcmdldElkLCBbcXVlcnldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XG59XG4vKiogU3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBxdWVyeS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSwgc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XG4gICAgLy8gT25seSBjbGVhbiB1cCB0aGUgcXVlcnkgdmlldyBhbmQgdGFyZ2V0IGlmIHRoaXMgaXMgdGhlIG9ubHkgcXVlcnkgbWFwcGVkXG4gICAgLy8gdG8gdGhlIHRhcmdldC5cbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LnNldChxdWVyeVZpZXcudGFyZ2V0SWQsIHF1ZXJpZXMuZmlsdGVyKHEgPT4gIXF1ZXJ5RXF1YWxzKHEsIHF1ZXJ5KSkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5kZWxldGUocXVlcnkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vIG90aGVyIHF1ZXJpZXMgYXJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0LCBjbGVhbiB1cCB0aGUgcXVlcnkgYW5kIHRoZSB0YXJnZXQuXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgbG9jYWwgcXVlcnkgdGFyZ2V0IGZpcnN0IHRvIGFsbG93IHVzIHRvIHZlcmlmeVxuICAgICAgICAvLyB3aGV0aGVyIGFueSBvdGhlciBjbGllbnQgaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGlzIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRSZW1haW5zQWN0aXZlID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNBY3RpdmVRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXRhcmdldFJlbWFpbnNBY3RpdmUpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXG4gICAgICAgICAgICAvKmtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhPSovIGZhbHNlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5jbGVhclF1ZXJ5U3RhdGUocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkLCBcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcbiAgICB9XG59XG4vKiogVW5saXN0ZW5zIHRvIHRoZSByZW1vdGUgc3RvcmUgd2hpbGUgc3RpbGwgbGlzdGVuaW5nIHRvIHRoZSBjYWNoZS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgcXVlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBVbnJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzXG4gICAgICAgIC8vIHdhdGNoIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhdGVzIHRoZSB3cml0ZSBvZiBsb2NhbCBtdXRhdGlvbiBiYXRjaCB3aGljaCBpbnZvbHZlcyBhZGRpbmcgdGhlXG4gKiB3cml0ZXMgdG8gdGhlIG11dGF0aW9uIHF1ZXVlLCBub3RpZnlpbmcgdGhlIHJlbW90ZSBzdG9yZSBhYm91dCBuZXdcbiAqIG11dGF0aW9ucyBhbmQgcmFpc2luZyBldmVudHMgZm9yIGFueSBjaGFuZ2VzIHRoaXMgd3JpdGUgY2F1c2VkLlxuICpcbiAqIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgY2FsbCBpcyByZXNvbHZlZCB3aGVuIHRoZSBhYm92ZSBzdGVwc1xuICogaGF2ZSBjb21wbGV0ZWQsICpub3QqIHdoZW4gdGhlIHdyaXRlIHdhcyBhY2tlZCBieSB0aGUgYmFja2VuZC4gVGhlXG4gKiB1c2VyQ2FsbGJhY2sgaXMgcmVzb2x2ZWQgb25jZSB0aGUgd3JpdGUgd2FzIGFja2VkL3JlamVjdGVkIGJ5IHRoZVxuICogYmFja2VuZCAob3IgZmFpbGVkIGxvY2FsbHkgZm9yIGFueSBvdGhlciByZWFzb24pLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgYmF0Y2gsIHVzZXJDYWxsYmFjaykge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2gpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRQZW5kaW5nTXV0YXRpb24ocmVzdWx0LmJhdGNoSWQpO1xuICAgICAgICBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYmF0Y2hJZCwgdXNlckNhbGxiYWNrKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIHJlc3VsdC5jaGFuZ2VzKTtcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwZXJzaXN0IHRoZSBtdXRhdGlvbiwgd2UgcmVqZWN0IHRoZSB1c2VyIGNhbGxiYWNrIGFuZFxuICAgICAgICAvLyBkb24ndCBzZW5kIHRoZSBtdXRhdGlvbi4gVGhlIHVzZXIgY2FuIHRoZW4gcmV0cnkgdGhlIHdyaXRlLlxuICAgICAgICBjb25zdCBlcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBwZXJzaXN0IHdyaXRlYCk7XG4gICAgICAgIHVzZXJDYWxsYmFjay5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBvbmUgcmVtb3RlIGV2ZW50IHRvIHRoZSBzeW5jIGVuZ2luZSwgbm90aWZ5aW5nIGFueSB2aWV3cyBvZiB0aGVcbiAqIGNoYW5nZXMsIGFuZCByZWxlYXNpbmcgYW55IHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcyB0aGF0IHdvdWxkIGJlY29tZVxuICogdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBzbmFwc2hvdCB2ZXJzaW9uIHRoZSByZW1vdGUgZXZlbnQgY29udGFpbnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50KHN5bmNFbmdpbmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KTtcbiAgICAgICAgLy8gVXBkYXRlIGByZWNlaXZlZERvY3VtZW50YCBhcyBhcHByb3ByaWF0ZSBmb3IgYW55IGxpbWJvIHRhcmdldHMuXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAobGltYm9SZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpbWJvIHJlc29sdXRpb24gbG9va3VwLCBpdCdzIGZvciBhIHNpbmdsZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBjb3VsZCBiZSBhZGRlZCwgbW9kaWZpZWQsIG9yIHJlbW92ZWQsIGJ1dCBub3QgYSBjb21iaW5hdGlvbi5cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplICtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplIDw9XG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgcHJvYmFibHkganVzdCBhIENVUlJFTlQgdGFyZ2V0Q2hhbmdlIG9yIHNpbWlsYXIuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBcHBsaWVzIGFuIE9ubGluZVN0YXRlIGNoYW5nZSB0byB0aGUgc3luYyBlbmdpbmUgYW5kIG5vdGlmaWVzIGFueSB2aWV3cyBvZlxuICogdGhlIGNoYW5nZS5cbiAqL1xuZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2Uoc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIC8vIElmIHdlIGFyZSB0aGUgc2Vjb25kYXJ5IGNsaWVudCwgd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlIHJlbW90ZSBzdG9yZSdzXG4gICAgLy8gb25saW5lIHN0YXRlICh0aGUgbG9jYWwgY2xpZW50IG1heSBnbyBvZmZsaW5lLCBldmVuIHRob3VnaCB0aGUgcHJpbWFyeVxuICAgIC8vIHRhYiByZW1haW5zIG9ubGluZSkgYW5kIG9ubHkgYXBwbHkgdGhlIHByaW1hcnkgdGFiJ3Mgb25saW5lIHN0YXRlIGZyb21cbiAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cbiAgICBpZiAoKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxuICAgICAgICBzb3VyY2UgPT09IDAgLyogT25saW5lU3RhdGVTb3VyY2UuUmVtb3RlU3RvcmUgKi8pIHx8XG4gICAgICAgICghc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXG4gICAgICAgICAgICBzb3VyY2UgPT09IDEgLyogT25saW5lU3RhdGVTb3VyY2UuU2hhcmVkQ2xpZW50U3RhdGUgKi8pKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZpZXdTbmFwc2hvdHMgPSBbXTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgocXVlcnksIHF1ZXJ5VmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZpZXdDaGFuZ2Uuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpO1xuICAgICAgICBpZiAobmV3Vmlld1NuYXBzaG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlKG5ld1ZpZXdTbmFwc2hvdHMpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XG4gICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmVqZWN0cyB0aGUgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0SUQuIFRoaXMgY2FuIGJlIHRyaWdnZXJlZCBieSB0aGVcbiAqIGJhY2tlbmQgZm9yIGFueSBhY3RpdmUgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gVGhlIHN5bmMgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHRhcmdldElkIC0gVGhlIHRhcmdldElEIGNvcnJlc3BvbmRzIHRvIG9uZSBwcmV2aW91c2x5IGluaXRpYXRlZCBieSB0aGVcbiAqIHVzZXIgYXMgcGFydCBvZiBUYXJnZXREYXRhIHBhc3NlZCB0byBsaXN0ZW4oKSBvbiBSZW1vdGVTdG9yZS5cbiAqIEBwYXJhbSBlcnIgLSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBjb25kaXRpb24gdGhhdCBoYXMgZm9yY2VkIHRoZSByZWplY3Rpb24uXG4gKiBOZWFybHkgYWx3YXlzIHRoaXMgd2lsbCBiZSBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHVzZXIgaXMgbm8gbG9uZ2VyXG4gKiBhdXRob3JpemVkIHRvIHNlZSB0aGUgZGF0YSBtYXRjaGluZyB0aGUgdGFyZ2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0TGlzdGVuKHN5bmNFbmdpbmUsIHRhcmdldElkLCBlcnIpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsICdyZWplY3RlZCcsIGVycik7XG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgY29uc3QgbGltYm9LZXkgPSBsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLmtleTtcbiAgICBpZiAobGltYm9LZXkpIHtcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IFdlIHJlYWxseSBvbmx5IHNob3VsZCBkbyB0aGUgZm9sbG93aW5nIG9uIHBlcm1pc3Npb25cbiAgICAgICAgLy8gZGVuaWVkIGVycm9ycywgYnV0IHdlIGRvbid0IGhhdmUgdGhlIGNhdXNlIGNvZGUgaGVyZS5cbiAgICAgICAgLy8gSXQncyBhIGxpbWJvIGRvYy4gQ3JlYXRlIGEgc3ludGhldGljIGV2ZW50IHNheWluZyBpdCB3YXMgZGVsZXRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgaGFjay4gSWRlYWxseSwgd2Ugd291bGQgaGF2ZSBhIG1ldGhvZCBpbiB0aGUgbG9jYWxcbiAgICAgICAgLy8gc3RvcmUgdG8gcHVyZ2UgYSBkb2N1bWVudC4gSG93ZXZlciwgaXQgd291bGQgYmUgdHJpY2t5IHRvIGtlZXAgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzdG9yZSdzIGludmFyaWFudHMgd2l0aCBhbm90aGVyIG1ldGhvZC5cbiAgICAgICAgbGV0IGRvY3VtZW50VXBkYXRlcyA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8vIFRPRE8oYi8yMTcxODkyMTYpOiBUaGlzIGxpbWJvIGRvY3VtZW50IHNob3VsZCBpZGVhbGx5IGhhdmUgYSByZWFkIHRpbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgcGlja2VkIHVwIGJ5IGFueSByZWFkLXRpbWUgYmFzZWQgc2NhbnMuIFRoZSBiYWNrZW5kLFxuICAgICAgICAvLyBob3dldmVyLCBkb2VzIG5vdCBzZW5kIGEgcmVhZCB0aW1lIGZvciB0YXJnZXQgcmVtb3ZhbHMuXG4gICAgICAgIGRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcy5pbnNlcnQobGltYm9LZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGxpbWJvS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvS2V5KTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogdGFyZ2V0Q2hhbmdlcz0gKi8gbmV3IE1hcCgpLCBcbiAgICAgICAgLyogdGFyZ2V0TWlzbWF0Y2hlcz0gKi8gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgZG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZUltcGwsIGV2ZW50KTtcbiAgICAgICAgLy8gU2luY2UgdGhpcyBxdWVyeSBmYWlsZWQsIHdlIHdvbid0IHdhbnQgdG8gbWFudWFsbHkgdW5saXN0ZW4gdG8gaXQuXG4gICAgICAgIC8vIFdlIG9ubHkgcmVtb3ZlIGl0IGZyb20gYm9va2tlZXBpbmcgYWZ0ZXIgd2Ugc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdGhlXG4gICAgICAgIC8vIFJlbW90ZUV2ZW50LiBJZiBgYXBwbHlSZW1vdGVFdmVudCgpYCB0aHJvd3MsIHdlIHdhbnQgdG8gcmUtbGlzdGVuIHRvXG4gICAgICAgIC8vIHRoaXMgcXVlcnkgd2hlbiB0aGUgUmVtb3RlU3RvcmUgcmVzdGFydHMgdGhlIFdhdGNoIHN0cmVhbSwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIHJlLXRyaWdnZXIgdGhlIHRhcmdldCBmYWlsdXJlLlxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5yZW1vdmUobGltYm9LZXkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIGZhbHNlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycikpXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25CYXRjaFJlc3VsdCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGJhdGNoSWQgPSBtdXRhdGlvbkJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIG11dGF0aW9uQmF0Y2hSZXN1bHQpO1xuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodFxuICAgICAgICAvLyB1cCksIHNvIHdlIHJhaXNlIHVzZXIgY2FsbGJhY2tzIGZpcnN0IHNvIHRoYXQgdGhleSBjb25zaXN0ZW50bHkgaGFwcGVuXG4gICAgICAgIC8vIGJlZm9yZSBsaXN0ZW4gZXZlbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCAvKmVycm9yPSovIG51bGwpO1xuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ2Fja25vd2xlZGdlZCcpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZShzeW5jRW5naW5lLCBiYXRjaElkLCBlcnJvcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlUmVqZWN0QmF0Y2goc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBtYXkgb3IgbWF5IG5vdCBiZSBhYmxlIHRvIGFwcGx5IHRoZSB3cml0ZSByZXN1bHQgYW5kXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0IHVwKSxcbiAgICAgICAgLy8gc28gd2UgcmFpc2UgdXNlciBjYWxsYmFja3MgZmlyc3Qgc28gdGhhdCB0aGV5IGNvbnNpc3RlbnRseSBoYXBwZW4gYmVmb3JlXG4gICAgICAgIC8vIGxpc3RlbiBldmVudHMuXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yKTtcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsICdyZWplY3RlZCcsIGVycm9yKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIHVzZXIgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBhdCB0aGUgbW9tZW50IG9mIGNhbGxpbmdcbiAqIGFyZSBhY2tub3dsZWRnZWQgLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoIWNhblVzZU5ldHdvcmsoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1RoZSBuZXR3b3JrIGlzIGRpc2FibGVkLiBUaGUgdGFzayByZXR1cm5lZCBieSAnICtcbiAgICAgICAgICAgIFwiJ2F3YWl0UGVuZGluZ1dyaXRlcygpJyB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGUgbmV0d29yayBpcyBlbmFibGVkLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGlnaGVzdEJhdGNoSWQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcbiAgICAgICAgaWYgKGhpZ2hlc3RCYXRjaElkID09PSBCQVRDSElEX1VOS05PV04pIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8gcGVuZGluZyB3cml0ZXMgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChoaWdoZXN0QmF0Y2hJZCkgfHwgW107XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5zZXQoaGlnaGVzdEJhdGNoSWQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCAnSW5pdGlhbGl6YXRpb24gb2Ygd2FpdEZvclBlbmRpbmdXcml0ZXMoKSBvcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIGNhbGxiYWNrLnJlamVjdChmaXJlc3RvcmVFcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoaXMgYmF0Y2ggaWQgdG8gZ2V0IGFja25vd2xlZGdlZCBieSBzZXJ2ZXIsXG4gKiBpZiB0aGVyZSBhcmUgYW55LlxuICovXG5mdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCkge1xuICAgIChzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChiYXRjaElkKSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmRlbGV0ZShiYXRjaElkKTtcbn1cbi8qKiBSZWplY3QgYWxsIG91dHN0YW5kaW5nIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyB0byBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHJlamVjdE91dHN0YW5kaW5nUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgZXJyb3JNZXNzYWdlKSB7XG4gICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrcyA9PiB7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsIGVycm9yTWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBjYWxsYmFjaykge1xuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XG4gICAgaWYgKCFuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgbmV3Q2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzLmluc2VydChiYXRjaElkLCBjYWxsYmFjayk7XG4gICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cbiAgICAgICAgbmV3Q2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBvciByZWplY3RzIHRoZSB1c2VyIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHRoZW4gZGlzY2FyZHNcbiAqIGl0LlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcbiAgICAvLyBOT1RFOiBNdXRhdGlvbnMgcmVzdG9yZWQgZnJvbSBwZXJzaXN0ZW5jZSB3b24ndCBoYXZlIGNhbGxiYWNrcywgc28gaXQnc1xuICAgIC8vIG9rYXkgZm9yIHRoZXJlIHRvIGJlIG5vIGNhbGxiYWNrIGZvciB0aGlzIElELlxuICAgIGlmIChuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBuZXdDYWxsYmFja3MuZ2V0KGJhdGNoSWQpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MucmVtb3ZlKGJhdGNoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXSA9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3M7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yID0gbnVsbCkge1xuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgIGZvciAoY29uc3QgcXVlcnkgb2Ygc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaEVycm9yKHF1ZXJ5LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICBjb25zdCBsaW1ib0tleXMgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICBsaW1ib0tleXMuZm9yRWFjaChsaW1ib0tleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0tleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBrZXkpIHtcbiAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC4gSW4gdGhhdCBjYXNlLFxuICAgIC8vIHRoZSBrZXkgd29uJ3QgZXhpc3QgaW4gYGxpbWJvVGFyZ2V0c0J5S2V5YC4gT25seSBkbyB0aGUgY2xlYW51cCBpZiB3ZSBzdGlsbCBoYXZlIHRoZSB0YXJnZXQuXG4gICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpO1xuICAgIGlmIChsaW1ib1RhcmdldElkID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgdGFyZ2V0IGFscmVhZHkgZ290IHJlbW92ZWQsIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBsaW1ib1RhcmdldElkKTtcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnJlbW92ZShrZXkpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5kZWxldGUobGltYm9UYXJnZXRJZCk7XG4gICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgbGltYm9DaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBsaW1ib0NoYW5nZSBvZiBsaW1ib0NoYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgQWRkZWRMaW1ib0RvY3VtZW50KSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5hZGRSZWZlcmVuY2UobGltYm9DaGFuZ2Uua2V5LCB0YXJnZXRJZCk7XG4gICAgICAgICAgICB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGltYm9DaGFuZ2UgaW5zdGFuY2VvZiBSZW1vdmVkTGltYm9Eb2N1bWVudCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnRG9jdW1lbnQgbm8gbG9uZ2VyIGluIGxpbWJvOiAnICsgbGltYm9DaGFuZ2Uua2V5KTtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZShsaW1ib0NoYW5nZS5rZXksIHRhcmdldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVmZXJlbmNlZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLmNvbnRhaW5zS2V5KGxpbWJvQ2hhbmdlLmtleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tMaW1ib0NoYW5nZShzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2UpIHtcbiAgICBjb25zdCBrZXkgPSBsaW1ib0NoYW5nZS5rZXk7XG4gICAgY29uc3Qga2V5U3RyaW5nID0ga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5nZXQoa2V5KSAmJlxuICAgICAgICAhc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmhhcyhrZXlTdHJpbmcpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ05ldyBkb2N1bWVudCBpbiBsaW1ibzogJyArIGtleSk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5hZGQoa2V5U3RyaW5nKTtcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG4gICAgfVxufVxuLyoqXG4gKiBTdGFydHMgbGlzdGVucyBmb3IgZG9jdW1lbnRzIGluIGxpbWJvIHRoYXQgYXJlIGVucXVldWVkIGZvciByZXNvbHV0aW9uLFxuICogc3ViamVjdCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMuXG4gKlxuICogV2l0aG91dCBib3VuZGluZyB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMsIHRoZSBzZXJ2ZXIgY2FuIGZhaWxcbiAqIHdpdGggXCJyZXNvdXJjZSBleGhhdXN0ZWRcIiBlcnJvcnMgd2hpY2ggY2FuIGxlYWQgdG8gcGF0aG9sb2dpY2FsIGNsaWVudFxuICogYmVoYXZpb3IgYXMgc2VlbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy8yNjgzLlxuICovXG5mdW5jdGlvbiBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKSB7XG4gICAgd2hpbGUgKHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5zaXplID4gMCAmJlxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5zaXplIDxcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGtleVN0cmluZyA9IHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9uc1xuICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAubmV4dCgpLnZhbHVlO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleVN0cmluZyk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhrZXlTdHJpbmcpKTtcbiAgICAgICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuc2V0KGxpbWJvVGFyZ2V0SWQsIG5ldyBMaW1ib1Jlc29sdXRpb24oa2V5KSk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5Lmluc2VydChrZXksIGxpbWJvVGFyZ2V0SWQpO1xuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgbmV3IFRhcmdldERhdGEocXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoa2V5LnBhdGgpKSwgbGltYm9UYXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGltYm9SZXNvbHV0aW9uXCIgLyogVGFyZ2V0UHVycG9zZS5MaW1ib1Jlc29sdXRpb24gKi8sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCBjaGFuZ2VzLCByZW1vdGVFdmVudCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IG5ld1NuYXBzID0gW107XG4gICAgY29uc3QgZG9jQ2hhbmdlc0luQWxsVmlld3MgPSBbXTtcbiAgICBjb25zdCBxdWVyaWVzUHJvY2Vzc2VkID0gW107XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgc2luY2UgYG9uV2F0Y2hDaGFuZ2UoKWAgbWlnaHQgbm90IGhhdmUgYmVlbiBhc3NpZ25lZCB5ZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgoXywgcXVlcnlWaWV3KSA9PiB7XG4gICAgICAgIHF1ZXJpZXNQcm9jZXNzZWQucHVzaChzeW5jRW5naW5lSW1wbFxuICAgICAgICAgICAgLmFwcGx5RG9jQ2hhbmdlcyhxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KVxuICAgICAgICAgICAgLnRoZW4odmlld1NuYXBzaG90ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBjaGFuZ2VzLCBvciB3ZSBhcmUgaGFuZGxpbmcgYSBnbG9iYWwgc25hcHNob3QsIG5vdGlmeVxuICAgICAgICAgICAgLy8gc2Vjb25kYXJ5IGNsaWVudHMgdG8gdXBkYXRlIHF1ZXJ5IHN0YXRlLlxuICAgICAgICAgICAgaWYgKHZpZXdTbmFwc2hvdCB8fCByZW1vdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUXVlcnkgc3RhdGUgaXMgc2V0IHRvIGBjdXJyZW50YCBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHZpZXcgY2hhbmdlIGFuZCBpdCBpcyB1cC10by1kYXRlLCBvcixcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIGdsb2JhbCBzbmFwc2hvdCwgdGhlIFRhcmdldCBpcyBjdXJyZW50LCBhbmQgbm8gY2hhbmdlcyB0byBiZSByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSB2aWV3U25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gIXZpZXdTbmFwc2hvdC5mcm9tQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKF9hID0gcmVtb3RlRXZlbnQgPT09IG51bGwgfHwgcmVtb3RlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVRdWVyeVN0YXRlKHF1ZXJ5Vmlldy50YXJnZXRJZCwgaXNDdXJyZW50ID8gJ2N1cnJlbnQnIDogJ25vdC1jdXJyZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZpZXdzIGlmIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmICghIXZpZXdTbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIG5ld1NuYXBzLnB1c2godmlld1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gTG9jYWxWaWV3Q2hhbmdlcy5mcm9tU25hcHNob3QocXVlcnlWaWV3LnRhcmdldElkLCB2aWV3U25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGRvY0NoYW5nZXNJbkFsbFZpZXdzLnB1c2goZG9jQ2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChxdWVyaWVzUHJvY2Vzc2VkKTtcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdTbmFwcyk7XG4gICAgYXdhaXQgbG9jYWxTdG9yZU5vdGlmeUxvY2FsVmlld0NoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgZG9jQ2hhbmdlc0luQWxsVmlld3MpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXBwbHlEb2NDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSB7XG4gICAgbGV0IHZpZXdEb2NDaGFuZ2VzID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoY2hhbmdlcyk7XG4gICAgaWYgKHZpZXdEb2NDaGFuZ2VzLm5lZWRzUmVmaWxsKSB7XG4gICAgICAgIC8vIFRoZSBxdWVyeSBoYXMgYSBsaW1pdCBhbmQgc29tZSBkb2NzIHdlcmUgcmVtb3ZlZCwgc28gd2UgbmVlZFxuICAgICAgICAvLyB0byByZS1ydW4gdGhlIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIHRvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICAvLyBkaWRuJ3QgbG9zZSBhbnkgZ29vZCBkb2NzIHRoYXQgaGFkIGJlZW4gcGFzdCB0aGUgbGltaXQuXG4gICAgICAgIHZpZXdEb2NDaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVZpZXcucXVlcnksIFxuICAgICAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIGZhbHNlKS50aGVuKCh7IGRvY3VtZW50cyB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoZG9jdW1lbnRzLCB2aWV3RG9jQ2hhbmdlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSByZW1vdGVFdmVudCAmJiByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGNvbnN0IHRhcmdldElzUGVuZGluZ1Jlc2V0ID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKSAhPSBudWxsO1xuICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSBxdWVyeVZpZXcudmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxuICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCk7XG4gICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3Q2hhbmdlLmxpbWJvQ2hhbmdlcyk7XG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZShzeW5jRW5naW5lLCB1c2VyKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgdXNlckNoYW5nZWQgPSAhc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIuaXNFcXVhbCh1c2VyKTtcbiAgICBpZiAodXNlckNoYW5nZWQpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnVXNlciBjaGFuZ2UuIE5ldyB1c2VyOicsIHVzZXIudG9LZXkoKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHVzZXIpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlciA9IHVzZXI7XG4gICAgICAgIC8vIEZhaWxzIHRhc2tzIHdhaXRpbmcgZm9yIHBlbmRpbmcgd3JpdGVzIHJlcXVlc3RlZCBieSBwcmV2aW91cyB1c2VyLlxuICAgICAgICByZWplY3RPdXRzdGFuZGluZ1BlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIFwiJ3dhaXRGb3JQZW5kaW5nV3JpdGVzJyBwcm9taXNlIGlzIHJlamVjdGVkIGR1ZSB0byBhIHVzZXIgY2hhbmdlLlwiKTtcbiAgICAgICAgLy8gVE9ETyhiLzExNDIyNjQxNyk6IENvbnNpZGVyIGNhbGxpbmcgdGhpcyBvbmx5IGluIHRoZSBwcmltYXJ5IHRhYi5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZXN1bHQucmVtb3ZlZEJhdGNoSWRzLCByZXN1bHQuYWRkZWRCYXRjaElkcyk7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYWZmZWN0ZWREb2N1bWVudHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHN5bmNFbmdpbmUsIHRhcmdldElkKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKGxpbWJvUmVzb2x1dGlvbiAmJiBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRLZXlTZXQoKS5hZGQobGltYm9SZXNvbHV0aW9uLmtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQga2V5U2V0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgICAgICAgICAga2V5U2V0ID0ga2V5U2V0LnVuaW9uV2l0aChxdWVyeVZpZXcudmlldy5zeW5jZWREb2N1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlTZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvbmNpbGUgdGhlIGxpc3Qgb2Ygc3luY2VkIGRvY3VtZW50cyBpbiBhbiBleGlzdGluZyB2aWV3IHdpdGggdGhvc2VcbiAqIGZyb20gcGVyc2lzdGVuY2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNocm9uaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lLCBxdWVyeVZpZXcpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgIGNvbnN0IHZpZXdTbmFwc2hvdCA9IHF1ZXJ5Vmlldy52aWV3LnN5bmNocm9uaXplV2l0aFBlcnNpc3RlZFN0YXRlKHF1ZXJ5UmVzdWx0KTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90LmxpbWJvQ2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3U25hcHNob3Q7XG59XG4vKipcbiAqIFJldHJpZXZlcyBuZXdseSBjaGFuZ2VkIGRvY3VtZW50cyBmcm9tIHJlbW90ZSBkb2N1bWVudCBjYWNoZSBhbmQgcmFpc2VzXG4gKiBzbmFwc2hvdHMgaWYgbmVlZGVkLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoc3luY0VuZ2luZSwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKS50aGVuKGNoYW5nZXMgPT4gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpKTtcbn1cbi8qKiBBcHBsaWVzIGEgbXV0YXRpb24gc3RhdGUgdG8gYW4gZXhpc3RpbmcgYmF0Y2guICAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUJhdGNoU3RhdGUoc3luY0VuZ2luZSwgYmF0Y2hJZCwgYmF0Y2hTdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBkb2N1bWVudHMgPSBhd2FpdCBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgaWYgKGRvY3VtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBIHRocm90dGxlZCB0YWIgbWF5IG5vdCBoYXZlIHNlZW4gdGhlIG11dGF0aW9uIGJlZm9yZSBpdCB3YXMgY29tcGxldGVkXG4gICAgICAgIC8vIGFuZCByZW1vdmVkIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlLCBpbiB3aGljaCBjYXNlIHdlIHdvbid0IGhhdmUgY2FjaGVkXG4gICAgICAgIC8vIHRoZSBhZmZlY3RlZCBkb2N1bWVudHMuIEluIHRoaXMgY2FzZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgdXBkYXRlXG4gICAgICAgIC8vIHNpbmNlIHRoYXQgbWVhbnMgd2UgZGlkbid0IGFwcGx5IHRoZSBtdXRhdGlvbiBsb2NhbGx5IGF0IGFsbCAoaWYgd2VcbiAgICAgICAgLy8gaGFkLCB3ZSB3b3VsZCBoYXZlIGNhY2hlZCB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzKSwgYW5kIHNvIHdlIHdpbGwganVzdFxuICAgICAgICAvLyBzZWUgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzIHZpYSBub3JtYWwgcmVtb3RlIGRvY3VtZW50IHVwZGF0ZXNcbiAgICAgICAgLy8gYXMgYXBwbGljYWJsZS5cbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQ2Fubm90IGFwcGx5IG11dGF0aW9uIGJhdGNoIHdpdGggaWQ6ICcgKyBiYXRjaElkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSB0aGUgcHJpbWFyeSBjbGllbnQsIHdlIG5lZWQgdG8gc2VuZCB0aGlzIHdyaXRlIHRvIHRoZVxuICAgICAgICAvLyBiYWNrZW5kLiBTZWNvbmRhcnkgY2xpZW50cyB3aWxsIGlnbm9yZSB0aGVzZSB3cml0ZXMgc2luY2UgdGhlaXIgcmVtb3RlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ2Fja25vd2xlZGdlZCcgfHwgYmF0Y2hTdGF0ZSA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAvLyBOT1RFOiBCb3RoIHRoZXNlIG1ldGhvZHMgYXJlIG5vLW9wcyBmb3IgYmF0Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgZnJvbVxuICAgICAgICAvLyBvdGhlciBjbGllbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBlcnJvciA/IGVycm9yIDogbnVsbCk7XG4gICAgICAgIHRyaWdnZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkKTtcbiAgICAgICAgbG9jYWxTdG9yZVJlbW92ZUNhY2hlZE11dGF0aW9uQmF0Y2hNZXRhZGF0YShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG4gICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGRvY3VtZW50cyk7XG59XG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmUsIGlzUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZUltcGwpO1xuICAgIGlmIChpc1ByaW1hcnkgPT09IHRydWUgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBTZWNvbmRhcnkgdGFicyBvbmx5IG1haW50YWluIFZpZXdzIGZvciB0aGVpciBsb2NhbCBsaXN0ZW5lcnMgYW5kIHRoZVxuICAgICAgICAvLyBWaWV3cyBpbnRlcm5hbCBzdGF0ZSBtYXkgbm90IGJlIDEwMCUgcG9wdWxhdGVkIChpbiBwYXJ0aWN1bGFyXG4gICAgICAgIC8vIHNlY29uZGFyeSB0YWJzIGRvbid0IHRyYWNrIHN5bmNlZERvY3VtZW50cywgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhlXG4gICAgICAgIC8vIHNlcnZlciBjb25zaWRlcnMgdG8gYmUgaW4gdGhlIHRhcmdldCkuIFNvIHdoZW4gYSBzZWNvbmRhcnkgYmVjb21lc1xuICAgICAgICAvLyBwcmltYXJ5LCB3ZSBuZWVkIHRvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHZpZXdzIGZvciBhbGwgdGFyZ2V0c1xuICAgICAgICAvLyBtYXRjaCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpO1xuICAgICAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMudG9BcnJheSgpKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldERhdGEgb2YgYWN0aXZlUXVlcmllcykge1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJpbWFyeSA9PT0gZmFsc2UgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgICAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICBhd2FpdCBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lSW1wbCwgYWN0aXZlVGFyZ2V0cyk7XG4gICAgICAgIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIGZhbHNlKTtcbiAgICB9XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gcmVzZXRMaW1ib0RvY3VtZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVBbGxSZWZlcmVuY2VzKCk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbn1cbi8qKlxuICogUmVjb25jaWxlIHRoZSBxdWVyeSB2aWV3cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgdGFyZ2V0cyB3aXRoIHRoZSBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS4gUmFpc2VzIHNuYXBzaG90cyBmb3IgYW55IGNoYW5nZXMgdGhhdCBhZmZlY3QgdGhlIGxvY2FsXG4gKiBjbGllbnQgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgc3RhdGUgb2YgYWxsIHRhcmdldCdzIHF1ZXJ5IGRhdGEuXG4gKlxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBUaGUgc3luYyBlbmdpbmUgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB0YXJnZXRzIC0gdGhlIGxpc3Qgb2YgdGFyZ2V0cyB3aXRoIHZpZXdzIHRoYXQgbmVlZCB0byBiZSByZWNvbXB1dGVkXG4gKiBAcGFyYW0gdHJhbnNpdGlvblRvUHJpbWFyeSAtIGB0cnVlYCBpZmYgdGhlIHRhYiB0cmFuc2l0aW9ucyBmcm9tIGEgc2Vjb25kYXJ5XG4gKiB0YWIgdG8gYSBwcmltYXJ5IHRhYlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZSwgdGFyZ2V0cywgdHJhbnNpdGlvblRvUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGFjdGl2ZVF1ZXJpZXMgPSBbXTtcbiAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IGhhdmUgYSBsb2NhbCBWaWV3LCB3ZSBmZXRjaCB0aGVpciBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAvLyBmcm9tIExvY2FsU3RvcmUgKGFzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHRoZSBzbmFwc2hvdCB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGNoYW5nZWQpIGFuZCByZWNvbmNpbGUgdGhlaXIgdmlld3Mgd2l0aCB0aGUgcGVyc2lzdGVkXG4gICAgICAgICAgICAvLyBzdGF0ZSAodGhlIGxpc3Qgb2Ygc3luY2VkRG9jdW1lbnRzIG1heSBoYXZlIGdvdHRlbiBvdXQgb2Ygc3luYykuXG4gICAgICAgICAgICB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcmllc1swXSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gYXdhaXQgc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdTbmFwc2hvdHMucHVzaCh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IG5ldmVyIGV4ZWN1dGVkIG9uIHRoaXMgY2xpZW50LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgdGFyZ2V0IGluIExvY2FsU3RvcmUgYW5kIGluaXRpYWxpemUgYSBuZXcgVmlldy5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGxvY2FsU3RvcmVHZXRDYWNoZWRUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xuICAgICAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldElkLCBcbiAgICAgICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUXVlcmllcy5wdXNoKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcbiAgICByZXR1cm4gYWN0aXZlUXVlcmllcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBRdWVyeWAgb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBgVGFyZ2V0YC4gVGhlcmUgaXMgbm8gd2F5IHRvXG4gKiBvYnRhaW4gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIHNvIHdlIHN5bnRoZXNpemUgYSBgUXVlcnlgIGZyb20gdGhlIGBUYXJnZXRgXG4gKiBvYmplY3QuXG4gKlxuICogVGhlIHN5bnRoZXNpemVkIHJlc3VsdCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgYFF1ZXJ5YCwgYnV0XG4gKiBzaW5jZSB0aGUgc3ludGhlc2l6ZWQgYFF1ZXJ5YCBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgdGhlXG4gKiBvcmlnaW5hbCBvbmUgKG9ubHkgdGhlIHByZXNlbnRhdGlvbiBvZiByZXN1bHRzIG1pZ2h0IGRpZmZlciksIHRoZSBwb3RlbnRpYWxcbiAqIGRpZmZlcmVuY2Ugd2lsbCBub3QgY2F1c2UgaXNzdWVzLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHRhcmdldC5wYXRoLCB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLCB0YXJnZXQub3JkZXJCeSwgdGFyZ2V0LmZpbHRlcnMsIHRhcmdldC5saW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIGNsaWVudHMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xufVxuLyoqIEFwcGxpZXMgYSBxdWVyeSB0YXJnZXQgY2hhbmdlIGZyb20gYSBkaWZmZXJlbnQgdGFiLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlKHN5bmNFbmdpbmUsIHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgdGFyZ2V0IHN0YXRlIG5vdGlmaWNhdGlvbiB2aWEgV2ViU3RvcmFnZSwgd2UgYXJlXG4gICAgICAgIC8vIGVpdGhlciBhbHJlYWR5IHNlY29uZGFyeSBvciBhbm90aGVyIHRhYiBoYXMgdGFrZW4gdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0lnbm9yaW5nIHVuZXhwZWN0ZWQgcXVlcnkgc3RhdGUgbm90aWZpY2F0aW9uLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VycmVudCc6XG4gICAgICAgICAgICBjYXNlICdub3QtY3VycmVudCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUdldE5ld0RvY3VtZW50Q2hhbmdlcyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeVswXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bnRoZXNpemVkUmVtb3RlRXZlbnQgPSBSZW1vdGVFdmVudC5jcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgc3RhdGUgPT09ICdjdXJyZW50JywgQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHN5bnRoZXNpemVkUmVtb3RlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAgICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBZGRzIG9yIHJlbW92ZXMgV2F0Y2ggdGFyZ2V0cyBmb3IgcXVlcmllcyBmcm9tIGRpZmZlcmVudCB0YWJzLiAqL1xuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZShzeW5jRW5naW5lLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBhZGRlZCkge1xuICAgICAgICAvLyBBIHRhcmdldCBpcyBhbHJlYWR5IGxpc3RlbmluZyB0byByZW1vdGUgc3RvcmUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvXG4gICAgICAgIC8vIHNoYXJlZENsaWVudFN0YXRlLlxuICAgICAgICBjb25zdCB0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5oYXModGFyZ2V0SWQpICYmXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKHRhcmdldEFscmVhZHlMaXN0ZW5pbmdUb1JlbW90ZVN0b3JlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdBZGRpbmcgYW4gYWxyZWFkeSBhY3RpdmUgdGFyZ2V0ICcgKyB0YXJnZXRJZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xuICAgICAgICBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSwgdGFyZ2V0RGF0YS50YXJnZXRJZCwgXG4gICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiByZW1vdmVkKSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUgc2luY2UgdGhlIHRhcmdldCBtaWdodCBoYXZlIGJlZW5cbiAgICAgICAgLy8gcmVtb3ZlZCBpZiBpdCBoYXMgYmVlbiByZWplY3RlZCBieSB0aGUgYmFja2VuZC5cbiAgICAgICAgaWYgKCFzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsZWFzZSBxdWVyaWVzIHRoYXQgYXJlIHN0aWxsIGFjdGl2ZS5cbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyBmYWxzZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlSZW1vdGVFdmVudCA9XG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0ID1cbiAgICAgICAgc3luY0VuZ2luZUdldFJlbW90ZUtleXNGb3JUYXJnZXQuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdExpc3RlbiA9XG4gICAgICAgIHN5bmNFbmdpbmVSZWplY3RMaXN0ZW4uYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UgPVxuICAgICAgICBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaEVycm9yID1cbiAgICAgICAgZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcbiAgICByZXR1cm4gc3luY0VuZ2luZUltcGw7XG59XG5mdW5jdGlvbiBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5hcHBseVN1Y2Nlc3NmdWxXcml0ZSA9XG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVN1Y2Nlc3NmdWxXcml0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUgPVxuICAgICAgICBzeW5jRW5naW5lUmVqZWN0RmFpbGVkV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgcmV0dXJuIHN5bmNFbmdpbmVJbXBsO1xufVxuLyoqXG4gKiBMb2FkcyBhIEZpcmVzdG9yZSBidW5kbGUgaW50byB0aGUgU0RLLiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aGVuXG4gKiB0aGUgYnVuZGxlIGZpbmlzaGVkIGxvYWRpbmcuXG4gKlxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBTeW5jRW5naW5lIHRvIHVzZS5cbiAqIEBwYXJhbSBidW5kbGVSZWFkZXIgLSBCdW5kbGUgdG8gbG9hZCBpbnRvIHRoZSBTREsuXG4gKiBAcGFyYW0gdGFzayAtIExvYWRCdW5kbGVUYXNrIHVzZWQgdG8gdXBkYXRlIHRoZSBsb2FkaW5nIHByb2dyZXNzIHRvIHB1YmxpYyBBUEkuXG4gKi9cbmZ1bmN0aW9uIHN5bmNFbmdpbmVMb2FkQnVuZGxlKHN5bmNFbmdpbmUsIGJ1bmRsZVJlYWRlciwgdGFzaykge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lSW1wbCwgYnVuZGxlUmVhZGVyLCB0YXNrKS50aGVuKGNvbGxlY3Rpb25Hcm91cHMgPT4ge1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5ub3RpZnlCdW5kbGVMb2FkZWQoY29sbGVjdGlvbkdyb3Vwcyk7XG4gICAgfSk7XG59XG4vKiogTG9hZHMgYSBidW5kbGUgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgYWZmZWN0ZWQgY29sbGVjdGlvbiBncm91cHMuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lLCByZWFkZXIsIHRhc2spIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHJlYWRlci5nZXRNZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCBza2lwID0gYXdhaXQgbG9jYWxTdG9yZUhhc05ld2VyQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgoYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MoYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSk7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBCdW5kbGVMb2FkZXIobWV0YWRhdGEsIHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgcmVhZGVyLnNlcmlhbGl6ZXIpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBhd2FpdCBsb2FkZXIuYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5jb21wbGV0ZSgpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCByZXN1bHQuY2hhbmdlZERvY3MsIFxuICAgICAgICAvKiByZW1vdGVFdmVudCAqLyB1bmRlZmluZWQpO1xuICAgICAgICAvLyBTYXZlIG1ldGFkYXRhLCBzbyBsb2FkaW5nIHRoZSBzYW1lIGJ1bmRsZSB3aWxsIHNraXAuXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xuICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgocmVzdWx0LnByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQuY2hhbmdlZENvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dXYXJuKExPR19UQUckMywgYExvYWRpbmcgYnVuZGxlIGZhaWxlZCB3aXRoICR7ZX1gKTtcbiAgICAgICAgdGFzay5fZmFpbFdpdGgoZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNldCgpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggaW4tbWVtb3J5IHBlcnNpc3RlbmNlLlxuICogVXNlcyBFYWdlckdDIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAqL1xuY2xhc3MgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ21lbW9yeSc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHRoaXMuY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHRoaXMuY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zdGFydCgpO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSB0aGlzLmNyZWF0ZUxvY2FsU3RvcmUoY2ZnKTtcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlciA9IHRoaXMuY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCB0aGlzLmxvY2FsU3RvcmUpO1xuICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlciA9IHRoaXMuY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgdGhpcy5sb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVMb2NhbFN0b3JlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlQZXJzaXN0ZW5jZShNZW1vcnlFYWdlckRlbGVnYXRlLmZhY3RvcnksIHRoaXMuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gdGhpcy5nY1NjaGVkdWxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgICAgKF9iID0gdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUuc2h1dGRvd24oKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zaHV0ZG93bigpO1xuICAgIH1cbn1cbk1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlciA9IHtcbiAgICBidWlsZDogKCkgPT4gbmV3IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcigpXG59O1xuY2xhc3MgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgZXh0ZW5kcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlU2l6ZUJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSBpbnN0YW5jZW9mIE1lbW9yeUxydURlbGVnYXRlKTtcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVTY2hlZHVsZXIoZ2FyYmFnZUNvbGxlY3RvciwgY2ZnLmFzeW5jUXVldWUsIGxvY2FsU3RvcmUpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgY29uc3QgbHJ1UGFyYW1zID0gdGhpcy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IExydVBhcmFtcy53aXRoQ2FjaGVTaXplKHRoaXMuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKHAgPT4gTWVtb3J5THJ1RGVsZWdhdGUuZmFjdG9yeShwLCBscnVQYXJhbXMpLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBJbmRleGVkREIgcGVyc2lzdGVuY2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCBmb3JjZU93bmVyc2hpcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudCc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKHRoaXMsIGNmZyk7XG4gICAgICAgIC8vIEVucXVldWUgd3JpdGVzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlKTtcbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5nY1NjaGVkdWxlciAmJiAhdGhpcy5nY1NjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgTHJ1U2NoZWR1bGVyKGdhcmJhZ2VDb2xsZWN0b3IsIGNmZy5hc3luY1F1ZXVlLCBsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBjb25zdCBpbmRleEJhY2tmaWxsZXIgPSBuZXcgSW5kZXhCYWNrZmlsbGVyKGxvY2FsU3RvcmUsIHRoaXMucGVyc2lzdGVuY2UpO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcuYXN5bmNRdWV1ZSwgaW5kZXhCYWNrZmlsbGVyKTtcbiAgICB9XG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gTHJ1UGFyYW1zLndpdGhDYWNoZVNpemUodGhpcy5jYWNoZVNpemVCeXRlcylcbiAgICAgICAgICAgIDogTHJ1UGFyYW1zLkRFRkFVTFQ7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUGVyc2lzdGVuY2UodGhpcy5zeW5jaHJvbml6ZVRhYnMsIHBlcnNpc3RlbmNlS2V5LCBjZmcuY2xpZW50SWQsIGxydVBhcmFtcywgY2ZnLmFzeW5jUXVldWUsIGdldFdpbmRvdygpLCBnZXREb2N1bWVudCgpLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsICEhdGhpcy5mb3JjZU93bmVyc2hpcCk7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIG11bHRpLXRhYiBJbmRleGVkREJcbiAqIHBlcnNpc3RlbmNlLlxuICpcbiAqIEluIHRoZSBsZWdhY3kgY2xpZW50LCB0aGlzIHByb3ZpZGVyIGlzIHVzZWQgdG8gcHJvdmlkZSBib3RoIG11bHRpLXRhYiBhbmRcbiAqIG5vbi1tdWx0aS10YWIgcGVyc2lzdGVuY2Ugc2luY2Ugd2UgY2Fubm90IHRlbGwgYXQgYnVpbGQgdGltZSB3aGV0aGVyXG4gKiBgc3luY2hyb25pemVUYWJzYCB3aWxsIGJlIGVuYWJsZWQuXG4gKi9cbmNsYXNzIE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMpIHtcbiAgICAgICAgc3VwZXIob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCAvKiBmb3JjZU93bmVyc2hpcD0gKi8gZmFsc2UpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVRhYnMgPSB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKGNmZyk7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmU7XG4gICAgICAgIGlmICh0aGlzLnNoYXJlZENsaWVudFN0YXRlIGluc3RhbmNlb2YgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN5bmNFbmdpbmUgPSB7XG4gICAgICAgICAgICAgICAgYXBwbHlCYXRjaFN0YXRlOiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXG4gICAgICAgICAgICAgICAgYXBwbHlUYXJnZXRTdGF0ZTogc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBhcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2U6IHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBnZXRBY3RpdmVDbGllbnRzOiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cy5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHM6IHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzLmJpbmQobnVsbCwgc3luY0VuZ2luZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihhc3luYyAoaXNQcmltYXJ5KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzeW5jRW5naW5lQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lLCBpc1ByaW1hcnkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1hcnkgJiYgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgICBpZiAoIVdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZS5pc0F2YWlsYWJsZSh3aW5kb3cpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnSW5kZXhlZERCIHBlcnNpc3RlbmNlIGlzIG9ubHkgYXZhaWxhYmxlIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgTG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSh3aW5kb3csIGNmZy5hc3luY1F1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgY2ZnLmNsaWVudElkLCBjZmcuaW5pdGlhbFVzZXIpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIHdpcmVzIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbnRlcmZhY2Ugd2l0aCB0aGVcbiAqIG5ldHdvcmsuXG4gKi9cbmNsYXNzIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBhc3luYyBpbml0aWFsaXplKG9mZmxpbmVDb21wb25lbnRQcm92aWRlciwgY2ZnKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmUpIHtcbiAgICAgICAgICAgIC8vIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIG1heSBnZXQgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgaWZcbiAgICAgICAgICAgIC8vIG11bHRpLXRhYiBwZXJzaXN0ZW5jZSBpcyB1c2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnNoYXJlZENsaWVudFN0YXRlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHRoaXMuY3JlYXRlRGF0YXN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUgPSB0aGlzLmNyZWF0ZVJlbW90ZVN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gdGhpcy5jcmVhdGVFdmVudE1hbmFnZXIoY2ZnKTtcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gdGhpcy5jcmVhdGVTeW5jRW5naW5lKGNmZywgXG4gICAgICAgIC8qIHN0YXJ0QXNQcmltYXJ5PSovICFvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY2hyb25pemVUYWJzKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAxIC8qIE9ubGluZVN0YXRlU291cmNlLlNoYXJlZENsaWVudFN0YXRlICovKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZS5iaW5kKG51bGwsIHRoaXMuc3luY0VuZ2luZSk7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5zeW5jRW5naW5lLmlzUHJpbWFyeUNsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50TWFuYWdlcihjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0V2ZW50TWFuYWdlcigpO1xuICAgIH1cbiAgICBjcmVhdGVEYXRhc3RvcmUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGNmZy5kYXRhYmFzZUluZm8pO1xuICAgICAgICByZXR1cm4gbmV3RGF0YXN0b3JlKGNmZy5hdXRoQ3JlZGVudGlhbHMsIGNmZy5hcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXdSZW1vdGVTdG9yZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMuZGF0YXN0b3JlLCBjZmcuYXN5bmNRdWV1ZSwgb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMCAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5SZW1vdGVTdG9yZSAqLyksIG5ld0Nvbm5lY3Rpdml0eU1vbml0b3IoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBzdGFydEFzUHJpbWFyeSkge1xuICAgICAgICByZXR1cm4gbmV3U3luY0VuZ2luZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLCBjZmcuaW5pdGlhbFVzZXIsIGNmZy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgc3RhcnRBc1ByaW1hcnkpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlU2h1dGRvd24odGhpcy5yZW1vdGVTdG9yZSk7XG4gICAgICAgIChfYSA9IHRoaXMuZGF0YXN0b3JlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVybWluYXRlKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZXZlbnRNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGVybWluYXRlKCk7XG4gICAgfVxufVxuT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIgPSB7XG4gICAgYnVpbGQ6ICgpID0+IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIb3cgbWFueSBieXRlcyB0byByZWFkIGVhY2ggdGltZSB3aGVuIGBSZWFkYWJsZVN0cmVhbVJlYWRlci5yZWFkKClgIGlzXG4gKiBjYWxsZWQuIE9ubHkgYXBwbGljYWJsZSBmb3IgYnl0ZSBzdHJlYW1zIHRoYXQgd2UgY29udHJvbCAoZS5nLiB0aG9zZSBiYWNrZWRcbiAqIGJ5IGFuIFVJbnQ4QXJyYXkpLlxuICovXG5jb25zdCBERUZBVUxUX0JZVEVTX1BFUl9SRUFEID0gMTAyNDA7XG4vKipcbiAqIEJ1aWxkcyBhIGBCeXRlU3RyZWFtUmVhZGVyYCBmcm9tIGEgVUludDhBcnJheS5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgZGF0YSBzb3VyY2UgdG8gdXNlLlxuICogQHBhcmFtIGJ5dGVzUGVyUmVhZCAtIEhvdyBtYW55IGJ5dGVzIGVhY2ggYHJlYWQoKWAgZnJvbSB0aGUgcmV0dXJuZWQgcmVhZGVyXG4gKiAgICAgICAgd2lsbCByZWFkLlxuICovXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQgPSBERUZBVUxUX0JZVEVTX1BFUl9SRUFEKSB7XG4gICAgbGV0IHJlYWRGcm9tID0gMDtcbiAgICAvLyBUaGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZvciBSZWFkYWJsZVN0cmVhbVJlYWRlciBjaGFuZ2VkLiBXZSB1c2VcbiAgICAvLyBgYW55YCBoZXJlIHRvIGFsbG93IHRoaXMgY29kZSB0byBjb21waWxlIHdpdGggZGlmZmVyZW50IHZlcnNpb25zLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQyOTcwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCByZWFkZXIgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgICAgICBpZiAocmVhZEZyb20gPCBzb3VyY2UuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShyZWFkRnJvbSwgcmVhZEZyb20gKyBieXRlc1BlclJlYWQpLFxuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZEZyb20gKz0gYnl0ZXNQZXJSZWFkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNhbmNlbCgpIHsgfSxcbiAgICAgICAgcmVsZWFzZUxvY2soKSB7IH0sXG4gICAgICAgIGNsb3NlZDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9O1xuICAgIHJldHVybiByZWFkZXI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGFyZ3VtZW50KSB7XG4gICAgaWYgKCFhcmd1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5ICR7YXJndW1lbnROYW1lfS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHR3byBib29sZWFuIG9wdGlvbnMgYXJlIG5vdCBzZXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKG9wdGlvbk5hbWUxLCBhcmd1bWVudDEsIG9wdGlvbk5hbWUyLCBhcmd1bWVudDIpIHtcbiAgICBpZiAoYXJndW1lbnQxID09PSB0cnVlICYmIGFyZ3VtZW50MiA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgJHtvcHRpb25OYW1lMX0gYW5kICR7b3B0aW9uTmFtZTJ9IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGRvY3VtZW50IChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXQgY29udGFpbnNcbiAqIGFuIGV2ZW4gbnVtYmVycyBvZiBzZWdtZW50cykuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRG9jdW1lbnRQYXRoKHBhdGgpIHtcbiAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZG9jdW1lbnQgcmVmZXJlbmNlLiBEb2N1bWVudCByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGNvbGxlY3Rpb24gKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdFxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKHBhdGgpIHtcbiAgICBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBjb2xsZWN0aW9uIHJlZmVyZW5jZS4gQ29sbGVjdGlvbiByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXQncyBhIG5vbi1udWxsIG9iamVjdCB3aXRob3V0IGEgY3VzdG9tIHByb3RvdHlwZVxuICogKGkuZS4gZXhjbHVkZXMgQXJyYXksIERhdGUsIGV0Yy4pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXG4gICAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBPYmplY3QucHJvdG90eXBlIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSk7XG59XG4vKiogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIC8gdmFsdWUgb2YgdGhlIHByb3ZpZGVkIGlucHV0LiAqL1xuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgIGlucHV0ID0gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDIwKX0uLi5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaW5wdXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYW4gYXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tT2JqZWN0TmFtZSA9IHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbU9iamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGEgY3VzdG9tICR7Y3VzdG9tT2JqZWN0TmFtZX0gb2JqZWN0YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYW4gb2JqZWN0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICdhIGZ1bmN0aW9uJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqIHRyeSB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIG9iamVjdC4gKi9cbmZ1bmN0aW9uIHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAsIG9wdGlvbmFsbHkgdW53cmFwcGluZyBDb21wYXQgdHlwZXMgdG8gZXhwb3NlIHRoZVxuICogdW5kZXJseWluZyBpbnN0YW5jZS4gVGhyb3dzIGlmICBgb2JqYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYFRgLlxuICpcbiAqIFRoaXMgY2FzdCBpcyB1c2VkIGluIHRoZSBMaXRlIGFuZCBGdWxsIFNESyB0byB2ZXJpZnkgaW5zdGFuY2UgdHlwZXMgZm9yXG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwdWJsaWMgQVBJLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNhc3Qob2JqLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdHJ1Y3Rvcikge1xuICAgIGlmICgnX2RlbGVnYXRlJyBpbiBvYmopIHtcbiAgICAgICAgLy8gVW53cmFwIENvbXBhdCB0eXBlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBvYmogPSBvYmouX2RlbGVnYXRlO1xuICAgIH1cbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLm5hbWUgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgaW5zdGFuY2UuIERpZCB5b3UgcGFzcyBhICcgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZURlc2NyaXB0aW9uKG9iaik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRXhwZWN0ZWQgdHlwZSAnJHtjb25zdHJ1Y3Rvci5uYW1lfScsIGJ1dCBpdCB3YXM6ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoZnVuY3Rpb25OYW1lLCBuKSB7XG4gICAgaWYgKG4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgcmVxdWlyZXMgYSBwb3NpdGl2ZSBudW1iZXIsIGJ1dCBpdCB3YXM6ICR7bn0uYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBPbiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBpcyBhIGBVaW50OEFycmF5YCBmb3Igbm93LlxuICovXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXIoc291cmNlLCBieXRlc1BlclJlYWQpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgTm9kZVBsYXRmb3JtLnRvQnl0ZVN0cmVhbVJlYWRlciBleHBlY3RzIHNvdXJjZSB0byBiZSBVaW50OEFycmF5LCBnb3QgJHt2YWx1ZURlc2NyaXB0aW9uKHNvdXJjZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiBPYnNlcnZlcjxUPiB0aGF0IHdpbGwgZGlzcGF0Y2ggZXZlbnRzXG4gKiBhc3luY2hyb25vdXNseS4gVG8gYWxsb3cgaW1tZWRpYXRlIHNpbGVuY2luZywgYSBtdXRlIGNhbGwgaXMgYWRkZWQgd2hpY2hcbiAqIGNhdXNlcyBldmVudHMgc2NoZWR1bGVkIHRvIG5vIGxvbmdlciBiZSByYWlzZWQuXG4gKi9cbmNsYXNzIEFzeW5jT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUsIHdpbGwgbm90IHJhaXNlIGZ1dHVyZSBldmVudHMuIE5lY2Vzc2FyeSB0byBkZWFsIHdpdGhcbiAgICAgICAgICogYXN5bmMgZGV0YWNobWVudCBvZiBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVFdmVudCh0aGlzLm9ic2VydmVyLm5leHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5lcnJvciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ1VuY2F1Z2h0IEVycm9yIGluIHNuYXBzaG90IGxpc3RlbmVyOicsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11dGUoKSB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUV2ZW50KGV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29tcGxldGUgZWxlbWVudCBpbiB0aGUgYnVuZGxlIHN0cmVhbSwgdG9nZXRoZXIgd2l0aCB0aGUgYnl0ZSBsZW5ndGggaXRcbiAqIG9jY3VwaWVzIGluIHRoZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFNpemVkQnVuZGxlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocGF5bG9hZCwgXG4gICAgLy8gSG93IG1hbnkgYnl0ZXMgdGhpcyBlbGVtZW50IHRha2VzIHRvIHN0b3JlIGluIHRoZSBidW5kbGUuXG4gICAgYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBpc0J1bmRsZU1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gJ21ldGFkYXRhJyBpbiB0aGlzLnBheWxvYWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGJ1bmRsZS5cbiAqXG4gKiBUYWtlcyBhIGJ1bmRsZSBzdHJlYW0gb3IgYnVmZmVyLCBhbmQgcHJlc2VudHMgYWJzdHJhY3Rpb25zIHRvIHJlYWQgYnVuZGxlZFxuICogZWxlbWVudHMgb3V0IG9mIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnQuXG4gKi9cbmNsYXNzIEJ1bmRsZVJlYWRlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgcmVhZGVyIHRvIHJlYWQgZnJvbSB1bmRlcmx5aW5nIGJpbmFyeSBidW5kbGUgZGF0YSBzb3VyY2UuICovXG4gICAgcmVhZGVyLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKiogQ2FjaGVkIGJ1bmRsZSBtZXRhZGF0YS4gKi9cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgYnVmZmVyIHRvIGhvbGQgYnVuZGxlIGNvbnRlbnQsIGFjY3VtdWxhdGluZyBpbmNvbXBsZXRlIGVsZW1lbnRcbiAgICAgICAgICogY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IG5ld1RleHREZWNvZGVyKCk7XG4gICAgICAgIC8vIFJlYWQgdGhlIG1ldGFkYXRhICh3aGljaCBpcyB0aGUgZmlyc3QgZWxlbWVudCkuXG4gICAgICAgIHRoaXMubmV4dEVsZW1lbnRJbXBsKCkudGhlbihlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yZXNvbHZlKGVsZW1lbnQucGF5bG9hZC5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJlamVjdChuZXcgRXJyb3IoYFRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBidW5kbGUgaXMgbm90IGEgbWV0YWRhdGEsIGl0IGlzXG4gICAgICAgICAgICAgJHtKU09OLnN0cmluZ2lmeShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQucGF5bG9hZCl9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB0aGlzLm1ldGFkYXRhLnJlamVjdChlcnJvcikpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEucHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgbmV4dEVsZW1lbnQoKSB7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgbWV0YWRhdGEgaXMgcmVhZCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAgICAgYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0RWxlbWVudEltcGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgZnJvbSB0aGUgaGVhZCBvZiBpbnRlcm5hbCBidWZmZXIsIGFuZCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tXG4gICAgICogdW5kZXJseWluZyBzdHJlYW0gaWYgYSBjb21wbGV0ZSBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZCwgdW50aWwgYW5cbiAgICAgKiBlbGVtZW50KGluY2x1ZGluZyB0aGUgcHJlZml4ZWQgbGVuZ3RoIGFuZCB0aGUgSlNPTiBzdHJpbmcpIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogT25jZSBhIGNvbXBsZXRlIGVsZW1lbnQgaXMgcmVhZCwgaXQgaXMgZHJvcHBlZCBmcm9tIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIFJldHVybnMgZWl0aGVyIHRoZSBidW5kbGVkIGVsZW1lbnQsIG9yIG51bGwgaWYgd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2ZcbiAgICAgKiB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGFzeW5jIG5leHRFbGVtZW50SW1wbCgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkTGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW5ndGhCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFN0cmluZyA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGxlbmd0aEJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE51bWJlcihsZW5ndGhTdHJpbmcpO1xuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKGBsZW5ndGggc3RyaW5nICgke2xlbmd0aFN0cmluZ30pIGlzIG5vdCB2YWxpZCBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gYXdhaXQgdGhpcy5yZWFkSnNvblN0cmluZyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IFNpemVkQnVuZGxlRWxlbWVudChKU09OLnBhcnNlKGpzb25TdHJpbmcpLCBsZW5ndGhCdWZmZXIubGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqIEZpcnN0IGluZGV4IG9mICd7JyBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci4gKi9cbiAgICBpbmRleE9mT3BlbkJyYWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5maW5kSW5kZXgodiA9PiB2ID09PSAneycuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyLCB1bnRpbCB0aGUgZmlyc3QgJ3snLCBhbmRcbiAgICAgKiByZXR1cm4gdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBJZiByZWFjaGVkIGVuZCBvZiB0aGUgc3RyZWFtLCByZXR1cm5zIGEgbnVsbC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkTGVuZ3RoKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleE9mT3BlbkJyYWNrZXQoKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBhd2FpdCB0aGlzLnB1bGxNb3JlRGF0YVRvQnVmZmVyKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYW5kIHRoZXJlXG4gICAgICAgIC8vIGhhcHBlbnMgdG8gYmUgbm8gbW9yZSBkYXRhIHRvIHByb2Nlc3MuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleE9mT3BlbkJyYWNrZXQoKTtcbiAgICAgICAgLy8gQnJva2Ugb3V0IG9mIHRoZSBsb29wIGJlY2F1c2UgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkLCBidXQgc3RpbGxcbiAgICAgICAgLy8gY2Fubm90IGZpbmQgYW4gb3BlbiBicmFja2V0LlxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBhIGxlbmd0aCBzdHJpbmcgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGxlbmd0aC5cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGZyb20gYSBzcGVjaWZpZWQgcG9zaXRpb24gZnJvbSB0aGUgaW50ZXJuYWwgYnVmZmVyLCBmb3IgYSBzcGVjaWZpZWRcbiAgICAgKiBudW1iZXIgb2YgYnl0ZXMsIHB1bGxpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgZGVjb2RlZCBmcm9tIHRoZSByZWFkIGJ5dGVzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRKc29uU3RyaW5nKGxlbmd0aCkge1xuICAgICAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gYXdhaXQgdGhpcy5wdWxsTW9yZURhdGFUb0J1ZmZlcigpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBtb3JlIGlzIGV4cGVjdGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGpzb24gc3RyaW5nLlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJhaXNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVuZGxlIGZvcm1hdDogJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWxscyBtb3JlIGRhdGEgZnJvbSB1bmRlcmx5aW5nIHN0cmVhbSB0byBpbnRlcm5hbCBidWZmZXIuXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgcHVsbE1vcmVEYXRhVG9CdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIubGVuZ3RoICsgcmVzdWx0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQocmVzdWx0LnZhbHVlLCB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0J1bmRsZVJlYWRlcihyZWFkZXIsIHNlcmlhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IEJ1bmRsZVJlYWRlckltcGwocmVhZGVyLCBzZXJpYWxpemVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW50ZXJuYWwgdHJhbnNhY3Rpb24gb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmcgdGhlIG11dGF0aW9ucyB0b1xuICogcGVyZm9ybSBhbmQgdGhlIGJhc2UgdmVyc2lvbnMgZm9yIGFueSBkb2N1bWVudHMgcmVhZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24kMiB7XG4gICAgY29uc3RydWN0b3IoZGF0YXN0b3JlKSB7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xuICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMucmVhZFZlcnNpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm11dGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWZlcnJlZCB1c2FnZSBlcnJvciB0aGF0IG9jY3VycmVkIHByZXZpb3VzbHkgaW4gdGhpcyB0cmFuc2FjdGlvbiB0aGF0XG4gICAgICAgICAqIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uIHRvIGZhaWwgb25jZSBpdCBhY3R1YWxseSBjb21taXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHdyaXR0ZW4gaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSB3cml0ZSB0byB0aGUgc2FtZSBrZXkgaW4gYSB0cmFuc2FjdGlvbiwgYW55XG4gICAgICAgICAqIHdyaXRlcyBhZnRlciB0aGUgZmlyc3QgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXAoa2V5cykge1xuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGaXJlc3RvcmUgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYWxsIHJlYWRzIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSBhbGwgd3JpdGVzLicpO1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGModGhpcy5kYXRhc3RvcmUsIGtleXMpO1xuICAgICAgICBkb2NzLmZvckVhY2goZG9jID0+IHRoaXMucmVjb3JkVmVyc2lvbihkb2MpKTtcbiAgICAgICAgcmV0dXJuIGRvY3M7XG4gICAgfVxuICAgIHNldChrZXksIGRhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdXBkYXRlKGtleSwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLnRvTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB0aGlzLndyaXRlKG5ldyBEZWxldGVNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBhc3luYyBjb21taXQoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVud3JpdHRlbiA9IHRoaXMucmVhZFZlcnNpb25zO1xuICAgICAgICAvLyBGb3IgZWFjaCBtdXRhdGlvbiwgbm90ZSB0aGF0IHRoZSBkb2Mgd2FzIHdyaXR0ZW4uXG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgdW53cml0dGVuLmRlbGV0ZShtdXRhdGlvbi5rZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGb3IgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGJ1dCBub3Qgd3JpdHRlbiB0bywgd2Ugd2FudCB0byBwZXJmb3JtXG4gICAgICAgIC8vIGEgYHZlcmlmeWAgb3BlcmF0aW9uLlxuICAgICAgICB1bndyaXR0ZW4uZm9yRWFjaCgoXywgcGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGludm9rZUNvbW1pdFJwYyh0aGlzLmRhdGFzdG9yZSwgdGhpcy5tdXRhdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlY29yZFZlcnNpb24oZG9jKSB7XG4gICAgICAgIGxldCBkb2NWZXJzaW9uO1xuICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gZG9jLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgYSBkZWxldGVkIGRvYyB1c2luZyBTbmFwc2hvdFZlcnNpb24ubWluKCkuXG4gICAgICAgICAgICBkb2NWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChkb2Mua2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRvY1ZlcnNpb24uaXNFcXVhbChleGlzdGluZ1ZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3aWxsIGZhaWwgbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0RvY3VtZW50IHZlcnNpb24gY2hhbmdlZCBiZXR3ZWVuIHR3byByZWFkcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFZlcnNpb25zLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvY1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhpcyBkb2N1bWVudCB3aGVuIGl0IHdhcyByZWFkIGluIHRoaXMgdHJhbnNhY3Rpb24sXG4gICAgICogYXMgYSBwcmVjb25kaXRpb24sIG9yIG5vIHByZWNvbmRpdGlvbiBpZiBpdCB3YXMgbm90IHJlYWQuXG4gICAgICovXG4gICAgcHJlY29uZGl0aW9uKGtleSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJlY29uZGl0aW9uIGZvciBhIGRvY3VtZW50IGlmIHRoZSBvcGVyYXRpb24gaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIHByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGEgZG9jdW1lbnQgaXMgd3JpdHRlbiwgd2Ugd2FudCB0byB0YWtlIGludG8gYWNjb3VudCB0aGVcbiAgICAgICAgLy8gcmVhZCB0aW1lIGFuZCBleGlzdGVuY2VcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QsIHNvIGZhaWwgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIHZhbGlkYXRlZCBsb2NhbGx5IGJlY2F1c2UgeW91IGNhbid0IHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIGJhY2tlbmQgd3JpdGUgdG8gYmUgYW4gaW5zZXJ0LiBUaGlzIGlzIHRoZSByZXZlcnNlXG4gICAgICAgICAgICAgICAgLy8gb2Ygd2hhdCB3ZSB3YW50LCBzaW5jZSB3ZSB3YW50IHRvIGFzc2VydCB0aGF0IHRoZSBkb2N1bWVudCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzcyB0aGF0IHRvIHRoZSBiYWNrZW5kLCB3ZSBoYXZlIHRvIHZhbGlkYXRlIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBjYW4gY2hhbmdlIG9uY2Ugd2UgY2FuIHNlbmQgc2VwYXJhdGUgdmVyaWZ5IHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHVwZGF0ZSBhIGRvY3VtZW50IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2N1bWVudCBleGlzdHMsIGJhc2UgcHJlY29uZGl0aW9uIG9uIGRvY3VtZW50IHVwZGF0ZSB0aW1lLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9jdW1lbnQgd2FzIG5vdCByZWFkLCBzbyB3ZSBqdXN0IHVzZSB0aGUgcHJlY29uZGl0aW9ucyBmb3IgYSBibGluZFxuICAgICAgICAgICAgLy8gdXBkYXRlLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUobXV0YXRpb24pIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgfVxuICAgIGVuc3VyZUNvbW1pdE5vdENhbGxlZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXG4gKiB3aXRoIGJhY2tvZmYuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uUnVubmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBkYXRhc3RvcmUsIG9wdGlvbnMsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbiA9IHVwZGF0ZUZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gZGVmZXJyZWQ7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPSBvcHRpb25zLm1heEF0dGVtcHRzO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMuYXN5bmNRdWV1ZSwgXCJ0cmFuc2FjdGlvbl9yZXRyeVwiIC8qIFRpbWVySWQuVHJhbnNhY3Rpb25SZXRyeSAqLyk7XG4gICAgfVxuICAgIC8qKiBSdW5zIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2V0cyB0aGUgcmVzdWx0IG9uIGRlZmVycmVkLiAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xuICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XG4gICAgfVxuICAgIHJ1bldpdGhCYWNrT2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbiQyKHRoaXMuZGF0YXN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdGhpcy50cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodXNlclByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tbWl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChjb21taXRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbkVycm9yKGNvbW1pdEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godXNlclByb21pc2VFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcih1c2VyUHJvbWlzZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyeVJ1blVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHVzZXJQcm9taXNlKSB8fFxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS5jYXRjaCB8fFxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbGxiYWNrIG11c3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXRyeSBlcnJvcnMgdGhyb3duIGJ5IHVzZXIgcHJvdmlkZWQgdXBkYXRlRnVuY3Rpb24uXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzUmVtYWluaW5nID4gMCAmJiB0aGlzLmlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgLT0gMTtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNSZXRyeWFibGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcbiAgICAgICAgICAgIC8vIEluIHRyYW5zYWN0aW9ucywgdGhlIGJhY2tlbmQgd2lsbCBmYWlsIG91dGRhdGVkIHJlYWRzIHdpdGggRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcbiAgICAgICAgICAgIC8vIG5vbi1tYXRjaGluZyBkb2N1bWVudCB2ZXJzaW9ucyB3aXRoIEFCT1JURUQuIFRoZXNlIGVycm9ycyBzaG91bGQgYmUgcmV0cmllZC5cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgICAgICAgcmV0dXJuIChjb2RlID09PSAnYWJvcnRlZCcgfHxcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnZmFpbGVkLXByZWNvbmRpdGlvbicgfHxcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnYWxyZWFkeS1leGlzdHMnIHx8XG4gICAgICAgICAgICAgICAgIWlzUGVybWFuZW50RXJyb3IoY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDIgPSAnRmlyZXN0b3JlQ2xpZW50JztcbmNvbnN0IE1BWF9DT05DVVJSRU5UX0xJTUJPX1JFU09MVVRJT05TID0gMTAwO1xuLyoqIERPTUV4Y2VwdGlvbiBlcnJvciBjb2RlIGNvbnN0YW50cy4gKi9cbmNvbnN0IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSA9IDExO1xuY29uc3QgRE9NX0VYQ0VQVElPTl9BQk9SVEVEID0gMjA7XG5jb25zdCBET01fRVhDRVBUSU9OX1FVT1RBX0VYQ0VFREVEID0gMjI7XG4vKipcbiAqIEZpcmVzdG9yZUNsaWVudCBpcyBhIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGNvbnN0cnVjdHMgYW5kIG93bnMgYWxsIG9mIHRoZSAvL1xuICogcGllY2VzIG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSAvL1xuICogYXN5bmMgcXVldWUgdGhhdCBpcyBzaGFyZWQgYnkgYWxsIG9mIHRoZSBvdGhlciBjb21wb25lbnRzIGluIHRoZSBzeXN0ZW0uIC8vXG4gKi9cbmNsYXNzIEZpcmVzdG9yZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBcbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgcXVldWUgcmVzcG9uc2libGUgZm9yIGFsbCBvZiBvdXIgaW50ZXJuYWwgcHJvY2Vzc2luZy4gV2hlblxuICAgICAqIHdlIGdldCBpbmNvbWluZyB3b3JrIGZyb20gdGhlIHVzZXIgKHZpYSBwdWJsaWMgQVBJKSBvciB0aGUgbmV0d29ya1xuICAgICAqIChpbmNvbWluZyBHUlBDIG1lc3NhZ2VzKSwgd2Ugc2hvdWxkIGFsd2F5cyBzY2hlZHVsZSBvbnRvIHRoaXMgcXVldWUuXG4gICAgICogVGhpcyBlbnN1cmVzIGFsbCBvZiBvdXIgd29yayBpcyBwcm9wZXJseSBzZXJpYWxpemVkIChlLmcuIHdlIGRvbid0XG4gICAgICogc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBvcGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIG9uZSBpcyB3YWl0aW5nIGZvclxuICAgICAqIGFuIGFzeW5jIEkvTyB0byBjb21wbGV0ZSkuXG4gICAgICovXG4gICAgYXN5bmNRdWV1ZSwgZGF0YWJhc2VJbmZvLCBjb21wb25lbnRQcm92aWRlcikge1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICB0aGlzLmNsaWVudElkID0gQXV0b0lkLm5ld0lkKCk7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIgPSBjb21wb25lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIHVzZXI9JywgdXNlci51aWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyKHVzZXIpO1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBuZXdBcHBDaGVja1Rva2VuID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIG5ldyBhcHAgY2hlY2sgdG9rZW49JywgbmV3QXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lcihuZXdBcHBDaGVja1Rva2VuLCB0aGlzLnVzZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luY1F1ZXVlOiB0aGlzLmFzeW5jUXVldWUsXG4gICAgICAgICAgICBkYXRhYmFzZUluZm86IHRoaXMuZGF0YWJhc2VJbmZvLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBhdXRoQ3JlZGVudGlhbHM6IHRoaXMuYXV0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgYXBwQ2hlY2tDcmVkZW50aWFsczogdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLFxuICAgICAgICAgICAgaW5pdGlhbFVzZXI6IHRoaXMudXNlcixcbiAgICAgICAgICAgIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zOiBNQVhfQ09OQ1VSUkVOVF9MSU1CT19SRVNPTFVUSU9OU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIHNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVudGVyUmVzdHJpY3RlZE1vZGUoKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXRFdmVuV2hpbGVSZXN0cmljdGVkKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ubGluZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25saW5lQ29tcG9uZW50cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29mZmxpbmVDb21wb25lbnRzLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgY3JlZGVudGlhbHMgcHJvdmlkZXIgbXVzdCBiZSB0ZXJtaW5hdGVkIGFmdGVyIHNodXR0aW5nIGRvd24gdGhlXG4gICAgICAgICAgICAgICAgLy8gUmVtb3RlU3RvcmUgYXMgaXQgd2lsbCBwcmV2ZW50IHRoZSBSZW1vdGVTdG9yZSBmcm9tIHJldHJpZXZpbmcgYXV0aFxuICAgICAgICAgICAgICAgIC8vIHRva2Vucy5cbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gc2h1dGRvd24gcGVyc2lzdGVuY2VgKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XG4gICAgY2xpZW50LmFzeW5jUXVldWUudmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpO1xuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gY2xpZW50LmNvbmZpZ3VyYXRpb247XG4gICAgYXdhaXQgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUoY29uZmlndXJhdGlvbik7XG4gICAgbGV0IGN1cnJlbnRVc2VyID0gY29uZmlndXJhdGlvbi5pbml0aWFsVXNlcjtcbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFVzZXIuaXNFcXVhbCh1c2VyKSkge1xuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2Uob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmUsIHVzZXIpO1xuICAgICAgICAgICAgY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2hlbiBhIHVzZXIgY2FsbHMgY2xlYXJQZXJzaXN0ZW5jZSgpIGluIG9uZSBjbGllbnQsIGFsbCBvdGhlciBjbGllbnRzXG4gICAgLy8gbmVlZCB0byBiZSB0ZXJtaW5hdGVkIHRvIGFsbG93IHRoZSBkZWxldGUgdG8gc3VjY2VlZC5cbiAgICBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucGVyc2lzdGVuY2Uuc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKCkgPT4gY2xpZW50LnRlcm1pbmF0ZSgpKTtcbiAgICBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBjb25zdCBvZmZsaW5lQ29tcG9uZW50cyA9IGF3YWl0IGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnSW5pdGlhbGl6aW5nIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgYXdhaXQgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZShvZmZsaW5lQ29tcG9uZW50cywgY2xpZW50LmNvbmZpZ3VyYXRpb24pO1xuICAgIC8vIFRoZSBDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIgb2YgdGhlIG9ubGluZSBjb21wb25lbnQgcHJvdmlkZXIgdGFrZXNcbiAgICAvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9mZmxpbmUgY29tcG9uZW50IHByb3ZpZGVyLlxuICAgIGNsaWVudC5zZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIodXNlciA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcbiAgICBjbGllbnQuc2V0QXBwQ2hlY2tUb2tlbkNoYW5nZUxpc3RlbmVyKChfLCB1c2VyKSA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcbiAgICBjbGllbnQuX29ubGluZUNvbXBvbmVudHMgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlcjtcbn1cbi8qKlxuICogRGVjaWRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlcnJvciBhbGxvd3MgdXMgdG8gZ3JhY2VmdWxseSBkaXNhYmxlXG4gKiBwZXJzaXN0ZW5jZSAoYXMgb3Bwb3NlZCB0byBjcmFzaGluZyB0aGUgY2xpZW50KS5cbiAqL1xuZnVuY3Rpb24gY2FuRmFsbGJhY2tGcm9tSW5kZXhlZERiRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OIHx8XG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYSBmZXcga25vd24gY2lyY3Vtc3RhbmNlcyB3aGVyZSB3ZSBjYW4gb3BlbiBJbmRleGVkRGIgYnV0XG4gICAgICAgIC8vIHRyeWluZyB0byByZWFkL3dyaXRlIHdpbGwgZmFpbCAoZS5nLiBxdW90YSBleGNlZWRlZCkuIEZvclxuICAgICAgICAvLyB3ZWxsLXVuZGVyc3Rvb2QgY2FzZXMsIHdlIGF0dGVtcHQgdG8gZGV0ZWN0IHRoZXNlIGFuZCB0aGVuIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgLy8gTk9URTogUmF0aGVyIHRoYW4gY29udGludWUgdG8gYWRkIHRvIHRoaXMgbGlzdCwgd2UgY291bGQgZGVjaWRlIHRvXG4gICAgICAgIC8vIGFsd2F5cyBmYWxsIGJhY2ssIHdpdGggdGhlIHJpc2sgdGhhdCB3ZSBtaWdodCBhY2NpZGVudGFsbHkgaGlkZSBlcnJvcnNcbiAgICAgICAgLy8gcmVwcmVzZW50aW5nIGFjdHVhbCBTREsgYnVncy5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gV2hlbiB0aGUgYnJvd3NlciBpcyBvdXQgb2YgcXVvdGEgd2UgY291bGQgZ2V0IGVpdGhlciBxdW90YSBleGNlZWRlZFxuICAgICAgICAvLyBvciBhbiBhYm9ydGVkIGVycm9yIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlcnJvciBoYXBwZW5lZCBkdXJpbmdcbiAgICAgICAgLy8gc2NoZW1hIG1pZ3JhdGlvbi5cbiAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCB8fFxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9BQk9SVEVEIHx8XG4gICAgICAgICAgICAvLyBGaXJlZm94IFByaXZhdGUgQnJvd3NpbmcgbW9kZSBkaXNhYmxlcyBJbmRleGVkRGIgYW5kIHJldHVybnNcbiAgICAgICAgICAgIC8vIElOVkFMSURfU1RBVEUgZm9yIGFueSB1c2FnZS5cbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQuX29mZmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIHVzZXIgcHJvdmlkZWQgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb2ZmbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nV2FybignRXJyb3IgdXNpbmcgdXNlciBwcm92aWRlZCBjYWNoZS4gRmFsbGluZyBiYWNrIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWVtb3J5IGNhY2hlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQuX29mZmxpbmVDb21wb25lbnRzO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpIHtcbiAgICBpZiAoIWNsaWVudC5fb25saW5lQ29tcG9uZW50cykge1xuICAgICAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb25saW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIGRlZmF1bHQgT25saW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICAgICAgICAgIGF3YWl0IHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgbmV3IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQuX29ubGluZUNvbXBvbmVudHM7XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW5jZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5wZXJzaXN0ZW5jZSk7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JlKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLmxvY2FsU3RvcmUpO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlU3RvcmUoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5yZW1vdGVTdG9yZSk7XG59XG5mdW5jdGlvbiBnZXRTeW5jRW5naW5lKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMuc3luY0VuZ2luZSk7XG59XG5mdW5jdGlvbiBnZXREYXRhc3RvcmUoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5kYXRhc3RvcmUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCkge1xuICAgIGNvbnN0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gYXdhaXQgZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpO1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmV2ZW50TWFuYWdlcjtcbiAgICBldmVudE1hbmFnZXIub25MaXN0ZW4gPSBzeW5jRW5naW5lTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uVW5saXN0ZW4gPSBzeW5jRW5naW5lVW5saXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcbiAgICBldmVudE1hbmFnZXIub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuID0gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uTGFzdFJlbW90ZVN0b3JlVW5saXN0ZW4gPSB0cmlnZ2VyUmVtb3RlU3RvcmVVbmxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBldmVudE1hbmFnZXI7XG59XG4vKiogRW5hYmxlcyB0aGUgbmV0d29yayBjb25uZWN0aW9uIGFuZCByZS1lbnF1ZXVlcyBhbGwgcGVuZGluZyBvcGVyYXRpb25zLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gYXdhaXQgZ2V0UGVyc2lzdGVuY2UoY2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVtb3RlU3RvcmUgPSBhd2FpdCBnZXRSZW1vdGVTdG9yZShjbGllbnQpO1xuICAgICAgICBwZXJzaXN0ZW5jZS5zZXROZXR3b3JrRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKiogRGlzYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi4gUGVuZGluZyBvcGVyYXRpb25zIHdpbGwgbm90IGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGlzYWJsZU5ldHdvcmsoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RvcmVEaXNhYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgd3JpdGVzIHRoYXQgd2VyZSBwZW5kaW5nIGF0IHRoZSB0aW1lXG4gKiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHJlY2VpdmVkIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuIEFuIGFja25vd2xlZGdlbWVudFxuICogY2FuIGJlIGVpdGhlciBhY2NlcHRhbmNlIG9yIHJlamVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50V2FpdEZvclBlbmRpbmdXcml0ZXMoY2xpZW50KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBxdWVyeSwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCBvcHRpb25zKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd3JhcHBlZE9ic2VydmVyLm11dGUoKTtcbiAgICAgICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBkb2NLZXkpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhbFN0b3JlID0gYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpO1xuICAgICAgICByZXR1cm4gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwga2V5LCBvcHRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeUZyb21DYWNoZShsb2NhbFN0b3JlLCBxdWVyeSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBJbXBsZW1lbnQgYW5kIGNhbGwgZXhlY3V0ZUFnZ3JlZ2F0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lciwgc2ltaWxhclxuICAgICAgICAvLyB0byB0aGUgaW1wbGVtZW50YXRpb24gaW4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lclxuICAgICAgICAvLyBhYm92ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3NzYyODM4NCk6IGNoZWNrIGBjYW5Vc2VOZXR3b3JrKClgIGFuZCBoYW5kbGUgbXVsdGktdGFiLlxuICAgICAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGludm9rZVJ1bkFnZ3JlZ2F0aW9uUXVlcnlScGMoZGF0YXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFdyaXRlKGNsaWVudCwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbnMsIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGNsaWVudCwgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xuICAgICAgICByZXR1cm4gYWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBUYWtlcyBhbiB1cGRhdGVGdW5jdGlvbiBpbiB3aGljaCBhIHNldCBvZiByZWFkcyBhbmQgd3JpdGVzIGNhbiBiZSBwZXJmb3JtZWRcbiAqIGF0b21pY2FsbHkuIEluIHRoZSB1cGRhdGVGdW5jdGlvbiwgdGhlIGNsaWVudCBjYW4gcmVhZCBhbmQgd3JpdGUgdmFsdWVzXG4gKiB1c2luZyB0aGUgc3VwcGxpZWQgdHJhbnNhY3Rpb24gb2JqZWN0LiBBZnRlciB0aGUgdXBkYXRlRnVuY3Rpb24sIGFsbFxuICogY2hhbmdlcyB3aWxsIGJlIGNvbW1pdHRlZC4gSWYgYSByZXRyeWFibGUgZXJyb3Igb2NjdXJzIChleDogc29tZSBvdGhlclxuICogY2xpZW50IGhhcyBjaGFuZ2VkIGFueSBvZiB0aGUgZGF0YSByZWZlcmVuY2VkKSwgdGhlbiB0aGUgdXBkYXRlRnVuY3Rpb25cbiAqIHdpbGwgYmUgY2FsbGVkIGFnYWluIGFmdGVyIGEgYmFja29mZi4gSWYgdGhlIHVwZGF0ZUZ1bmN0aW9uIHN0aWxsIGZhaWxzXG4gKiBhZnRlciBhbGwgcmV0cmllcywgdGhlbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSByZWplY3RlZC5cbiAqXG4gKiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgdXBkYXRlRnVuY3Rpb24gY29udGFpbnMgbWV0aG9kcyBmb3JcbiAqIGFjY2Vzc2luZyBkb2N1bWVudHMgYW5kIGNvbGxlY3Rpb25zLiBVbmxpa2Ugb3RoZXIgZGF0YXN0b3JlIGFjY2VzcywgZGF0YVxuICogYWNjZXNzZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBub3QgcmVmbGVjdCBsb2NhbCBjaGFuZ2VzIHRoYXQgaGF2ZSBub3RcbiAqIGJlZW4gY29tbWl0dGVkLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzIHJlcXVpcmVkIHRoYXQgYWxsIHJlYWRzIGFyZVxuICogcGVyZm9ybWVkIGJlZm9yZSBhbnkgd3JpdGVzLiBUcmFuc2FjdGlvbnMgbXVzdCBiZSBwZXJmb3JtZWQgd2hpbGUgb25saW5lLlxuICovXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbihjbGllbnQsIHVwZGF0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XG4gICAgICAgIG5ldyBUcmFuc2FjdGlvblJ1bm5lcihjbGllbnQuYXN5bmNRdWV1ZSwgZGF0YXN0b3JlLCBvcHRpb25zLCB1cGRhdGVGdW5jdGlvbiwgZGVmZXJyZWQpLnJ1bigpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgcmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGRvY0tleSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gY2FjaGUuIChIb3dldmVyLCB0aGlzIGRvY3VtZW50IG1heSAnICtcbiAgICAgICAgICAgICAgICBcImV4aXN0IG9uIHRoZSBzZXJ2ZXIuIFJ1biBhZ2FpbiB3aXRob3V0IHNldHRpbmcgJ3NvdXJjZScgaW4gXCIgK1xuICAgICAgICAgICAgICAgICd0aGUgR2V0T3B0aW9ucyB0byBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLiknKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gZ2V0IGRvY3VtZW50ICcke2RvY0tleX0gZnJvbSBjYWNoZWApO1xuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgZG9jdW1lbnQgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxuICogU25hcHNob3RMaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgcmVzdWx0KSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIoe1xuICAgICAgICBuZXh0OiAoc25hcCkgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gc25hcC5kb2NzLmhhcyhrZXkpO1xuICAgICAgICAgICAgaWYgKCFleGlzdHMgJiYgc25hcC5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElmIHdlJ3JlIG9ubGluZSBhbmQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBleGlzdCB0aGVuIHdlIHJlc29sdmUgd2l0aCBhIGRvYy5leGlzdHMgc2V0IHRvIGZhbHNlLiBJZlxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUgaG93ZXZlciwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLiBUd28gb3B0aW9uczogMSkgQ2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3BvbnNlIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyIHNvIHdlIGNhbiBkZWxpdmVyIHRoYXQgZXZlbiB3aGVuIHlvdSdyZVxuICAgICAgICAgICAgICAgIC8vIG9mZmxpbmUgMikgQWN0dWFsbHkgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoZSBvbmxpbmUgY2FzZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGJlY2F1c2UgdGhlIGNsaWVudCBpcyBvZmZsaW5lLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cyAmJlxuICAgICAgICAgICAgICAgIHNuYXAuZnJvbUNhY2hlICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gc2VydmVyLiAoSG93ZXZlciwgdGhpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGRvZXMgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50LiknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShzbmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGUgPT4gcmVzdWx0LnJlamVjdChlKVxuICAgIH0pO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxuICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBleGVjdXRlIHF1ZXJ5ICcke3F1ZXJ5fSBhZ2FpbnN0IGNhY2hlYCk7XG4gICAgICAgIHJlc3VsdC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIGEgbGF0ZW5jeS1jb21wZW5zYXRlZCBxdWVyeSBzbmFwc2hvdCBmcm9tIHRoZSBiYWNrZW5kIHZpYSBhXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIHJlc3VsdCkge1xuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90LmZyb21DYWNoZSAmJiBvcHRpb25zLnNvdXJjZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudHMgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGVzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50cyBtYXkgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50cy4pJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXG4gICAgfSk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZGF0YWJhc2VJZCwgZGF0YSwgcmVzdWx0VGFzaykge1xuICAgIGNvbnN0IHJlYWRlciA9IGNyZWF0ZUJ1bmRsZVJlYWRlcihkYXRhLCBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgc3luY0VuZ2luZUxvYWRCdW5kbGUoYXdhaXQgZ2V0U3luY0VuZ2luZShjbGllbnQpLCByZWFkZXIsIHJlc3VsdFRhc2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0TmFtZWRRdWVyeShjbGllbnQsIHF1ZXJ5TmFtZSkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IGxvY2FsU3RvcmVHZXROYW1lZFF1ZXJ5KGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgcXVlcnlOYW1lKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgc2VyaWFsaXplcikge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudCA9IG5ld1RleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCdW5kbGVSZWFkZXIodG9CeXRlU3RyZWFtUmVhZGVyKGNvbnRlbnQpLCBzZXJpYWxpemVyKTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFNldEluZGV4Q29uZmlndXJhdGlvbihjbGllbnQsIGluZGV4ZXMpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgaW5kZXhlcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoY2xpZW50LCBpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlU2V0SW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgaXNFbmFibGVkKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcyhjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlRGVsZXRlQWxsRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbXBhcmVzIHR3byBgRXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zYCBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqL1xuZnVuY3Rpb24gbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMxLnRpbWVvdXRTZWNvbmRzID09PSBvcHRpb25zMi50aW1lb3V0U2Vjb25kcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgRXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zYCB3aXRoIHRoZSBzYW1lXG4gKiBvcHRpb24gdmFsdWVzIGFzIHRoZSBnaXZlbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVMb25nUG9sbGluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0ge307XG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbG9uZS50aW1lb3V0U2Vjb25kcyA9IG9wdGlvbnMudGltZW91dFNlY29uZHM7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckMSA9ICdDb21wb25lbnRQcm92aWRlcic7XG4vKipcbiAqIEFuIGluc3RhbmNlIG1hcCB0aGF0IGVuc3VyZXMgb25seSBvbmUgRGF0YXN0b3JlIGV4aXN0cyBwZXIgRmlyZXN0b3JlXG4gKiBpbnN0YW5jZS5cbiAqL1xuY29uc3QgZGF0YXN0b3JlSW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuIE11c3QgYmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSBpcyB0ZXJtaW5hdGVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnRzKGZpcmVzdG9yZSkge1xuICAgIGNvbnN0IGRhdGFzdG9yZSA9IGRhdGFzdG9yZUluc3RhbmNlcy5nZXQoZmlyZXN0b3JlKTtcbiAgICBpZiAoZGF0YXN0b3JlKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ1JlbW92aW5nIERhdGFzdG9yZScpO1xuICAgICAgICBkYXRhc3RvcmVJbnN0YW5jZXMuZGVsZXRlKGZpcmVzdG9yZSk7XG4gICAgICAgIGRhdGFzdG9yZS50ZXJtaW5hdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlRGF0YWJhc2VJbmZvKGRhdGFiYXNlSWQsIGFwcElkLCBwZXJzaXN0ZW5jZUtleSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gc2V0dGluZ3MoKSBkZWZhdWx0czpcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb20nO1xuY29uc3QgREVGQVVMVF9TU0wgPSB0cnVlO1xuLy8gVGhlIG1pbmltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgaGFyZGNvZGVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSB2YWx1ZSBoZXJlXG4vLyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHZhbHVlIHVzZWQgYnkgdGhlIHNlcnZlciwgYXMgdGhlIHNlcnZlciB3aWxsXG4vLyBzaWxlbnRseSBpZ25vcmUgYSB2YWx1ZSBiZWxvdyB0aGUgbWluaW11bSBhbmQgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0LlxuLy8gR29vZ2xlcnMgc2VlIGIvMjY2ODY4ODcxIGZvciByZWxldmFudCBkaXNjdXNzaW9uLlxuY29uc3QgTUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMgPSA1O1xuLy8gTm8gbWF4aW11bSBsb25nLXBvbGxpbmcgdGltZW91dCBpcyBjb25maWd1cmVkIGluIHRoZSBzZXJ2ZXIsIGFuZCBkZWZhdWx0cyB0b1xuLy8gMzAgc2Vjb25kcywgd2hpY2ggaXMgd2hhdCBXYXRjaCBhcHBlYXJzIHRvIHVzZS5cbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cbmNvbnN0IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gMzA7XG4vLyBXaGV0aGVyIGxvbmctcG9sbGluZyBhdXRvLWRldGVjdGVkIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbmNvbnN0IERFRkFVTFRfQVVUT19ERVRFQ1RfTE9OR19QT0xMSU5HID0gdHJ1ZTtcbi8qKlxuICogQSBjb25jcmV0ZSB0eXBlIGRlc2NyaWJpbmcgYWxsIHRoZSB2YWx1ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB2aWEgYVxuICogdXNlci1zdXBwbGllZCBgRmlyZXN0b3JlU2V0dGluZ3NgIG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIHR5cGUgc28gdGhhdFxuICogZGVmYXVsdHMgY2FuIGJlIHN1cHBsaWVkIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5LlxuICovXG5jbGFzcyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChzZXR0aW5ncy5ob3N0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zc2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwiQ2FuJ3QgcHJvdmlkZSBzc2wgb3B0aW9uIGlmIGhvc3Qgb3B0aW9uIGlzIG5vdCBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBERUZBVUxUX0hPU1Q7XG4gICAgICAgICAgICB0aGlzLnNzbCA9IERFRkFVTFRfU1NMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gc2V0dGluZ3MuaG9zdDtcbiAgICAgICAgICAgIHRoaXMuc3NsID0gKF9hID0gc2V0dGluZ3Muc3NsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1NTTDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gc2V0dGluZ3MuY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9ICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5sb2NhbENhY2hlID0gc2V0dGluZ3MubG9jYWxDYWNoZTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBMUlVfREVGQVVMVF9DQUNIRV9TSVpFX0JZVEVTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCAmJlxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0ICR7TFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFU31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKCdleHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nJywgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgJ2V4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyk7XG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9ICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZztcbiAgICAgICAgaWYgKHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgY29lcmNlIHRoZSB2YWx1ZSB0byBib29sZWFuIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAvLyB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBoYXMgbmFycm93ZWQgdGhlIHR5cGUgdG8gYm9vbGVhbiBhbHJlYWR5LlxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFBvaW50bGVzc0Jvb2xlYW5FeHByZXNzaW9uSlNcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID1cbiAgICAgICAgICAgICAgICAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyA9IGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKChfYiA9IHNldHRpbmdzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pO1xuICAgICAgICB2YWxpZGF0ZUxvbmdQb2xsaW5nT3B0aW9ucyh0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyk7XG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gISFzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXM7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhvc3QgPT09IG90aGVyLmhvc3QgJiZcbiAgICAgICAgICAgIHRoaXMuc3NsID09PSBvdGhlci5zc2wgJiZcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPT09IG90aGVyLmNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID09PSBvdGhlci5jYWNoZVNpemVCeXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nID09PVxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PVxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyAmJlxuICAgICAgICAgICAgbG9uZ1BvbGxpbmdPcHRpb25zRXF1YWwodGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMsIG90aGVyLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9PT0gb3RoZXIuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAmJlxuICAgICAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPT09IG90aGVyLnVzZUZldGNoU3RyZWFtcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzTmFOKG9wdGlvbnMudGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogYCArXG4gICAgICAgICAgICAgICAgYCR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gKG11c3Qgbm90IGJlIE5hTilgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA8IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcbiAgICAgICAgICAgICAgICBgKG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA+IE1BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSBgICtcbiAgICAgICAgICAgICAgICBgKG1heGltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIENsb3VkIEZpcmVzdG9yZSBzZXJ2aWNlIGludGVyZmFjZS5cbiAqXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Uge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxuICovXG5jbGFzcyBGaXJlc3RvcmUkMSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfYXV0aENyZWRlbnRpYWxzLCBfYXBwQ2hlY2tDcmVkZW50aWFscywgX2RhdGFiYXNlSWQsIF9hcHApIHtcbiAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gX2F1dGhDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tDcmVkZW50aWFscyA9IF9hcHBDaGVja0NyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLl9kYXRhYmFzZUlkID0gX2RhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMuX2FwcCA9IF9hcHA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGl0J3MgYSBGaXJlc3RvcmUgb3IgRmlyZXN0b3JlIExpdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlLWxpdGUnO1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUtleSA9ICcobGl0ZSknO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoe30pO1xuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgICAvLyBBIHRhc2sgdGhhdCBpcyBhc3NpZ25lZCB3aGVuIHRoZSB0ZXJtaW5hdGUoKSBpcyBpbnZva2VkIGFuZCByZXNvbHZlZCB3aGVuXG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhhdmUgc2h1dCBkb3duLiBPdGhlcndpc2UsIEZpcmVzdG9yZSBpcyBub3QgdGVybWluYXRlZCxcbiAgICAgICAgLy8gd2hpY2ggY2FuIG1lYW4gZWl0aGVyIHRoZSBGaXJlc3RvcmVDbGllbnQgaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcsXG4gICAgICAgIC8vIG9yIHJlc3RhcnRpbmcuXG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSAnbm90VGVybWluYXRlZCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEZpcmVzdG9yZWAgc2VydmljZVxuICAgICAqIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXBwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBcIkZpcmVzdG9yZSB3YXMgbm90IGluaXRpYWxpemVkIHVzaW5nIHRoZSBGaXJlYmFzZSBTREsuICdhcHAnIGlzIFwiICtcbiAgICAgICAgICAgICAgICAnbm90IGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHA7XG4gICAgfVxuICAgIGdldCBfaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0Zyb3plbjtcbiAgICB9XG4gICAgZ2V0IF90ZXJtaW5hdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzayAhPT0gJ25vdFRlcm1pbmF0ZWQnO1xuICAgIH1cbiAgICBfc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzRnJvemVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgaXRzIHNldHRpbmdzIGNhbiBubyBsb25nZXIgJyArXG4gICAgICAgICAgICAgICAgJ2JlIGNoYW5nZWQuIFlvdSBjYW4gb25seSBtb2RpZnkgc2V0dGluZ3MgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xuICAgICAgICAgICAgICAgICdtZXRob2RzIG9uIGEgRmlyZXN0b3JlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoc2V0dGluZ3MpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKHNldHRpbmdzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gICAgX2ZyZWV6ZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gICAgX2RlbGV0ZSgpIHtcbiAgICAgICAgLy8gVGhlIGBfdGVybWluYXRlVGFza2AgbXVzdCBiZSBhc3NpZ25lZCBmdXR1cmUgdGhhdCBjb21wbGV0ZXMgd2hlblxuICAgICAgICAvLyB0ZXJtaW5hdGUgaXMgY29tcGxldGUuIFRoZSBleGlzdGVuY2Ugb2YgdGhpcyBmdXR1cmUgcHV0cyBTREsgaW4gc3RhdGVcbiAgICAgICAgLy8gdGhhdCB3aWxsIG5vdCBhY2NlcHQgZnVydGhlciBBUEkgaW50ZXJhY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hdGVUYXNrID09PSAnbm90VGVybWluYXRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSB0aGlzLl90ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzaztcbiAgICB9XG4gICAgYXN5bmMgX3Jlc3RhcnQoKSB7XG4gICAgICAgIC8vIFRoZSBgX3Rlcm1pbmF0ZVRhc2tgIG11c3QgZXF1YWwgJ25vdFRlcm1pbmF0ZWQnIGFmdGVyIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgY2xpZW50IGlzIGluIGEgc3RhdGUgdGhhdCBhY2NlcHRzIEFQSSBjYWxscy5cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPT09ICdub3RUZXJtaW5hdGVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVUYXNrID0gJ25vdFRlcm1pbmF0ZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgRmlyZXN0b3JlYCBpbnN0YW5jZS4gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHA6IHRoaXMuX2FwcCxcbiAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHRoaXMuX2RhdGFiYXNlSWQsXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5fc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhbGwgY29tcG9uZW50cyB1c2VkIGJ5IHRoaXMgY2xpZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgbWV0aG9kIHRvIGNsZWFuIHVwIHRoZWlyIG93biBkZXBlbmRlbmNpZXMsIGJ1dCBtdXN0IGFsc28gY2FsbCB0aGlzXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogT25seSBldmVyIGNhbGxlZCBvbmNlLlxuICAgICAqL1xuICAgIF90ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJlbW92ZUNvbXBvbmVudHModGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4vKipcbiAqIE1vZGlmeSB0aGlzIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIEZpcmVzdG9yZSBlbXVsYXRvci5cbiAqXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55XG4gKiBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgdG8gY29uZmlndXJlIHRvIGNvbm5lY3QgdG8gdGhlXG4gKiBlbXVsYXRvci5cbiAqIEBwYXJhbSBob3N0IC0gdGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpLlxuICogQHBhcmFtIHBvcnQgLSB0aGUgZW11bGF0b3IgcG9ydCAoZXg6IDkwMDApLlxuICogQHBhcmFtIG9wdGlvbnMubW9ja1VzZXJUb2tlbiAtIHRoZSBtb2NrIGF1dGggdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmdcbiAqIFNlY3VyaXR5IFJ1bGVzLlxuICovXG5mdW5jdGlvbiBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoZmlyZXN0b3JlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSQxKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBuZXdIb3N0U2V0dGluZyA9IGAke2hvc3R9OiR7cG9ydH1gO1xuICAgIGlmIChzZXR0aW5ncy5ob3N0ICE9PSBERUZBVUxUX0hPU1QgJiYgc2V0dGluZ3MuaG9zdCAhPT0gbmV3SG9zdFNldHRpbmcpIHtcbiAgICAgICAgbG9nV2FybignSG9zdCBoYXMgYmVlbiBzZXQgaW4gYm90aCBzZXR0aW5ncygpIGFuZCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IoKSwgZW11bGF0b3IgaG9zdCAnICtcbiAgICAgICAgICAgICd3aWxsIGJlIHVzZWQuJyk7XG4gICAgfVxuICAgIGZpcmVzdG9yZS5fc2V0U2V0dGluZ3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyksIHsgaG9zdDogbmV3SG9zdFNldHRpbmcsIHNzbDogZmFsc2UgfSkpO1xuICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgdXNlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcbiAgICAgICAgICAgIHVzZXIgPSBVc2VyLk1PQ0tfVVNFUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgdWlkID0gb3B0aW9ucy5tb2NrVXNlclRva2VuLnN1YiB8fCBvcHRpb25zLm1vY2tVc2VyVG9rZW4udXNlcl9pZDtcbiAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyKHVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZXN0b3JlLl9hdXRoQ3JlZGVudGlhbHMgPSBuZXcgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihuZXcgT0F1dGhUb2tlbih0b2tlbiwgdXNlcikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgUXVlcnlgIHJlZmVycyB0byBhIHF1ZXJ5IHdoaWNoIHlvdSBjYW4gcmVhZCBvciBsaXN0ZW4gdG8uIFlvdSBjYW4gYWxzb1xuICogY29uc3RydWN0IHJlZmluZWQgYFF1ZXJ5YCBvYmplY3RzIGJ5IGFkZGluZyBmaWx0ZXJzIGFuZCBvcmRlcmluZy5cbiAqL1xuY2xhc3MgUXVlcnkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpdGUgdmVyc2lvbiBvZiB0aGUgUXVlcnkgY2xhc3MgaW4gdGhlIG1haW4gU0RLLlxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29udmVydGVyLCBfcXVlcnkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gX3F1ZXJ5O1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVlcnknO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9xdWVyeSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBEb2N1bWVudFJlZmVyZW5jZWAgcmVmZXJzIHRvIGEgZG9jdW1lbnQgbG9jYXRpb24gaW4gYSBGaXJlc3RvcmUgZGF0YWJhc2VcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byB3cml0ZSwgcmVhZCwgb3IgbGlzdGVuIHRvIHRoZSBsb2NhdGlvbi4gVGhlIGRvY3VtZW50IGF0XG4gKiB0aGUgcmVmZXJlbmNlZCBsb2NhdGlvbiBtYXkgb3IgbWF5IG5vdCBleGlzdC5cbiAqL1xuY2xhc3MgRG9jdW1lbnRSZWZlcmVuY2Uge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb252ZXJ0ZXIsIF9rZXkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdkb2N1bWVudCc7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBnZXQgX3BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50J3MgaWRlbnRpZmllciB3aXRoaW4gaXRzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IChyZWxhdGl2ZVxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCB0aGlzLmNvbnZlcnRlciwgdGhpcy5fa2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9rZXkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXG4gKiBkb2N1bWVudCByZWZlcmVuY2VzLCBhbmQgcXVlcnlpbmcgZm9yIGRvY3VtZW50cyAodXNpbmcge0BsaW5rIChxdWVyeToxKX0pLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XG4gICAgICAgIHN1cGVyKGZpcmVzdG9yZSwgY29udmVydGVyLCBuZXdRdWVyeUZvclBhdGgoX3BhdGgpKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29sbGVjdGlvbic7XG4gICAgfVxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcbiAgICAgKiBzdWJjb2xsZWN0aW9uLiBJZiB0aGlzIGlzbid0IGEgc3ViY29sbGVjdGlvbiwgdGhlIHJlZmVyZW5jZSBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLl9wYXRoLnBvcExhc3QoKTtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkocGFyZW50UGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9wYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uJywgJ3BhdGgnLCBwYXRoKTtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBjb2xsZWN0aW9uKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgYWJzb2x1dGVQYXRoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZWxpdGUpOiBDb25zaWRlciB1c2luZyBFcnJvckZhY3RvcnkgLVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgUXVlcnlgIGluc3RhbmNlIHRoYXQgaW5jbHVkZXMgYWxsIGRvY3VtZW50cyBpbiB0aGVcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XG4gKiBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGlzIElEIGFzIHRoZSBsYXN0IHNlZ21lbnQgb2YgaXRzIHBhdGhcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxuICovXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnY29sbGVjdGlvbkdyb3VwJywgJ2NvbGxlY3Rpb24gaWQnLCBjb2xsZWN0aW9uSWQpO1xuICAgIGlmIChjb2xsZWN0aW9uSWQuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXG4gICAgICAgICAgICBgY29sbGVjdGlvbkdyb3VwKCkuIENvbGxlY3Rpb24gSURzIG11c3Qgbm90IGNvbnRhaW4gJy8nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXG4gICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpKTtcbn1cbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xuICAgIC8vIFdlIGFsbG93IG9taXNzaW9uIG9mICdwYXRoU3RyaW5nJyBidXQgZXhwbGljaXRseSBwcm9oaWJpdCBwYXNzaW5nIGluIGJvdGhcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhdGggPSBBdXRvSWQubmV3SWQoKTtcbiAgICB9XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdkb2MnLCAncGF0aCcsIHBhdGgpO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUkMSkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudCwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgcGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSA/IHBhcmVudC5jb252ZXJ0ZXIgOiBudWxsLCBuZXcgRG9jdW1lbnRLZXkoYWJzb2x1dGVQYXRoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHJlZmVyZW5jZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIHJlZkVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHxcbiAgICAgICAgbGVmdCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpICYmXG4gICAgICAgIChyaWdodCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBsZWZ0LnBhdGggPT09IHJpZ2h0LnBhdGggJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcXVlcmllcyBwb2ludCB0byB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBhcHBseVxuICogdGhlIHNhbWUgY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBxdWVyeUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeSAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiAobGVmdC5maXJlc3RvcmUgPT09IHJpZ2h0LmZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgcXVlcnlFcXVhbHMobGVmdC5fcXVlcnksIHJpZ2h0Ll9xdWVyeSkgJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHID0gJ0FzeW5jUXVldWUnO1xuY2xhc3MgQXN5bmNRdWV1ZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRhaWwgPSBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2YgcmV0cnlhYmxlIG9wZXJhdGlvbnMuIFJldHJ5YWJsZSBvcGVyYXRpb25zIGFyZSBydW4gaW4gb3JkZXIgYW5kXG4gICAgICAgIC8vIHJldHJpZWQgd2l0aCBiYWNrb2ZmLlxuICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcyA9IFtdO1xuICAgICAgICAvLyBJcyB0aGlzIEFzeW5jUXVldWUgYmVpbmcgc2h1dCBkb3duPyBPbmNlIGl0IGlzIHNldCB0byB0cnVlLCBpdCB3aWxsIG5vdFxuICAgICAgICAvLyBiZSBjaGFuZ2VkIGFnYWluLlxuICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IGZhbHNlO1xuICAgICAgICAvLyBPcGVyYXRpb25zIHNjaGVkdWxlZCB0byBiZSBxdWV1ZWQgaW4gdGhlIGZ1dHVyZS4gT3BlcmF0aW9ucyBhcmVcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgYXJlIHJ1biBvciBjYW5jZWxlZC5cbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoaWxlIHRoZXJlJ3MgYW4gb3V0c3RhbmRpbmcgQXN5bmNRdWV1ZSBvcGVyYXRpb24sIHVzZWQgZm9yXG4gICAgICAgIC8vIGFzc2VydGlvbiBzYW5pdHktY2hlY2tzLlxuICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLy8gRW5hYmxlZCBkdXJpbmcgc2h1dGRvd24gb24gU2FmYXJpIHRvIHByZXZlbnQgZnV0dXJlIGFjY2VzcyB0byBJbmRleGVkREIuXG4gICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IGZhbHNlO1xuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwID0gW107XG4gICAgICAgIC8vIEJhY2tvZmYgdGltZXIgdXNlZCB0byBzY2hlZHVsZSByZXRyaWVzIGZvciByZXRyeWFibGUgb3BlcmF0aW9uc1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMsIFwiYXN5bmNfcXVldWVfcmV0cnlcIiAvKiBUaW1lcklkLkFzeW5jUXVldWVSZXRyeSAqLyk7XG4gICAgICAgIC8vIFZpc2liaWxpdHkgaGFuZGxlciB0aGF0IHRyaWdnZXJzIGFuIGltbWVkaWF0ZSByZXRyeSBvZiBhbGwgcmV0cnlhYmxlXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIE1lYW50IHRvIHNwZWVkIHVwIHJlY292ZXJ5IHdoZW4gd2UgcmVnYWluIGZpbGUgc3lzdGVtIGFjY2Vzc1xuICAgICAgICAvLyBhZnRlciBwYWdlIGNvbWVzIGludG8gZm9yZWdyb3VuZC5cbiAgICAgICAgdGhpcy52aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5za2lwQmFja29mZigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgIH1cbiAgICBnZXQgaXNTaHV0dGluZ0Rvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NodXR0aW5nRG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cbiAgICAgKiB3ZSBpZ25vcmUgdGhlIFByb21pc2UgcmVzdWx0KS5cbiAgICAgKi9cbiAgICBlbnF1ZXVlQW5kRm9yZ2V0KG9wKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5lbnF1ZXVlKG9wKTtcbiAgICB9XG4gICAgZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQob3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLmVucXVldWVJbnRlcm5hbChvcCk7XG4gICAgfVxuICAgIGVudGVyUmVzdHJpY3RlZE1vZGUocHVyZ2VFeGlzdGluZ1Rhc2tzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IHB1cmdlRXhpc3RpbmdUYXNrcyB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnF1ZXVlKG9wKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93bikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIFByb21pc2UgdGhhdCB3ZSBjYW4gcmV0dXJuIHRvIHRoZSBjYWxsZWUuIFRoaXNcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIHJldHVybiBhIFwiaGFuZ2luZyBQcm9taXNlXCIgb25seSB0byB0aGUgY2FsbGVlIGFuZCBzdGlsbFxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBxdWV1ZSBldmVuIHdoZW4gdGhlIG9wZXJhdGlvbiBpcyBub3QgcnVuLlxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVJbnRlcm5hbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24gJiYgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHJlc29sdmUgJ3Rhc2snXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AoKS50aGVuKHRhc2sucmVzb2x2ZSwgdGFzay5yZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJvbWlzZTtcbiAgICAgICAgfSkudGhlbigoKSA9PiB0YXNrLnByb21pc2UpO1xuICAgIH1cbiAgICBlbnF1ZXVlUmV0cnlhYmxlKG9wKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5TmV4dE9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBuZXh0IG9wZXJhdGlvbiBmcm9tIHRoZSByZXRyeWFibGUgcXVldWUuIElmIHRoZSBvcGVyYXRpb24gZmFpbHMsXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJ5TmV4dE9wKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmV0cnlhYmxlT3BzWzBdKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHLCAnT3BlcmF0aW9uIGZhaWxlZCB3aXRoIHJldHJ5YWJsZSBlcnJvcjogJyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTsgLy8gRmFpbHVyZSB3aWxsIGJlIGhhbmRsZWQgYnkgQXN5bmNRdWV1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBvcGVyYXRpb25zLCB3ZSByZS1zY2hlZHVsZSBgcmV0cnlOZXh0T3AoKWAuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBpbml0aWFsIGF0dGVtcHQgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZXkgYXJlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGVucXVldWVkLiBJZiwgZm9yIGV4YW1wbGUsIGBvcDFgLCBgb3AyYCwgYG9wM2AgYXJlIGVucXVldWVkIGFuZCBgb3AxYFxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZW5xdWV1ZWQgY2FsbHMgdG8gYHJldHJ5TmV4dE9wKClgLiBgb3AzKClgIHdpbGwgdGhlbiBydW4gaW4gdGhlXG4gICAgICAgICAgICAvLyBjYWxsIHNjaGVkdWxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxuICAgICAgICAgICAgLy8gbmV3IGJhY2tvZmYgb24gZXZlcnkgY2FsbCwgdGhlcmUgaXMgb25seSBldmVyIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bigoKSA9PiB0aGlzLnJldHJ5TmV4dE9wKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWVJbnRlcm5hbChvcCkge1xuICAgICAgICBjb25zdCBuZXdUYWlsID0gdGhpcy50YWlsLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBvcCgpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHVyZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ0lOVEVSTkFMIFVOSEFORExFRCBFUlJPUjogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhpcy50YWlsIGJlY29tZXMgYSByZWplY3RlZCBQcm9taXNlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFsbCBmdXJ0aGVyIGF0dGVtcHRzIHRvIGNoYWluICh2aWEgLnRoZW4pIHdpbGwganVzdCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhaWwgPSBuZXdUYWlsO1xuICAgICAgICByZXR1cm4gbmV3VGFpbDtcbiAgICB9XG4gICAgZW5xdWV1ZUFmdGVyRGVsYXkodGltZXJJZCwgZGVsYXlNcywgb3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IgdGltZXJJZHMgdGhhdCBoYXZlIGJlZW4gb3ZlcnJpZGRlbi5cbiAgICAgICAgaWYgKHRoaXMudGltZXJJZHNUb1NraXAuaW5kZXhPZih0aW1lcklkKSA+IC0xKSB7XG4gICAgICAgICAgICBkZWxheU1zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBEZWxheWVkT3BlcmF0aW9uLmNyZWF0ZUFuZFNjaGVkdWxlKHRoaXMsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmVkT3AgPT4gdGhpcy5yZW1vdmVEZWxheWVkT3BlcmF0aW9uKHJlbW92ZWRPcCkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnB1c2goZGVsYXllZE9wKTtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcbiAgICB9XG4gICAgdmVyaWZ5Tm90RmFpbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5mYWlsdXJlKSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBxdWV1ZWQgdGFza3MgYXJlIGZpbmlzaGVkIGV4ZWN1dGluZy4gRGVsYXllZFxuICAgICAqIG9wZXJhdGlvbnMgYXJlIG5vdCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgZHJhaW4oKSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gS2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlIHRhaWwgaXMgbm8gbG9uZ2VyIGFkdmFuY2VkLFxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBubyBtb3JlIG5ldyBvcGVyYXRpb25zIHdlcmUgZW5xdWV1ZWQgYW5kIHRoYXQgYWxsXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cbiAgICAgICAgbGV0IGN1cnJlbnRUYWlsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50VGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUYWlsO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50VGFpbCAhPT0gdGhpcy50YWlsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBEZXRlcm1pbmUgaWYgYSBkZWxheWVkIG9wZXJhdGlvbiB3aXRoIGEgcGFydGljdWxhciBUaW1lcklkXG4gICAgICogZXhpc3RzLlxuICAgICAqL1xuICAgIGNvbnRhaW5zRGVsYXllZE9wZXJhdGlvbih0aW1lcklkKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wLnRpbWVySWQgPT09IHRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogUnVucyBzb21lIG9yIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMgZWFybHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFzdFRpbWVySWQgLSBEZWxheWVkIG9wZXJhdGlvbnMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGlzIFRpbWVySWRcbiAgICAgKiB3aWxsIGJlIGRyYWluZWQuIFBhc3MgVGltZXJJZC5BbGwgdG8gcnVuIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgb3BlcmF0aW9ucyBoYXZlIGJlZW4gcnVuLlxuICAgICAqL1xuICAgIHJ1bkFsbERlbGF5ZWRPcGVyYXRpb25zVW50aWwobGFzdFRpbWVySWQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUnVuIG9wcyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5J2QgcnVuIGlmIHRoZXkgcmFuIG5hdHVyYWxseS5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbiAgICAgICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS50YXJnZXRUaW1lTXMgLSBiLnRhcmdldFRpbWVNcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcC5za2lwRGVsYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWVySWQgIT09IFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogU2tpcCBhbGwgc3Vic2VxdWVudCBkZWxheXMgZm9yIGEgdGltZXIgaWQuXG4gICAgICovXG4gICAgc2tpcERlbGF5c0ZvclRpbWVySWQodGltZXJJZCkge1xuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwLnB1c2godGltZXJJZCk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgb25jZSBhIERlbGF5ZWRPcGVyYXRpb24gaXMgcnVuIG9yIGNhbmNlbGVkLiAqL1xuICAgIHJlbW92ZURlbGF5ZWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5pbmRleE9mKG9wKTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlcyAqL1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxuICogVGhpcyByZXR1cm5zIGV4cGVjdGVkIG91dHB1dCBvZiBtZXNzYWdlICsgc3RhY2sgd2hlbiBhdmFpbGFibGUuXG4gKiBAcGFyYW0gZXJyb3IgLSBFcnJvciBvciBGaXJlc3RvcmVFcnJvclxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcikge1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSArICdcXG4nICsgZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRhc2sgb2YgbG9hZGluZyBhIEZpcmVzdG9yZSBidW5kbGUuIEl0IHByb3ZpZGVzIHByb2dyZXNzIG9mIGJ1bmRsZVxuICogbG9hZGluZywgYXMgd2VsbCBhcyB0YXNrIGNvbXBsZXRpb24gYW5kIGVycm9yIGV2ZW50cy5cbiAqXG4gKiBUaGUgQVBJIGlzIGNvbXBhdGlibGUgd2l0aCBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmNsYXNzIExvYWRCdW5kbGVUYXNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHt9O1xuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICAgICAgdG90YWxCeXRlczogMCxcbiAgICAgICAgICAgIHRvdGFsRG9jdW1lbnRzOiAwLFxuICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXG4gICAgICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGZ1bmN0aW9ucyB0byBsaXN0ZW4gdG8gYnVuZGxlIGxvYWRpbmcgcHJvZ3Jlc3MgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBuZXh0IC0gQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBwcm9ncmVzcyB1cGRhdGUgZnJvbSBidW5kbGUgbG9hZGluZy4gVHlwaWNhbGx5IGBuZXh0YCBjYWxscyBvY2N1clxuICAgICAqICAgZWFjaCB0aW1lIGEgRmlyZXN0b3JlIGRvY3VtZW50IGlzIGxvYWRlZCBmcm9tIHRoZSBidW5kbGUuXG4gICAgICogQHBhcmFtIGVycm9yIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy4gVGhlIHRhc2sgYWJvcnRzIGFmdGVyIHJlcG9ydGluZyB0aGVcbiAgICAgKiAgIGVycm9yLCBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgdXBkYXRlcyBhZnRlciB0aGlzLlxuICAgICAqIEBwYXJhbSBjb21wbGV0ZSAtIENhbGxlZCB3aGVuIHRoZSBsb2FkaW5nIHRhc2sgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25Qcm9ncmVzcyhuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+LmNhdGNoYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuXG4gICAgICovXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5wcm9taXNlLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi50aGVuYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBDYWxsZWQgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxvYWRpbmcgdGFzayB3aXRoIGEgZmluYWwgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHVwZGF0ZS5cbiAgICAgKiAgIFRoZSB1cGRhdGUgd2lsbCBhbHdheXMgaGF2ZSBpdHMgYHRhc2tTdGF0ZWAgc2V0IHRvIGBcIlN1Y2Nlc3NcImAuXG4gICAgICogQHBhcmFtIG9uUmVqZWN0ZWQgLSBDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGJ1bmRsZSBsb2FkaW5nLlxuICAgICAqL1xuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIG9ic2VydmVycyB0aGF0IGJ1bmRsZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQsIHdpdGggYSBwcm92aWRlZFxuICAgICAqIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb21wbGV0ZVdpdGgocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVzb2x2ZShwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgZmFpbGVkLCB3aXRoIGEgcHJvdmlkZWRcbiAgICAgKiBgRXJyb3JgIGFzIHRoZSByZWFzb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mYWlsV2l0aChlcnJvcikge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MudGFza1N0YXRlID0gJ0Vycm9yJztcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYSBwcm9ncmVzcyB1cGRhdGUgb2YgbG9hZGluZyBhIGJ1bmRsZS5cbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBUaGUgbmV3IHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dChwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gaW5kaWNhdGUgdGhlIExSVSBnYXJiYWdlIGNvbGxlY3Rpb24gc2hvdWxkIGJlIGRpc2FibGVkLlxuICogU2V0IHRoaXMgdmFsdWUgYXMgdGhlIGBjYWNoZVNpemVCeXRlc2Agb24gdGhlIHNldHRpbmdzIHBhc3NlZCB0byB0aGVcbiAqIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxuICovXG5jb25zdCBDQUNIRV9TSVpFX1VOTElNSVRFRCA9IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEO1xuLyoqXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxuICpcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKi9cbmNsYXNzIEZpcmVzdG9yZSBleHRlbmRzIEZpcmVzdG9yZSQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIsIGRhdGFiYXNlSWQsIGFwcCkge1xuICAgICAgICBzdXBlcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEge0BsaW5rIEZpcmVzdG9yZX0gb3IgRmlyZXN0b3JlIExpdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlJztcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgQXN5bmNRdWV1ZUltcGwoKTtcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAoYXBwID09PSBudWxsIHx8IGFwcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwLm5hbWUpIHx8ICdbREVGQVVMVF0nO1xuICAgIH1cbiAgICBhc3luYyBfdGVybWluYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGUgPSB0aGlzLl9maXJlc3RvcmVDbGllbnQudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlSW1wbCh0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZXN0b3JlQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXdhaXQgdGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uLCBpbmNsdWRpbmdcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcbiAqIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gd2l0aCB3aGljaCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbFxuICogYmUgYXNzb2NpYXRlZC5cbiAqIEBwYXJhbSBzZXR0aW5ncyAtIEEgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVGaXJlc3RvcmUoYXBwLCBzZXR0aW5ncywgZGF0YWJhc2VJZCkge1xuICAgIGlmICghZGF0YWJhc2VJZCkge1xuICAgICAgICBkYXRhYmFzZUlkID0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZChkYXRhYmFzZUlkKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoZGF0YWJhc2VJZCk7XG4gICAgICAgIGlmIChkZWVwRXF1YWwoaW5pdGlhbFNldHRpbmdzLCBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ2luaXRpYWxpemVGaXJlc3RvcmUoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRGaXJlc3RvcmUoKSB0byByZXR1cm4gdGhlJyArXG4gICAgICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmxvY2FsQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGUgYW5kIGNhY2hlU2l6ZUJ5dGVzIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXQgdGhlIHNhbWUgdGltZSBhcyBjYWNoZVNpemVCeXRlcyB3aWxsYCArXG4gICAgICAgICAgICBgYmUgZGVwcmVjYXRlZC4gSW5zdGVhZCwgc3BlY2lmeSB0aGUgY2FjaGUgc2l6ZSBpbiB0aGUgY2FjaGUgb2JqZWN0YCk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBDQUNIRV9TSVpFX1VOTElNSVRFRCAmJlxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7XG4gICAgICAgIG9wdGlvbnM6IHNldHRpbmdzLFxuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpcmVzdG9yZShhcHBPckRhdGFiYXNlSWQsIG9wdGlvbmFsRGF0YWJhc2VJZCkge1xuICAgIGNvbnN0IGFwcCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdvYmplY3QnID8gYXBwT3JEYXRhYmFzZUlkIDogZ2V0QXBwKCk7XG4gICAgY29uc3QgZGF0YWJhc2VJZCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYXBwT3JEYXRhYmFzZUlkXG4gICAgICAgIDogb3B0aW9uYWxEYXRhYmFzZUlkIHx8IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKS5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBpZGVudGlmaWVyOiBkYXRhYmFzZUlkXG4gICAgfSk7XG4gICAgaWYgKCFkYi5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ2ZpcmVzdG9yZScpO1xuICAgICAgICBpZiAoZW11bGF0b3IpIHtcbiAgICAgICAgICAgIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKSB7XG4gICAgaWYgKGZpcmVzdG9yZS5fdGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQpIHtcbiAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XG4gICAgfVxuICAgIHJldHVybiBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudDtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcbiAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgKChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5hcHBJZCkgfHwgJycsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKTtcbiAgICBpZiAoIWZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgIGlmICgoKF9iID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpICYmXG4gICAgICAgICAgICAoKF9jID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIF9vZmZsaW5lOiBzZXR0aW5ncy5sb2NhbENhY2hlLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgX29ubGluZTogc2V0dGluZ3MubG9jYWxDYWNoZS5fb25saW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQgPSBuZXcgRmlyZXN0b3JlQ2xpZW50KGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX2FwcENoZWNrQ3JlZGVudGlhbHMsIGZpcmVzdG9yZS5fcXVldWUsIGRhdGFiYXNlSW5mbywgZmlyZXN0b3JlLl9jb21wb25lbnRzUHJvdmlkZXIgJiZcbiAgICAgICAgYnVpbGRDb21wb25lbnRQcm92aWRlcihmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlcikpO1xufVxuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRQcm92aWRlcihjb21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICBjb25zdCBvbmxpbmUgPSBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29ubGluZS5idWlsZCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9vZmZsaW5lOiBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUuYnVpbGQob25saW5lKSxcbiAgICAgICAgX29ubGluZTogb25saW5lXG4gICAgfTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uIFRoZXJlIGFyZSBzZXZlcmFsIHJlYXNvbnMgd2h5IHRoaXMgY2FuIGZhaWwsIHdoaWNoIGNhbiBiZVxuICogaWRlbnRpZmllZCBieSB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cbiAqXG4gKiAgICogZmFpbGVkLXByZWNvbmRpdGlvbjogVGhlIGFwcCBpcyBhbHJlYWR5IG9wZW4gaW4gYW5vdGhlciBicm93c2VyIHRhYi5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIE5vdGU6IGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uc1xuICogKG90aGVyIHRoYW4ge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0gb3JcbiAqIHtAbGluayBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlfS5cbiAqXG4gKiBQZXJzaXN0ZW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBlbmFibGUgcGVyc2lzdGVuY2UgZm9yLlxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXG4gKiBwZXJzaXN0ZW5jZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudCBzdG9yYWdlLlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xuICogdHVybiBvbiBJbmRleGVkRGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSwgcGVyc2lzdGVuY2VTZXR0aW5ncykge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKCkgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUsICcgK1xuICAgICAgICAneW91IGNhbiB1c2UgYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIsIHtcbiAgICAgICAgYnVpbGQ6IChvbmxpbmVDb21wb25lbnRzKSA9PiBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudHMsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCBwZXJzaXN0ZW5jZVNldHRpbmdzID09PSBudWxsIHx8IHBlcnNpc3RlbmNlU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcnNpc3RlbmNlU2V0dGluZ3MuZm9yY2VPd25lcnNoaXApXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgbXVsdGktdGFiIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuIElmIGVuYWJsZWRcbiAqIGFjcm9zcyBhbGwgdGFicywgYWxsIG9wZXJhdGlvbnMgc2hhcmUgYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLCBpbmNsdWRpbmdcbiAqIHNoYXJlZCBleGVjdXRpb24gb2YgcXVlcmllcyBhbmQgbGF0ZW5jeS1jb21wZW5zYXRlZCBsb2NhbCBkb2N1bWVudCB1cGRhdGVzXG4gKiBhY3Jvc3MgYWxsIGNvbm5lY3RlZCBpbnN0YW5jZXMuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgd2lsbCByZWplY3QgdGhlIHByb21pc2Ugb3JcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHkgdGhpcyBjYW4gZmFpbCwgd2hpY2ggY2FuIGJlXG4gKiBpZGVudGlmaWVkIGJ5IHRoZSBgY29kZWAgb24gdGhlIGVycm9yLlxuICpcbiAqICAgKiBmYWlsZWQtcHJlY29uZGl0aW9uOiBUaGUgYXBwIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGJyb3dzZXIgdGFiIGFuZFxuICogICAgIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZC5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudFxuICogc3RvcmFnZS5cbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIEluc3RlYWQsIHNldFxuICogYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgIHRvIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAgdG9cbiAqIHR1cm4gb24gaW5kZXhlZGRiIGNhY2hlLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2hlbiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWBcbiAqIGlzIGFscmVhZHkgc3BlY2lmaWVkIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSkge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZSwgJyArXG4gICAgICAgICd5b3UgY2FuIHVzZSBgRmlyZXN0b3JlU2V0dGluZ3MuY2FjaGVgIGluc3RlYWQuJyk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XG4gICAgc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoZmlyZXN0b3JlLCBPbmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlciwge1xuICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcylcbiAgICB9KTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGJvdGggdGhlIGBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJgIGFuZCBgT25saW5lQ29tcG9uZW50UHJvdmlkZXJgLlxuICogSWYgdGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGEgcmVjb3ZlcmFibGUgZXJyb3IgKHNlZVxuICogYGNhblJlY292ZXJGcm9tSW5kZXhlZERiRXJyb3IoKWAgYmVsb3cpLCB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZWplY3RlZFxuICogYnV0IHRoZSBjbGllbnQgcmVtYWlucyB1c2FibGUuXG4gKi9cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGlmIChmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudCB8fCBmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIHBlcnNpc3RlbmNlIGNhbiBubyBsb25nZXIgYmUgJyArXG4gICAgICAgICAgICAnZW5hYmxlZC4gWW91IGNhbiBvbmx5IGVuYWJsZSBwZXJzaXN0ZW5jZSBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXG4gICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmIChmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciB8fCBmaXJlc3RvcmUuX2dldFNldHRpbmdzKCkubG9jYWxDYWNoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnU0RLIGNhY2hlIGlzIGFscmVhZHkgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciA9IHtcbiAgICAgICAgX29ubGluZTogb25saW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgIF9vZmZsaW5lOiBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICB9O1xuICAgIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpO1xufVxuLyoqXG4gKiBDbGVhcnMgdGhlIHBlcnNpc3RlbnQgc3RvcmFnZS4gVGhpcyBpbmNsdWRlcyBwZW5kaW5nIHdyaXRlcyBhbmQgY2FjaGVkXG4gKiBkb2N1bWVudHMuXG4gKlxuICogTXVzdCBiZSBjYWxsZWQgd2hpbGUgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIGlzIG5vdCBzdGFydGVkIChhZnRlciB0aGUgYXBwIGlzXG4gKiB0ZXJtaW5hdGVkIG9yIHdoZW4gdGhlIGFwcCBpcyBmaXJzdCBpbml0aWFsaXplZCkuIE9uIHN0YXJ0dXAsIHRoaXMgZnVuY3Rpb25cbiAqIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBmdW5jdGlvbnMgKG90aGVyIHRoYW4ge0BsaW5rXG4gKiBpbml0aWFsaXplRmlyZXN0b3JlfSBvciB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0pKS4gSWYgdGhlIHtAbGluayBGaXJlc3RvcmV9XG4gKiBpbnN0YW5jZSBpcyBzdGlsbCBydW5uaW5nLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIGVycm9yIGNvZGVcbiAqIG9mIGBmYWlsZWQtcHJlY29uZGl0aW9uYC5cbiAqXG4gKiBOb3RlOiBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgdG8gaGVscCB3cml0ZVxuICogcmVsaWFibGUgdGVzdHMgdGhhdCB1c2UgQ2xvdWQgRmlyZXN0b3JlLiBJdCB1c2VzIGFuIGVmZmljaWVudCBtZWNoYW5pc20gZm9yXG4gKiBkcm9wcGluZyBleGlzdGluZyBkYXRhIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHNlY3VyZWx5IG92ZXJ3cml0ZSBvclxuICogb3RoZXJ3aXNlIG1ha2UgY2FjaGVkIGRhdGEgdW5yZWNvdmVyYWJsZS4gRm9yIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBzZW5zaXRpdmVcbiAqIHRvIHRoZSBkaXNjbG9zdXJlIG9mIGNhY2hlZCBkYXRhIGluIGJldHdlZW4gdXNlciBzZXNzaW9ucywgd2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCBub3QgZW5hYmxpbmcgcGVyc2lzdGVuY2UgYXQgYWxsLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gY2xlYXIgcGVyc2lzdGVuY2UgZm9yLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UgaXNcbiAqIGNsZWFyZWQuIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCAmJiAhZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdQZXJzaXN0ZW5jZSBjYW4gb25seSBiZSBjbGVhcmVkIGJlZm9yZSBhIEZpcmVzdG9yZSBpbnN0YW5jZSBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBvciBhZnRlciBpdCBpcyB0ZXJtaW5hdGVkLicpO1xuICAgIH1cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGZpcmVzdG9yZS5fcXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5kZXhlZERiQ2xlYXJQZXJzaXN0ZW5jZShpbmRleGVkRGJTdG9yYWdlUHJlZml4KGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbi8qKlxuICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBmb3IgdGhlIGFjdGl2ZSB1c2VyIGhhdmUgYmVlblxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyB3cml0ZXMuXG4gKiBPdGhlcndpc2UsIHRoZSBwcm9taXNlIHdhaXRzIGZvciBhbGwgcHJldmlvdXNseSBpc3N1ZWQgd3JpdGVzIChpbmNsdWRpbmdcbiAqIHRob3NlIHdyaXR0ZW4gaW4gYSBwcmV2aW91cyBhcHAgc2Vzc2lvbiksIGJ1dCBpdCBkb2VzIG5vdCB3YWl0IGZvciB3cml0ZXNcbiAqIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvclxuICogYWRkaXRpb25hbCB3cml0ZXMsIGNhbGwgYHdhaXRGb3JQZW5kaW5nV3JpdGVzKClgIGFnYWluLlxuICpcbiAqIEFueSBvdXRzdGFuZGluZyBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgcHJvbWlzZXMgYXJlIHJlamVjdGVkIGR1cmluZyB1c2VyXG4gKiBjaGFuZ2VzLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHdoZW4gYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBoYXZlIGJlZW5cbiAqIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZC5cbiAqL1xuZnVuY3Rpb24gd2FpdEZvclBlbmRpbmdXcml0ZXMoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpO1xufVxuLyoqXG4gKiBSZS1lbmFibGVzIHVzZSBvZiB0aGUgbmV0d29yayBmb3IgdGhpcyB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBhZnRlciBhIHByaW9yXG4gKiBjYWxsIHRvIHtAbGluayBkaXNhYmxlTmV0d29ya30uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGVuYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRFbmFibGVOZXR3b3JrKGNsaWVudCk7XG59XG4vKipcbiAqIERpc2FibGVzIG5ldHdvcmsgdXNhZ2UgZm9yIHRoaXMgaW5zdGFuY2UuIEl0IGNhbiBiZSByZS1lbmFibGVkIHZpYSB7QGxpbmtcbiAqIGVuYWJsZU5ldHdvcmt9LiBXaGlsZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCwgYW55IHNuYXBzaG90IGxpc3RlbmVycyxcbiAqIGBnZXREb2MoKWAgb3IgYGdldERvY3MoKWAgY2FsbHMgd2lsbCByZXR1cm4gcmVzdWx0cyBmcm9tIGNhY2hlLCBhbmQgYW55IHdyaXRlXG4gKiBvcGVyYXRpb25zIHdpbGwgYmUgcXVldWVkIHVudGlsIHRoZSBuZXR3b3JrIGlzIHJlc3RvcmVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpO1xufVxuLyoqXG4gKiBUZXJtaW5hdGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgb25seSB0aGUgYGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgZnVuY3Rpb25cbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuXG4gKlxuICogVG8gcmVzdGFydCBhZnRlciB0ZXJtaW5hdGlvbiwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEZpcmViYXNlRmlyZXN0b3JlIHdpdGhcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cbiAqXG4gKiBUZXJtaW5hdGlvbiBkb2VzIG5vdCBjYW5jZWwgYW55IHBlbmRpbmcgd3JpdGVzLCBhbmQgYW55IHByb21pc2VzIHRoYXQgYXJlXG4gKiBhd2FpdGluZyBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3aWxsIG5vdCBiZSByZXNvbHZlZC4gSWYgeW91IGhhdmVcbiAqIHBlcnNpc3RlbmNlIGVuYWJsZWQsIHRoZSBuZXh0IHRpbWUgeW91IHN0YXJ0IHRoaXMgaW5zdGFuY2UsIGl0IHdpbGwgcmVzdW1lXG4gKiBzZW5kaW5nIHRoZXNlIHdyaXRlcyB0byB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgaXMgbm90IHJlcXVpcmVkLiBUaGlzXG4gKiBmdW5jdGlvbiBpcyB1c2VmdWwgb25seSB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIHRoaXMgaW5zdGFuY2UgdG8gcmVsZWFzZSBhbGxcbiAqIG9mIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB0b1xuICogZW5zdXJlIHRoYXQgYWxsIGxvY2FsIHN0YXRlIGlzIGRlc3Ryb3llZCBiZXR3ZWVuIHRlc3QgcnVucy5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluc3RhbmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogdGVybWluYXRlZC5cbiAqL1xuZnVuY3Rpb24gdGVybWluYXRlKGZpcmVzdG9yZSkge1xuICAgIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoZmlyZXN0b3JlLmFwcCwgJ2ZpcmVzdG9yZScsIGZpcmVzdG9yZS5fZGF0YWJhc2VJZC5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZS5fZGVsZXRlKCk7XG59XG4vKipcbiAqIExvYWRzIGEgRmlyZXN0b3JlIGJ1bmRsZSBpbnRvIHRoZSBsb2NhbCBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGxvYWQgYnVuZGxlcyBmb3IuXG4gKiBAcGFyYW0gYnVuZGxlRGF0YSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1bmRsZSB0byBiZSBsb2FkZWQuIFZhbGlkXG4gKiBvYmplY3RzIGFyZSBgQXJyYXlCdWZmZXJgLCBgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5gIG9yIGBzdHJpbmdgLlxuICpcbiAqIEByZXR1cm5zIEEgYExvYWRCdW5kbGVUYXNrYCBvYmplY3QsIHdoaWNoIG5vdGlmaWVzIGNhbGxlcnMgd2l0aCBwcm9ncmVzc1xuICogdXBkYXRlcywgYW5kIGNvbXBsZXRpb24gb3IgZXJyb3IgZXZlbnRzLiBJdCBjYW4gYmUgdXNlZCBhcyBhXG4gKiBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmZ1bmN0aW9uIGxvYWRCdW5kbGUoZmlyZXN0b3JlLCBidW5kbGVEYXRhKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHJlc3VsdFRhc2sgPSBuZXcgTG9hZEJ1bmRsZVRhc2soKTtcbiAgICBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBidW5kbGVEYXRhLCByZXN1bHRUYXNrKTtcbiAgICByZXR1cm4gcmVzdWx0VGFzaztcbn1cbi8qKlxuICogUmVhZHMgYSBGaXJlc3RvcmUge0BsaW5rIFF1ZXJ5fSBmcm9tIGxvY2FsIGNhY2hlLCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlblxuICogbmFtZS5cbiAqXG4gKiBUaGUgbmFtZWQgcXVlcmllcyBhcmUgcGFja2FnZWQgIGludG8gYnVuZGxlcyBvbiB0aGUgc2VydmVyIHNpZGUgKGFsb25nXG4gKiB3aXRoIHJlc3VsdGluZyBkb2N1bWVudHMpLCBhbmQgbG9hZGVkIHRvIGxvY2FsIGNhY2hlIHVzaW5nIGBsb2FkQnVuZGxlYC4gT25jZVxuICogaW4gbG9jYWwgY2FjaGUsIHVzZSB0aGlzIG1ldGhvZCB0byBleHRyYWN0IGEge0BsaW5rIFF1ZXJ5fSBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gcmVhZCB0aGUgcXVlcnkgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSBRdWVyeSBvciBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIG5hbWVkUXVlcnkoZmlyZXN0b3JlLCBuYW1lKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXROYW1lZFF1ZXJ5KGNsaWVudCwgbmFtZSkudGhlbihuYW1lZFF1ZXJ5ID0+IHtcbiAgICAgICAgaWYgKCFuYW1lZFF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgbnVsbCwgbmFtZWRRdWVyeS5xdWVyeSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckZpcmVzdG9yZSh2YXJpYW50LCB1c2VGZXRjaFN0cmVhbXMgPSB0cnVlKSB7XG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnZmlyZXN0b3JlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWQsIG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlSW5zdGFuY2UgPSBuZXcgRmlyZXN0b3JlKG5ldyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGFwcCwgY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKSksIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2VJZCksIGFwcCk7XG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7IHVzZUZldGNoU3RyZWFtcyB9LCBzZXR0aW5ncyk7XG4gICAgICAgIGZpcmVzdG9yZUluc3RhbmNlLl9zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiBmaXJlc3RvcmVJbnN0YW5jZTtcbiAgICB9LCAnUFVCTElDJykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFnZ3JlZ2F0ZSB0eXBlLlxuICovXG5jbGFzcyBBZ2dyZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhbGlhcywgYWdncmVnYXRlVHlwZSwgZmllbGRQYXRoKSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFnZ3JlZ2F0aW9uIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBieSBGaXJlc3RvcmUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmNsYXNzIEFnZ3JlZ2F0ZUZpZWxkIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQWdncmVnYXRlRmllbGQ8VD5cbiAgICAgKiBAcGFyYW0gYWdncmVnYXRlVHlwZSBTcGVjaWZpZXMgdGhlIHR5cGUgb2YgYWdncmVnYXRpb24gb3BlcmF0aW9uIHRvIHBlcmZvcm0uXG4gICAgICogQHBhcmFtIF9pbnRlcm5hbEZpZWxkUGF0aCBPcHRpb25hbGx5IHNwZWNpZmllcyB0aGUgZmllbGQgdGhhdCBpcyBhZ2dyZWdhdGVkLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFnZ3JlZ2F0ZVR5cGUgPSAnY291bnQnLCBfaW50ZXJuYWxGaWVsZFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxGaWVsZFBhdGggPSBfaW50ZXJuYWxGaWVsZFBhdGg7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlRmllbGQnO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZVR5cGUgPSBhZ2dyZWdhdGVUeXBlO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHJlc3VsdHMgb2YgZXhlY3V0aW5nIGFuIGFnZ3JlZ2F0aW9uIHF1ZXJ5LlxuICovXG5jbGFzcyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90IHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBfdXNlckRhdGFXcml0ZXIsIF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlUXVlcnlTbmFwc2hvdCc7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcXVlcnkuXG4gICAgICpcbiAgICAgKiBUaGUga2V5cyBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXG4gICAgICogYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCBzcGVjaWZpZWQgdG8gdGhlIGFnZ3JlZ2F0aW9uIG1ldGhvZCwgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiB3aWxsIGJlIHRoZSBjb3JyZXNwb25kaW5nIGFnZ3JlZ2F0aW9uIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbnMgcGVyZm9ybWVkIG92ZXIgdGhlIHVuZGVybHlpbmdcbiAgICAgKiBxdWVyeS5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydE9iamVjdE1hcCh0aGlzLl9kYXRhKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIGJ5dGVzLlxuICovXG5jbGFzcyBCeXRlcyB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihieXRlU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2J5dGVTdHJpbmcgPSBieXRlU3RyaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmcsIGNvbnZlcnRpbmcgaXQgdG9cbiAgICAgKiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNlNjQgLSBUaGUgQmFzZTY0IHN0cmluZyB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgZGF0YSBmcm9tIEJhc2U2NCBzdHJpbmc6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIFVpbnQ4QXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgVWludDhBcnJheSB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheShhcnJheSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b0Jhc2U2NCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGluIGEgbmV3IGBVaW50OEFycmF5YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVaW50OEFycmF5IGNyZWF0ZWQgZnJvbSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgdG9VaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b1VpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnQnl0ZXMoYmFzZTY0OiAnICsgdGhpcy50b0Jhc2U2NCgpICsgJyknO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgQnl0ZXNgIG9iamVjdCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBCeXRlc2Agb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLmlzRXF1YWwob3RoZXIuX2J5dGVTdHJpbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRmllbGRQYXRoYCByZWZlcnMgdG8gYSBmaWVsZCBpbiBhIGRvY3VtZW50LiBUaGUgcGF0aCBtYXkgY29uc2lzdCBvZiBhXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcbiAqIGxpc3Qgb2YgZmllbGQgbmFtZXMgKHJlZmVycmluZyB0byBhIG5lc3RlZCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLlxuICpcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxuICogbmFtZSBpcyBwcm92aWRlZCwgdGhlIHBhdGggd2lsbCBwb2ludCB0byBhIG5lc3RlZCBmaWVsZCBpbiBhIGRvY3VtZW50LlxuICovXG5jbGFzcyBGaWVsZFBhdGgge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgRmllbGRQYXRoYCBmcm9tIHRoZSBwcm92aWRlZCBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxuICAgICAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWVzIC0gQSBsaXN0IG9mIGZpZWxkIG5hbWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmZpZWxkTmFtZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBuYW1lIGF0IGFyZ3VtZW50ICQoaSArIDEpLiBgICtcbiAgICAgICAgICAgICAgICAgICAgJ0ZpZWxkIG5hbWVzIG11c3Qgbm90IGJlIGVtcHR5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsUGF0aCA9IG5ldyBGaWVsZFBhdGgkMShmaWVsZE5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEZpZWxkUGF0aGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgRmllbGRQYXRoYCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxQYXRoLmlzRXF1YWwob3RoZXIuX2ludGVybmFsUGF0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCBzZW50aW5lbCBgRmllbGRQYXRoYCB0byByZWZlciB0byB0aGUgSUQgb2YgYSBkb2N1bWVudC5cbiAqIEl0IGNhbiBiZSB1c2VkIGluIHF1ZXJpZXMgdG8gc29ydCBvciBmaWx0ZXIgYnkgdGhlIGRvY3VtZW50IElELlxuICovXG5mdW5jdGlvbiBkb2N1bWVudElkKCkge1xuICAgIHJldHVybiBuZXcgRmllbGRQYXRoKERPQ1VNRU5UX0tFWV9OQU1FKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2VudGluZWwgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiB3cml0aW5nIGRvY3VtZW50IGZpZWxkcyB3aXRoIGBzZXQoKWBcbiAqIG9yIGB1cGRhdGUoKWAuXG4gKi9cbmNsYXNzIEZpZWxkVmFsdWUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWMgQVBJIGVuZHBvaW50IHRoYXQgcmV0dXJucyB0aGlzIGNsYXNzLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbWV0aG9kTmFtZSkge1xuICAgICAgICB0aGlzLl9tZXRob2ROYW1lID0gX21ldGhvZE5hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWMgbG9jYXRpb24gaW4gRmlyZXN0b3JlLiBUaGVcbiAqIGxvY2F0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGxhdGl0dWRlL2xvbmdpdHVkZSBwYWlyLlxuICpcbiAqIExhdGl0dWRlIHZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIG9mIFstOTAsIDkwXS5cbiAqIExvbmdpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTE4MCwgMTgwXS5cbiAqL1xuY2xhc3MgR2VvUG9pbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIGBHZW9Qb2ludGAgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGxhdGl0dWRlIGFuZFxuICAgICAqIGxvbmdpdHVkZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIGFzIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAuXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsYXRpdHVkZSkgfHwgbGF0aXR1ZGUgPCAtOTAgfHwgbGF0aXR1ZGUgPiA5MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0xhdGl0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLCBidXQgd2FzOiAnICsgbGF0aXR1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5pdGUobG9uZ2l0dWRlKSB8fCBsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0xvbmdpdHVkZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLCBidXQgd2FzOiAnICsgbG9uZ2l0dWRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXQgPSBsYXRpdHVkZTtcbiAgICAgICAgdGhpcy5fbG9uZyA9IGxvbmdpdHVkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxhdGl0dWRlIG9mIHRoaXMgYEdlb1BvaW50YCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgbGF0aXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBsb25naXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEdlb1BvaW50YCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBHZW9Qb2ludGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXQgPT09IG90aGVyLl9sYXQgJiYgdGhpcy5fbG9uZyA9PT0gb3RoZXIuX2xvbmc7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBHZW9Qb2ludC4gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiB0aGlzLl9sYXQsIGxvbmdpdHVkZTogdGhpcy5fbG9uZyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBwcml2YXRlIHRvIEpTIGNvbnN1bWVycyBvZiBvdXIgQVBJLCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHByZWZpeGVkXG4gICAgICogd2l0aCBhbiB1bmRlcnNjb3JlLlxuICAgICAqL1xuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xhdCwgb3RoZXIuX2xhdCkgfHxcbiAgICAgICAgICAgIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5fbG9uZywgb3RoZXIuX2xvbmcpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSB2ZWN0b3IgdHlwZSBpbiBGaXJlc3RvcmUgZG9jdW1lbnRzLlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIHdpdGgge0BsaW5rIEZpZWxkVmFsdWUudmVjdG9yfS5cbiAqXG4gKiBAY2xhc3MgVmVjdG9yVmFsdWVcbiAqL1xuY2xhc3MgVmVjdG9yVmFsdWUge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIC8vIE1ha2luZyBhIGNvcHkgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gKHZhbHVlcyB8fCBbXSkubWFwKG4gPT4gbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSByYXcgbnVtYmVyIGFycmF5IGZvcm0gb2YgdGhlIHZlY3Rvci5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLm1hcChuID0+IG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIFZlY3RvclZhbHVlIGhhcyB0aGUgc2FtZSByYXcgbnVtYmVyIGFycmF5cywgcmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBpc1ByaW1pdGl2ZUFycmF5RXF1YWwodGhpcy5fdmFsdWVzLCBvdGhlci5fdmFsdWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBSRVNFUlZFRF9GSUVMRF9SRUdFWCA9IC9eX18uKl9fJC87XG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGRvY3VtZW50IGRhdGEgKGUuZy4gZm9yIGEgc2V0RGF0YSBjYWxsKS4gKi9cbmNsYXNzIFBhcnNlZFNldERhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5maWVsZE1hc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIFwidXBkYXRlXCIgZGF0YSAoaS5lLiBmb3IgYW4gdXBkYXRlRGF0YSBjYWxsKS4gKi9cbmNsYXNzIFBhcnNlZFVwZGF0ZURhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIFxuICAgIC8vIFRoZSBmaWVsZE1hc2sgZG9lcyBub3QgaW5jbHVkZSBkb2N1bWVudCB0cmFuc2Zvcm1zLlxuICAgIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dyaXRlKGRhdGFTb3VyY2UpIHtcbiAgICBzd2l0Y2ggKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgY2FzZSAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLzogLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgMiAvKiBVc2VyRGF0YVNvdXJjZS5NZXJnZVNldCAqLzogLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovOlxuICAgICAgICBjYXNlIDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG59XG4vKiogQSBcImNvbnRleHRcIiBvYmplY3QgcGFzc2VkIGFyb3VuZCB3aGlsZSBwYXJzaW5nIHVzZXIgZGF0YS4gKi9cbmNsYXNzIFBhcnNlQ29udGV4dEltcGwge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgUGFyc2VDb250ZXh0IHdpdGggdGhlIGdpdmVuIHNvdXJjZSBhbmQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIFRoZSBzZXR0aW5ncyBmb3IgdGhlIHBhcnNlci5cbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSBJRCBvZiB0aGUgRmlyZXN0b3JlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBWYWx1ZSBwcm90by5cbiAgICAgKiBAcGFyYW0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAtIFdoZXRoZXIgdG8gaWdub3JlIHVuZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICogcmF0aGVyIHRoYW4gdGhyb3cuXG4gICAgICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHRyYW5zZm9ybXMgZW5jb3VudGVyZWRcbiAgICAgKiB3aGlsZSBwYXJzaW5nIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBmaWVsZE1hc2sgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCBwYXRocyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXG4gICAgICogdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdywgc28gcGF0aCBjYW4gYmVcbiAgICAgKiBudWxsIHRvIGluZGljYXRlIHRoZSBjb250ZXh0IHJlcHJlc2VudHMgYW55IGxvY2F0aW9uIHdpdGhpbiBhbiBhcnJheSAoaW5cbiAgICAgKiB3aGljaCBjYXNlIGNlcnRhaW4gZmVhdHVyZXMgd2lsbCBub3Qgd29yayBhbmQgZXJyb3JzIHdpbGwgYmUgc29tZXdoYXRcbiAgICAgKiBjb21wcm9taXNlZCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIGRhdGFiYXNlSWQsIHNlcmlhbGl6ZXIsIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIGZpZWxkVHJhbnNmb3JtcywgZmllbGRNYXNrKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgLy8gTWlub3IgaGFjazogSWYgZmllbGRUcmFuc2Zvcm1zIGlzIHVuZGVmaW5lZCwgd2UgYXNzdW1lIHRoaXMgaXMgYW5cbiAgICAgICAgLy8gZXh0ZXJuYWwgY2FsbCBhbmQgd2UgbmVlZCB0byB2YWxpZGF0ZSB0aGUgZW50aXJlIHBhdGguXG4gICAgICAgIGlmIChmaWVsZFRyYW5zZm9ybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2sgfHwgW107XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5wYXRoO1xuICAgIH1cbiAgICBnZXQgZGF0YVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZGF0YVNvdXJjZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgY29udGV4dCB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3Mgb3ZlcndyaXR0ZW4uICovXG4gICAgY29udGV4dFdpdGgoY29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNldHRpbmdzKSwgY29uZmlndXJhdGlvbiksIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIHRoaXMuZmllbGRUcmFuc2Zvcm1zLCB0aGlzLmZpZWxkTWFzayk7XG4gICAgfVxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcbiAgICAgICAgY29udGV4dC52YWxpZGF0ZVBhdGhTZWdtZW50KGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChmaWVsZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiBjaGlsZFBhdGgsIGFycmF5RWxlbWVudDogZmFsc2UgfSk7XG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoKCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBjaGlsZENvbnRleHRGb3JBcnJheShpbmRleCkge1xuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdzsgc28gbWFrZSBwYXRoXG4gICAgICAgIC8vIHVuZGVmaW5lZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiB1bmRlZmluZWQsIGFycmF5RWxlbWVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY3JlYXRlRXJyb3IocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvcihyZWFzb24sIHRoaXMuc2V0dGluZ3MubWV0aG9kTmFtZSwgdGhpcy5zZXR0aW5ncy5oYXNDb252ZXJ0ZXIgfHwgZmFsc2UsIHRoaXMucGF0aCwgdGhpcy5zZXR0aW5ncy50YXJnZXREb2MpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyAndHJ1ZScgaWYgJ2ZpZWxkUGF0aCcgd2FzIHRyYXZlcnNlZCB3aGVuIGNyZWF0aW5nIHRoaXMgY29udGV4dC4gKi9cbiAgICBjb250YWlucyhmaWVsZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZpZWxkTWFzay5maW5kKGZpZWxkID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKGZpZWxkKSkgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMuZmluZCh0cmFuc2Zvcm0gPT4gZmllbGRQYXRoLmlzUHJlZml4T2YodHJhbnNmb3JtLmZpZWxkKSkgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlUGF0aCgpIHtcbiAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogUmVtb3ZlIG51bGwgY2hlY2sgb25jZSB3ZSBoYXZlIHByb3BlciBwYXRocyBmb3IgZmllbGRzXG4gICAgICAgIC8vIHdpdGhpbiBhcnJheXMuXG4gICAgICAgIGlmICghdGhpcy5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXRoU2VnbWVudCh0aGlzLnBhdGguZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZVBhdGhTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKCdEb2N1bWVudCBmaWVsZHMgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNXcml0ZSh0aGlzLmRhdGFTb3VyY2UpICYmIFJFU0VSVkVEX0ZJRUxEX1JFR0VYLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBjYW5ub3QgYmVnaW4gYW5kIGVuZCB3aXRoIFwiX19cIicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgZm9yIHBhcnNpbmcgcmF3IHVzZXIgaW5wdXQgKHByb3ZpZGVkIHZpYSB0aGUgQVBJKSBpbnRvIGludGVybmFsIG1vZGVsXG4gKiBjbGFzc2VzLlxuICovXG5jbGFzcyBVc2VyRGF0YVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRvcC1sZXZlbCBwYXJzZSBjb250ZXh0LiAqL1xuICAgIGNyZWF0ZUNvbnRleHQoZGF0YVNvdXJjZSwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoe1xuICAgICAgICAgICAgZGF0YVNvdXJjZSxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICB0YXJnZXREb2MsXG4gICAgICAgICAgICBwYXRoOiBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKSxcbiAgICAgICAgICAgIGFycmF5RWxlbWVudDogZmFsc2UsXG4gICAgICAgICAgICBoYXNDb252ZXJ0ZXJcbiAgICAgICAgfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcbiAgICByZXR1cm4gbmV3IFVzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgISFzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKTtcbn1cbi8qKiBQYXJzZSBkb2N1bWVudCBkYXRhIGZyb20gYSBzZXQoKSBjYWxsLiAqL1xuZnVuY3Rpb24gcGFyc2VTZXREYXRhKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGlucHV0LCBoYXNDb252ZXJ0ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkc1xuICAgICAgICA/IDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi9cbiAgICAgICAgOiAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIpO1xuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBwYXJzZU9iamVjdChpbnB1dCwgY29udGV4dCk7XG4gICAgbGV0IGZpZWxkTWFzaztcbiAgICBsZXQgZmllbGRUcmFuc2Zvcm1zO1xuICAgIGlmIChvcHRpb25zLm1lcmdlKSB7XG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2soY29udGV4dC5maWVsZE1hc2spO1xuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tZXJnZUZpZWxkcykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGaWVsZFBhdGhzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3RyaW5nT3JGaWVsZFBhdGggb2Ygb3B0aW9ucy5tZXJnZUZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgc3RyaW5nT3JGaWVsZFBhdGgsIHRhcmdldERvYyk7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuY29udGFpbnMoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGaWVsZCAnJHtmaWVsZFBhdGh9JyBpcyBzcGVjaWZpZWQgaW4geW91ciBmaWVsZCBtYXNrIGJ1dCBtaXNzaW5nIGZyb20geW91ciBpbnB1dCBkYXRhLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyh2YWxpZGF0ZWRGaWVsZFBhdGhzLCBmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkRmllbGRQYXRocy5wdXNoKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRNYXNrID0gbmV3IEZpZWxkTWFzayh2YWxpZGF0ZWRGaWVsZFBhdGhzKTtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybSA9PiBmaWVsZE1hc2suY292ZXJzKHRyYW5zZm9ybS5maWVsZCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmllbGRNYXNrID0gbnVsbDtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGFyc2VkU2V0RGF0YShuZXcgT2JqZWN0VmFsdWUodXBkYXRlRGF0YSksIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKTtcbn1cbmNsYXNzIERlbGV0ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovKSB7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2Zvcm0gdG8gYWRkIGZvciBhIGRlbGV0ZSwgYnV0IHdlIG5lZWQgdG8gYWRkIGl0IHRvIG91clxuICAgICAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovKSB7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwgYCArXG4gICAgICAgICAgICAgICAgJ29mIHlvdXIgdXBkYXRlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBlbmNvdW50ZXIgZGVsZXRlIHNlbnRpbmVscyBmb3IgcXVlcmllcyBvciBub24tbWVyZ2Ugc2V0KCkgY2FsbHMuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2Fubm90IGJlIHVzZWQgd2l0aCBzZXQoKSB1bmxlc3MgeW91IHBhc3MgYCArXG4gICAgICAgICAgICAgICAgJ3ttZXJnZTp0cnVlfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNoaWxkIGNvbnRleHQgZm9yIHBhcnNpbmcgU2VyaWFsaXphYmxlRmllbGRWYWx1ZXMuXG4gKlxuICogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjYWxsaW5nIGBQYXJzZUNvbnRleHQuY29udGV4dFdpdGhgIGJlY2F1c2UgaXQga2VlcHNcbiAqIHRoZSBmaWVsZFRyYW5zZm9ybXMgYW5kIGZpZWxkTWFzayBzZXBhcmF0ZS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBjb250ZXh0IGhhcyBpdHMgYGRhdGFTb3VyY2VgIHNldCB0byBgVXNlckRhdGFTb3VyY2UuQXJndW1lbnRgLlxuICogQWx0aG91Z2ggdGhlc2UgdmFsdWVzIGFyZSB1c2VkIHdpdGggd3JpdGVzLCBhbnkgZWxlbWVudHMgaW4gdGhlc2UgRmllbGRWYWx1ZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCB3cml0ZXMgc2luY2UgdGhleSBjYW5ub3QgY29udGFpbiBhbnkgRmllbGRWYWx1ZSBzZW50aW5lbHMsXG4gKiBldGMuXG4gKlxuICogQHBhcmFtIGZpZWxkVmFsdWUgLSBUaGUgc2VudGluZWwgRmllbGRWYWx1ZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgY2hpbGRcbiAqICAgICBjb250ZXh0LlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgcGFyZW50IGNvbnRleHQuXG4gKiBAcGFyYW0gYXJyYXlFbGVtZW50IC0gV2hldGhlciBvciBub3QgdGhlIEZpZWxkVmFsdWUgaGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dChmaWVsZFZhbHVlLCBjb250ZXh0LCBhcnJheUVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoe1xuICAgICAgICBkYXRhU291cmNlOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLFxuICAgICAgICB0YXJnZXREb2M6IGNvbnRleHQuc2V0dGluZ3MudGFyZ2V0RG9jLFxuICAgICAgICBtZXRob2ROYW1lOiBmaWVsZFZhbHVlLl9tZXRob2ROYW1lLFxuICAgICAgICBhcnJheUVsZW1lbnRcbiAgICB9LCBjb250ZXh0LmRhdGFiYXNlSWQsIGNvbnRleHQuc2VyaWFsaXplciwgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcbn1cbmNsYXNzIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGNvbnRleHQucGF0aCwgbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbDtcbiAgICB9XG59XG5jbGFzcyBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX2VsZW1lbnRzO1xuICAgIH1cbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlQ29udGV4dCA9IGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KHRoaXMsIGNvbnRleHQsIFxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlVbmlvbiA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbCh0aGlzLl9lbGVtZW50cywgb3RoZXIuX2VsZW1lbnRzKSk7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9lbGVtZW50cykge1xuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXG4gICAgICAgIC8qYXJyYXk9Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xuICAgIH1cbn1cbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9vcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9vcGVyYW5kID0gX29wZXJhbmQ7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbnVtZXJpY0luY3JlbWVudCA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKGNvbnRleHQuc2VyaWFsaXplciwgdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB0aGlzLl9vcGVyYW5kKSk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBudW1lcmljSW5jcmVtZW50KTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudEZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICB0aGlzLl9vcGVyYW5kID09PSBvdGhlci5fb3BlcmFuZCk7XG4gICAgfVxufVxuLyoqIFBhcnNlIHVwZGF0ZSBkYXRhIGZyb20gYW4gdXBkYXRlKCkgY2FsbC4gKi9cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlRGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgZm9yRWFjaChpbnB1dCwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwga2V5LCB0YXJnZXREb2MpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcbn1cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGEgbGlzdCBvZiBmaWVsZC92YWx1ZSBhcmd1bWVudHMuICovXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVZhcmFyZ3ModXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgZmllbGQsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XG4gICAgY29uc3Qga2V5cyA9IFtmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBmaWVsZCwgdGFyZ2V0RG9jKV07XG4gICAgY29uc3QgdmFsdWVzID0gW3ZhbHVlXTtcbiAgICBpZiAobW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke21ldGhvZE5hbWV9KCkgbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggYW4gZXZlbiBudW1iZXIgYCArXG4gICAgICAgICAgICAnb2YgYXJndW1lbnRzIHRoYXQgYWx0ZXJuYXRlIGJldHdlZW4gZmllbGQgbmFtZXMgYW5kIHZhbHVlcy4nKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3JlRmllbGRzQW5kVmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGtleXMucHVzaChmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBtb3JlRmllbGRzQW5kVmFsdWVzW2ldKSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKG1vcmVGaWVsZHNBbmRWYWx1ZXNbaSArIDFdKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRNYXNrUGF0aHMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgdG8gcGljayB0aGUgbGFzdCB2YWx1ZSBmb3IgYSBmaWVsZCBpZiB0aGVcbiAgICAvLyB1c2VyIHNwZWNpZmllZCB0aGUgZmllbGQgbXVsdGlwbGUgdGltZXMuXG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyhmaWVsZE1hc2tQYXRocywga2V5c1tpXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBrZXlzW2ldO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcbiAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsdWUsIGNoaWxkQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGF0YS5zZXQocGF0aCwgcGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcbn1cbi8qKlxuICogUGFyc2UgYSBcInF1ZXJ5IHZhbHVlXCIgKGUuZy4gdmFsdWUgaW4gYSB3aGVyZSBmaWx0ZXIgb3IgYSB2YWx1ZSBpbiBhIGN1cnNvclxuICogYm91bmQpLlxuICpcbiAqIEBwYXJhbSBhbGxvd0FycmF5cyAtIFdoZXRoZXIgdGhlIHF1ZXJ5IHZhbHVlIGlzIGFuIGFycmF5IHRoYXQgbWF5IGRpcmVjdGx5XG4gKiBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlLmcuIHRoZSBvcGVyYW5kIG9mIGFuIGBpbmAgcXVlcnkpLlxuICovXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5VmFsdWUodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIGlucHV0LCBhbGxvd0FycmF5cyA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoYWxsb3dBcnJheXMgPyA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8gOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLCBtZXRob2ROYW1lKTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpO1xuICAgIHJldHVybiBwYXJzZWQ7XG59XG4vKipcbiAqIFBhcnNlcyB1c2VyIGRhdGEgdG8gUHJvdG9idWYgVmFsdWVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIERhdGEgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGNvbnRleHQgLSBBIGNvbnRleHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBwYXRoIGJlaW5nIHBhcnNlZCxcbiAqIHRoZSBzb3VyY2Ugb2YgdGhlIGRhdGEgYmVpbmcgcGFyc2VkLCBldGMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLCBvciBudWxsIGlmIHRoZSB2YWx1ZSB3YXMgYSBGaWVsZFZhbHVlIHNlbnRpbmVsXG4gKiB0aGF0IHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBwYXJzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRhKGlucHV0LCBjb250ZXh0KSB7XG4gICAgLy8gVW53cmFwIHRoZSBBUEkgdHlwZSBmcm9tIHRoZSBDb21wYXQgU0RLLiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBBUEkgdHlwZVxuICAgIC8vIGZyb20gZmlyZXN0b3JlLWV4cC5cbiAgICBpbnB1dCA9IGdldE1vZHVsYXJJbnN0YW5jZShpbnB1dCk7XG4gICAgaWYgKGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ1Vuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOicsIGNvbnRleHQsIGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSB7XG4gICAgICAgIC8vIEZpZWxkVmFsdWVzIHVzdWFsbHkgcGFyc2UgaW50byB0cmFuc2Zvcm1zIChleGNlcHQgZGVsZXRlRmllbGQoKSlcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkbyBub3Qgd2FudCB0byBpbmNsdWRlIHRoaXMgZmllbGQgaW4gb3VyIHBhcnNlZCBkYXRhXG4gICAgICAgIC8vIChhcyBkb2luZyBzbyB3aWxsIG92ZXJ3cml0ZSB0aGUgZmllbGQgZGlyZWN0bHkgcHJpb3IgdG8gdGhlIHRyYW5zZm9ybVxuICAgICAgICAvLyB0cnlpbmcgdG8gdHJhbnNmb3JtIGl0KS4gU28gd2UgZG9uJ3QgYWRkIHRoaXMgbG9jYXRpb24gdG9cbiAgICAgICAgLy8gY29udGV4dC5maWVsZE1hc2sgYW5kIHdlIHJldHVybiBudWxsIGFzIG91ciBwYXJzaW5nIHJlc3VsdC5cbiAgICAgICAgcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCBpdCBjYW4gbmV2ZXIgcGFydGljaXBhdGUgaW4gdGhlIGZpZWxkTWFzaywgc29cbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIHRoaXMgYmVsb3cuIElmIGBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzYCBpcyBmYWxzZSxcbiAgICAgICAgLy8gYHBhcnNlU2NhbGFyVmFsdWVgIHdpbGwgcmVqZWN0IGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBjb250ZXh0LnBhdGggaXMgbnVsbCB3ZSBhcmUgaW5zaWRlIGFuIGFycmF5IGFuZCB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAgIC8vIGZpZWxkIG1hc2sgcGF0aHMgbW9yZSBncmFudWxhciB0aGFuIHRoZSB0b3AtbGV2ZWwgYXJyYXkuXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogSW5jbHVkZSB0aGUgcGF0aCBjb250YWluaW5nIHRoZSBhcnJheSBpbiB0aGUgZXJyb3JcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBJTiBxdWVyaWVzLCB0aGUgcGFyc2VkIGRhdGEgaXMgYW4gYXJyYXkgKHJlcHJlc2VudGluZ1xuICAgICAgICAgICAgLy8gdGhlIHNldCBvZiB2YWx1ZXMgdG8gYmUgaW5jbHVkZWQgZm9yIHRoZSBJTiBxdWVyeSkgdGhhdCBtYXkgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGNvbnRhaW4gYWRkaXRpb25hbCBhcnJheXMgKGVhY2ggcmVwcmVzZW50aW5nIGFuIGluZGl2aWR1YWwgZmllbGRcbiAgICAgICAgICAgIC8vIHZhbHVlKSwgc28gd2UgZGlzYWJsZSB0aGlzIHZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zZXR0aW5ncy5hcnJheUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRhdGFTb3VyY2UgIT09IDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ05lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KGlucHV0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVNjYWxhclZhbHVlKGlucHV0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaiwgY29udGV4dCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGlmIChpc0VtcHR5KG9iaikpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IG9iamVjdCwgd2UgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIHVwZGF0ZVxuICAgICAgICAvLyBtYXNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzZXJ2ZXIgY3JlYXRlcyBhIG1hcCBlbnRyeS5cbiAgICAgICAgaWYgKGNvbnRleHQucGF0aCAmJiBjb250ZXh0LnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3JFYWNoKG9iaiwgKGtleSwgdmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWwsIGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yRmllbGQoa2V5KSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gcGFyc2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXBWYWx1ZTogeyBmaWVsZHMgfSB9O1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheShhcnJheSwgY29udGV4dCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBlbnRyeUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFycmF5KSB7XG4gICAgICAgIGxldCBwYXJzZWRFbnRyeSA9IHBhcnNlRGF0YShlbnRyeSwgY29udGV4dC5jaGlsZENvbnRleHRGb3JBcnJheShlbnRyeUluZGV4KSk7XG4gICAgICAgIGlmIChwYXJzZWRFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGluY2x1ZGUgbnVsbHMgaW4gdGhlIGFycmF5IGZvciBmaWVsZHMgYmVpbmcgcmVwbGFjZWQgd2l0aCBhXG4gICAgICAgICAgICAvLyBzZW50aW5lbC5cbiAgICAgICAgICAgIHBhcnNlZEVudHJ5ID0geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlZEVudHJ5KTtcbiAgICAgICAgZW50cnlJbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKipcbiAqIFwiUGFyc2VzXCIgdGhlIHByb3ZpZGVkIEZpZWxkVmFsdWVJbXBsLCBhZGRpbmcgYW55IG5lY2Vzc2FyeSB0cmFuc2Zvcm1zIHRvXG4gKiBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICAvLyBTZW50aW5lbHMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggd3JpdGVzLCBhbmQgbm90IHdpdGhpbiBhcnJheXMuXG4gICAgaWYgKCFpc1dyaXRlKGNvbnRleHQuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt2YWx1ZS5fbWV0aG9kTmFtZX0oKSBjYW4gb25seSBiZSB1c2VkIHdpdGggdXBkYXRlKCkgYW5kIHNldCgpYCk7XG4gICAgfVxuICAgIGlmICghY29udGV4dC5wYXRoKSB7XG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dmFsdWUuX21ldGhvZE5hbWV9KCkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW5zaWRlIGFycmF5c2ApO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IHZhbHVlLl90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpO1xuICAgIGlmIChmaWVsZFRyYW5zZm9ybSkge1xuICAgICAgICBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5wdXNoKGZpZWxkVHJhbnNmb3JtKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBhIHNjYWxhciB2YWx1ZSAoaS5lLiBub3QgYW4gT2JqZWN0LCBBcnJheSwgb3IgRmllbGRWYWx1ZSlcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NhbGFyVmFsdWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKGNvbnRleHQuc2VyaWFsaXplciwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4geyBib29sZWFuVmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAuZnJvbURhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcCkge1xuICAgICAgICAvLyBGaXJlc3RvcmUgYmFja2VuZCB0cnVuY2F0ZXMgcHJlY2lzaW9uIGRvd24gdG8gbWljcm9zZWNvbmRzLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gb2ZmbGluZSBtb2RlIHdvcmtzIHRoZSBzYW1lIHdpdGggcmVnYXJkcyB0byB0cnVuY2F0aW9uLCBwZXJmb3JtIHRoZVxuICAgICAgICAvLyB0cnVuY2F0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGJhY2tlbmQgdG8gZG8gdGhhdC5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcCh2YWx1ZS5zZWNvbmRzLCBNYXRoLmZsb29yKHZhbHVlLm5hbm9zZWNvbmRzIC8gMTAwMCkgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB0b1RpbWVzdGFtcChjb250ZXh0LnNlcmlhbGl6ZXIsIHRpbWVzdGFtcClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBHZW9Qb2ludCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VvUG9pbnRWYWx1ZToge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB2YWx1ZS5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHZhbHVlLmxvbmdpdHVkZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB7IGJ5dGVzVmFsdWU6IHRvQnl0ZXMoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZS5fYnl0ZVN0cmluZykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xuICAgICAgICBjb25zdCB0aGlzRGIgPSBjb250ZXh0LmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IG90aGVyRGIgPSB2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQ7XG4gICAgICAgIGlmICghb3RoZXJEYi5pc0VxdWFsKHRoaXNEYikpIHtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IHJlZmVyZW5jZSBpcyBmb3IgZGF0YWJhc2UgJyArXG4gICAgICAgICAgICAgICAgYCR7b3RoZXJEYi5wcm9qZWN0SWR9LyR7b3RoZXJEYi5kYXRhYmFzZX0gYnV0IHNob3VsZCBiZSBgICtcbiAgICAgICAgICAgICAgICBgZm9yIGRhdGFiYXNlICR7dGhpc0RiLnByb2plY3RJZH0vJHt0aGlzRGIuZGF0YWJhc2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiB0b1Jlc291cmNlTmFtZSh2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQgfHwgY29udGV4dC5kYXRhYmFzZUlkLCB2YWx1ZS5fa2V5LnBhdGgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmVjdG9yVmFsdWUodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgVW5zdXBwb3J0ZWQgZmllbGQgdmFsdWU6ICR7dmFsdWVEZXNjcmlwdGlvbih2YWx1ZSl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFZlY3RvclZhbHVlIHByb3RvIHZhbHVlICh1c2luZyB0aGUgaW50ZXJuYWwgZm9ybWF0KS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VWZWN0b3JWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xuICAgIGNvbnN0IG1hcFZhbHVlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogVkVDVE9SX1ZBTFVFX1NFTlRJTkVMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldOiB7XG4gICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLnRvQXJyYXkoKS5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdWZWN0b3JWYWx1ZXMgbXVzdCBvbmx5IGNvbnRhaW4gbnVtZXJpYyB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9Eb3VibGUoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBWYWx1ZSB9O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXG4gKiBKU09OIG9iamVjdHMgc2luY2UgdGhleSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3RydWN0IHZhbHVlLiBBcnJheXMsIERhdGVzLFxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgaW5wdXQgIT09IG51bGwgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIFRpbWVzdGFtcCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEdlb1BvaW50KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgQnl0ZXMpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBWZWN0b3JWYWx1ZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdChtZXNzYWdlLCBjb250ZXh0LCBpbnB1dCkge1xuICAgIGlmICghbG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkgfHwgIWlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJ2FuIG9iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIE1hc3NhZ2UgdGhlIGVycm9yIGlmIGl0IHdhcyBhbiBvYmplY3QuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKG1lc3NhZ2UgKyAnIGEgY3VzdG9tIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyAnICsgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nKCkgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xuICAgIC8vIElmIHJlcXVpcmVkLCByZXBsYWNlIHRoZSBGaWVsZFBhdGggQ29tcGF0IGNsYXNzIHdpdGggdGhlIGZpcmVzdG9yZS1leHBcbiAgICAvLyBGaWVsZFBhdGguXG4gICAgcGF0aCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXRoKTtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5faW50ZXJuYWxQYXRoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ZpZWxkIHBhdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgJztcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobWVzc2FnZSwgbWV0aG9kTmFtZSwgXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XG4gICAgfVxufVxuLyoqXG4gKiBNYXRjaGVzIGFueSBjaGFyYWN0ZXJzIGluIGEgZmllbGQgcGF0aCBzdHJpbmcgdGhhdCBhcmUgcmVzZXJ2ZWQuXG4gKi9cbmNvbnN0IEZJRUxEX1BBVEhfUkVTRVJWRUQgPSBuZXcgUmVnRXhwKCdbflxcXFwqL1xcXFxbXFxcXF1dJyk7XG4vKipcbiAqIFdyYXBzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IHRoZSBtZXRob2QgdGhhdFxuICogd2FzIHRocm93bi5cbiAqIEBwYXJhbSBtZXRob2ROYW1lIC0gVGhlIHB1YmxpY2x5IHZpc2libGUgbWV0aG9kIG5hbWVcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIGZvcm0gb2YgYSBmaWVsZCBwYXRoIHdoaWNoIHdpbGwgYmVcbiAqIHNwbGl0IG9uIGRvdHMuXG4gKiBAcGFyYW0gdGFyZ2V0RG9jIC0gVGhlIGRvY3VtZW50IGFnYWluc3Qgd2hpY2ggdGhlIGZpZWxkIHBhdGggd2lsbCBiZVxuICogZXZhbHVhdGVkLlxuICovXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xuICAgIGNvbnN0IGZvdW5kID0gcGF0aC5zZWFyY2goRklFTERfUEFUSF9SRVNFUlZFRCk7XG4gICAgaWYgKGZvdW5kID49IDApIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGNvbnRhaW4gYCArXG4gICAgICAgICAgICBgJ34nLCAnKicsICcvJywgJ1snLCBvciAnXSdgLCBtZXRob2ROYW1lLCBcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoLi4ucGF0aC5zcGxpdCgnLicpKS5faW50ZXJuYWxQYXRoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGAgK1xuICAgICAgICAgICAgYGJlZ2luIHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2AsIG1ldGhvZE5hbWUsIFxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKHJlYXNvbiwgbWV0aG9kTmFtZSwgaGFzQ29udmVydGVyLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICBjb25zdCBoYXNQYXRoID0gcGF0aCAmJiAhcGF0aC5pc0VtcHR5KCk7XG4gICAgY29uc3QgaGFzRG9jdW1lbnQgPSB0YXJnZXREb2MgIT09IHVuZGVmaW5lZDtcbiAgICBsZXQgbWVzc2FnZSA9IGBGdW5jdGlvbiAke21ldGhvZE5hbWV9KCkgY2FsbGVkIHdpdGggaW52YWxpZCBkYXRhYDtcbiAgICBpZiAoaGFzQ29udmVydGVyKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAodmlhIGB0b0ZpcmVzdG9yZSgpYCknO1xuICAgIH1cbiAgICBtZXNzYWdlICs9ICcuICc7XG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG4gICAgaWYgKGhhc1BhdGggfHwgaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyAoZm91bmQnO1xuICAgICAgICBpZiAoaGFzUGF0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCBpbiBmaWVsZCAke3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZG9jdW1lbnQgJHt0YXJnZXREb2N9YDtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnKSc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlICsgcmVhc29uICsgZGVzY3JpcHRpb24pO1xufVxuLyoqIENoZWNrcyBgaGF5c3RhY2tgIGlmIEZpZWxkUGF0aCBgbmVlZGxlYCBpcyBwcmVzZW50LiBSdW5zIGluIE8obikuICovXG5mdW5jdGlvbiBmaWVsZE1hc2tDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgcmV0dXJuIGhheXN0YWNrLnNvbWUodiA9PiB2LmlzRXF1YWwobmVlZGxlKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcbiAqIGRhdGFiYXNlLiBUaGUgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0b1xuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXG4gKlxuICogRm9yIGEgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcG9pbnRzIHRvIGEgbm9uLWV4aXN0aW5nIGRvY3VtZW50LCBhbnkgZGF0YVxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXG4gKi9cbmNsYXNzIERvY3VtZW50U25hcHNob3QkMSB7XG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cbiAgICAvLyB0aGUgbGVnYWN5IFNESy4gVGhlIGNoYW5nZXMgYXJlOlxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RNZXRhZGF0YS5cbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdXNlckRhdGFXcml0ZXIsIF9rZXksIF9kb2N1bWVudCwgX2NvbnZlcnRlcikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRlciA9IF9jb252ZXJ0ZXI7XG4gICAgfVxuICAgIC8qKiBQcm9wZXJ0eSBvZiB0aGUgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcHJvdmlkZXMgdGhlIGRvY3VtZW50J3MgSUQuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBEb2N1bWVudFJlZmVyZW5jZWAgZm9yIHRoZSBkb2N1bWVudCBpbmNsdWRlZCBpbiB0aGUgYERvY3VtZW50U25hcHNob3RgLlxuICAgICAqL1xuICAgIGdldCByZWYoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl9jb252ZXJ0ZXIsIHRoaXMuX2tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgd2hldGhlciBvciBub3QgdGhlIGRvY3VtZW50IGF0IHRoZSBzbmFwc2hvdCdzIGxvY2F0aW9uIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGRvY3VtZW50IGV4aXN0cy5cbiAgICAgKi9cbiAgICBleGlzdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudCAhPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IG9yIGB1bmRlZmluZWRgXG4gICAgICogaWYgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcbiAgICAgICAgICAgIC8vIGlmIGEgY29udmVydGVyIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgdGhpcy5fa2V5LCB0aGlzLl9kb2N1bWVudCwgXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRlci5mcm9tRmlyZXN0b3JlKHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodGhpcy5fZG9jdW1lbnQuZGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCAoZm9yIGV4YW1wbGUgJ2Zvbycgb3IgJ2Zvby5iYXInKSB0byBhIHNwZWNpZmljXG4gICAgICogZmllbGQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXQoZmllbGRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnRG9jdW1lbnRTbmFwc2hvdC5nZXQnLCBmaWVsZFBhdGgpKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcbiAqIGFuZCBpdHMgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0byBnZXQgYVxuICogc3BlY2lmaWMgZmllbGQuXG4gKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBvZmZlcnMgdGhlIHNhbWUgQVBJIHN1cmZhY2UgYXMgYVxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cbiAqICd1bmRlZmluZWQnLlxuICovXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QkMSBleHRlbmRzIERvY3VtZW50U25hcHNob3QkMSB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YSgpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRoYXQgY2FsbHMgYGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKWAgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudChtZXRob2ROYW1lLCBhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiBhcmcuX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmcuX2RlbGVnYXRlLl9pbnRlcm5hbFBhdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChxdWVyeSkge1xuICAgIGlmIChxdWVyeS5saW1pdFR5cGUgPT09IFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovICYmXG4gICAgICAgIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgJ2xpbWl0VG9MYXN0KCkgcXVlcmllcyByZXF1aXJlIHNwZWNpZnlpbmcgYXQgbGVhc3Qgb25lIG9yZGVyQnkoKSBjbGF1c2UnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGBBcHBsaWFibGVDb25zdHJhaW50YCBpcyBhbiBhYnN0cmFjdGlvbiBvZiBhIGNvbnN0cmFpbnQgdGhhdCBjYW4gYmUgYXBwbGllZFxuICogdG8gYSBGaXJlc3RvcmUgcXVlcnkuXG4gKi9cbmNsYXNzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xufVxuLyoqXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayB3aGVyZX0sXG4gKiB7QGxpbmsgb3JkZXJCeX0sIHtAbGluayAoc3RhcnRBdDoxKX0sIHtAbGluayAoc3RhcnRBZnRlcjoxKX0sIHtAbGlua1xuICogKGVuZEJlZm9yZToxKX0sIHtAbGluayAoZW5kQXQ6MSl9LCB7QGxpbmsgbGltaXR9LCB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0XG4gKiBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5Q29uc3RyYWludCBleHRlbmRzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xufVxuZnVuY3Rpb24gcXVlcnkocXVlcnksIHF1ZXJ5Q29uc3RyYWludCwgLi4uYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICBsZXQgcXVlcnlDb25zdHJhaW50cyA9IFtdO1xuICAgIGlmIChxdWVyeUNvbnN0cmFpbnQgaW5zdGFuY2VvZiBBcHBsaWFibGVDb25zdHJhaW50KSB7XG4gICAgICAgIHF1ZXJ5Q29uc3RyYWludHMucHVzaChxdWVyeUNvbnN0cmFpbnQpO1xuICAgIH1cbiAgICBxdWVyeUNvbnN0cmFpbnRzID0gcXVlcnlDb25zdHJhaW50cy5jb25jYXQoYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpO1xuICAgIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50cyk7XG4gICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIHF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAgICAgcXVlcnkgPSBjb25zdHJhaW50Ll9hcHBseShxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn1cbi8qKlxuICogQSBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XG4gKiBhIEZpcmVzdG9yZSBxdWVyeSBieSBmaWx0ZXJpbmcgb24gb25lIG9yIG1vcmUgZG9jdW1lbnQgZmllbGRzLlxuICogYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSBhbmQgY2FuIHRoZW5cbiAqIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zXG4gKiB0aGlzIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xuICAgICAgICB0aGlzLl9vcCA9IF9vcDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ3doZXJlJztcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KF9maWVsZCwgX29wLCBfdmFsdWUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5fcGFyc2UocXVlcnkpO1xuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBmaWx0ZXIpKTtcbiAgICB9XG4gICAgX3BhcnNlKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IG5ld1F1ZXJ5RmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgJ3doZXJlJywgcmVhZGVyLCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHRoaXMuX2ZpZWxkLCB0aGlzLl9vcCwgdGhpcy5fdmFsdWUpO1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0gdGhhdCBlbmZvcmNlcyB0aGF0IGRvY3VtZW50c1xuICogbXVzdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgYW5kIHRoYXQgdGhlIHZhbHVlIHNob3VsZCBzYXRpc2Z5IHRoZVxuICogcmVsYXRpb24gY29uc3RyYWludCBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggdG8gY29tcGFyZVxuICogQHBhcmFtIG9wU3RyIC0gVGhlIG9wZXJhdGlvbiBzdHJpbmcgKGUuZyBcIiZsdDtcIiwgXCImbHQ7PVwiLCBcIj09XCIsIFwiJmx0O1wiLFxuICogICBcIiZsdDs9XCIsIFwiIT1cIikuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIGNvbXBhcmlzb25cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIHdoZXJlKGZpZWxkUGF0aCwgb3BTdHIsIHZhbHVlKSB7XG4gICAgY29uc3Qgb3AgPSBvcFN0cjtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnd2hlcmUnLCBmaWVsZFBhdGgpO1xuICAgIHJldHVybiBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKGZpZWxkLCBvcCwgdmFsdWUpO1xufVxuLyoqXG4gKiBBIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzXG4gKiByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeSBieSBwZXJmb3JtaW5nIHRoZSBsb2dpY2FsIE9SIG9yIEFORCBvZiBtdWx0aXBsZVxuICoge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fXMgb3Ige0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH1zLlxuICogYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayBvcn0gb3JcbiAqIHtAbGluayBhbmR9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XG4gKiBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhlIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBBcHBsaWFibGVDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fcXVlcnlDb25zdHJhaW50cyA9IF9xdWVyeUNvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfcXVlcnlDb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCh0eXBlLCBfcXVlcnlDb25zdHJhaW50cyk7XG4gICAgfVxuICAgIF9wYXJzZShxdWVyeSkge1xuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzID0gdGhpcy5fcXVlcnlDb25zdHJhaW50c1xuICAgICAgICAgICAgLm1hcChxdWVyeUNvbnN0cmFpbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Q29uc3RyYWludC5fcGFyc2UocXVlcnkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihwYXJzZWRGaWx0ZXIgPT4gcGFyc2VkRmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPiAwKTtcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRmlsdGVyc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShwYXJzZWRGaWx0ZXJzLCB0aGlzLl9nZXRPcGVyYXRvcigpKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbHRlciA9IHRoaXMuX3BhcnNlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlci5nZXRGaWx0ZXJzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGV4aXN0aW5nIHF1ZXJ5IGlmIG5vdCBhZGRpbmcgYW55IG1vcmUgZmlsdGVycyAoZS5nLiBhbiBlbXB0eVxuICAgICAgICAgICAgLy8gY29tcG9zaXRlIGZpbHRlcikuXG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVOZXdGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBwYXJzZWRGaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcikpO1xuICAgIH1cbiAgICBfZ2V0UXVlcnlDb25zdHJhaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHM7XG4gICAgfVxuICAgIF9nZXRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FuZCcgPyBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLyA6IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGRpc2p1bmN0aW9uIG9mXG4gKiB0aGUgZ2l2ZW4gZmlsdGVyIGNvbnN0cmFpbnRzLiBBIGRpc2p1bmN0aW9uIGZpbHRlciBpbmNsdWRlcyBhIGRvY3VtZW50IGlmIGl0XG4gKiBzYXRpc2ZpZXMgYW55IG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gT3B0aW9uYWwuIFRoZSBsaXN0IG9mXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGRpc2p1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxuICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIG9yKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAvLyBPbmx5IHN1cHBvcnQgUXVlcnlGaWx0ZXJDb25zdHJhaW50c1xuICAgIHF1ZXJ5Q29uc3RyYWludHMuZm9yRWFjaChxdWVyeUNvbnN0cmFpbnQgPT4gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoJ29yJywgcXVlcnlDb25zdHJhaW50KSk7XG4gICAgcmV0dXJuIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLywgcXVlcnlDb25zdHJhaW50cyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGNvbmp1bmN0aW9uIG9mXG4gKiB0aGUgZ2l2ZW4gZmlsdGVyIGNvbnN0cmFpbnRzLiBBIGNvbmp1bmN0aW9uIGZpbHRlciBpbmNsdWRlcyBhIGRvY3VtZW50IGlmIGl0XG4gKiBzYXRpc2ZpZXMgYWxsIG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gT3B0aW9uYWwuIFRoZSBsaXN0IG9mXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGNvbmp1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxuICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIGFuZCguLi5xdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgLy8gT25seSBzdXBwb3J0IFF1ZXJ5RmlsdGVyQ29uc3RyYWludHNcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdhbmQnLCBxdWVyeUNvbnN0cmFpbnQpKTtcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8sIHF1ZXJ5Q29uc3RyYWludHMpO1xufVxuLyoqXG4gKiBBIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIHNvcnQgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlPcmRlckJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nXG4gKiB7QGxpbmsgb3JkZXJCeX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YC5cbiAqXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgb3JkZXJCeSBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50IGluXG4gKiB0aGUgcXVlcnkgcmVzdWx0LlxuICovXG5jbGFzcyBRdWVyeU9yZGVyQnlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9kaXJlY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnknO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZShfZmllbGQsIF9kaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDb25zdHJhaW50KF9maWVsZCwgX2RpcmVjdGlvbik7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBvcmRlckJ5ID0gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fZmllbGQsIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeS5fcXVlcnksIG9yZGVyQnkpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlPcmRlckJ5Q29uc3RyYWludH0gdGhhdCBzb3J0cyB0aGUgcXVlcnkgcmVzdWx0IGJ5IHRoZVxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXG4gKlxuICogTm90ZTogRG9jdW1lbnRzIHRoYXQgZG8gbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50XG4gKiBpbiB0aGUgcXVlcnkgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgZmllbGQgdG8gc29ydCBieS5cbiAqIEBwYXJhbSBkaXJlY3Rpb25TdHIgLSBPcHRpb25hbCBkaXJlY3Rpb24gdG8gc29ydCBieSAoJ2FzYycgb3IgJ2Rlc2MnKS4gSWZcbiAqIG5vdCBzcGVjaWZpZWQsIG9yZGVyIHdpbGwgYmUgYXNjZW5kaW5nLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBvcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uU3RyID0gJ2FzYycpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHI7XG4gICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnb3JkZXJCeScsIGZpZWxkUGF0aCk7XG4gICAgcmV0dXJuIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQuX2NyZWF0ZShwYXRoLCBkaXJlY3Rpb24pO1xufVxuLyoqXG4gKiBBIGBRdWVyeUxpbWl0Q29uc3RyYWludGAgaXMgdXNlZCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyByZXR1cm5lZCBieVxuICogYSBGaXJlc3RvcmUgcXVlcnkuXG4gKiBgUXVlcnlMaW1pdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgbGltaXR9IG9yXG4gKiB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3XG4gKiBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlMaW1pdENvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUxpbWl0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgIHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcbiAgICAgICAgdGhpcy5fbGltaXRUeXBlID0gX2xpbWl0VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdENvbnN0cmFpbnQodHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fbGltaXQsIHRoaXMuX2xpbWl0VHlwZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nXG4gKiBkb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIGxpbWl0KGxpbWl0KSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZU51bWJlcignbGltaXQnLCBsaW1pdCk7XG4gICAgcmV0dXJuIFF1ZXJ5TGltaXRDb25zdHJhaW50Ll9jcmVhdGUoJ2xpbWl0JywgbGltaXQsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBsYXN0IG1hdGNoaW5nXG4gKiBkb2N1bWVudHMuXG4gKlxuICogWW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgYG9yZGVyQnlgIGNsYXVzZSBmb3IgYGxpbWl0VG9MYXN0YCBxdWVyaWVzLFxuICogb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBkdXJpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBsaW1pdFRvTGFzdChsaW1pdCkge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoJ2xpbWl0VG9MYXN0JywgbGltaXQpO1xuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdFRvTGFzdCcsIGxpbWl0LCBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gZXhjbHVkZSBkb2N1bWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYVxuICogcmVzdWx0IHNldCByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChzdGFydEF0OjEpfSBvclxuICoge0BsaW5rIChzdGFydEFmdGVyOjEpfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhXG4gKiBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50KHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBib3VuZCA9IG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIHRoaXMudHlwZSwgdGhpcy5fZG9jT3JGaWVsZHMsIHRoaXMuX2luY2x1c2l2ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0QXQoLi4uZG9jT3JGaWVsZHMpIHtcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEF0JywgZG9jT3JGaWVsZHMsIFxuICAgIC8qaW5jbHVzaXZlPSovIHRydWUpO1xufVxuZnVuY3Rpb24gc3RhcnRBZnRlciguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeVN0YXJ0QXRDb25zdHJhaW50Ll9jcmVhdGUoJ3N0YXJ0QWZ0ZXInLCBkb2NPckZpZWxkcywgXG4gICAgLyppbmNsdXNpdmU9Ki8gZmFsc2UpO1xufVxuLyoqXG4gKiBBIGBRdWVyeUVuZEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBlbmQgb2YgYVxuICogcmVzdWx0IHNldCByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqIGBRdWVyeUVuZEF0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayAoZW5kQXQ6MSl9IG9yXG4gKiB7QGxpbmsgKGVuZEJlZm9yZToxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcbiAqIHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUVuZEF0Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhFbmRBdChxdWVyeS5fcXVlcnksIGJvdW5kKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5kQmVmb3JlKC4uLmRvY09yRmllbGRzKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEJlZm9yZScsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyBmYWxzZSk7XG59XG5mdW5jdGlvbiBlbmRBdCguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeUVuZEF0Q29uc3RyYWludC5fY3JlYXRlKCdlbmRBdCcsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyB0cnVlKTtcbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYm91bmQgZnJvbSBhIGRvY3VtZW50IG9yIGZpZWxkcyAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSkge1xuICAgIGRvY09yRmllbGRzWzBdID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY09yRmllbGRzWzBdKTtcbiAgICBpZiAoZG9jT3JGaWVsZHNbMF0gaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90JDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jdW1lbnQocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzWzBdLl9kb2N1bWVudCwgaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgcmVhZGVyLCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdRdWVyeUZpbHRlcihxdWVyeSwgbWV0aG9kTmFtZSwgZGF0YVJlYWRlciwgZGF0YWJhc2VJZCwgZmllbGRQYXRoLCBvcCwgdmFsdWUpIHtcbiAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICBpZiAoZmllbGRQYXRoLmlzS2V5RmllbGQoKSkge1xuICAgICAgICBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fCBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiBZb3UgY2FuJ3QgcGVyZm9ybSAnJHtvcH0nIHF1ZXJpZXMgb24gZG9jdW1lbnRJZCgpLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUxpc3QucHVzaChwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgYXJyYXlWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXM6IHJlZmVyZW5jZUxpc3QgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8XG4gICAgICAgICAgICBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gfHxcbiAgICAgICAgICAgIG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZSwgXG4gICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlciA9IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWVsZFBhdGgsIG9wLCBmaWVsZFZhbHVlKTtcbiAgICByZXR1cm4gZmlsdGVyO1xufVxuZnVuY3Rpb24gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5LCBmaWVsZFBhdGgsIGRpcmVjdGlvbikge1xuICAgIGlmIChxdWVyeS5zdGFydEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBzdGFydEF0KCkgb3Igc3RhcnRBZnRlcigpIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVuZEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBlbmRBdCgpIG9yIGVuZEJlZm9yZSgpIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXJCeSA9IG5ldyBPcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gb3JkZXJCeTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgQm91bmRgIHdpbGwgYWx3YXlzIGluY2x1ZGUgdGhlIGtleSBvZiB0aGUgZG9jdW1lbnRcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXG4gKiBwb3NpdGlvbi5cbiAqXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XG4gKiBvZiB0aGUgcXVlcnkgb3IgaWYgYW55IG9mIHRoZSBmaWVsZHMgaW4gdGhlIG9yZGVyIGJ5IGFyZSBhbiB1bmNvbW1pdHRlZFxuICogc2VydmVyIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeSwgZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jLCBpbmNsdXNpdmUpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5OT1RfRk9VTkQsIGBDYW4ndCB1c2UgYSBEb2N1bWVudFNuYXBzaG90IHRoYXQgZG9lc24ndCBleGlzdCBmb3IgYCArXG4gICAgICAgICAgICBgJHttZXRob2ROYW1lfSgpLmApO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgLy8gQmVjYXVzZSBwZW9wbGUgZXhwZWN0IHRvIGNvbnRpbnVlL2VuZCBhIHF1ZXJ5IGF0IHRoZSBleGFjdCBkb2N1bWVudFxuICAgIC8vIHByb3ZpZGVkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgaW1wbGljaXQgc29ydCBvcmRlciByYXRoZXIgdGhhbiB0aGUgZXhwbGljaXRcbiAgICAvLyBzb3J0IG9yZGVyLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBjb250YWluIHRoZSBkb2N1bWVudCBrZXkuIFRoYXQgd2F5XG4gICAgLy8gdGhlIHBvc2l0aW9uIGJlY29tZXMgdW5hbWJpZ3VvdXMgYW5kIHRoZSBxdWVyeSBjb250aW51ZXMvZW5kcyBleGFjdGx5IGF0XG4gICAgLy8gdGhlIHByb3ZpZGVkIGRvY3VtZW50LiBXaXRob3V0IHRoZSBrZXkgKGJ5IHVzaW5nIHRoZSBleHBsaWNpdCBzb3J0XG4gICAgLy8gb3JkZXJzKSwgbXVsdGlwbGUgZG9jdW1lbnRzIGNvdWxkIG1hdGNoIHRoZSBwb3NpdGlvbiwgeWllbGRpbmcgZHVwbGljYXRlXG4gICAgLy8gcmVzdWx0cy5cbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcbiAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gocmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jLmtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2MuZGF0YS5maWVsZChvcmRlckJ5LmZpZWxkKTtcbiAgICAgICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGZvciB3aGljaCB0aGUgZmllbGQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeS5maWVsZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBpcyBhbiB1bmNvbW1pdHRlZCBzZXJ2ZXIgdGltZXN0YW1wLiAoU2luY2UgdGhlIHZhbHVlIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhpcyBmaWVsZCBpcyB1bmtub3duLCB5b3UgY2Fubm90IHN0YXJ0L2VuZCBhIHF1ZXJ5IHdpdGggaXQuKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhIGAgK1xuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCAnJHtmaWVsZH0nICh1c2VkIGFzIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9yZGVyQnkpIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIGZpZWxkIHZhbHVlcyB0byBhIGBCb3VuZGAgZm9yIHRoZSBnaXZlbiBxdWVyeS5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnksIGRhdGFiYXNlSWQsIGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHZhbHVlcywgaW5jbHVzaXZlKSB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IG9yZGVyIGJ5J3MgYmVjYXVzZSBpdCBoYXMgdG8gbWF0Y2ggdGhlIHF1ZXJ5IHRoZSB1c2VyIG1hZGVcbiAgICBjb25zdCBvcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5O1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gb3JkZXJCeS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCB0byAke21ldGhvZE5hbWV9KCkuIGAgK1xuICAgICAgICAgICAgYFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBgICtcbiAgICAgICAgICAgIGBudW1iZXIgb2Ygb3JkZXJCeSgpIGNsYXVzZXNgKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBFeHBlY3RlZCBhIHN0cmluZyBmb3IgZG9jdW1lbnQgSUQgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCksIGJ1dCBnb3QgYSAke3R5cGVvZiByYXdWYWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgcmF3VmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBhbmQgb3JkZXJpbmcgYnkgZG9jdW1lbnRJZCgpLCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgYmUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7cmF3VmFsdWV9JyBjb250YWlucyBhIHNsYXNoLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmF3VmFsdWUpKTtcbiAgICAgICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBhbmQgb3JkZXJpbmcgYnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgcmVzdWx0IGluIGEgYCArXG4gICAgICAgICAgICAgICAgICAgIGB2YWxpZCBkb2N1bWVudCBwYXRoLCBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGNvbnRhaW5zIGFuIG9kZCBudW1iZXIgYCArXG4gICAgICAgICAgICAgICAgICAgIGBvZiBzZWdtZW50cy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShwYXRoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChyZWZWYWx1ZShkYXRhYmFzZUlkLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgcmF3VmFsdWUpO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBgZG9jdW1lbnRJZFZhbHVlYCBpbnRvIGEgYFJlZmVyZW5jZVZhbHVlYCwgdGhyb3dpbmdcbiAqIGFwcHJvcHJpYXRlIGVycm9ycyBpZiB0aGUgdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIGBEb2N1bWVudFJlZmVyZW5jZWBcbiAqIG9yIGBzdHJpbmdgLCBvciBpZiB0aGUgc3RyaW5nIGlzIG1hbGZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIGRvY3VtZW50SWRWYWx1ZSkge1xuICAgIGRvY3VtZW50SWRWYWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2N1bWVudElkVmFsdWUpO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9jdW1lbnRJZFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSAnICtcbiAgICAgICAgICAgICAgICAnbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9jdW1lbnQgSUQsIGJ1dCBpdCB3YXMgYW4gZW1wdHkgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgZG9jdW1lbnRJZFZhbHVlLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBieSBgICtcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgJyR7ZG9jdW1lbnRJZFZhbHVlfScgY29udGFpbnMgYSAnLycgY2hhcmFjdGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGRvY3VtZW50SWRWYWx1ZSkpO1xuICAgICAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBieSBgICtcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcHJvdmlkZWQgbXVzdCByZXN1bHQgaW4gYSB2YWxpZCBkb2N1bWVudCBwYXRoLCBgICtcbiAgICAgICAgICAgICAgICBgYnV0ICcke3BhdGh9JyBpcyBub3QgYmVjYXVzZSBpdCBoYXMgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cyAoJHtwYXRoLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBuZXcgRG9jdW1lbnRLZXkocGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudElkVmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jdW1lbnRJZFZhbHVlLl9rZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBgICtcbiAgICAgICAgICAgIGBzdHJpbmcgb3IgYSBEb2N1bWVudFJlZmVyZW5jZSwgYnV0IGl0IHdhczogYCArXG4gICAgICAgICAgICBgJHt2YWx1ZURlc2NyaXB0aW9uKGRvY3VtZW50SWRWYWx1ZSl9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIGEgZGlzanVuY3RpdmUgZmlsdGVyIHNhdGlzZmllcyBhbGxcbiAqIGFycmF5IHJlcXVpcmVtZW50cy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcGVyYXRvcikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIFF1ZXJ5LiBBIG5vbi1lbXB0eSBhcnJheSBpcyByZXF1aXJlZCBmb3IgJyArXG4gICAgICAgICAgICBgJyR7b3BlcmF0b3IudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBvcGVyYXRvciwgcmV0dXJucyB0aGUgc2V0IG9mIG9wZXJhdG9ycyB0aGF0IGNhbm5vdCBiZSB1c2VkIHdpdGggaXQuXG4gKlxuICogVGhpcyBpcyBub3QgYSBjb21wcmVoZW5zaXZlIGNoZWNrLCBhbmQgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGVcbiAqIGxvbmcgdGVybS4gVmFsaWRhdGlvbnMgc2hvdWxkIG9jY3VyIGluIHRoZSBGaXJlc3RvcmUgYmFja2VuZC5cbiAqXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcbiAqIDEuIE9ubHkgb25lIGluZXF1YWxpdHkgcGVyIHF1ZXJ5LlxuICogMi4gYE5PVF9JTmAgY2Fubm90IGJlIHVzZWQgd2l0aCBhcnJheSwgZGlzanVuY3RpdmUsIG9yIGBOT1RfRVFVQUxgIG9wZXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY29uZmxpY3RpbmdPcHMob3ApIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgIHJldHVybiBbXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLywgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dO1xuICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxuICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dO1xuICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyxcbiAgICAgICAgICAgICAgICBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sXG4gICAgICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sXG4gICAgICAgICAgICAgICAgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqL1xuICAgICAgICAgICAgXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5LCBmaWVsZEZpbHRlcikge1xuICAgIGNvbnN0IGNvbmZsaWN0aW5nT3AgPSBmaW5kT3BJbnNpZGVGaWx0ZXJzKHF1ZXJ5LmZpbHRlcnMsIGNvbmZsaWN0aW5nT3BzKGZpZWxkRmlsdGVyLm9wKSk7XG4gICAgaWYgKGNvbmZsaWN0aW5nT3AgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gaXQncyBhIGR1cGxpY2F0ZSBvcCB0byBnaXZlIGEgc2xpZ2h0bHkgY2xlYXJlciBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoY29uZmxpY3RpbmdPcCA9PT0gZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSBtb3JlIHRoYW4gb25lICcgK1xuICAgICAgICAgICAgICAgIGAnJHtmaWVsZEZpbHRlci5vcC50b1N0cmluZygpfScgZmlsdGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlICcke2ZpZWxkRmlsdGVyLm9wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzIGAgK1xuICAgICAgICAgICAgICAgIGB3aXRoICcke2NvbmZsaWN0aW5nT3AudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XG4gICAgbGV0IHRlc3RRdWVyeSA9IHF1ZXJ5O1xuICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xuICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIHN1YkZpbHRlcnMpIHtcbiAgICAgICAgdmFsaWRhdGVOZXdGaWVsZEZpbHRlcih0ZXN0UXVlcnksIHN1YkZpbHRlcik7XG4gICAgICAgIHRlc3RRdWVyeSA9IHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcbiAgICB9XG59XG4vLyBDaGVja3MgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBmaWx0ZXIgb3BlcmF0b3JzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWx0ZXJzIGFuZFxuLy8gcmV0dXJucyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMsIG9yIG51bGwgaWYgbm9uZSBhcmUuXG5mdW5jdGlvbiBmaW5kT3BJbnNpZGVGaWx0ZXJzKGZpbHRlcnMsIG9wZXJhdG9ycykge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZmllbGRGaWx0ZXIub3ApID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXIub3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludChmdW5jdGlvbk5hbWUsIHF1ZXJ5Q29uc3RyYWludCkge1xuICAgIGlmICghKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KSAmJlxuICAgICAgICAhKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIEFwcGxpYWJsZUNvbnN0cmFpbnRzIGNyZWF0ZWQgd2l0aCBhIGNhbGwgdG8gJ3doZXJlKC4uLiknLCAnb3IoLi4uKScsIG9yICdhbmQoLi4uKScuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUNvbnN0cmFpbnRBcnJheShxdWVyeUNvbnN0cmFpbnQpIHtcbiAgICBjb25zdCBjb21wb3NpdGVGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkRmlsdGVyQ291bnQgPSBxdWVyeUNvbnN0cmFpbnQuZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJDb3VudCA+IDEgfHxcbiAgICAgICAgKGNvbXBvc2l0ZUZpbHRlckNvdW50ID4gMCAmJiBmaWVsZEZpbHRlckNvdW50ID4gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWRRdWVyeS4gV2hlbiB1c2luZyBjb21wb3NpdGUgZmlsdGVycywgeW91IGNhbm5vdCB1c2UgJyArXG4gICAgICAgICAgICAnbW9yZSB0aGFuIG9uZSBmaWx0ZXIgYXQgdGhlIHRvcCBsZXZlbC4gQ29uc2lkZXIgbmVzdGluZyB0aGUgbXVsdGlwbGUgJyArXG4gICAgICAgICAgICAnZmlsdGVycyB3aXRoaW4gYW4gYGFuZCguLi4pYCBzdGF0ZW1lbnQuIEZvciBleGFtcGxlOiAnICtcbiAgICAgICAgICAgICdjaGFuZ2UgYHF1ZXJ5KHF1ZXJ5LCB3aGVyZSguLi4pLCBvciguLi4pKWAgdG8gJyArXG4gICAgICAgICAgICAnYHF1ZXJ5KHF1ZXJ5LCBhbmQod2hlcmUoLi4uKSwgb3IoLi4uKSkpYC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnZlcnRzIEZpcmVzdG9yZSdzIGludGVybmFsIHR5cGVzIHRvIHRoZSBKYXZhU2NyaXB0IHR5cGVzIHRoYXQgd2UgZXhwb3NlXG4gKiB0byB0aGUgdXNlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XG4gICAgY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xuICAgICAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJvb2xlYW5WYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0Qnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdCh2YWx1ZS5tYXBWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZlY3RvclZhbHVlKHZhbHVlLm1hcFZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnZlcnRPYmplY3QobWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3RNYXAobWFwVmFsdWUuZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnZlcnRPYmplY3RNYXAoZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yRWFjaChmaWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb252ZXJ0VmVjdG9yVmFsdWUobWFwVmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IChfYyA9IChfYiA9IChfYSA9IG1hcFZhbHVlLmZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWx1ZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZhbHVlKHZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRHZW9Qb2ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sb25naXR1ZGUpKTtcbiAgICB9XG4gICAgY29udmVydEFycmF5KGFycmF5VmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLm1hcCh2YWx1ZSA9PiB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpKTtcbiAgICB9XG4gICAgY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcbiAgICAgICAgc3dpdGNoIChzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xuICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUocHJldmlvdXNWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAnZXN0aW1hdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAoZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydFRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChub3JtYWxpemVkVmFsdWUuc2Vjb25kcywgbm9ybWFsaXplZFZhbHVlLm5hbm9zKTtcbiAgICB9XG4gICAgY29udmVydERvY3VtZW50S2V5KG5hbWUsIGV4cGVjdGVkRGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCByZXNvdXJjZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcbiAgICAgICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlUGF0aCkpO1xuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gbmV3IERhdGFiYXNlSWQocmVzb3VyY2VQYXRoLmdldCgxKSwgcmVzb3VyY2VQYXRoLmdldCgzKSk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShyZXNvdXJjZVBhdGgucG9wRmlyc3QoNSkpO1xuICAgICAgICBpZiAoIWRhdGFiYXNlSWQuaXNFcXVhbChleHBlY3RlZERhdGFiYXNlSWQpKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGIvNjQxMzAyMDIpOiBTb21laG93IHN1cHBvcnQgZm9yZWlnbiByZWZlcmVuY2VzLlxuICAgICAgICAgICAgbG9nRXJyb3IoYERvY3VtZW50ICR7a2V5fSBjb250YWlucyBhIGRvY3VtZW50IGAgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2Ugd2l0aGluIGEgZGlmZmVyZW50IGRhdGFiYXNlIChgICtcbiAgICAgICAgICAgICAgICBgJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vJHtkYXRhYmFzZUlkLmRhdGFiYXNlfSkgd2hpY2ggaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgIGBzdXBwb3J0ZWQuIEl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBgICtcbiAgICAgICAgICAgICAgICBgZGF0YWJhc2UgKCR7ZXhwZWN0ZWREYXRhYmFzZUlkLnByb2plY3RJZH0vJHtleHBlY3RlZERhdGFiYXNlSWQuZGF0YWJhc2V9KSBgICtcbiAgICAgICAgICAgICAgICBgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29udmVydHMgY3VzdG9tIG1vZGVsIG9iamVjdCBvZiB0eXBlIFQgaW50byBgRG9jdW1lbnREYXRhYCBieSBhcHBseWluZyB0aGVcbiAqIGNvbnZlcnRlciBpZiBpdCBleGlzdHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gY29udmVydGluZyB1c2VyIG9iamVjdHMgdG8gYERvY3VtZW50RGF0YWBcbiAqIGJlY2F1c2Ugd2Ugd2FudCB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgaWZcbiAqIHRoZWlyIGBzZXQoKWAgb3IgZmFpbHMgZHVlIHRvIGludmFsaWQgZGF0YSBvcmlnaW5hdGluZyBmcm9tIGEgYHRvRmlyZXN0b3JlKClgXG4gKiBjYWxsLlxuICovXG5mdW5jdGlvbiBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIoY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLm1lcmdlIHx8IG9wdGlvbnMubWVyZ2VGaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBDYXN0IHRvIGBhbnlgIGluIG9yZGVyIHRvIHNhdGlzZnkgdGhlIHVuaW9uIHR5cGUgY29uc3RyYWludCBvblxuICAgICAgICAgICAgLy8gdG9GaXJlc3RvcmUoKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbn1cbmNsYXNzIExpdGVVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgc3VtIG9mXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXG4gKiBAcGFyYW0gZmllbGQgU3BlY2lmaWVzIHRoZSBmaWVsZCB0byBzdW0gYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxuICovXG5mdW5jdGlvbiBzdW0oZmllbGQpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdzdW0nLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQkMSgnc3VtJywgZmllbGQpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGF2ZXJhZ2Ugb2ZcbiAqIGEgc3BlY2lmaWVkIGZpZWxkIG92ZXIgYSByYW5nZSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cbiAqIEBwYXJhbSBmaWVsZCBTcGVjaWZpZXMgdGhlIGZpZWxkIHRvIGF2ZXJhZ2UgYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxuICovXG5mdW5jdGlvbiBhdmVyYWdlKGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnYXZnJywgZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEoJ2F2ZXJhZ2UnLCBmaWVsZCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY291bnQgb2ZcbiAqIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdjb3VudCcpO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gJ0FnZ3JlZ2F0ZUZpZWxkYCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSBsZWZ0IENvbXBhcmUgdGhpcyBBZ2dyZWdhdGVGaWVsZCB0byB0aGUgYHJpZ2h0YC5cbiAqIEBwYXJhbSByaWdodCBDb21wYXJlIHRoaXMgQWdncmVnYXRlRmllbGQgdG8gdGhlIGBsZWZ0YC5cbiAqL1xuZnVuY3Rpb24gYWdncmVnYXRlRmllbGRFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgQWdncmVnYXRlRmllbGQgJiZcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVGaWVsZCAmJlxuICAgICAgICBsZWZ0LmFnZ3JlZ2F0ZVR5cGUgPT09IHJpZ2h0LmFnZ3JlZ2F0ZVR5cGUgJiZcbiAgICAgICAgKChfYSA9IGxlZnQuX2ludGVybmFsRmllbGRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2Fub25pY2FsU3RyaW5nKCkpID09PVxuICAgICAgICAgICAgKChfYiA9IHJpZ2h0Ll9pbnRlcm5hbEZpZWxkUGF0aCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbm9uaWNhbFN0cmluZygpKSk7XG59XG4vKipcbiAqIENvbXBhcmVzIHR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBUd28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCBcImVxdWFsXCIgaWYgdGhleSBoYXZlXG4gKiB1bmRlcmx5aW5nIHF1ZXJpZXMgdGhhdCBjb21wYXJlIGVxdWFsLCBhbmQgdGhlIHNhbWUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gbGVmdCAtIFRoZSBmaXJzdCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIFRoZSBzZWNvbmQgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBcImVxdWFsXCIsIGFzIGRlZmluZWQgYWJvdmUsIG9yIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIChxdWVyeUVxdWFsKGxlZnQucXVlcnksIHJpZ2h0LnF1ZXJ5KSAmJiBkZWVwRXF1YWwobGVmdC5kYXRhKCksIHJpZ2h0LmRhdGEoKSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNQYXJ0aWFsT2JzZXJ2ZXIob2JqKSB7XG4gICAgcmV0dXJuIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgWyduZXh0JywgJ2Vycm9yJywgJ2NvbXBsZXRlJ10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGFuIG9iamVjdCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBzcGVjaWZpZWRcbiAqIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmplY3QgPSBvYmo7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAobWV0aG9kIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTWV0YWRhdGEgYWJvdXQgYSBzbmFwc2hvdCwgZGVzY3JpYmluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYXBzaG90LlxuICovXG5jbGFzcyBTbmFwc2hvdE1ldGFkYXRhIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc1BlbmRpbmdXcml0ZXMsIGZyb21DYWNoZSkge1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdXcml0ZXMgPSBoYXNQZW5kaW5nV3JpdGVzO1xuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYFNuYXBzaG90TWV0YWRhdGFgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9PT0gb3RoZXIuaGFzUGVuZGluZ1dyaXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPT09IG90aGVyLmZyb21DYWNoZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXIgRmlyZXN0b3JlXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXG4gKiBleHBsaWNpdGx5IHZlcmlmeSBhIGRvY3VtZW50J3MgZXhpc3RlbmNlLlxuICovXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgbWV0YWRhdGEsIGNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgY29udmVydGVyKTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlSW1wbCA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZGF0YSBleGlzdHMuIFRydWUgaWYgdGhlIGRvY3VtZW50IGV4aXN0cy5cbiAgICAgKi9cbiAgICBleGlzdHMoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5leGlzdHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgc2VydmVyVGltZXN0YW1wKClgIHZhbHVlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgICogc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb21cbiAgICAgKiB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wcyB0aGF0XG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IG9yIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgZGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcbiAgICAgICAgICAgIC8vIGlmIGEgY29udmVydGVyIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIHRoaXMubWV0YWRhdGEsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0ZXIuZnJvbUZpcmVzdG9yZShzbmFwc2hvdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHRoaXMuX2RvY3VtZW50LmRhdGEudmFsdWUsIG9wdGlvbnMuc2VydmVyVGltZXN0YW1wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGEgYHNlcnZlclRpbWVzdGFtcCgpYCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2V0IHRvXG4gICAgICogaXRzIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYnlcbiAgICAgKiBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIChmb3IgZXhhbXBsZSAnZm9vJyBvciAnZm9vLmJhcicpIHRvIGEgc3BlY2lmaWNcbiAgICAgKiBmaWVsZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgdGhlIGZpZWxkIGlzIHJldHJpZXZlZFxuICAgICAqIGZyb20gdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHNcbiAgICAgKiB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXQoZmllbGRQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RvY3VtZW50LmRhdGEuZmllbGQoZmllbGRQYXRoRnJvbUFyZ3VtZW50KCdEb2N1bWVudFNuYXBzaG90LmdldCcsIGZpZWxkUGF0aCkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZSBhcyBwYXJ0IG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0XG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcbiAqIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcbiAqIGBleGlzdHNgIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHRydWUgYW5kIGBkYXRhKClgIHdpbGwgbmV2ZXIgcmV0dXJuXG4gKiAndW5kZWZpbmVkJy5cbiAqL1xuY2xhc3MgUXVlcnlEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYHNlcnZlclRpbWVzdGFtcCgpYCB2YWx1ZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgYnkgcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxuICAgICAqIGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YShvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEEgYFF1ZXJ5U25hcHNob3RgIGNvbnRhaW5zIHplcm8gb3IgbW9yZSBgRG9jdW1lbnRTbmFwc2hvdGAgb2JqZWN0c1xuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudHMgY2FuIGJlIGFjY2Vzc2VkIGFzIGFuXG4gKiBhcnJheSB2aWEgdGhlIGBkb2NzYCBwcm9wZXJ0eSBvciBlbnVtZXJhdGVkIHVzaW5nIHRoZSBgZm9yRWFjaGAgbWV0aG9kLiBUaGVcbiAqIG51bWJlciBvZiBkb2N1bWVudHMgY2FuIGJlIGRldGVybWluZWQgdmlhIHRoZSBgZW1wdHlgIGFuZCBgc2l6ZWBcbiAqIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIFF1ZXJ5U25hcHNob3Qge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBxdWVyeSwgX3NuYXBzaG90KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IF9zbmFwc2hvdDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBTbmFwc2hvdE1ldGFkYXRhKF9zbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBfc25hcHNob3QuZnJvbUNhY2hlKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIH1cbiAgICAvKiogQW4gYXJyYXkgb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cbiAgICBnZXQgZG9jcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4gcmVzdWx0LnB1c2goZG9jKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc25hcHNob3QuZG9jcy5zaXplO1xuICAgIH1cbiAgICAvKiogVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIGEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgZm9yXG4gICAgICogZWFjaCBkb2N1bWVudCBpbiB0aGUgc25hcHNob3QuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGJpbmRpbmcgZm9yIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEodGhpcy5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGRvYy5rZXkpLCB0aGlzLl9zbmFwc2hvdC5mcm9tQ2FjaGUpLCB0aGlzLnF1ZXJ5LmNvbnZlcnRlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZG9jdW1lbnRzIGNoYW5nZXMgc2luY2UgdGhlIGxhc3Qgc25hcHNob3QuIElmIHRoaXNcbiAgICAgKiBpcyB0aGUgZmlyc3Qgc25hcHNob3QsIGFsbCBkb2N1bWVudHMgd2lsbCBiZSBpbiB0aGUgbGlzdCBhcyAnYWRkZWQnXG4gICAgICogY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gYFNuYXBzaG90TGlzdGVuT3B0aW9uc2AgdGhhdCBjb250cm9sIHdoZXRoZXIgbWV0YWRhdGEtb25seVxuICAgICAqIGNoYW5nZXMgKGkuZS4gb25seSBgRG9jdW1lbnRTbmFwc2hvdC5tZXRhZGF0YWAgY2hhbmdlZCkgc2hvdWxkIHRyaWdnZXJcbiAgICAgKiBzbmFwc2hvdCBldmVudHMuXG4gICAgICovXG4gICAgZG9jQ2hhbmdlcyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9ICEhb3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xuICAgICAgICBpZiAoaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyAmJiB0aGlzLl9zbmFwc2hvdC5leGNsdWRlc01ldGFkYXRhQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RvIGluY2x1ZGUgbWV0YWRhdGEgY2hhbmdlcyB3aXRoIHlvdXIgZG9jdW1lbnQgY2hhbmdlcywgeW91IG11c3QgJyArXG4gICAgICAgICAgICAgICAgJ2Fsc28gcGFzcyB7IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6dHJ1ZSB9IHRvIG9uU25hcHNob3QoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZENoYW5nZXMgfHxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICE9PSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gY2hhbmdlc0Zyb21TbmFwc2hvdCh0aGlzLCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzID0gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlcztcbiAgICB9XG59XG4vKiogQ2FsY3VsYXRlcyB0aGUgYXJyYXkgb2YgYERvY3VtZW50Q2hhbmdlYHMgZm9yIGEgZ2l2ZW4gYFZpZXdTbmFwc2hvdGAuICovXG5mdW5jdGlvbiBjaGFuZ2VzRnJvbVNuYXBzaG90KHF1ZXJ5U25hcHNob3QsIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpIHtcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90LmRvY0NoYW5nZXMubWFwKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XG4gICAgICAgICAgICBjaGFuZ2UuZG9jO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICBvbGRJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4KytcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQSBgRG9jdW1lbnRTZXRgIHRoYXQgaXMgdXBkYXRlZCBpbmNyZW1lbnRhbGx5IGFzIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gdXNlXG4gICAgICAgIC8vIHRvIGxvb2t1cCB0aGUgaW5kZXggb2YgYSBkb2N1bWVudC5cbiAgICAgICAgbGV0IGluZGV4VHJhY2tlciA9IHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3M7XG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzXG4gICAgICAgICAgICAuZmlsdGVyKGNoYW5nZSA9PiBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzIHx8IGNoYW5nZS50eXBlICE9PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8pXG4gICAgICAgICAgICAubWFwKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XG4gICAgICAgICAgICBsZXQgb2xkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxldCBuZXdJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlICE9PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuZGVsZXRlKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuYWRkKGNoYW5nZS5kb2MpO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXhUcmFja2VyLmluZGV4T2YoY2hhbmdlLmRvYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiByZXN1bHRDaGFuZ2VUeXBlKGNoYW5nZS50eXBlKSxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgb2xkSW5kZXgsXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3VsdENoYW5nZVR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiAnYWRkZWQnO1xuICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XG4gICAgICAgICAgICByZXR1cm4gJ21vZGlmaWVkJztcbiAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiAncmVtb3ZlZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbi8vIFRPRE8oZmlyZXN0b3JlZXhwKTogQWRkIHRlc3RzIGZvciBzbmFwc2hvdEVxdWFsIHdpdGggZGlmZmVyZW50IHNuYXBzaG90XG4vLyBtZXRhZGF0YVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHNuYXBzaG90cyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gcmlnaHQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzbmFwc2hvdHMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzbmFwc2hvdEVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gKGxlZnQuX2ZpcmVzdG9yZSA9PT0gcmlnaHQuX2ZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgbGVmdC5fa2V5LmlzRXF1YWwocmlnaHQuX2tleSkgJiZcbiAgICAgICAgICAgIChsZWZ0Ll9kb2N1bWVudCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcmlnaHQuX2RvY3VtZW50ID09PSBudWxsXG4gICAgICAgICAgICAgICAgOiBsZWZ0Ll9kb2N1bWVudC5pc0VxdWFsKHJpZ2h0Ll9kb2N1bWVudCkpICYmXG4gICAgICAgICAgICBsZWZ0Ll9jb252ZXJ0ZXIgPT09IHJpZ2h0Ll9jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5U25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0Ll9maXJlc3RvcmUgPT09IHJpZ2h0Ll9maXJlc3RvcmUgJiZcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmXG4gICAgICAgICAgICBsZWZ0Lm1ldGFkYXRhLmlzRXF1YWwocmlnaHQubWV0YWRhdGEpICYmXG4gICAgICAgICAgICBsZWZ0Ll9zbmFwc2hvdC5pc0VxdWFsKHJpZ2h0Ll9zbmFwc2hvdCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAuXG4gKlxuICogTm90ZTogYGdldERvYygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5IHdhaXRpbmdcbiAqIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZiB5b3UgYXJlXG4gKiBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsIGludm9rZVxuICoge0BsaW5rIGdldERvY0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY0Zyb21TZXJ2ZXJ9LlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIG9mIHRoZSBkb2N1bWVudCB0byBmZXRjaC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2MocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbn1cbmNsYXNzIEV4cFVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBjb252ZXJ0Qnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwga2V5KTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSBjYWNoZS5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgY2FjaGVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldERvY0Zyb21DYWNoZShyZWZlcmVuY2UpIHtcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRGcm9tTG9jYWxDYWNoZShjbGllbnQsIHJlZmVyZW5jZS5fa2V5KS50aGVuKGRvYyA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWZlcmVuY2UuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShkb2MgIT09IG51bGwgJiYgZG9jLmhhc0xvY2FsTXV0YXRpb25zLCBcbiAgICAvKiBmcm9tQ2FjaGU9ICovIHRydWUpLCByZWZlcmVuY2UuY29udmVydGVyKSk7XG59XG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSB0aGUgc2VydmVyLlxuICogUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgbmV0d29yayBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldERvY0Zyb21TZXJ2ZXIocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSwge1xuICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXG4gICAgfSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgLlxuICpcbiAqIE5vdGU6IGBnZXREb2NzKClgIGF0dGVtcHRzIHRvIHByb3ZpZGUgdXAtdG8tZGF0ZSBkYXRhIHdoZW4gcG9zc2libGUgYnlcbiAqIHdhaXRpbmcgZm9yIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQgbWF5IHJldHVybiBjYWNoZWQgZGF0YSBvciBmYWlsIGlmXG4gKiB5b3UgYXJlIG9mZmxpbmUgYW5kIHRoZSBzZXJ2ZXIgY2Fubm90IGJlIHJlYWNoZWQuIFRvIHNwZWNpZnkgdGhpcyBiZWhhdmlvcixcbiAqIGludm9rZSB7QGxpbmsgZ2V0RG9jc0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY3NGcm9tU2VydmVyfS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3MocXVlcnkpIHtcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5Ll9xdWVyeSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIGNhY2hlLlxuICogUmV0dXJucyBhbiBlbXB0eSByZXN1bHQgc2V0IGlmIG5vIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgcXVlcnkgYXJlIGN1cnJlbnRseVxuICogY2FjaGVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeS5cbiAqL1xuZnVuY3Rpb24gZ2V0RG9jc0Zyb21DYWNoZShxdWVyeSkge1xuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSkudGhlbihzbmFwc2hvdCA9PiBuZXcgUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBxdWVyeSwgc25hcHNob3QpKTtcbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgIGZyb20gdGhlXG4gKiBzZXJ2ZXIuIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3NGcm9tU2VydmVyKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnksIHtcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG5mdW5jdGlvbiBzZXREb2MocmVmZXJlbmNlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKGRhdGFSZWFkZXIsICdzZXREb2MnLCByZWZlcmVuY2UuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZmVyZW5jZS5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURvYyhyZWZlcmVuY2UsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xuICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxuICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICBsZXQgcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyhkYXRhUmVhZGVyLCAndXBkYXRlRG9jJywgcmVmZXJlbmNlLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcbn1cbi8qKlxuICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHNwZWNpZmllZCBgRG9jdW1lbnRSZWZlcmVuY2VgLlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gZGVsZXRlLlxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogZGVsZXRlZCBmcm9tIHRoZSBiYWNrZW5kIChub3RlIHRoYXQgaXQgd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURvYyhyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgbXV0YXRpb25zID0gW25ldyBEZWxldGVNdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSldO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpO1xufVxuLyoqXG4gKiBBZGQgYSBuZXcgZG9jdW1lbnQgdG8gc3BlY2lmaWVkIGBDb2xsZWN0aW9uUmVmZXJlbmNlYCB3aXRoIHRoZSBnaXZlbiBkYXRhLFxuICogYXNzaWduaW5nIGl0IGEgZG9jdW1lbnQgSUQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gdG8gYWRkIHRoaXMgZG9jdW1lbnQgdG8uXG4gKiBAcGFyYW0gZGF0YSAtIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIGZvciB0aGUgbmV3IGRvY3VtZW50LlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlXG4gKiBuZXdseSBjcmVhdGVkIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgKE5vdGUgdGhhdCBpdFxuICogd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXG4gKi9cbmZ1bmN0aW9uIGFkZERvYyhyZWZlcmVuY2UsIGRhdGEpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgZG9jUmVmID0gZG9jKHJlZmVyZW5jZSk7XG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSk7XG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnYWRkRG9jJywgZG9jUmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCB7fSk7XG4gICAgY29uc3QgbXV0YXRpb24gPSBwYXJzZWQudG9NdXRhdGlvbihkb2NSZWYuX2tleSwgUHJlY29uZGl0aW9uLmV4aXN0cyhmYWxzZSkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKS50aGVuKCgpID0+IGRvY1JlZik7XG59XG5mdW5jdGlvbiBvblNuYXBzaG90KHJlZmVyZW5jZSwgLi4uYXJncykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJlZmVyZW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWZlcmVuY2UpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgc291cmNlOiAnZGVmYXVsdCdcbiAgICB9O1xuICAgIGxldCBjdXJyQXJnID0gMDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbY3VyckFyZ10gPT09ICdvYmplY3QnICYmICFpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1tjdXJyQXJnXTtcbiAgICAgICAgY3VyckFyZysrO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyxcbiAgICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZVxuICAgIH07XG4gICAgaWYgKGlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyckFyZ10pKSB7XG4gICAgICAgIGNvbnN0IHVzZXJPYnNlcnZlciA9IGFyZ3NbY3VyckFyZ107XG4gICAgICAgIGFyZ3NbY3VyckFyZ10gPSAoX2EgPSB1c2VyT2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQodXNlck9ic2VydmVyKTtcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMV0gPSAoX2IgPSB1c2VyT2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKHVzZXJPYnNlcnZlcik7XG4gICAgICAgIGFyZ3NbY3VyckFyZyArIDJdID0gKF9jID0gdXNlck9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZCh1c2VyT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgbGV0IGZpcmVzdG9yZTtcbiAgICBsZXQgaW50ZXJuYWxRdWVyeTtcbiAgICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgICAgICBpbnRlcm5hbFF1ZXJ5ID0gbmV3UXVlcnlGb3JQYXRoKHJlZmVyZW5jZS5fa2V5LnBhdGgpO1xuICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXG4gICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJyQXJnICsgMl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY2FzdChyZWZlcmVuY2UsIFF1ZXJ5KTtcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgICAgIGludGVybmFsUXVlcnkgPSBxdWVyeS5fcXVlcnk7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2N1cnJBcmddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbY3VyckFyZ10obmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBhcmdzW2N1cnJBcmcgKyAxXSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1cnJBcmcgKyAyXVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHJlZmVyZW5jZS5fcXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudExpc3RlbihjbGllbnQsIGludGVybmFsUXVlcnksIGludGVybmFsT3B0aW9ucywgb2JzZXJ2ZXIpO1xufVxuZnVuY3Rpb24gb25TbmFwc2hvdHNJblN5bmMoZmlyZXN0b3JlLCBhcmcpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBpc1BhcnRpYWxPYnNlcnZlcihhcmcpXG4gICAgICAgID8gYXJnXG4gICAgICAgIDoge1xuICAgICAgICAgICAgbmV4dDogYXJnXG4gICAgICAgIH07XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGNsaWVudCwgb2JzZXJ2ZXIpO1xufVxuLyoqXG4gKiBMb2NhbGx5IHdyaXRlcyBgbXV0YXRpb25zYCBvbiB0aGUgYXN5bmMgcXVldWUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIFZpZXdTbmFwc2hvdH0gdGhhdCBjb250YWlucyB0aGUgc2luZ2xlIGRvY3VtZW50IHNwZWNpZmllZCBieSBgcmVmYFxuICogdG8gYSB7QGxpbmsgRG9jdW1lbnRTbmFwc2hvdH0uXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmLCBzbmFwc2hvdCkge1xuICAgIGNvbnN0IGRvYyA9IHNuYXBzaG90LmRvY3MuZ2V0KHJlZi5fa2V5KTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShzbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBzbmFwc2hvdC5mcm9tQ2FjaGUpLCByZWYuY29udmVydGVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnlcbiAqIHdpdGhvdXQgYWN0dWFsbHkgZG93bmxvYWRpbmcgdGhlIGRvY3VtZW50cy5cbiAqXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNvdW50IHRoZSBkb2N1bWVudHMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcbiAqIGZpbmFsIGNvdW50LCBub3QgdGhlIGRvY3VtZW50cycgZGF0YSwgaXMgZG93bmxvYWRlZC4gVGhpcyBmdW5jdGlvbiBjYW5cbiAqIGNvdW50IHRoZSBkb2N1bWVudHMgaW4gY2FzZXMgd2hlcmUgdGhlIHJlc3VsdCBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0b1xuICogZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxuICpcbiAqIFRoZSByZXN1bHQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHByZXNlbnRlZCwgdW5hbHRlcmVkLCB3aXRob3V0XG4gKiBjb25zaWRlcmluZyBhbnkgbG9jYWwgc3RhdGUuIFRoYXQgaXMsIGRvY3VtZW50cyBpbiB0aGUgbG9jYWwgY2FjaGUgYXJlIG5vdFxuICogdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLCBuZWl0aGVyIGFyZSBsb2NhbCBtb2RpZmljYXRpb25zIG5vdCB5ZXRcbiAqIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzZXJ2ZXIuIFByZXZpb3VzbHktZG93bmxvYWRlZCByZXN1bHRzLCBpZiBhbnksIGFyZSBub3RcbiAqIHVzZWQuIEV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvbiBuZWNlc3NhcmlseSBpbnZvbHZlcyBhIHJvdW5kIHRyaXAgdG9cbiAqIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IHNpemUgaXMgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY291bnQ7IHRoZSBjb3VudCBjYW4gYmVcbiAqIHJldHJpZXZlZCBmcm9tIGBzbmFwc2hvdC5kYXRhKCkuY291bnRgLCB3aGVyZSBgc25hcHNob3RgIGlzIHRoZVxuICogYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIHdoaWNoIHRoZSByZXR1cm5lZCBQcm9taXNlIHJlc29sdmVzLlxuICovXG5mdW5jdGlvbiBnZXRDb3VudEZyb21TZXJ2ZXIocXVlcnkpIHtcbiAgICBjb25zdCBjb3VudFF1ZXJ5U3BlYyA9IHtcbiAgICAgICAgY291bnQ6IGNvdW50KClcbiAgICB9O1xuICAgIHJldHVybiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBjb3VudFF1ZXJ5U3BlYyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmllZCBhZ2dyZWdhdGlvbnMgb3ZlciB0aGUgZG9jdW1lbnRzIGluIHRoZSByZXN1bHRcbiAqIHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnkgd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxuICpcbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcbiAqIGZpbmFsIGFnZ3JlZ2F0aW9uIHZhbHVlcywgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGFyZSBkb3dubG9hZGVkLiBUaGlzXG4gKiBmdW5jdGlvbiBjYW4gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgb2YgdGhlIGRvY3VtZW50cyBpbiBjYXNlcyB3aGVyZSB0aGUgcmVzdWx0XG4gKiBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0byBkb3dubG9hZCBlbnRpcmVseSAodGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXG4gKlxuICogVGhlIHJlc3VsdCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgcHJlc2VudGVkLCB1bmFsdGVyZWQsIHdpdGhvdXRcbiAqIGNvbnNpZGVyaW5nIGFueSBsb2NhbCBzdGF0ZS4gVGhhdCBpcywgZG9jdW1lbnRzIGluIHRoZSBsb2NhbCBjYWNoZSBhcmUgbm90XG4gKiB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIG5laXRoZXIgYXJlIGxvY2FsIG1vZGlmaWNhdGlvbnMgbm90IHlldFxuICogc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlci4gUHJldmlvdXNseS1kb3dubG9hZGVkIHJlc3VsdHMsIGlmIGFueSwgYXJlIG5vdFxuICogdXNlZC4gRXZlcnkgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIG5lY2Vzc2FyaWx5IGludm9sdmVzIGEgcm91bmQgdHJpcCB0b1xuICogdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIHJlc3VsdCBzZXQgaXMgYWdncmVnYXRlZCBvdmVyLlxuICogQHBhcmFtIGFnZ3JlZ2F0ZVNwZWMgQW4gYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgYWdncmVnYXRlc1xuICogdG8gcGVyZm9ybSBvdmVyIHRoZSByZXN1bHQgc2V0LiBUaGUgQWdncmVnYXRlU3BlYyBzcGVjaWZpZXMgYWxpYXNlcyBmb3IgZWFjaFxuICogYWdncmVnYXRlLCB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgYWdncmVnYXRlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBhZ2dyZWdhdGVTbmFwc2hvdCA9IGF3YWl0IGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIocXVlcnksIHtcbiAqICAgY291bnRPZkRvY3M6IGNvdW50KCksXG4gKiAgIHRvdGFsSG91cnM6IHN1bSgnaG91cnMnKSxcbiAqICAgYXZlcmFnZVNjb3JlOiBhdmVyYWdlKCdzY29yZScpXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb3VudE9mRG9jczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmNvdW50T2ZEb2NzO1xuICogY29uc3QgdG90YWxIb3VyczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLnRvdGFsSG91cnM7XG4gKiBjb25zdCBhdmVyYWdlU2NvcmU6IG51bWJlciB8IG51bGwgPSBhZ2dyZWdhdGVTbmFwc2hvdC5kYXRhKCkuYXZlcmFnZVNjb3JlO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIocXVlcnksIGFnZ3JlZ2F0ZVNwZWMpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgaW50ZXJuYWxBZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUltcGwoYWxpYXMsIGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlLCBhZ2dyZWdhdGUuX2ludGVybmFsRmllbGRQYXRoKTtcbiAgICB9KTtcbiAgICAvLyBSdW4gdGhlIGFnZ3JlZ2F0aW9uIGFuZCBjb252ZXJ0IHRoZSByZXN1bHRzXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCBpbnRlcm5hbEFnZ3JlZ2F0ZXMpLnRoZW4oYWdncmVnYXRlUmVzdWx0ID0+IGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb3JlIGFnZ3JlZ2F0aW9uIHJlc3VsdCB0byBhbiBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGBcbiAqIHRoYXQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBjb25zdW1lci5cbiAqIEBwYXJhbSBxdWVyeVxuICogQHBhcmFtIGFnZ3JlZ2F0ZVJlc3VsdCBDb3JlIGFnZ3JlZ2F0aW9uIHJlc3VsdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSB7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gbmV3IEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QocXVlcnksIHVzZXJEYXRhV3JpdGVyLCBhZ2dyZWdhdGVSZXN1bHQpO1xuICAgIHJldHVybiBxdWVyeVNuYXBzaG90O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5TG9jYWxDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnknO1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmdhcmJhZ2VDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FyYmFnZUNvbGxlY3Rvci5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIGJ1aWxkOiAoKSA9PiBuZXcgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIodW5kZWZpbmVkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbn1cbmNsYXNzIFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnQnO1xuICAgICAgICBsZXQgdGFiTWFuYWdlcjtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy50YWJNYW5hZ2VyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBzZXR0aW5ncy50YWJNYW5hZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFiTWFuYWdlciA9IHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IHRhYk1hbmFnZXIuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlFYWdlcic7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG5jbGFzcyBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoY2FjaGVTaXplKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlMcnUnO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKCkgPT4gbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNhY2hlU2l6ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvcmAuIFRoaXMgaXMgYWxzbyB0aGVcbiAqIGRlZmF1bHQgZ2FyYmFnZSBjb2xsZWN0b3IgdW5sZXNzIGl0IGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yKCkge1xuICAgIHJldHVybiBuZXcgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yYC5cbiAqXG4gKiBBIHRhcmdldCBzaXplIGNhbiBiZSBzcGVjaWZpZWQgYXMgcGFydCBvZiB0aGUgc2V0dGluZyBwYXJhbWV0ZXIuIFRoZVxuICogY29sbGVjdG9yIHdpbGwgc3RhcnQgZGVsZXRpbmcgZG9jdW1lbnRzIG9uY2UgdGhlIGNhY2hlIHNpemUgZXhjZWVkc1xuICogdGhlIGdpdmVuIHNpemUuIFRoZSBkZWZhdWx0IGNhY2hlIHNpemUgaXMgNDBNQiAoNDAgKiAxMDI0ICogMTAyNCBieXRlcykuXG4gKi9cbmZ1bmN0aW9uIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3Ioc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3JJbXBsKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUxvY2FsQ2FjaGVgLiBUaGUgaW5zdGFuY2UgY2FuIGJlIHNldCB0b1xuICogYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCB0byB0ZWxsIHRoZSBTREsgd2hpY2ggY2FjaGUgbGF5ZXIgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBtZW1vcnlMb2NhbENhY2hlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cbiAqXG4gKiBQZXJzaXN0ZW50IGNhY2hlIGNhbm5vdCBiZSB1c2VkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudExvY2FsQ2FjaGUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG5jbGFzcyBTaW5nbGVUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZm9yY2VPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudFNpbmdsZVRhYic7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IHtcbiAgICAgICAgICAgIGJ1aWxkOiAob25saW5lQ29tcG9uZW50cykgPT4gbmV3IEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMsIHRoaXMuZm9yY2VPd25lcnNoaXApXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTXVsdGlUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdQZXJzaXN0ZW50TXVsdGlwbGVUYWInO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZShzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcmAuXG4gKlxuICogQHBhcmFtIHNldHRpbmdzIENvbmZpZ3VyZXMgdGhlIGNyZWF0ZWQgdGFiIG1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5nbGVUYWJNYW5hZ2VySW1wbChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuZm9yY2VPd25lcnNoaXApO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyYC5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlcigpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpVGFiTWFuYWdlckltcGwoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyA9IHtcbiAgICBtYXhBdHRlbXB0czogNVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tYXhBdHRlbXB0cyA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01heCBhdHRlbXB0cyBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgd3JpdGUgYmF0Y2gsIHVzZWQgdG8gcGVyZm9ybSBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXG4gKlxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFkZGluZyB3cml0ZXMgdG8gdGhlIHdyaXRlIGJhdGNoLiBOb25lIG9mIHRoZSB3cml0ZXNcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcbiAqIGNhbGxlZC5cbiAqL1xuY2xhc3MgV3JpdGVCYXRjaCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfY29tbWl0SGFuZGxlcikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl9jb21taXRIYW5kbGVyID0gX2NvbW1pdEhhbmRsZXI7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xuICAgIH1cbiAgICBzZXQoZG9jdW1lbnRSZWYsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlRGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIFRoaXMgYFdyaXRlQmF0Y2hgIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgRGVsZXRlTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdHMgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhpcyB3cml0ZSBiYXRjaCBhcyBhIHNpbmdsZSBhdG9taWMgdW5pdC5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgb2YgdGhlc2Ugd3JpdGVzIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdFxuICAgICAqIG9jY3VyIGFmdGVyIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZVxuICAgICAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXG4gICAgICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgYXMgYW4gYXRvbWljIHVuaXQgKG5vdGUgdGhhdCBpdCB3b24ndFxuICAgICAqIHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICAgICAqL1xuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIHRoaXMuX2NvbW1pdHRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1pdEhhbmRsZXIodGhpcy5fbXV0YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIF92ZXJpZnlOb3RDb21taXR0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21taXR0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIHdyaXRlIGJhdGNoIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlciBjb21taXQoKSAnICtcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gY2FsbGVkLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIGZpcmVzdG9yZSkge1xuICAgIGRvY3VtZW50UmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50UmVmKTtcbiAgICBpZiAoZG9jdW1lbnRSZWYuZmlyZXN0b3JlICE9PSBmaXJlc3RvcmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1Byb3ZpZGVkIGRvY3VtZW50IHJlZmVyZW5jZSBpcyBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBpbnN0YW5jZS4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudFJlZjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUT0RPKG1yc2NobWlkdCkgQ29uc2lkZXIgdXNpbmcgYEJhc2VUcmFuc2FjdGlvbmAgYXMgdGhlIGJhc2UgY2xhc3MgaW4gdGhlXG4vLyBsZWdhY3kgU0RLLlxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gX3RyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqL1xuICAgIGdldChkb2N1bWVudFJlZikge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5sb29rdXAoW3JlZi5fa2V5XSkudGhlbihkb2NzID0+IHtcbiAgICAgICAgICAgIGlmICghZG9jcyB8fCBkb2NzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzWzBdO1xuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbnVsbCwgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQoZG9jdW1lbnRSZWYsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24uc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uc2V0KHJlZi5fa2V5LCBwYXJzZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24udXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udXBkYXRlKHJlZi5fa2V5LCBwYXJzZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGlzIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cbiAgICBkZWxldGUoZG9jdW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLmRlbGV0ZShyZWYuX2tleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBUaGUgYFRyYW5zYWN0aW9uYCBvYmplY3QgcGFzc2VkIHRvIGEgdHJhbnNhY3Rpb24ncyBgdXBkYXRlRnVuY3Rpb25gIHByb3ZpZGVzXG4gKiB0aGUgbWV0aG9kcyB0byByZWFkIGFuZCB3cml0ZSBkYXRhIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dC4gU2VlXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uJDEge1xuICAgIC8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgc2FtZSBsb2dpYyBhcyB0aGUgVHJhbnNhY3Rpb24gQVBJIGluIHRoZSBMaXRlIFNES1xuICAgIC8vIGJ1dCBpcyBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIHJldHVybiBpdHMgb3duIERvY3VtZW50U25hcHNob3QgdHlwZXMuXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZWQgYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZC5cbiAgICAgKiBAcmV0dXJucyBBIGBEb2N1bWVudFNuYXBzaG90YCB3aXRoIHRoZSByZWFkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0KGRvY3VtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcih0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gc3VwZXJcbiAgICAgICAgICAgIC5nZXQoZG9jdW1lbnRSZWYpXG4gICAgICAgICAgICAudGhlbihsaXRlRG9jdW1lbnRTbmFwc2hvdCA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbGl0ZURvY3VtZW50U25hcHNob3QuX2RvY3VtZW50LCBuZXcgU25hcHNob3RNZXRhZGF0YShcbiAgICAgICAgLyogaGFzUGVuZGluZ1dyaXRlcz0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBmcm9tQ2FjaGU9ICovIGZhbHNlKSwgcmVmLmNvbnZlcnRlcikpO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGdpdmVuIGB1cGRhdGVGdW5jdGlvbmAgYW5kIHRoZW4gYXR0ZW1wdHMgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXG4gKiBhcHBsaWVkIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24uIElmIGFueSBkb2N1bWVudCByZWFkIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIGhhcyBjaGFuZ2VkLCBDbG91ZCBGaXJlc3RvcmUgcmV0cmllcyB0aGUgYHVwZGF0ZUZ1bmN0aW9uYC4gSWYgaXQgZmFpbHMgdG9cbiAqIGNvbW1pdCBhZnRlciA1IGF0dGVtcHRzLCB0aGUgdHJhbnNhY3Rpb24gZmFpbHMuXG4gKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGlzIDUwMC5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEZpcmVzdG9yZSBkYXRhYmFzZSB0byBydW4gdGhpc1xuICogdHJhbnNhY3Rpb24gYWdhaW5zdC5cbiAqIEBwYXJhbSB1cGRhdGVGdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIGNvbnRleHQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyB0b1xuICogY29tbWl0LlxuICogQHJldHVybnMgSWYgdGhlIHRyYW5zYWN0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb3Igd2FzIGV4cGxpY2l0bHkgYWJvcnRlZFxuICogKHRoZSBgdXBkYXRlRnVuY3Rpb25gIHJldHVybmVkIGEgZmFpbGVkIHByb21pc2UpLCB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGVcbiAqIGB1cGRhdGVGdW5jdGlvbiBgaXMgcmV0dXJuZWQgaGVyZS4gT3RoZXJ3aXNlLCBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLCBhXG4gKiByZWplY3RlZCBwcm9taXNlIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgZmFpbHVyZSBlcnJvciBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCBpbnRlcm5hbFRyYW5zYWN0aW9uID0+IHVwZGF0ZUZ1bmN0aW9uKG5ldyBUcmFuc2FjdGlvbihmaXJlc3RvcmUsIGludGVybmFsVHJhbnNhY3Rpb24pKSwgb3B0aW9uc1dpdGhEZWZhdWx0cyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZW50aW5lbCBmb3IgdXNlIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSBvclxuICoge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSB3aXRoIGB7bWVyZ2U6IHRydWV9YCB0byBtYXJrIGEgZmllbGQgZm9yIGRlbGV0aW9uLlxuICovXG5mdW5jdGlvbiBkZWxldGVGaWVsZCgpIHtcbiAgICByZXR1cm4gbmV3IERlbGV0ZUZpZWxkVmFsdWVJbXBsKCdkZWxldGVGaWVsZCcpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSB0b1xuICogaW5jbHVkZSBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wIGluIHRoZSB3cml0dGVuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsKCdzZXJ2ZXJUaW1lc3RhbXAnKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHVuaW9uIHRoZSBnaXZlbiBlbGVtZW50cyB3aXRoIGFueSBhcnJheVxuICogdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBFYWNoIHNwZWNpZmllZCBlbGVtZW50IHRoYXQgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdCBpbiB0aGUgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLiBJZiB0aGUgZmllbGQgYmVpbmdcbiAqIG1vZGlmaWVkIGlzIG5vdCBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBhcnJheVxuICogY29udGFpbmluZyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHVuaW9uIGludG8gdGhlIGFycmF5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgLlxuICovXG5mdW5jdGlvbiBhcnJheVVuaW9uKC4uLmVsZW1lbnRzKSB7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgYWN0dWFsbHkgcGFyc2UgdGhlIGRhdGEgdW50aWwgaXQncyB1c2VkIGluIHNldCgpIG9yXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cbiAgICByZXR1cm4gbmV3IEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCgnYXJyYXlVbmlvbicsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayAoc2V0RG9jOjEpfSBvciB7QGxpbmtcbiAqIHVwZGF0ZURvYzoxfSB0aGF0IHRlbGxzIHRoZSBzZXJ2ZXIgdG8gcmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50cyBmcm9tIGFueVxuICogYXJyYXkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBBbGwgaW5zdGFuY2VzIG9mIGVhY2ggZWxlbWVudFxuICogc3BlY2lmaWVkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS4gSWYgdGhlIGZpZWxkIGJlaW5nIG1vZGlmaWVkIGlzIG5vdFxuICogYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxuICogYHVwZGF0ZURvYygpYFxuICovXG5mdW5jdGlvbiBhcnJheVJlbW92ZSguLi5lbGVtZW50cykge1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXG4gICAgcmV0dXJuIG5ldyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsKCdhcnJheVJlbW92ZScsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIGluY3JlbWVudCB0aGUgZmllbGQncyBjdXJyZW50IHZhbHVlIGJ5XG4gKiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogSWYgZWl0aGVyIHRoZSBvcGVyYW5kIG9yIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIHVzZXMgZmxvYXRpbmcgcG9pbnRcbiAqIHByZWNpc2lvbiwgYWxsIGFyaXRobWV0aWMgZm9sbG93cyBJRUVFIDc1NCBzZW1hbnRpY3MuIElmIGJvdGggdmFsdWVzIGFyZVxuICogaW50ZWdlcnMsIHZhbHVlcyBvdXRzaWRlIG9mIEphdmFTY3JpcHQncyBzYWZlIG51bWJlciByYW5nZVxuICogKGBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUmAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCkgYXJlIGFsc28gc3ViamVjdCB0b1xuICogcHJlY2lzaW9uIGxvc3MuIEZ1cnRoZXJtb3JlLCBvbmNlIHByb2Nlc3NlZCBieSB0aGUgRmlyZXN0b3JlIGJhY2tlbmQsIGFsbFxuICogaW50ZWdlciBvcGVyYXRpb25zIGFyZSBjYXBwZWQgYmV0d2VlbiAtMl42MyBhbmQgMl42My0xLlxuICpcbiAqIElmIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIGBudW1iZXJgLCBvciBpZiB0aGUgZmllbGQgZG9lcyBub3RcbiAqIHlldCBleGlzdCwgdGhlIHRyYW5zZm9ybWF0aW9uIHNldHMgdGhlIGZpZWxkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gbiAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcbiAqIGB1cGRhdGVEb2MoKWBcbiAqL1xuZnVuY3Rpb24gaW5jcmVtZW50KG4pIHtcbiAgICByZXR1cm4gbmV3IE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCgnaW5jcmVtZW50Jywgbik7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQ3JlYXRlIGEgYFZlY3RvclZhbHVlYCBpbnN0YW5jZSB3aXRoIGEgY29weSBvZiB0aGlzIGFycmF5IG9mIG51bWJlcnMuXG4gKlxuICogQHJldHVybnMgQSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gdmVjdG9yKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgVmVjdG9yVmFsdWUodmFsdWVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIHdyaXRlIGJhdGNoLCB1c2VkIGZvciBwZXJmb3JtaW5nIG11bHRpcGxlIHdyaXRlcyBhcyBhIHNpbmdsZVxuICogYXRvbWljIG9wZXJhdGlvbi4gVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHtAbGluayBXcml0ZUJhdGNofVxuICogaXMgNTAwLlxuICpcbiAqIFVubGlrZSB0cmFuc2FjdGlvbnMsIHdyaXRlIGJhdGNoZXMgYXJlIHBlcnNpc3RlZCBvZmZsaW5lIGFuZCB0aGVyZWZvcmUgYXJlXG4gKiBwcmVmZXJhYmxlIHdoZW4geW91IGRvbid0IG5lZWQgdG8gY29uZGl0aW9uIHlvdXIgd3JpdGVzIG9uIHJlYWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJucyBBIHtAbGluayBXcml0ZUJhdGNofSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgZXhlY3V0ZSBtdWx0aXBsZVxuICogd3JpdGVzLlxuICovXG5mdW5jdGlvbiB3cml0ZUJhdGNoKGZpcmVzdG9yZSkge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gbmV3IFdyaXRlQmF0Y2goZmlyZXN0b3JlLCBtdXRhdGlvbnMgPT4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBzZXRJbmRleENvbmZpZ3VyYXRpb24oZmlyZXN0b3JlLCBqc29uT3JDb25maWd1cmF0aW9uKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGlmICghY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyIHx8XG4gICAgICAgIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb2ZmbGluZS5raW5kID09PSAnbWVtb3J5Jykge1xuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFdlIGRvbid0IHJldHVybiBhbiBlcnJvciBpZiB0aGUgdXNlciBoYXMgbm90IGVuYWJsZWRcbiAgICAgICAgLy8gcGVyc2lzdGVuY2Ugc2luY2UgYGVuYWJsZUluZGV4ZWRkYlBlcnNpc3RlbmNlKClgIGNhbiBmYWlsIG9uIHRoZSBXZWIuXG4gICAgICAgIGxvZ1dhcm4oJ0Nhbm5vdCBlbmFibGUgaW5kZXhlcyB3aGVuIHBlcnNpc3RlbmNlIGlzIGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IHBhcnNlSW5kZXhlcyhqc29uT3JDb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50U2V0SW5kZXhDb25maWd1cmF0aW9uKGNsaWVudCwgcGFyc2VkSW5kZXhlcyk7XG59XG5mdW5jdGlvbiBwYXJzZUluZGV4ZXMoanNvbk9yQ29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGluZGV4Q29uZmlndXJhdGlvbiA9IHR5cGVvZiBqc29uT3JDb25maWd1cmF0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRyeVBhcnNlSnNvbihqc29uT3JDb25maWd1cmF0aW9uKVxuICAgICAgICA6IGpzb25PckNvbmZpZ3VyYXRpb247XG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0cnlHZXRTdHJpbmcoaW5kZXgsICdjb2xsZWN0aW9uR3JvdXAnKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoU3RyaW5nID0gdHJ5R2V0U3RyaW5nKGZpZWxkLCAnZmllbGRQYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoJ3NldEluZGV4Q29uZmlndXJhdGlvbicsIGZpZWxkUGF0aFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5hcnJheUNvbmZpZyA9PT0gJ0NPTlRBSU5TJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcmRlciA9PT0gJ0FTQ0VORElORycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnREVTQ0VORElORycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMucHVzaChuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIGNvbGxlY3Rpb25Hcm91cCwgc2VnbWVudHMsIEluZGV4U3RhdGUuZW1wdHkoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRJbmRleGVzO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBwYXJzZSBKU09OOiAnICsgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5R2V0U3RyaW5nKGRhdGEsIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhW3Byb3BlcnR5XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01pc3Npbmcgc3RyaW5nIHZhbHVlIGZvcjogJyArIHByb3BlcnR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFbcHJvcGVydHldO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJgIGZvciBjb25maWd1cmluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgdXNlZFxuICogZm9yIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAqXG4gKiBUbyB1c2UsIGNhbGwgYGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcigpYCB0byBnZXQgYW4gaW5zdGFuY2UuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyJztcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFBlcnNpc3RlbnRDYWNoZSBJbmRleCBNYW5hZ2VyIHVzZWQgYnkgdGhlIGdpdmVuIGBGaXJlc3RvcmVgXG4gKiBvYmplY3QuXG4gKlxuICogQHJldHVybiBUaGUgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2UsIG9yIGBudWxsYCBpZiBsb2NhbFxuICogcGVyc2lzdGVudCBzdG9yYWdlIGlzIG5vdCBpbiB1c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihmaXJlc3RvcmUpIHtcbiAgICB2YXIgX2E7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2FjaGVkSW5zdGFuY2UgPSBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZS5nZXQoZmlyZXN0b3JlKTtcbiAgICBpZiAoY2FjaGVkSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEluc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgaWYgKCgoX2EgPSBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fb2ZmbGluZS5raW5kKSAhPT0gJ3BlcnNpc3RlbnQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoZmlyZXN0b3JlKTtcbiAgICBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZS5zZXQoZmlyZXN0b3JlLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuLyoqXG4gKiBFbmFibGVzIHRoZSBTREsgdG8gY3JlYXRlIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBhdXRvbWF0aWNhbGx5IGZvciBsb2NhbFxuICogcXVlcnkgZXhlY3V0aW9uIHdoZW4gdGhlIFNESyBiZWxpZXZlcyBjYWNoZSBpbmRleGVzIGNhbiBoZWxwIGltcHJvdmVcbiAqIHBlcmZvcm1hbmNlLlxuICpcbiAqIFRoaXMgZmVhdHVyZSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICovXG5mdW5jdGlvbiBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbihpbmRleE1hbmFnZXIpIHtcbiAgICBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCB0cnVlKTtcbn1cbi8qKlxuICogU3RvcHMgY3JlYXRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIGF1dG9tYXRpY2FsbHkgZm9yIGxvY2FsIHF1ZXJ5XG4gKiBleGVjdXRpb24uIFRoZSBpbmRleGVzIHdoaWNoIGhhdmUgYmVlbiBjcmVhdGVkIGJ5IGNhbGxpbmdcbiAqIGBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbigpYCBzdGlsbCB0YWtlIGVmZmVjdC5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uKGluZGV4TWFuYWdlcikge1xuICAgIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGZhbHNlKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIGRlbGV0ZXMgaW5kZXhlcyBnZW5lcmF0ZWQgYnlcbiAqIGBzZXRJbmRleENvbmZpZ3VyYXRpb24oKWAsIHdoaWNoIGlzIGRlcHJlY2F0ZWQuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMoaW5kZXhNYW5hZ2VyKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChpbmRleE1hbmFnZXIuX2ZpcmVzdG9yZSk7XG4gICAgY29uc3QgcHJvbWlzZSA9IGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcyhjbGllbnQpO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1ZygnZGVsZXRpbmcgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBzdWNjZWVkZWQnKSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGxvZ1dhcm4oJ2RlbGV0aW5nIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgZmFpbGVkJywgZXJyb3IpKTtcbn1cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGlzRW5hYmxlZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoaW5kZXhNYW5hZ2VyLl9maXJlc3RvcmUpO1xuICAgIGNvbnN0IHByb21pc2UgPSBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoY2xpZW50LCBpc0VuYWJsZWQpO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1Zyhgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXG4gICAgICAgIGBpc0VuYWJsZWQ9JHtpc0VuYWJsZWR9IHN1Y2NlZWRlZGApKVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gbG9nV2Fybihgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXG4gICAgICAgIGBpc0VuYWJsZWQ9JHtpc0VuYWJsZWR9IGZhaWxlZGAsIGVycm9yKSk7XG59XG4vKipcbiAqIE1hcHMgYEZpcmVzdG9yZWAgaW5zdGFuY2VzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIGBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJgIGluc3RhbmNlcy5cbiAqXG4gKiBVc2UgYSBgV2Vha01hcGAgc28gdGhhdCB0aGUgbWFwcGluZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZHJvcHBlZCB3aGVuIHRoZVxuICogYEZpcmVzdG9yZWAgaW5zdGFuY2UgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFRoaXMgZW11bGF0ZXMgYSBwcml2YXRlIG1lbWJlclxuICogYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vZ29vLmdsZS80NTR5dnVnLlxuICovXG5jb25zdCBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBgUXVlcnlUYXJnZXRgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBxdWVyeS4gUmV0dXJucyBgbnVsbGBcbiAqIGlmIHRoZSBGaXJlc3RvcmUgY2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkgaGFzIG5vdCBiZWVuXG4gKiBpbml0aWFsaXplZCBvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSB0byBjb252ZXJ0IHRvIHByb3RvIHJlcHJlc2VudGF0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2ludGVybmFsUXVlcnlUb1Byb3RvUXVlcnlUYXJnZXQocXVlcnkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBjbGllbnQuX29ubGluZUNvbXBvbmVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhc3RvcmUuc2VyaWFsaXplcjtcbiAgICBpZiAoc2VyaWFsaXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5Ll9xdWVyeSkpLnF1ZXJ5VGFyZ2V0O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwcml2YXRlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogUmV0dXJucyBgUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3RgIHdoaWNoIGNvbnRhaW5zIHRoZSBwcm90byByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIGdpdmVuIGFnZ3JlZ2F0aW9uIHF1ZXJ5IHJlcXVlc3QuIFJldHVybnMgbnVsbCBpZiB0aGUgRmlyZXN0b3JlIGNsaWVudFxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgb3IgaGFzIGJlZW5cbiAqIHRlcm1pbmF0ZWQuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIFF1ZXJ5IHRvIGNvbnZlcnQgdG8gcHJvdG8gcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0gYWdncmVnYXRlU3BlYyAtIFRoZSBzZXQgb2YgYWdncmVnYXRpb25zIGFuZCB0aGVpciBhbGlhc2VzLlxuICovXG5mdW5jdGlvbiBfaW50ZXJuYWxBZ2dyZWdhdGlvblF1ZXJ5VG9Qcm90b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFnZ3JlZ2F0ZXMgPSBtYXBUb0FycmF5KGFnZ3JlZ2F0ZVNwZWMsIChhZ2dyZWdhdGUsIGFsaWFzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlSW1wbChhbGlhcywgYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUsIGFnZ3JlZ2F0ZS5faW50ZXJuYWxGaWVsZFBhdGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YXN0b3JlLnNlcmlhbGl6ZXI7XG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeS5fcXVlcnkpLCBhZ2dyZWdhdGVzLCBcbiAgICAvKiBza2lwQWxpYXNpbmc9ICovIHRydWUpLnJlcXVlc3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRlc3RpbmcgaG9va3MgZm9yIHVzZSBieSBGaXJlc3RvcmUncyBpbnRlZ3JhdGlvbiB0ZXN0IHN1aXRlIHRvIHJlYWNoIGludG8gdGhlXG4gKiBTREsgaW50ZXJuYWxzIHRvIHZhbGlkYXRlIGxvZ2ljIGFuZCBiZWhhdmlvciB0aGF0IGlzIG5vdCB2aXNpYmxlIGZyb20gdGhlXG4gKiBwdWJsaWMgQVBJIHN1cmZhY2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFRlc3RpbmdIb29rcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjcmVhdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIG5vdGlmaWVkIHdoZW4gYW4gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaFxuICAgICAqIG9jY3VycyBpbiB0aGUgV2F0Y2ggbGlzdGVuIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIFRoZSByZWxhdGl2ZSBvcmRlciBpbiB3aGljaCBjYWxsYmFja3MgYXJlIG5vdGlmaWVkIGlzIHVuc3BlY2lmaWVkOyBkbyBub3RcbiAgICAgKiByZWx5IG9uIGFueSBwYXJ0aWN1bGFyIG9yZGVyaW5nLiBJZiBhIGdpdmVuIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQgbXVsdGlwbGVcbiAgICAgKiB0aW1lcyB0aGVuIGl0IHdpbGwgYmUgbm90aWZpZWQgbXVsdGlwbGUgdGltZXMsIG9uY2UgcGVyIHJlZ2lzdHJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgdW5yZWdpc3RlcnMgdGhlIGdpdmVuIGNhbGxiYWNrOyBvbmx5XG4gICAgICogdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGRvZXMgYW55dGhpbmc7IGFsbCBzdWJzZXF1ZW50XG4gICAgICogaW52b2NhdGlvbnMgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gVGVzdGluZ0hvb2tzU3BpSW1wbC5pbnN0YW5jZS5vbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBgVGVzdGluZ0hvb2tzU3BpYC5cbiAqL1xuY2xhc3MgVGVzdGluZ0hvb2tzU3BpSW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIXRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlID0gbmV3IFRlc3RpbmdIb29rc1NwaUltcGwoKTtcbiAgICAgICAgICAgIHNldFRlc3RpbmdIb29rc1NwaSh0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2U7XG4gICAgfVxuICAgIG5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goaW5mbykge1xuICAgICAgICB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZC5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGluZm8pKTtcbiAgICB9XG4gICAgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpZCA9IFN5bWJvbCgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZDtcbiAgICAgICAgY2FsbGJhY2tzLnNldChpZCwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FsbGJhY2tzLmRlbGV0ZShpZCk7XG4gICAgfVxufVxubGV0IHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSA9IG51bGw7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5yZWdpc3RlckZpcmVzdG9yZSgnbm9kZScpO1xuXG5leHBvcnQgeyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyLCBBZ2dyZWdhdGVGaWVsZCwgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCwgQnl0ZXMsIENBQ0hFX1NJWkVfVU5MSU1JVEVELCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSwgRG9jdW1lbnRTbmFwc2hvdCwgRmllbGRQYXRoLCBGaWVsZFZhbHVlLCBGaXJlc3RvcmUsIEZpcmVzdG9yZUVycm9yLCBHZW9Qb2ludCwgTG9hZEJ1bmRsZVRhc2ssIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgUXVlcnksIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgUXVlcnlDb25zdHJhaW50LCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUXVlcnlMaW1pdENvbnN0cmFpbnQsIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIFF1ZXJ5U25hcHNob3QsIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFNuYXBzaG90TWV0YWRhdGEsIFRpbWVzdGFtcCwgVHJhbnNhY3Rpb24sIFZlY3RvclZhbHVlLCBXcml0ZUJhdGNoLCBBdXRvSWQgYXMgX0F1dG9JZCwgQnl0ZVN0cmluZyBhcyBfQnl0ZVN0cmluZywgRGF0YWJhc2VJZCBhcyBfRGF0YWJhc2VJZCwgRG9jdW1lbnRLZXkgYXMgX0RvY3VtZW50S2V5LCBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciBhcyBfRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIsIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgYXMgX0VtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIEZpZWxkUGF0aCQxIGFzIF9GaWVsZFBhdGgsIFRlc3RpbmdIb29rcyBhcyBfVGVzdGluZ0hvb2tzLCBjYXN0IGFzIF9jYXN0LCBkZWJ1Z0Fzc2VydCBhcyBfZGVidWdBc3NlcnQsIF9pbnRlcm5hbEFnZ3JlZ2F0aW9uUXVlcnlUb1Byb3RvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QsIF9pbnRlcm5hbFF1ZXJ5VG9Qcm90b1F1ZXJ5VGFyZ2V0LCBpc0Jhc2U2NEF2YWlsYWJsZSBhcyBfaXNCYXNlNjRBdmFpbGFibGUsIGxvZ1dhcm4gYXMgX2xvZ1dhcm4sIHZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIgYXMgX3ZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIsIGFkZERvYywgYWdncmVnYXRlRmllbGRFcXVhbCwgYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsLCBhbmQsIGFycmF5UmVtb3ZlLCBhcnJheVVuaW9uLCBhdmVyYWdlLCBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlLCBjb2xsZWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvciwgY291bnQsIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMsIGRlbGV0ZURvYywgZGVsZXRlRmllbGQsIGRpc2FibGVOZXR3b3JrLCBkaXNhYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24sIGRvYywgZG9jdW1lbnRJZCwgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU5ldHdvcmssIGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBlbmRBdCwgZW5kQmVmb3JlLCBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkLCBleGVjdXRlV3JpdGUsIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIsIGdldENvdW50RnJvbVNlcnZlciwgZ2V0RG9jLCBnZXREb2NGcm9tQ2FjaGUsIGdldERvY0Zyb21TZXJ2ZXIsIGdldERvY3MsIGdldERvY3NGcm9tQ2FjaGUsIGdldERvY3NGcm9tU2VydmVyLCBnZXRGaXJlc3RvcmUsIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgaW5jcmVtZW50LCBpbml0aWFsaXplRmlyZXN0b3JlLCBsaW1pdCwgbGltaXRUb0xhc3QsIGxvYWRCdW5kbGUsIG1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvciwgbWVtb3J5TG9jYWxDYWNoZSwgbWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvciwgbmFtZWRRdWVyeSwgb25TbmFwc2hvdCwgb25TbmFwc2hvdHNJblN5bmMsIG9yLCBvcmRlckJ5LCBwZXJzaXN0ZW50TG9jYWxDYWNoZSwgcGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlciwgcGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXIsIHF1ZXJ5LCBxdWVyeUVxdWFsLCByZWZFcXVhbCwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0RG9jLCBzZXRJbmRleENvbmZpZ3VyYXRpb24sIHNldExvZ0xldmVsLCBzbmFwc2hvdEVxdWFsLCBzdGFydEFmdGVyLCBzdGFydEF0LCBzdW0sIHRlcm1pbmF0ZSwgdXBkYXRlRG9jLCB2ZWN0b3IsIHdhaXRGb3JQZW5kaW5nV3JpdGVzLCB3aGVyZSwgd3JpdGVCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': LogLevel.DEBUG,\n    'verbose': LogLevel.VERBOSE,\n    'info': LogLevel.INFO,\n    'warn': LogLevel.WARN,\n    'error': LogLevel.ERROR,\n    'silent': LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [LogLevel.DEBUG]: 'log',\n    [LogLevel.VERBOSE]: 'log',\n    [LogLevel.INFO]: 'info',\n    [LogLevel.WARN]: 'warn',\n    [LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbGl2aWFsZXdhbmRvd3NraS9EZXNrdG9wL2ZydWl0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xuICovXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcbi8qKlxuICogVGhlIEpTIFNESyBzdXBwb3J0cyA1IGxvZyBsZXZlbHMgYW5kIGFsc28gYWxsb3dzIGEgdXNlciB0aGUgYWJpbGl0eSB0b1xuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxuICpcbiAqIFRoZSBvcmRlciBpcyBhIGZvbGxvd3M6XG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXG4gKlxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIHdpbGwgYmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXG4gKiBgVkVSQk9TRWAgbG9ncyB3aWxsIG5vdClcbiAqL1xudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOXCJdID0gM10gPSBcIldBUk5cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA1XSA9IFwiU0lMRU5UXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XG4gICAgJ2RlYnVnJzogTG9nTGV2ZWwuREVCVUcsXG4gICAgJ3ZlcmJvc2UnOiBMb2dMZXZlbC5WRVJCT1NFLFxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcbiAgICAnd2Fybic6IExvZ0xldmVsLldBUk4sXG4gICAgJ2Vycm9yJzogTG9nTGV2ZWwuRVJST1IsXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXG4gKi9cbmNvbnN0IGRlZmF1bHRMb2dMZXZlbCA9IExvZ0xldmVsLklORk87XG4vKipcbiAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cbiAqIGNocm9tZSkuIFRvIGF2b2lkIGZvcmNpbmcgdXNlcnMgdG8gaGF2ZSB0byBvcHQtaW4gdG8gdGhlc2UgbG9ncyB0d2ljZVxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxuICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcbiAgICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcbiAgICBbTG9nTGV2ZWwuVkVSQk9TRV06ICdsb2cnLFxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxuICAgIFtMb2dMZXZlbC5FUlJPUl06ICdlcnJvcidcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBoYW5kbGVyIHdpbGwgZm9yd2FyZCBERUJVRywgVkVSQk9TRSwgSU5GTywgV0FSTiwgYW5kIEVSUk9SXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAobG9nVHlwZSA8IGluc3RhbmNlLmxvZ0xldmVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IG1ldGhvZCA9IENvbnNvbGVNZXRob2RbbG9nVHlwZV07XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gbG9nIGEgbWVzc2FnZSB3aXRoIGFuIGludmFsaWQgbG9nVHlwZSAodmFsdWU6ICR7bG9nVHlwZX0pYCk7XG4gICAgfVxufTtcbmNsYXNzIExvZ2dlciB7XG4gICAgLyoqXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXG4gICAgICogRmlyZWJhc2UncyBsb2dnaW5nIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBnaXZlbiBMb2dnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpb25hbCwgYWRkaXRpb25hbCwgdXNlci1kZWZpbmVkIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGxvZ0xldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgfVxuICAgIHNldCBsb2dMZXZlbCh2YWwpIHtcbiAgICAgICAgaWYgKCEodmFsIGluIExvZ0xldmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB2YWw7XG4gICAgfVxuICAgIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXG4gICAgc2V0TG9nTGV2ZWwodmFsKSB7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xuICAgIH1cbiAgICBnZXQgbG9nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XG4gICAgfVxuICAgIHNldCBsb2dIYW5kbGVyKHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XG4gICAgfVxuICAgIGdldCB1c2VyTG9nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xuICAgIH1cbiAgICBzZXQgdXNlckxvZ0hhbmRsZXIodmFsKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XG4gICAgfVxuICAgIGxvZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmXG4gICAgICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICAgIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xuICAgICAgICBpbnN0LnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGN1c3RvbUxvZ0xldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sZXZlbCkge1xuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nQ2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IChjdXN0b21Mb2dMZXZlbCAhPT0gbnVsbCAmJiBjdXN0b21Mb2dMZXZlbCAhPT0gdm9pZCAwID8gY3VzdG9tTG9nTGV2ZWwgOiBpbnN0YW5jZS5sb2dMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsW2xldmVsXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnN0YW5jZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IExvZ0xldmVsLCBMb2dnZXIsIHNldExvZ0xldmVsLCBzZXRVc2VyTG9nSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorCode: () => (/* binding */ StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* binding */ StringFormat),\n/* harmony export */   _FbsBlob: () => (/* binding */ FbsBlob),\n/* harmony export */   _Location: () => (/* binding */ Location),\n/* harmony export */   _TaskEvent: () => (/* binding */ TaskEvent),\n/* harmony export */   _TaskState: () => (/* binding */ TaskState),\n/* harmony export */   _UploadTask: () => (/* binding */ UploadTask),\n/* harmony export */   _dataFromString: () => (/* binding */ dataFromString),\n/* harmony export */   _getChild: () => (/* binding */ _getChild),\n/* harmony export */   _invalidArgument: () => (/* binding */ invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* binding */ invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* binding */ connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   getBlob: () => (/* binding */ getBlob),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getStorage: () => (/* binding */ getStorage),\n/* harmony export */   getStream: () => (/* binding */ getStream),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   listAll: () => (/* binding */ listAll),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   updateMetadata: () => (/* binding */ updateMetadata),\n/* harmony export */   uploadBytes: () => (/* binding */ uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* binding */ uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* binding */ uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Constants used in the Firebase Storage library.\n */\n/**\n * Domain name for firebase storage.\n */\nconst DEFAULT_HOST = 'firebasestorage.googleapis.com';\n/**\n * The key in Firebase config json for the storage bucket.\n */\nconst CONFIG_STORAGE_BUCKET_KEY = 'storageBucket';\n/**\n * 2 minutes\n *\n * The timeout for all operations except upload.\n */\nconst DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;\n/**\n * 10 minutes\n *\n * The timeout for upload.\n */\nconst DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;\n/**\n * 1 second\n */\nconst DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error returned by the Firebase Storage SDK.\n * @public\n */\nclass StorageError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    /**\n     * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and\n     *  added to the end of the message.\n     * @param message  - Error message.\n     * @param status_ - Corresponding HTTP Status Code\n     */\n    constructor(code, message, status_ = 0) {\n        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);\n        this.status_ = status_;\n        /**\n         * Stores custom error data unique to the `StorageError`.\n         */\n        this.customData = { serverResponse: null };\n        this._baseMessage = this.message;\n        // Without this, `instanceof StorageError`, in tests for example,\n        // returns false.\n        Object.setPrototypeOf(this, StorageError.prototype);\n    }\n    get status() {\n        return this.status_;\n    }\n    set status(status) {\n        this.status_ = status;\n    }\n    /**\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\n     */\n    _codeEquals(code) {\n        return prependCode(code) === this.code;\n    }\n    /**\n     * Optional response message that was added by the server.\n     */\n    get serverResponse() {\n        return this.customData.serverResponse;\n    }\n    set serverResponse(serverResponse) {\n        this.customData.serverResponse = serverResponse;\n        if (this.customData.serverResponse) {\n            this.message = `${this._baseMessage}\\n${this.customData.serverResponse}`;\n        }\n        else {\n            this.message = this._baseMessage;\n        }\n    }\n}\n/**\n * @public\n * Error codes that can be attached to `StorageError` objects.\n */\nvar StorageErrorCode;\n(function (StorageErrorCode) {\n    // Shared between all platforms\n    StorageErrorCode[\"UNKNOWN\"] = \"unknown\";\n    StorageErrorCode[\"OBJECT_NOT_FOUND\"] = \"object-not-found\";\n    StorageErrorCode[\"BUCKET_NOT_FOUND\"] = \"bucket-not-found\";\n    StorageErrorCode[\"PROJECT_NOT_FOUND\"] = \"project-not-found\";\n    StorageErrorCode[\"QUOTA_EXCEEDED\"] = \"quota-exceeded\";\n    StorageErrorCode[\"UNAUTHENTICATED\"] = \"unauthenticated\";\n    StorageErrorCode[\"UNAUTHORIZED\"] = \"unauthorized\";\n    StorageErrorCode[\"UNAUTHORIZED_APP\"] = \"unauthorized-app\";\n    StorageErrorCode[\"RETRY_LIMIT_EXCEEDED\"] = \"retry-limit-exceeded\";\n    StorageErrorCode[\"INVALID_CHECKSUM\"] = \"invalid-checksum\";\n    StorageErrorCode[\"CANCELED\"] = \"canceled\";\n    // JS specific\n    StorageErrorCode[\"INVALID_EVENT_NAME\"] = \"invalid-event-name\";\n    StorageErrorCode[\"INVALID_URL\"] = \"invalid-url\";\n    StorageErrorCode[\"INVALID_DEFAULT_BUCKET\"] = \"invalid-default-bucket\";\n    StorageErrorCode[\"NO_DEFAULT_BUCKET\"] = \"no-default-bucket\";\n    StorageErrorCode[\"CANNOT_SLICE_BLOB\"] = \"cannot-slice-blob\";\n    StorageErrorCode[\"SERVER_FILE_WRONG_SIZE\"] = \"server-file-wrong-size\";\n    StorageErrorCode[\"NO_DOWNLOAD_URL\"] = \"no-download-url\";\n    StorageErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    StorageErrorCode[\"INVALID_ARGUMENT_COUNT\"] = \"invalid-argument-count\";\n    StorageErrorCode[\"APP_DELETED\"] = \"app-deleted\";\n    StorageErrorCode[\"INVALID_ROOT_OPERATION\"] = \"invalid-root-operation\";\n    StorageErrorCode[\"INVALID_FORMAT\"] = \"invalid-format\";\n    StorageErrorCode[\"INTERNAL_ERROR\"] = \"internal-error\";\n    StorageErrorCode[\"UNSUPPORTED_ENVIRONMENT\"] = \"unsupported-environment\";\n})(StorageErrorCode || (StorageErrorCode = {}));\nfunction prependCode(code) {\n    return 'storage/' + code;\n}\nfunction unknown() {\n    const message = 'An unknown error occurred, please check the error payload for ' +\n        'server response.';\n    return new StorageError(StorageErrorCode.UNKNOWN, message);\n}\nfunction objectNotFound(path) {\n    return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, \"Object '\" + path + \"' does not exist.\");\n}\nfunction quotaExceeded(bucket) {\n    return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, \"Quota for bucket '\" +\n        bucket +\n        \"' exceeded, please view quota on \" +\n        'https://firebase.google.com/pricing/.');\n}\nfunction unauthenticated() {\n    const message = 'User is not authenticated, please authenticate using Firebase ' +\n        'Authentication and try again.';\n    return new StorageError(StorageErrorCode.UNAUTHENTICATED, message);\n}\nfunction unauthorizedApp() {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, 'This app does not have permission to access Firebase Storage on this project.');\n}\nfunction unauthorized(path) {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED, \"User does not have permission to access '\" + path + \"'.\");\n}\nfunction retryLimitExceeded() {\n    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');\n}\nfunction canceled() {\n    return new StorageError(StorageErrorCode.CANCELED, 'User canceled the upload/download.');\n}\nfunction invalidUrl(url) {\n    return new StorageError(StorageErrorCode.INVALID_URL, \"Invalid URL '\" + url + \"'.\");\n}\nfunction invalidDefaultBucket(bucket) {\n    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, \"Invalid default bucket '\" + bucket + \"'.\");\n}\nfunction noDefaultBucket() {\n    return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, 'No default bucket ' +\n        \"found. Did you set the '\" +\n        CONFIG_STORAGE_BUCKET_KEY +\n        \"' property when initializing the app?\");\n}\nfunction cannotSliceBlob() {\n    return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');\n}\nfunction serverFileWrongSize() {\n    return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');\n}\nfunction noDownloadURL() {\n    return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');\n}\n/**\n * @internal\n */\nfunction invalidArgument(message) {\n    return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);\n}\nfunction appDeleted() {\n    return new StorageError(StorageErrorCode.APP_DELETED, 'The Firebase app was deleted.');\n}\n/**\n * @param name - The name of the operation that was invalid.\n *\n * @internal\n */\nfunction invalidRootOperation(name) {\n    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, \"The operation '\" +\n        name +\n        \"' cannot be performed on a root reference, create a non-root \" +\n        \"reference using child, such as .child('file.png').\");\n}\n/**\n * @param format - The format that was not valid.\n * @param message - A message describing the format violation.\n */\nfunction invalidFormat(format, message) {\n    return new StorageError(StorageErrorCode.INVALID_FORMAT, \"String does not match format '\" + format + \"': \" + message);\n}\n/**\n * @param message - A message describing the internal error.\n */\nfunction internalError(message) {\n    throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Internal error: ' + message);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Firebase Storage location data.\n *\n * @internal\n */\nclass Location {\n    constructor(bucket, path) {\n        this.bucket = bucket;\n        this.path_ = path;\n    }\n    get path() {\n        return this.path_;\n    }\n    get isRoot() {\n        return this.path.length === 0;\n    }\n    fullServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\n    }\n    bucketOnlyServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o';\n    }\n    static makeFromBucketSpec(bucketString, host) {\n        let bucketLocation;\n        try {\n            bucketLocation = Location.makeFromUrl(bucketString, host);\n        }\n        catch (e) {\n            // Not valid URL, use as-is. This lets you put bare bucket names in\n            // config.\n            return new Location(bucketString, '');\n        }\n        if (bucketLocation.path === '') {\n            return bucketLocation;\n        }\n        else {\n            throw invalidDefaultBucket(bucketString);\n        }\n    }\n    static makeFromUrl(url, host) {\n        let location = null;\n        const bucketDomain = '([A-Za-z0-9.\\\\-_]+)';\n        function gsModify(loc) {\n            if (loc.path.charAt(loc.path.length - 1) === '/') {\n                loc.path_ = loc.path_.slice(0, -1);\n            }\n        }\n        const gsPath = '(/(.*))?$';\n        const gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\n        const gsIndices = { bucket: 1, path: 3 };\n        function httpModify(loc) {\n            loc.path_ = decodeURIComponent(loc.path);\n        }\n        const version = 'v[A-Za-z0-9_]+';\n        const firebaseStorageHost = host.replace(/[.]/g, '\\\\.');\n        const firebaseStoragePath = '(/([^?#]*).*)?$';\n        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`, 'i');\n        const firebaseStorageIndices = { bucket: 1, path: 3 };\n        const cloudStorageHost = host === DEFAULT_HOST\n            ? '(?:storage.googleapis.com|storage.cloud.google.com)'\n            : host;\n        const cloudStoragePath = '([^?#]*)';\n        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, 'i');\n        const cloudStorageIndices = { bucket: 1, path: 2 };\n        const groups = [\n            { regex: gsRegex, indices: gsIndices, postModify: gsModify },\n            {\n                regex: firebaseStorageRegExp,\n                indices: firebaseStorageIndices,\n                postModify: httpModify\n            },\n            {\n                regex: cloudStorageRegExp,\n                indices: cloudStorageIndices,\n                postModify: httpModify\n            }\n        ];\n        for (let i = 0; i < groups.length; i++) {\n            const group = groups[i];\n            const captures = group.regex.exec(url);\n            if (captures) {\n                const bucketValue = captures[group.indices.bucket];\n                let pathValue = captures[group.indices.path];\n                if (!pathValue) {\n                    pathValue = '';\n                }\n                location = new Location(bucketValue, pathValue);\n                group.postModify(location);\n                break;\n            }\n        }\n        if (location == null) {\n            throw invalidUrl(url);\n        }\n        return location;\n    }\n}\n\n/**\n * A request whose promise always fails.\n */\nclass FailRequest {\n    constructor(error) {\n        this.promise_ = Promise.reject(error);\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(_appDelete = false) { }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Accepts a callback for an action to perform (`doRequest`),\n * and then a callback for when the backoff has completed (`backoffCompleteCb`).\n * The callback sent to start requires an argument to call (`onRequestComplete`).\n * When `start` calls `doRequest`, it passes a callback for when the request has\n * completed, `onRequestComplete`. Based on this, the backoff continues, with\n * another call to `doRequest` and the above loop continues until the timeout\n * is hit, or a successful response occurs.\n * @description\n * @param doRequest Callback to perform request\n * @param backoffCompleteCb Callback to call when backoff has been completed\n */\nfunction start(doRequest, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nbackoffCompleteCb, timeout) {\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\n    // type instead of a bunch of functions with state shared in the closure)\n    let waitSeconds = 1;\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n    // TODO: find a way to exclude Node type definition for storage because storage only works in browser\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let retryTimeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let globalTimeoutId = null;\n    let hitTimeout = false;\n    let cancelState = 0;\n    function canceled() {\n        return cancelState === 2;\n    }\n    let triggeredCallback = false;\n    function triggerCallback(...args) {\n        if (!triggeredCallback) {\n            triggeredCallback = true;\n            backoffCompleteCb.apply(null, args);\n        }\n    }\n    function callWithDelay(millis) {\n        retryTimeoutId = setTimeout(() => {\n            retryTimeoutId = null;\n            doRequest(responseHandler, canceled());\n        }, millis);\n    }\n    function clearGlobalTimeout() {\n        if (globalTimeoutId) {\n            clearTimeout(globalTimeoutId);\n        }\n    }\n    function responseHandler(success, ...args) {\n        if (triggeredCallback) {\n            clearGlobalTimeout();\n            return;\n        }\n        if (success) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        const mustStop = canceled() || hitTimeout;\n        if (mustStop) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        if (waitSeconds < 64) {\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n            waitSeconds *= 2;\n        }\n        let waitMillis;\n        if (cancelState === 1) {\n            cancelState = 2;\n            waitMillis = 0;\n        }\n        else {\n            waitMillis = (waitSeconds + Math.random()) * 1000;\n        }\n        callWithDelay(waitMillis);\n    }\n    let stopped = false;\n    function stop(wasTimeout) {\n        if (stopped) {\n            return;\n        }\n        stopped = true;\n        clearGlobalTimeout();\n        if (triggeredCallback) {\n            return;\n        }\n        if (retryTimeoutId !== null) {\n            if (!wasTimeout) {\n                cancelState = 2;\n            }\n            clearTimeout(retryTimeoutId);\n            callWithDelay(0);\n        }\n        else {\n            if (!wasTimeout) {\n                cancelState = 1;\n            }\n        }\n    }\n    callWithDelay(0);\n    globalTimeoutId = setTimeout(() => {\n        hitTimeout = true;\n        stop(true);\n    }, timeout);\n    return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nfunction stop(id) {\n    id(false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isJustDef(p) {\n    return p !== void 0;\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isFunction(p) {\n    return typeof p === 'function';\n}\nfunction isNonArrayObject(p) {\n    return typeof p === 'object' && !Array.isArray(p);\n}\nfunction isString(p) {\n    return typeof p === 'string' || p instanceof String;\n}\nfunction isNativeBlob(p) {\n    return isNativeBlobDefined() && p instanceof Blob;\n}\nfunction isNativeBlobDefined() {\n    return typeof Blob !== 'undefined';\n}\nfunction validateNumber(argument, minValue, maxValue, value) {\n    if (value < minValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);\n    }\n    if (value > maxValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction makeUrl(urlPart, host, protocol) {\n    let origin = host;\n    if (protocol == null) {\n        origin = `https://${host}`;\n    }\n    return `${protocol}://${origin}/v0${urlPart}`;\n}\nfunction makeQueryString(params) {\n    const encode = encodeURIComponent;\n    let queryPart = '?';\n    for (const key in params) {\n        if (params.hasOwnProperty(key)) {\n            const nextPart = encode(key) + '=' + encode(params[key]);\n            queryPart = queryPart + nextPart + '&';\n        }\n    }\n    // Chop off the extra '&' or '?' on the end\n    queryPart = queryPart.slice(0, -1);\n    return queryPart;\n}\n\n/**\n * Error codes for requests made by the XhrIo wrapper.\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    ErrorCode[ErrorCode[\"NETWORK_ERROR\"] = 1] = \"NETWORK_ERROR\";\n    ErrorCode[ErrorCode[\"ABORT\"] = 2] = \"ABORT\";\n})(ErrorCode || (ErrorCode = {}));\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Checks the status code to see if the action should be retried.\n *\n * @param status Current HTTP status code returned by server.\n * @param additionalRetryCodes additional retry codes to check against\n */\nfunction isRetryStatusCode(status, additionalRetryCodes) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    const isFiveHundredCode = status >= 500 && status < 600;\n    const extraRetryCodes = [\n        // Request Timeout: web server didn't receive full request in time.\n        408,\n        // Too Many Requests: you're getting rate-limited, basically.\n        429\n    ];\n    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;\n    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;\n    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Handles network logic for all Storage Requests, including error reporting and\n * retries with backoff.\n *\n * @param I - the type of the backend's network response.\n * @param - O the output type used by the rest of the SDK. The conversion\n * happens in the specified `callback_`.\n */\nclass NetworkRequest {\n    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true) {\n        this.url_ = url_;\n        this.method_ = method_;\n        this.headers_ = headers_;\n        this.body_ = body_;\n        this.successCodes_ = successCodes_;\n        this.additionalRetryCodes_ = additionalRetryCodes_;\n        this.callback_ = callback_;\n        this.errorCallback_ = errorCallback_;\n        this.timeout_ = timeout_;\n        this.progressCallback_ = progressCallback_;\n        this.connectionFactory_ = connectionFactory_;\n        this.retry = retry;\n        this.pendingConnection_ = null;\n        this.backoffId_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.promise_ = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n            this.start_();\n        });\n    }\n    /**\n     * Actually starts the retry loop.\n     */\n    start_() {\n        const doTheRequest = (backoffCallback, canceled) => {\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            const connection = this.connectionFactory_();\n            this.pendingConnection_ = connection;\n            const progressListener = progressEvent => {\n                const loaded = progressEvent.loaded;\n                const total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (this.progressCallback_ !== null) {\n                    this.progressCallback_(loaded, total);\n                }\n            };\n            if (this.progressCallback_ !== null) {\n                connection.addUploadProgressListener(progressListener);\n            }\n            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            connection\n                .send(this.url_, this.method_, this.body_, this.headers_)\n                .then(() => {\n                if (this.progressCallback_ !== null) {\n                    connection.removeUploadProgressListener(progressListener);\n                }\n                this.pendingConnection_ = null;\n                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;\n                const status = connection.getStatus();\n                if (!hitServer ||\n                    (isRetryStatusCode(status, this.additionalRetryCodes_) &&\n                        this.retry)) {\n                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                const successCode = this.successCodes_.indexOf(status) !== -1;\n                backoffCallback(true, new RequestEndStatus(successCode, connection));\n            });\n        };\n        /**\n         * @param requestWentThrough - True if the request eventually went\n         *     through, false if it hit the retry limit or was canceled.\n         */\n        const backoffDone = (requestWentThrough, status) => {\n            const resolve = this.resolve_;\n            const reject = this.reject_;\n            const connection = status.connection;\n            if (status.wasSuccessCode) {\n                try {\n                    const result = this.callback_(connection, connection.getResponse());\n                    if (isJustDef(result)) {\n                        resolve(result);\n                    }\n                    else {\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            else {\n                if (connection !== null) {\n                    const err = unknown();\n                    err.serverResponse = connection.getErrorText();\n                    if (this.errorCallback_) {\n                        reject(this.errorCallback_(connection, err));\n                    }\n                    else {\n                        reject(err);\n                    }\n                }\n                else {\n                    if (status.canceled) {\n                        const err = this.appDelete_ ? appDeleted() : canceled();\n                        reject(err);\n                    }\n                    else {\n                        const err = retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        };\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        }\n        else {\n            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);\n        }\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            stop(this.backoffId_);\n        }\n        if (this.pendingConnection_ !== null) {\n            this.pendingConnection_.abort();\n        }\n    }\n}\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled - Defaults to false.\n */\nclass RequestEndStatus {\n    constructor(wasSuccessCode, connection, canceled) {\n        this.wasSuccessCode = wasSuccessCode;\n        this.connection = connection;\n        this.canceled = !!canceled;\n    }\n}\nfunction addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers['Authorization'] = 'Firebase ' + authToken;\n    }\n}\nfunction addVersionHeader_(headers, firebaseVersion) {\n    headers['X-Firebase-Storage-Version'] =\n        'webjs/' + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : 'AppManager');\n}\nfunction addGmpidHeader_(headers, appId) {\n    if (appId) {\n        headers['X-Firebase-GMPID'] = appId;\n    }\n}\nfunction addAppCheckHeader_(headers, appCheckToken) {\n    if (appCheckToken !== null) {\n        headers['X-Firebase-AppCheck'] = appCheckToken;\n    }\n}\nfunction makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true) {\n    const queryPart = makeQueryString(requestInfo.urlParams);\n    const url = requestInfo.url + queryPart;\n    const headers = Object.assign({}, requestInfo.headers);\n    addGmpidHeader_(headers, appId);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers, firebaseVersion);\n    addAppCheckHeader_(headers, appCheckToken);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getBlobBuilder() {\n    if (typeof BlobBuilder !== 'undefined') {\n        return BlobBuilder;\n    }\n    else if (typeof WebKitBlobBuilder !== 'undefined') {\n        return WebKitBlobBuilder;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Concatenates one or more values together and converts them to a Blob.\n *\n * @param args The values that will make up the resulting blob.\n * @return The blob.\n */\nfunction getBlob$1(...args) {\n    const BlobBuilder = getBlobBuilder();\n    if (BlobBuilder !== undefined) {\n        const bb = new BlobBuilder();\n        for (let i = 0; i < args.length; i++) {\n            bb.append(args[i]);\n        }\n        return bb.getBlob();\n    }\n    else {\n        if (isNativeBlobDefined()) {\n            return new Blob(args);\n        }\n        else {\n            throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, \"This browser doesn't seem to support creating Blobs\");\n        }\n    }\n}\n/**\n * Slices the blob. The returned blob contains data from the start byte\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\n *\n * @param blob The blob to be sliced.\n * @param start Index of the starting byte.\n * @param end Index of the ending byte.\n * @return The blob slice or null if not supported.\n */\nfunction sliceBlob(blob, start, end) {\n    if (blob.webkitSlice) {\n        return blob.webkitSlice(start, end);\n    }\n    else if (blob.mozSlice) {\n        return blob.mozSlice(start, end);\n    }\n    else if (blob.slice) {\n        return blob.slice(start, end);\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Node actually doesn't validate base64 strings.\n    // A quick sanity check that is not a fool-proof validation\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\n        throw invalidFormat('base64', 'Invalid character found');\n    }\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enumeration of the possible string formats for upload.\n * @public\n */\nconst StringFormat = {\n    /**\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\n     * sequence.\n     * Example: The string 'Hello! \\\\ud83d\\\\ude0a' becomes the byte sequence\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\n     */\n    RAW: 'raw',\n    /**\n     * Indicates the string should be interpreted as base64-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64: 'base64',\n    /**\n     * Indicates the string should be interpreted as base64url-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64URL: 'base64url',\n    /**\n     * Indicates the string is a data URL, such as one obtained from\n     * canvas.toDataURL().\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\n     * becomes the byte sequence\n     * 69 a6 9a\n     * (the content-type \"application/octet-stream\" is also applied, but can\n     * be overridden in the metadata object).\n     */\n    DATA_URL: 'data_url'\n};\nclass StringData {\n    constructor(data, contentType) {\n        this.data = data;\n        this.contentType = contentType || null;\n    }\n}\n/**\n * @internal\n */\nfunction dataFromString(format, stringData) {\n    switch (format) {\n        case StringFormat.RAW:\n            return new StringData(utf8Bytes_(stringData));\n        case StringFormat.BASE64:\n        case StringFormat.BASE64URL:\n            return new StringData(base64Bytes_(format, stringData));\n        case StringFormat.DATA_URL:\n            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));\n        // do nothing\n    }\n    // assert(false);\n    throw unknown();\n}\nfunction utf8Bytes_(value) {\n    const b = [];\n    for (let i = 0; i < value.length; i++) {\n        let c = value.charCodeAt(i);\n        if (c <= 127) {\n            b.push(c);\n        }\n        else {\n            if (c <= 2047) {\n                b.push(192 | (c >> 6), 128 | (c & 63));\n            }\n            else {\n                if ((c & 64512) === 55296) {\n                    // The start of a surrogate pair.\n                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;\n                    if (!valid) {\n                        // The second surrogate wasn't there.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        const hi = c;\n                        const lo = value.charCodeAt(++i);\n                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\n                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n                else {\n                    if ((c & 64512) === 56320) {\n                        // Invalid low surrogate.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n            }\n        }\n    }\n    return new Uint8Array(b);\n}\nfunction percentEncodedBytes_(value) {\n    let decoded;\n    try {\n        decoded = decodeURIComponent(value);\n    }\n    catch (e) {\n        throw invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\n    }\n    return utf8Bytes_(decoded);\n}\nfunction base64Bytes_(format, value) {\n    switch (format) {\n        case StringFormat.BASE64: {\n            const hasMinus = value.indexOf('-') !== -1;\n            const hasUnder = value.indexOf('_') !== -1;\n            if (hasMinus || hasUnder) {\n                const invalidChar = hasMinus ? '-' : '_';\n                throw invalidFormat(format, \"Invalid character '\" +\n                    invalidChar +\n                    \"' found: is it base64url encoded?\");\n            }\n            break;\n        }\n        case StringFormat.BASE64URL: {\n            const hasPlus = value.indexOf('+') !== -1;\n            const hasSlash = value.indexOf('/') !== -1;\n            if (hasPlus || hasSlash) {\n                const invalidChar = hasPlus ? '+' : '/';\n                throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n            }\n            value = value.replace(/-/g, '+').replace(/_/g, '/');\n            break;\n        }\n        // do nothing\n    }\n    let bytes;\n    try {\n        bytes = decodeBase64(value);\n    }\n    catch (e) {\n        if (e.message.includes('polyfill')) {\n            throw e;\n        }\n        throw invalidFormat(format, 'Invalid character found');\n    }\n    const array = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        array[i] = bytes.charCodeAt(i);\n    }\n    return array;\n}\nclass DataURLParts {\n    constructor(dataURL) {\n        this.base64 = false;\n        this.contentType = null;\n        const matches = dataURL.match(/^data:([^,]+)?,/);\n        if (matches === null) {\n            throw invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n        }\n        const middle = matches[1] || null;\n        if (middle != null) {\n            this.base64 = endsWith(middle, ';base64');\n            this.contentType = this.base64\n                ? middle.substring(0, middle.length - ';base64'.length)\n                : middle;\n        }\n        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n}\nfunction dataURLBytes_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    if (parts.base64) {\n        return base64Bytes_(StringFormat.BASE64, parts.rest);\n    }\n    else {\n        return percentEncodedBytes_(parts.rest);\n    }\n}\nfunction dataURLContentType_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    return parts.contentType;\n}\nfunction endsWith(s, end) {\n    const longEnough = s.length >= end.length;\n    if (!longEnough) {\n        return false;\n    }\n    return s.substring(s.length - end.length) === end;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param opt_elideCopy - If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n *\n * @internal\n */\nclass FbsBlob {\n    constructor(data, elideCopy) {\n        let size = 0;\n        let blobType = '';\n        if (isNativeBlob(data)) {\n            this.data_ = data;\n            size = data.size;\n            blobType = data.type;\n        }\n        else if (data instanceof ArrayBuffer) {\n            if (elideCopy) {\n                this.data_ = new Uint8Array(data);\n            }\n            else {\n                this.data_ = new Uint8Array(data.byteLength);\n                this.data_.set(new Uint8Array(data));\n            }\n            size = this.data_.length;\n        }\n        else if (data instanceof Uint8Array) {\n            if (elideCopy) {\n                this.data_ = data;\n            }\n            else {\n                this.data_ = new Uint8Array(data.length);\n                this.data_.set(data);\n            }\n            size = data.length;\n        }\n        this.size_ = size;\n        this.type_ = blobType;\n    }\n    size() {\n        return this.size_;\n    }\n    type() {\n        return this.type_;\n    }\n    slice(startByte, endByte) {\n        if (isNativeBlob(this.data_)) {\n            const realBlob = this.data_;\n            const sliced = sliceBlob(realBlob, startByte, endByte);\n            if (sliced === null) {\n                return null;\n            }\n            return new FbsBlob(sliced);\n        }\n        else {\n            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n            return new FbsBlob(slice, true);\n        }\n    }\n    static getBlob(...args) {\n        if (isNativeBlobDefined()) {\n            const blobby = args.map((val) => {\n                if (val instanceof FbsBlob) {\n                    return val.data_;\n                }\n                else {\n                    return val;\n                }\n            });\n            return new FbsBlob(getBlob$1.apply(null, blobby));\n        }\n        else {\n            const uint8Arrays = args.map((val) => {\n                if (isString(val)) {\n                    return dataFromString(StringFormat.RAW, val).data;\n                }\n                else {\n                    // Blobs don't exist, so this has to be a Uint8Array.\n                    return val.data_;\n                }\n            });\n            let finalLength = 0;\n            uint8Arrays.forEach((array) => {\n                finalLength += array.byteLength;\n            });\n            const merged = new Uint8Array(finalLength);\n            let index = 0;\n            uint8Arrays.forEach((array) => {\n                for (let i = 0; i < array.length; i++) {\n                    merged[index++] = array[i];\n                }\n            });\n            return new FbsBlob(merged, true);\n        }\n    }\n    uploadData() {\n        return this.data_;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the Object resulting from parsing the given JSON, or null if the\n * given string does not represent a JSON object.\n */\nfunction jsonObjectOrNull(s) {\n    let obj;\n    try {\n        obj = JSON.parse(s);\n    }\n    catch (e) {\n        return null;\n    }\n    if (isNonArrayObject(obj)) {\n        return obj;\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Contains helper methods for manipulating paths.\n */\n/**\n * @return Null if the path is already at the root.\n */\nfunction parent(path) {\n    if (path.length === 0) {\n        return null;\n    }\n    const index = path.lastIndexOf('/');\n    if (index === -1) {\n        return '';\n    }\n    const newPath = path.slice(0, index);\n    return newPath;\n}\nfunction child(path, childPath) {\n    const canonicalChildPath = childPath\n        .split('/')\n        .filter(component => component.length > 0)\n        .join('/');\n    if (path.length === 0) {\n        return canonicalChildPath;\n    }\n    else {\n        return path + '/' + canonicalChildPath;\n    }\n}\n/**\n * Returns the last component of a path.\n * '/foo/bar' -> 'bar'\n * '/foo/bar/baz/' -> 'baz/'\n * '/a' -> 'a'\n */\nfunction lastComponent(path) {\n    const index = path.lastIndexOf('/', path.length - 2);\n    if (index === -1) {\n        return path;\n    }\n    else {\n        return path.slice(index + 1);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction noXform_(metadata, value) {\n    return value;\n}\nclass Mapping {\n    constructor(server, local, writable, xform) {\n        this.server = server;\n        this.local = local || server;\n        this.writable = !!writable;\n        this.xform = xform || noXform_;\n    }\n}\nlet mappings_ = null;\nfunction xformPath(fullPath) {\n    if (!isString(fullPath) || fullPath.length < 2) {\n        return fullPath;\n    }\n    else {\n        return lastComponent(fullPath);\n    }\n}\nfunction getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    const mappings = [];\n    mappings.push(new Mapping('bucket'));\n    mappings.push(new Mapping('generation'));\n    mappings.push(new Mapping('metageneration'));\n    mappings.push(new Mapping('name', 'fullPath', true));\n    function mappingsXformPath(_metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    const nameMapping = new Mapping('name');\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\n     * Coerces the second param to a number, if it is defined.\n     */\n    function xformSize(_metadata, size) {\n        if (size !== undefined) {\n            return Number(size);\n        }\n        else {\n            return size;\n        }\n    }\n    const sizeMapping = new Mapping('size');\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping('timeCreated'));\n    mappings.push(new Mapping('updated'));\n    mappings.push(new Mapping('md5Hash', null, true));\n    mappings.push(new Mapping('cacheControl', null, true));\n    mappings.push(new Mapping('contentDisposition', null, true));\n    mappings.push(new Mapping('contentEncoding', null, true));\n    mappings.push(new Mapping('contentLanguage', null, true));\n    mappings.push(new Mapping('contentType', null, true));\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\n    mappings_ = mappings;\n    return mappings_;\n}\nfunction addRef(metadata, service) {\n    function generateRef() {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const loc = new Location(bucket, path);\n        return service._makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\nfunction fromResource(service, resource, mappings) {\n    const metadata = {};\n    metadata['type'] = 'file';\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, service);\n    return metadata;\n}\nfunction fromResourceString(service, resourceString, mappings) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromResource(service, resource, mappings);\n}\nfunction downloadUrlFromResourceString(metadata, resourceString, host, protocol) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    if (!isString(obj['downloadTokens'])) {\n        // This can happen if objects are uploaded through GCS and retrieved\n        // through list, so we don't want to throw an Error.\n        return null;\n    }\n    const tokens = obj['downloadTokens'];\n    if (tokens.length === 0) {\n        return null;\n    }\n    const encode = encodeURIComponent;\n    const tokensList = tokens.split(',');\n    const urls = tokensList.map((token) => {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n        const base = makeUrl(urlPart, host, protocol);\n        const queryString = makeQueryString({\n            alt: 'media',\n            token\n        });\n        return base + queryString;\n    });\n    return urls[0];\n}\nfunction toResourceString(metadata, mappings) {\n    const resource = {};\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PREFIXES_KEY = 'prefixes';\nconst ITEMS_KEY = 'items';\nfunction fromBackendResponse(service, bucket, resource) {\n    const listResult = {\n        prefixes: [],\n        items: [],\n        nextPageToken: resource['nextPageToken']\n    };\n    if (resource[PREFIXES_KEY]) {\n        for (const path of resource[PREFIXES_KEY]) {\n            const pathWithoutTrailingSlash = path.replace(/\\/$/, '');\n            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));\n            listResult.prefixes.push(reference);\n        }\n    }\n    if (resource[ITEMS_KEY]) {\n        for (const item of resource[ITEMS_KEY]) {\n            const reference = service._makeStorageReference(new Location(bucket, item['name']));\n            listResult.items.push(reference);\n        }\n    }\n    return listResult;\n}\nfunction fromResponseString(service, bucket, resourceString) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromBackendResponse(service, bucket, resource);\n}\n\n/**\n * Contains a fully specified request.\n *\n * @param I - the type of the backend's network response.\n * @param O - the output response type used by the rest of the SDK.\n */\nclass RequestInfo {\n    constructor(url, method, \n    /**\n     * Returns the value with which to resolve the request's promise. Only called\n     * if the request is successful. Throw from this function to reject the\n     * returned Request's promise with the thrown error.\n     * Note: The XhrIo passed to this function may be reused after this callback\n     * returns. Do not keep a reference to it in any way.\n     */\n    handler, timeout) {\n        this.url = url;\n        this.method = method;\n        this.handler = handler;\n        this.timeout = timeout;\n        this.urlParams = {};\n        this.headers = {};\n        this.body = null;\n        this.errorHandler = null;\n        /**\n         * Called with the current number of bytes uploaded and total size (-1 if not\n         * computable) of the request body (i.e. used to report upload progress).\n         */\n        this.progressCallback = null;\n        this.successCodes = [200];\n        this.additionalRetryCodes = [];\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws the UNKNOWN StorageError if cndn is false.\n */\nfunction handlerCheck(cndn) {\n    if (!cndn) {\n        throw unknown();\n    }\n}\nfunction metadataHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nfunction listHandler(service, bucket) {\n    function handler(xhr, text) {\n        const listResult = fromResponseString(service, bucket, text);\n        handlerCheck(listResult !== null);\n        return listResult;\n    }\n    return handler;\n}\nfunction downloadUrlHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);\n    }\n    return handler;\n}\nfunction sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        let newErr;\n        if (xhr.getStatus() === 401) {\n            if (\n            // This exact message string is the only consistent part of the\n            // server's error response that identifies it as an App Check error.\n            xhr.getErrorText().includes('Firebase App Check token is invalid')) {\n                newErr = unauthorizedApp();\n            }\n            else {\n                newErr = unauthenticated();\n            }\n        }\n        else {\n            if (xhr.getStatus() === 402) {\n                newErr = quotaExceeded(location.bucket);\n            }\n            else {\n                if (xhr.getStatus() === 403) {\n                    newErr = unauthorized(location.path);\n                }\n                else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.status = xhr.getStatus();\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction objectErrorHandler(location) {\n    const shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        let newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = objectNotFound(location.path);\n        }\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction getMetadata$2(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction list$2(service, location, delimiter, pageToken, maxResults) {\n    const urlParams = {};\n    if (location.isRoot) {\n        urlParams['prefix'] = '';\n    }\n    else {\n        urlParams['prefix'] = location.path + '/';\n    }\n    if (delimiter && delimiter.length > 0) {\n        urlParams['delimiter'] = delimiter;\n    }\n    if (pageToken) {\n        urlParams['pageToken'] = pageToken;\n    }\n    if (maxResults) {\n        urlParams['maxResults'] = maxResults;\n    }\n    const urlPart = location.bucketOnlyServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\nfunction getBytes$1(service, location, maxDownloadSizeBytes) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol) + '?alt=media';\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    if (maxDownloadSizeBytes !== undefined) {\n        requestInfo.headers['Range'] = `bytes=0-${maxDownloadSizeBytes}`;\n        requestInfo.successCodes = [200 /* OK */, 206 /* Partial Content */];\n    }\n    return requestInfo;\n}\nfunction getDownloadUrl(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction updateMetadata$2(service, location, metadata, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'PATCH';\n    const body = toResourceString(metadata, mappings);\n    const headers = { 'Content-Type': 'application/json; charset=utf-8' };\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction deleteObject$2(service, location) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'DELETE';\n    const timeout = service.maxOperationRetryTime;\n    function handler(_xhr, _text) { }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [200, 204];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction determineContentType_(metadata, blob) {\n    return ((metadata && metadata['contentType']) ||\n        (blob && blob.type()) ||\n        'application/octet-stream');\n}\nfunction metadataForUpload_(location, blob, metadata) {\n    const metadataClone = Object.assign({}, metadata);\n    metadataClone['fullPath'] = location.path;\n    metadataClone['size'] = blob.size();\n    if (!metadataClone['contentType']) {\n        metadataClone['contentType'] = determineContentType_(null, blob);\n    }\n    return metadataClone;\n}\n/**\n * Prepare RequestInfo for uploads as Content-Type: multipart.\n */\nfunction multipartUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const headers = {\n        'X-Goog-Upload-Protocol': 'multipart'\n    };\n    function genBoundary() {\n        let str = '';\n        for (let i = 0; i < 2; i++) {\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    const boundary = genBoundary();\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n    const metadata_ = metadataForUpload_(location, blob, metadata);\n    const metadataString = toResourceString(metadata_, mappings);\n    const preBlobPart = '--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n        metadataString +\n        '\\r\\n--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: ' +\n        metadata_['contentType'] +\n        '\\r\\n\\r\\n';\n    const postBlobPart = '\\r\\n--' + boundary + '--';\n    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    const urlParams = { name: metadata_['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n */\nclass ResumableUploadStatus {\n    constructor(current, total, finalized, metadata) {\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n}\nfunction checkResumeHeader_(xhr, allowed) {\n    let status = null;\n    try {\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\n    }\n    catch (e) {\n        handlerCheck(false);\n    }\n    const allowedStatus = allowed || ['active'];\n    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);\n    return status;\n}\nfunction createResumableUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const metadataForUpload = metadataForUpload_(location, blob, metadata);\n    const urlParams = { name: metadataForUpload['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const headers = {\n        'X-Goog-Upload-Protocol': 'resumable',\n        'X-Goog-Upload-Command': 'start',\n        'X-Goog-Upload-Header-Content-Length': `${blob.size()}`,\n        'X-Goog-Upload-Header-Content-Type': metadataForUpload['contentType'],\n        'Content-Type': 'application/json; charset=utf-8'\n    };\n    const body = toResourceString(metadataForUpload, mappings);\n    const timeout = service.maxUploadRetryTime;\n    function handler(xhr) {\n        checkResumeHeader_(xhr);\n        let url;\n        try {\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(isString(url));\n        return url;\n    }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nfunction getResumableUploadStatus(service, location, url, blob) {\n    const headers = { 'X-Goog-Upload-Command': 'query' };\n    function handler(xhr) {\n        const status = checkResumeHeader_(xhr, ['active', 'final']);\n        let sizeString = null;\n        try {\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        if (!sizeString) {\n            // null or empty string\n            handlerCheck(false);\n        }\n        const size = Number(sizeString);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nconst RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nfunction continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    const status_ = new ResumableUploadStatus(0, 0);\n    if (status) {\n        status_.current = status.current;\n        status_.total = status.total;\n    }\n    else {\n        status_.current = 0;\n        status_.total = blob.size();\n    }\n    if (blob.size() !== status_.total) {\n        throw serverFileWrongSize();\n    }\n    const bytesLeft = status_.total - status_.current;\n    let bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    const startByte = status_.current;\n    const endByte = startByte + bytesToUpload;\n    let uploadCommand = '';\n    if (bytesToUpload === 0) {\n        uploadCommand = 'finalize';\n    }\n    else if (bytesLeft === bytesToUpload) {\n        uploadCommand = 'upload, finalize';\n    }\n    else {\n        uploadCommand = 'upload';\n    }\n    const headers = {\n        'X-Goog-Upload-Command': uploadCommand,\n        'X-Goog-Upload-Offset': `${status_.current}`\n    };\n    const body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        const uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n        const newCurrent = status_.current + bytesToUpload;\n        const size = blob.size();\n        let metadata;\n        if (uploadStatus === 'final') {\n            metadata = metadataHandler(service, mappings)(xhr, text);\n        }\n        else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event that is triggered on a task.\n * @internal\n */\nconst TaskEvent = {\n    /**\n     * For this event,\n     * <ul>\n     *   <li>The `next` function is triggered on progress updates and when the\n     *       task is paused/resumed with an `UploadTaskSnapshot` as the first\n     *       argument.</li>\n     *   <li>The `error` function is triggered if the upload is canceled or fails\n     *       for another reason.</li>\n     *   <li>The `complete` function is triggered if the upload completes\n     *       successfully.</li>\n     * </ul>\n     */\n    STATE_CHANGED: 'state_changed'\n};\n// type keys = keyof TaskState\n/**\n * Represents the current state of a running upload.\n * @internal\n */\nconst TaskState = {\n    /** The task is currently transferring data. */\n    RUNNING: 'running',\n    /** The task was paused by the user. */\n    PAUSED: 'paused',\n    /** The task completed successfully. */\n    SUCCESS: 'success',\n    /** The task was canceled. */\n    CANCELED: 'canceled',\n    /** The task failed with an error. */\n    ERROR: 'error'\n};\nfunction taskStateFromInternalTaskState(state) {\n    switch (state) {\n        case \"running\" /* InternalTaskState.RUNNING */:\n        case \"pausing\" /* InternalTaskState.PAUSING */:\n        case \"canceling\" /* InternalTaskState.CANCELING */:\n            return TaskState.RUNNING;\n        case \"paused\" /* InternalTaskState.PAUSED */:\n            return TaskState.PAUSED;\n        case \"success\" /* InternalTaskState.SUCCESS */:\n            return TaskState.SUCCESS;\n        case \"canceled\" /* InternalTaskState.CANCELED */:\n            return TaskState.CANCELED;\n        case \"error\" /* InternalTaskState.ERROR */:\n            return TaskState.ERROR;\n        default:\n            // TODO(andysoto): assert(false);\n            return TaskState.ERROR;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Observer {\n    constructor(nextOrObserver, error, complete) {\n        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;\n        if (asFunctions) {\n            this.next = nextOrObserver;\n            this.error = error !== null && error !== void 0 ? error : undefined;\n            this.complete = complete !== null && complete !== void 0 ? complete : undefined;\n        }\n        else {\n            const observer = nextOrObserver;\n            this.next = observer.next;\n            this.error = observer.error;\n            this.complete = observer.complete;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a function that invokes f with its arguments asynchronously as a\n * microtask, i.e. as soon as possible after the current script returns back\n * into browser code.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(f) {\n    return (...argsToForward) => {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(() => f(...argsToForward));\n    };\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** An override for the text-based Connection. Used in tests. */\nlet textFactoryOverride = null;\n/**\n * Network layer that works in Node.\n *\n * This network implementation should not be used in browsers as it does not\n * support progress updates.\n */\nclass FetchConnection {\n    constructor() {\n        this.errorText_ = '';\n        this.sent_ = false;\n        this.errorCode_ = ErrorCode.NO_ERROR;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError('cannot .send() more than once');\n        }\n        this.sent_ = true;\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.body_ = await response.arrayBuffer();\n        }\n        catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getErrorCode() {\n        if (this.errorCode_ === undefined) {\n            throw internalError('cannot .getErrorCode() before receiving response');\n        }\n        return this.errorCode_;\n    }\n    getStatus() {\n        if (this.statusCode_ === undefined) {\n            throw internalError('cannot .getStatus() before receiving response');\n        }\n        return this.statusCode_;\n    }\n    getErrorText() {\n        return this.errorText_;\n    }\n    abort() {\n        // Not supported\n    }\n    getResponseHeader(header) {\n        if (!this.headers_) {\n            throw internalError('cannot .getResponseHeader() before receiving response');\n        }\n        return this.headers_.get(header);\n    }\n    addUploadProgressListener(listener) {\n        // Not supported\n    }\n    removeUploadProgressListener(listener) {\n        // Not supported\n    }\n}\nclass FetchTextConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError('cannot .getResponse() before receiving response');\n        }\n        return Buffer.from(this.body_).toString('utf-8');\n    }\n}\nfunction newTextConnection() {\n    return textFactoryOverride\n        ? textFactoryOverride()\n        : new FetchTextConnection();\n}\nclass FetchBytesConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError('cannot .getResponse() before sending');\n        }\n        return this.body_;\n    }\n}\nfunction newBytesConnection() {\n    return new FetchBytesConnection();\n}\nclass FetchStreamConnection extends FetchConnection {\n    constructor() {\n        super(...arguments);\n        this.stream_ = null;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError('cannot .send() more than once');\n        }\n        this.sent_ = true;\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.stream_ = response.body;\n        }\n        catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getResponse() {\n        if (!this.stream_) {\n            throw internalError('cannot .getResponse() before sending');\n        }\n        return this.stream_;\n    }\n}\nfunction newStreamConnection() {\n    return new FetchStreamConnection();\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n * @internal\n */\nclass UploadTask {\n    isExponentialBackoffExpired() {\n        return this.sleepTime > this.maxSleepTime;\n    }\n    /**\n     * @param ref - The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob - The blob to upload.\n     */\n    constructor(ref, blob, metadata = null) {\n        /**\n         * Number of bytes transferred so far.\n         */\n        this._transferred = 0;\n        this._needToFetchStatus = false;\n        this._needToFetchMetadata = false;\n        this._observers = [];\n        this._error = undefined;\n        this._uploadUrl = undefined;\n        this._request = undefined;\n        this._chunkMultiplier = 1;\n        this._resolve = undefined;\n        this._reject = undefined;\n        this._ref = ref;\n        this._blob = blob;\n        this._metadata = metadata;\n        this._mappings = getMappings();\n        this._resumable = this._shouldDoResumable(this._blob);\n        this._state = \"running\" /* InternalTaskState.RUNNING */;\n        this._errorHandler = error => {\n            this._request = undefined;\n            this._chunkMultiplier = 1;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this._needToFetchStatus = true;\n                this.completeTransitions_();\n            }\n            else {\n                const backoffExpired = this.isExponentialBackoffExpired();\n                if (isRetryStatusCode(error.status, [])) {\n                    if (backoffExpired) {\n                        error = retryLimitExceeded();\n                    }\n                    else {\n                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);\n                        this._needToFetchStatus = true;\n                        this.completeTransitions_();\n                        return;\n                    }\n                }\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this._metadataErrorHandler = error => {\n            this._request = undefined;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this.completeTransitions_();\n            }\n            else {\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this.sleepTime = 0;\n        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n            this._start();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this._promise.then(null, () => { });\n    }\n    _makeProgressCallback() {\n        const sizeBefore = this._transferred;\n        return loaded => this._updateProgress(sizeBefore + loaded);\n    }\n    _shouldDoResumable(blob) {\n        return blob.size() > 256 * 1024;\n    }\n    _start() {\n        if (this._state !== \"running\" /* InternalTaskState.RUNNING */) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this._request !== undefined) {\n            return;\n        }\n        if (this._resumable) {\n            if (this._uploadUrl === undefined) {\n                this._createResumable();\n            }\n            else {\n                if (this._needToFetchStatus) {\n                    this._fetchStatus();\n                }\n                else {\n                    if (this._needToFetchMetadata) {\n                        // Happens if we miss the metadata on upload completion.\n                        this._fetchMetadata();\n                    }\n                    else {\n                        this.pendingTimeout = setTimeout(() => {\n                            this.pendingTimeout = undefined;\n                            this._continueUpload();\n                        }, this.sleepTime);\n                    }\n                }\n            }\n        }\n        else {\n            this._oneShotUpload();\n        }\n    }\n    _resolveToken(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.all([\n            this._ref.storage._getAuthToken(),\n            this._ref.storage._getAppCheckToken()\n        ]).then(([authToken, appCheckToken]) => {\n            switch (this._state) {\n                case \"running\" /* InternalTaskState.RUNNING */:\n                    callback(authToken, appCheckToken);\n                    break;\n                case \"canceling\" /* InternalTaskState.CANCELING */:\n                    this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                    break;\n                case \"pausing\" /* InternalTaskState.PAUSING */:\n                    this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                    break;\n            }\n        });\n    }\n    // TODO(andysoto): assert false\n    _createResumable() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = createRequest;\n            createRequest.getPromise().then((url) => {\n                this._request = undefined;\n                this._uploadUrl = url;\n                this._needToFetchStatus = false;\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _fetchStatus() {\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);\n            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = statusRequest;\n            statusRequest.getPromise().then(status => {\n                status = status;\n                this._request = undefined;\n                this._updateProgress(status.current);\n                this._needToFetchStatus = false;\n                if (status.finalized) {\n                    this._needToFetchMetadata = true;\n                }\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _continueUpload() {\n        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        const status = new ResumableUploadStatus(this._transferred, this._blob.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            let requestInfo;\n            try {\n                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());\n            }\n            catch (e) {\n                this._error = e;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n                return;\n            }\n            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, \n            /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.\n            );\n            this._request = uploadRequest;\n            uploadRequest.getPromise().then((newStatus) => {\n                this._increaseMultiplier();\n                this._request = undefined;\n                this._updateProgress(newStatus.current);\n                if (newStatus.finalized) {\n                    this._metadata = newStatus.metadata;\n                    this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n                }\n                else {\n                    this.completeTransitions_();\n                }\n            }, this._errorHandler);\n        });\n    }\n    _increaseMultiplier() {\n        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        // Max chunk size is 32M.\n        if (currentSize * 2 < 32 * 1024 * 1024) {\n            this._chunkMultiplier *= 2;\n        }\n    }\n    _fetchMetadata() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);\n            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = metadataRequest;\n            metadataRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._metadataErrorHandler);\n        });\n    }\n    _oneShotUpload() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = multipartRequest;\n            multipartRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._updateProgress(this._blob.size());\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._errorHandler);\n        });\n    }\n    _updateProgress(transferred) {\n        const old = this._transferred;\n        this._transferred = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this._transferred !== old) {\n            this._notifyObservers();\n        }\n    }\n    _transition(state) {\n        if (this._state === state) {\n            return;\n        }\n        switch (state) {\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                if (this._request !== undefined) {\n                    this._request.cancel();\n                }\n                else if (this.pendingTimeout) {\n                    clearTimeout(this.pendingTimeout);\n                    this.pendingTimeout = undefined;\n                    this.completeTransitions_();\n                }\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                const wasPaused = this._state === \"paused\" /* InternalTaskState.PAUSED */;\n                this._state = state;\n                if (wasPaused) {\n                    this._notifyObservers();\n                    this._start();\n                }\n                break;\n            case \"paused\" /* InternalTaskState.PAUSED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"canceled\" /* InternalTaskState.CANCELED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._error = canceled();\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"error\" /* InternalTaskState.ERROR */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"success\" /* InternalTaskState.SUCCESS */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n        }\n    }\n    completeTransitions_() {\n        switch (this._state) {\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                break;\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n                this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                this._start();\n                break;\n        }\n    }\n    /**\n     * A snapshot of the current task state.\n     */\n    get snapshot() {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        return {\n            bytesTransferred: this._transferred,\n            totalBytes: this._blob.size(),\n            state: externalState,\n            metadata: this._metadata,\n            task: this,\n            ref: this._ref\n        };\n    }\n    /**\n     * Adds a callback for an event.\n     * @param type - The type of event to listen for.\n     * @param nextOrObserver -\n     *     The `next` function, which gets called for each item in\n     *     the event stream, or an observer object with some or all of these three\n     *     properties (`next`, `error`, `complete`).\n     * @param error - A function that gets called with a `StorageError`\n     *     if the event stream ends due to an error.\n     * @param completed - A function that gets called if the\n     *     event stream ends normally.\n     * @returns\n     *     If only the event argument is passed, returns a function you can use to\n     *     add callbacks (see the examples above). If more than just the event\n     *     argument is passed, returns a function you can call to unregister the\n     *     callbacks.\n     */\n    on(type, nextOrObserver, error, completed) {\n        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.\n        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);\n        this._addObserver(observer);\n        return () => {\n            this._removeObserver(observer);\n        };\n    }\n    /**\n     * This object behaves like a Promise, and resolves with its snapshot data\n     * when the upload completes.\n     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.\n     * @param onRejected - The rejection callback.\n     */\n    then(onFulfilled, onRejected) {\n        // These casts are needed so that TypeScript can infer the types of the\n        // resulting Promise.\n        return this._promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Equivalent to calling `then(null, onRejected)`.\n     */\n    catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n    /**\n     * Adds the given observer.\n     */\n    _addObserver(observer) {\n        this._observers.push(observer);\n        this._notifyObserver(observer);\n    }\n    /**\n     * Removes the given observer.\n     */\n    _removeObserver(observer) {\n        const i = this._observers.indexOf(observer);\n        if (i !== -1) {\n            this._observers.splice(i, 1);\n        }\n    }\n    _notifyObservers() {\n        this._finishPromise();\n        const observers = this._observers.slice();\n        observers.forEach(observer => {\n            this._notifyObserver(observer);\n        });\n    }\n    _finishPromise() {\n        if (this._resolve !== undefined) {\n            let triggered = true;\n            switch (taskStateFromInternalTaskState(this._state)) {\n                case TaskState.SUCCESS:\n                    async(this._resolve.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    const toCall = this._reject;\n                    async(toCall.bind(null, this._error))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this._resolve = undefined;\n                this._reject = undefined;\n            }\n        }\n    }\n    _notifyObserver(observer) {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        switch (externalState) {\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next) {\n                    async(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete) {\n                    async(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n        }\n    }\n    /**\n     * Resumes a paused task. Has no effect on a currently running or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    resume() {\n        const valid = this._state === \"paused\" /* InternalTaskState.PAUSED */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"running\" /* InternalTaskState.RUNNING */);\n        }\n        return valid;\n    }\n    /**\n     * Pauses a currently running task. Has no effect on a paused or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    pause() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */;\n        if (valid) {\n            this._transition(\"pausing\" /* InternalTaskState.PAUSING */);\n        }\n        return valid;\n    }\n    /**\n     * Cancels a currently running or paused task. Has no effect on a complete or\n     * failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    cancel() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"canceling\" /* InternalTaskState.CANCELING */);\n        }\n        return valid;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides methods to interact with a bucket in the Firebase Storage service.\n * @internal\n * @param _location - An fbs.location, or the URL at\n *     which to base this object, in one of the following forms:\n *         gs://<bucket>/<object-path>\n *         http[s]://firebasestorage.googleapis.com/\n *                     <api-version>/b/<bucket>/o/<object-path>\n *     Any query or fragment strings will be ignored in the http[s]\n *     format. If no value is passed, the storage object will use a URL based on\n *     the project ID of the base firebase.App instance.\n */\nclass Reference {\n    constructor(_service, location) {\n        this._service = _service;\n        if (location instanceof Location) {\n            this._location = location;\n        }\n        else {\n            this._location = Location.makeFromUrl(location, _service.host);\n        }\n    }\n    /**\n     * Returns the URL for the bucket and path this object references,\n     *     in the form gs://<bucket>/<object-path>\n     * @override\n     */\n    toString() {\n        return 'gs://' + this._location.bucket + '/' + this._location.path;\n    }\n    _newRef(service, location) {\n        return new Reference(service, location);\n    }\n    /**\n     * A reference to the root of this object's bucket.\n     */\n    get root() {\n        const location = new Location(this._location.bucket, '');\n        return this._newRef(this._service, location);\n    }\n    /**\n     * The name of the bucket containing this reference's object.\n     */\n    get bucket() {\n        return this._location.bucket;\n    }\n    /**\n     * The full path of this object.\n     */\n    get fullPath() {\n        return this._location.path;\n    }\n    /**\n     * The short name of this object, which is the last component of the full path.\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\n     */\n    get name() {\n        return lastComponent(this._location.path);\n    }\n    /**\n     * The `StorageService` instance this `StorageReference` is associated with.\n     */\n    get storage() {\n        return this._service;\n    }\n    /**\n     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if\n     * this reference is the root.\n     */\n    get parent() {\n        const newPath = parent(this._location.path);\n        if (newPath === null) {\n            return null;\n        }\n        const location = new Location(this._location.bucket, newPath);\n        return new Reference(this._service, location);\n    }\n    /**\n     * Utility function to throw an error in methods that do not accept a root reference.\n     */\n    _throwIfRoot(name) {\n        if (this._location.path === '') {\n            throw invalidRootOperation(name);\n        }\n    }\n}\n/**\n * Download the bytes at the object's location.\n * @returns A Promise containing the downloaded bytes.\n */\nfunction getBytesInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getBytes');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newBytesConnection)\n        .then(bytes => maxDownloadSizeBytes !== undefined\n        ? // GCS may not honor the Range header for small files\n            bytes.slice(0, maxDownloadSizeBytes)\n        : bytes);\n}\n/** Stream the bytes at the object's location. */\nfunction getStreamInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getStream');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    // Transforms the stream so that only `maxDownloadSizeBytes` bytes are piped to the result\n    const newMaxSizeTransform = (n) => {\n        let missingBytes = n;\n        return {\n            transform(chunk, controller) {\n                // GCS may not honor the Range header for small files\n                if (chunk.length < missingBytes) {\n                    controller.enqueue(chunk);\n                    missingBytes -= chunk.length;\n                }\n                else {\n                    controller.enqueue(chunk.slice(0, missingBytes));\n                    controller.terminate();\n                }\n            }\n        };\n    };\n    const result = maxDownloadSizeBytes !== undefined\n        ? new TransformStream(newMaxSizeTransform(maxDownloadSizeBytes))\n        : new TransformStream(); // The default transformer forwards all chunks to its readable side\n    ref.storage\n        .makeRequestWithTokens(requestInfo, newStreamConnection)\n        .then(readableStream => readableStream.pipeThrough(result))\n        .catch(err => result.writable.abort(err));\n    return result.readable;\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n *\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytes');\n    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(finalMetadata => {\n        return {\n            metadata: finalMetadata,\n            ref\n        };\n    });\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytesResumable');\n    return new UploadTask(ref, new FbsBlob(data), metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - StorageReference where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the newly uploaded string.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString$1(ref, value, format = StringFormat.RAW, metadata) {\n    ref._throwIfRoot('uploadString');\n    const data = dataFromString(format, value);\n    const metadataClone = Object.assign({}, metadata);\n    if (metadataClone['contentType'] == null && data.contentType != null) {\n        metadataClone['contentType'] = data.contentType;\n    }\n    return uploadBytes$1(ref, data.data, metadataClone);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: listAll may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - StorageReference to get list from.\n *\n * @returns A Promise that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll$1(ref) {\n    const accumulator = {\n        prefixes: [],\n        items: []\n    };\n    return listAllHelper(ref, accumulator).then(() => accumulator);\n}\n/**\n * Separated from listAll because async functions can't use \"arguments\".\n * @param ref\n * @param accumulator\n * @param pageToken\n */\nasync function listAllHelper(ref, accumulator, pageToken) {\n    const opt = {\n        // maxResults is 1000 by default.\n        pageToken\n    };\n    const nextPage = await list$1(ref, opt);\n    accumulator.prefixes.push(...nextPage.prefixes);\n    accumulator.items.push(...nextPage.items);\n    if (nextPage.nextPageToken != null) {\n        await listAllHelper(ref, accumulator, nextPage.nextPageToken);\n    }\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - StorageReference to get list from.\n * @param options - See ListOptions for details.\n * @returns A Promise that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list$1(ref, options) {\n    if (options != null) {\n        if (typeof options.maxResults === 'number') {\n            validateNumber('options.maxResults', \n            /* minValue= */ 1, \n            /* maxValue= */ 1000, options.maxResults);\n        }\n    }\n    const op = options || {};\n    const requestInfo = list$2(ref.storage, ref._location, \n    /*delimiter= */ '/', op.pageToken, op.maxResults);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - StorageReference to get metadata from.\n */\nfunction getMetadata$1(ref) {\n    ref._throwIfRoot('getMetadata');\n    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - StorageReference to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves\n *     with the new metadata for this object.\n *     See `firebaseStorage.Reference.prototype.getMetadata`\n */\nfunction updateMetadata$1(ref, metadata) {\n    ref._throwIfRoot('updateMetadata');\n    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns the download URL for the given Reference.\n * @public\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL$1(ref) {\n    ref._throwIfRoot('getDownloadURL');\n    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(url => {\n        if (url === null) {\n            throw noDownloadURL();\n        }\n        return url;\n    });\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - StorageReference for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject$1(ref) {\n    ref._throwIfRoot('deleteObject');\n    const requestInfo = deleteObject$2(ref.storage, ref._location);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns reference for object obtained by appending `childPath` to `ref`.\n *\n * @param ref - StorageReference to get child of.\n * @param childPath - Child path from provided ref.\n * @returns A reference to the object obtained by\n * appending childPath, removing any duplicate, beginning, or trailing\n * slashes.\n *\n */\nfunction _getChild$1(ref, childPath) {\n    const newPath = child(ref._location.path, childPath);\n    const location = new Location(ref._location.bucket, newPath);\n    return new Reference(ref.storage, location);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isUrl(path) {\n    return /^[A-Za-z]+:\\/\\//.test(path);\n}\n/**\n * Returns a firebaseStorage.Reference for the given url.\n */\nfunction refFromURL(service, url) {\n    return new Reference(service, url);\n}\n/**\n * Returns a firebaseStorage.Reference for the given path in the default\n * bucket.\n */\nfunction refFromPath(ref, path) {\n    if (ref instanceof FirebaseStorageImpl) {\n        const service = ref;\n        if (service._bucket == null) {\n            throw noDefaultBucket();\n        }\n        const reference = new Reference(service, service._bucket);\n        if (path != null) {\n            return refFromPath(reference, path);\n        }\n        else {\n            return reference;\n        }\n    }\n    else {\n        // ref is a Reference\n        if (path !== undefined) {\n            return _getChild$1(ref, path);\n        }\n        else {\n            return ref;\n        }\n    }\n}\nfunction ref$1(serviceOrRef, pathOrUrl) {\n    if (pathOrUrl && isUrl(pathOrUrl)) {\n        if (serviceOrRef instanceof FirebaseStorageImpl) {\n            return refFromURL(serviceOrRef, pathOrUrl);\n        }\n        else {\n            throw invalidArgument('To use ref(service, url), the first argument must be a Storage instance.');\n        }\n    }\n    else {\n        return refFromPath(serviceOrRef, pathOrUrl);\n    }\n}\nfunction extractBucket(host, config) {\n    const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];\n    if (bucketString == null) {\n        return null;\n    }\n    return Location.makeFromBucketSpec(bucketString, host);\n}\nfunction connectStorageEmulator$1(storage, host, port, options = {}) {\n    storage.host = `${host}:${port}`;\n    storage._protocol = 'http';\n    const { mockUserToken } = options;\n    if (mockUserToken) {\n        storage._overrideAuthToken =\n            typeof mockUserToken === 'string'\n                ? mockUserToken\n                : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(mockUserToken, storage.app.options.projectId);\n    }\n}\n/**\n * A service that provides Firebase Storage Reference instances.\n * @param opt_url - gs:// url to a custom Storage Bucket\n *\n * @internal\n */\nclass FirebaseStorageImpl {\n    constructor(\n    /**\n     * FirebaseApp associated with this StorageService instance.\n     */\n    app, _authProvider, \n    /**\n     * @internal\n     */\n    _appCheckProvider, \n    /**\n     * @internal\n     */\n    _url, _firebaseVersion) {\n        this.app = app;\n        this._authProvider = _authProvider;\n        this._appCheckProvider = _appCheckProvider;\n        this._url = _url;\n        this._firebaseVersion = _firebaseVersion;\n        this._bucket = null;\n        /**\n         * This string can be in the formats:\n         * - host\n         * - host:port\n         */\n        this._host = DEFAULT_HOST;\n        this._protocol = 'https';\n        this._appId = null;\n        this._deleted = false;\n        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;\n        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;\n        this._requests = new Set();\n        if (_url != null) {\n            this._bucket = Location.makeFromBucketSpec(_url, this._host);\n        }\n        else {\n            this._bucket = extractBucket(this._host, this.app.options);\n        }\n    }\n    /**\n     * The host string for this service, in the form of `host` or\n     * `host:port`.\n     */\n    get host() {\n        return this._host;\n    }\n    set host(host) {\n        this._host = host;\n        if (this._url != null) {\n            this._bucket = Location.makeFromBucketSpec(this._url, host);\n        }\n        else {\n            this._bucket = extractBucket(host, this.app.options);\n        }\n    }\n    /**\n     * The maximum time to retry uploads in milliseconds.\n     */\n    get maxUploadRetryTime() {\n        return this._maxUploadRetryTime;\n    }\n    set maxUploadRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxUploadRetryTime = time;\n    }\n    /**\n     * The maximum time to retry operations other than uploads or downloads in\n     * milliseconds.\n     */\n    get maxOperationRetryTime() {\n        return this._maxOperationRetryTime;\n    }\n    set maxOperationRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxOperationRetryTime = time;\n    }\n    async _getAuthToken() {\n        if (this._overrideAuthToken) {\n            return this._overrideAuthToken;\n        }\n        const auth = this._authProvider.getImmediate({ optional: true });\n        if (auth) {\n            const tokenData = await auth.getToken();\n            if (tokenData !== null) {\n                return tokenData.accessToken;\n            }\n        }\n        return null;\n    }\n    async _getAppCheckToken() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app) && this.app.settings.appCheckToken) {\n            return this.app.settings.appCheckToken;\n        }\n        const appCheck = this._appCheckProvider.getImmediate({ optional: true });\n        if (appCheck) {\n            const result = await appCheck.getToken();\n            // TODO: What do we want to do if there is an error getting the token?\n            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be\n            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            return result.token;\n        }\n        return null;\n    }\n    /**\n     * Stop running requests and prevent more from being created.\n     */\n    _delete() {\n        if (!this._deleted) {\n            this._deleted = true;\n            this._requests.forEach(request => request.cancel());\n            this._requests.clear();\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Returns a new firebaseStorage.Reference object referencing this StorageService\n     * at the given Location.\n     */\n    _makeStorageReference(loc) {\n        return new Reference(this, loc);\n    }\n    /**\n     * @param requestInfo - HTTP RequestInfo object\n     * @param authToken - Firebase auth token\n     */\n    _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {\n        if (!this._deleted) {\n            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry);\n            this._requests.add(request);\n            // Request removes itself from set when complete.\n            request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));\n            return request;\n        }\n        else {\n            return new FailRequest(appDeleted());\n        }\n    }\n    async makeRequestWithTokens(requestInfo, requestFactory) {\n        const [authToken, appCheckToken] = await Promise.all([\n            this._getAuthToken(),\n            this._getAppCheckToken()\n        ]);\n        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();\n    }\n}\n\nconst name = \"@firebase/storage\";\nconst version = \"0.13.6\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Type constant for Firebase Storage.\n */\nconst STORAGE_TYPE = 'storage';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise containing the object's bytes\n */\nfunction getBytes(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getBytesInternal(ref, maxDownloadSizeBytes);\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytes$1(ref, data, metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the string to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString(ref, value, format, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadString$1(ref, value, format, metadata);\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytesResumable$1(ref, data, metadata);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - {@link StorageReference} to get metadata from.\n */\nfunction getMetadata(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getMetadata$1(ref);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - {@link StorageReference} to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves with the new metadata for this object.\n */\nfunction updateMetadata(ref, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return updateMetadata$1(ref, metadata);\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - {@link StorageReference} to get list from.\n * @param options - See {@link ListOptions} for details.\n * @returns A `Promise` that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list(ref, options) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return list$1(ref, options);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: `listAll` may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - {@link StorageReference} to get list from.\n *\n * @returns A `Promise` that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return listAll$1(ref);\n}\n/**\n * Returns the download URL for the given {@link StorageReference}.\n * @public\n * @param ref - {@link StorageReference} to get the download URL for.\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getDownloadURL$1(ref);\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - {@link StorageReference} for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return deleteObject$1(ref);\n}\nfunction ref(serviceOrRef, pathOrUrl) {\n    serviceOrRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(serviceOrRef);\n    return ref$1(serviceOrRef, pathOrUrl);\n}\n/**\n * @internal\n */\nfunction _getChild(ref, childPath) {\n    return _getChild$1(ref, childPath);\n}\n/**\n * Gets a {@link FirebaseStorage} instance for the given Firebase app.\n * @public\n * @param app - Firebase app to get {@link FirebaseStorage} instance for.\n * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.\n * If not passed, uses the app's default Storage Bucket.\n * @returns A {@link FirebaseStorage} instance.\n */\nfunction getStorage(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), bucketUrl) {\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app);\n    const storageProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, STORAGE_TYPE);\n    const storageInstance = storageProvider.getImmediate({\n        identifier: bucketUrl\n    });\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('storage');\n    if (emulator) {\n        connectStorageEmulator(storageInstance, ...emulator);\n    }\n    return storageInstance;\n}\n/**\n * Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.\n *\n * @param storage - The {@link FirebaseStorage} instance\n * @param host - The emulator host (ex: localhost)\n * @param port - The emulator port (ex: 5001)\n * @param options - Emulator options. `options.mockUserToken` is the mock auth\n * token to use for unit testing Security Rules.\n * @public\n */\nfunction connectStorageEmulator(storage, host, port, options = {}) {\n    connectStorageEmulator$1(storage, host, port, options);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * This API is not available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise that resolves with a Blob containing the object's bytes\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getBlob(ref, maxDownloadSizeBytes) {\n    throw new Error('getBlob() is only available in Browser-like environments');\n}\n/**\n * Downloads the data at the object's location. Raises an error event if the\n * object is not found.\n *\n * This API is only available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A stream with the object's data as bytes\n */\nfunction getStream(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getStreamInternal(ref, maxDownloadSizeBytes);\n}\n\n/**\n * Cloud Storage for Firebase\n *\n * @packageDocumentation\n */\nfunction factory(container, { instanceIdentifier: url }) {\n    const app = container.getProvider('app').getImmediate();\n    const authProvider = container.getProvider('auth-internal');\n    const appCheckProvider = container.getProvider('app-check-internal');\n    return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n}\nfunction registerStorage() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(STORAGE_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n}\nregisterStorage();\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDRjtBQUMzRTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTLEdBQUcsa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLElBQUksK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxvQkFBb0IsR0FBRyxRQUFRLEtBQUssYUFBYSxJQUFJLG9CQUFvQjtBQUN2SSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGlCQUFpQjtBQUNoSCxzQ0FBc0M7QUFDdEM7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsY0FBYyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxjQUFjLFVBQVU7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0EsY0FBYyxTQUFTLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLHNCQUFzQixLQUFLLEdBQUcsS0FBSztBQUNuQztBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0EsMEJBQTBCLHFEQUFNO0FBQ2hDLFVBQVUsa0VBQWtCO0FBQzVCLDRCQUE0QiwyREFBWTtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixpRkFBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzREFBVztBQUN4RjtBQUNBO0FBQ0EsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQyxJQUFJLDhEQUFlO0FBQ25CO0FBQ0E7O0FBRXFmO0FBQ3JmIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfaXNGaXJlYmFzZVNlcnZlckFwcCwgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBTREtfVkVSU0lPTiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgY3JlYXRlTW9ja1VzZXJUb2tlbiwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgdXNlZCBpbiB0aGUgRmlyZWJhc2UgU3RvcmFnZSBsaWJyYXJ5LlxuICovXG4vKipcbiAqIERvbWFpbiBuYW1lIGZvciBmaXJlYmFzZSBzdG9yYWdlLlxuICovXG5jb25zdCBERUZBVUxUX0hPU1QgPSAnZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tJztcbi8qKlxuICogVGhlIGtleSBpbiBGaXJlYmFzZSBjb25maWcganNvbiBmb3IgdGhlIHN0b3JhZ2UgYnVja2V0LlxuICovXG5jb25zdCBDT05GSUdfU1RPUkFHRV9CVUNLRVRfS0VZID0gJ3N0b3JhZ2VCdWNrZXQnO1xuLyoqXG4gKiAyIG1pbnV0ZXNcbiAqXG4gKiBUaGUgdGltZW91dCBmb3IgYWxsIG9wZXJhdGlvbnMgZXhjZXB0IHVwbG9hZC5cbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfT1BFUkFUSU9OX1JFVFJZX1RJTUUgPSAyICogNjAgKiAxMDAwO1xuLyoqXG4gKiAxMCBtaW51dGVzXG4gKlxuICogVGhlIHRpbWVvdXQgZm9yIHVwbG9hZC5cbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfVVBMT0FEX1JFVFJZX1RJTUUgPSAxMCAqIDYwICogMTAwMDtcbi8qKlxuICogMSBzZWNvbmRcbiAqL1xuY29uc3QgREVGQVVMVF9NSU5fU0xFRVBfVElNRV9NSUxMSVMgPSAxMDAwO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBlcnJvciByZXR1cm5lZCBieSB0aGUgRmlyZWJhc2UgU3RvcmFnZSBTREsuXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb2RlIC0gQSBgU3RvcmFnZUVycm9yQ29kZWAgc3RyaW5nIHRvIGJlIHByZWZpeGVkIHdpdGggJ3N0b3JhZ2UvJyBhbmRcbiAgICAgKiAgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAgLSBFcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBzdGF0dXNfIC0gQ29ycmVzcG9uZGluZyBIVFRQIFN0YXR1cyBDb2RlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgc3RhdHVzXyA9IDApIHtcbiAgICAgICAgc3VwZXIocHJlcGVuZENvZGUoY29kZSksIGBGaXJlYmFzZSBTdG9yYWdlOiAke21lc3NhZ2V9ICgke3ByZXBlbmRDb2RlKGNvZGUpfSlgKTtcbiAgICAgICAgdGhpcy5zdGF0dXNfID0gc3RhdHVzXztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyBjdXN0b20gZXJyb3IgZGF0YSB1bmlxdWUgdG8gdGhlIGBTdG9yYWdlRXJyb3JgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0geyBzZXJ2ZXJSZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB0aGlzLl9iYXNlTWVzc2FnZSA9IHRoaXMubWVzc2FnZTtcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBgaW5zdGFuY2VvZiBTdG9yYWdlRXJyb3JgLCBpbiB0ZXN0cyBmb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gcmV0dXJucyBmYWxzZS5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFN0b3JhZ2VFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNfO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIGEgYFN0b3JhZ2VFcnJvckNvZGVgIGFnYWluc3QgdGhpcyBlcnJvcidzIGNvZGUsIGZpbHRlcmluZyBvdXQgdGhlIHByZWZpeC5cbiAgICAgKi9cbiAgICBfY29kZUVxdWFscyhjb2RlKSB7XG4gICAgICAgIHJldHVybiBwcmVwZW5kQ29kZShjb2RlKSA9PT0gdGhpcy5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCByZXNwb25zZSBtZXNzYWdlIHRoYXQgd2FzIGFkZGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgZ2V0IHNlcnZlclJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EYXRhLnNlcnZlclJlc3BvbnNlO1xuICAgIH1cbiAgICBzZXQgc2VydmVyUmVzcG9uc2Uoc2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhLnNlcnZlclJlc3BvbnNlID0gc2VydmVyUmVzcG9uc2U7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke3RoaXMuX2Jhc2VNZXNzYWdlfVxcbiR7dGhpcy5jdXN0b21EYXRhLnNlcnZlclJlc3BvbnNlfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLl9iYXNlTWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHB1YmxpY1xuICogRXJyb3IgY29kZXMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYFN0b3JhZ2VFcnJvcmAgb2JqZWN0cy5cbiAqL1xudmFyIFN0b3JhZ2VFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFN0b3JhZ2VFcnJvckNvZGUpIHtcbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBhbGwgcGxhdGZvcm1zXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiT0JKRUNUX05PVF9GT1VORFwiXSA9IFwib2JqZWN0LW5vdC1mb3VuZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJCVUNLRVRfTk9UX0ZPVU5EXCJdID0gXCJidWNrZXQtbm90LWZvdW5kXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlBST0pFQ1RfTk9UX0ZPVU5EXCJdID0gXCJwcm9qZWN0LW5vdC1mb3VuZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJRVU9UQV9FWENFRURFRFwiXSA9IFwicXVvdGEtZXhjZWVkZWRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gXCJ1bmF1dGhlbnRpY2F0ZWRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5BVVRIT1JJWkVEXCJdID0gXCJ1bmF1dGhvcml6ZWRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5BVVRIT1JJWkVEX0FQUFwiXSA9IFwidW5hdXRob3JpemVkLWFwcFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJSRVRSWV9MSU1JVF9FWENFRURFRFwiXSA9IFwicmV0cnktbGltaXQtZXhjZWVkZWRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9DSEVDS1NVTVwiXSA9IFwiaW52YWxpZC1jaGVja3N1bVwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJDQU5DRUxFRFwiXSA9IFwiY2FuY2VsZWRcIjtcbiAgICAvLyBKUyBzcGVjaWZpY1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0VWRU5UX05BTUVcIl0gPSBcImludmFsaWQtZXZlbnQtbmFtZVwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX1VSTFwiXSA9IFwiaW52YWxpZC11cmxcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9ERUZBVUxUX0JVQ0tFVFwiXSA9IFwiaW52YWxpZC1kZWZhdWx0LWJ1Y2tldFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJOT19ERUZBVUxUX0JVQ0tFVFwiXSA9IFwibm8tZGVmYXVsdC1idWNrZXRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQ0FOTk9UX1NMSUNFX0JMT0JcIl0gPSBcImNhbm5vdC1zbGljZS1ibG9iXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlNFUlZFUl9GSUxFX1dST05HX1NJWkVcIl0gPSBcInNlcnZlci1maWxlLXdyb25nLXNpemVcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiTk9fRE9XTkxPQURfVVJMXCJdID0gXCJuby1kb3dubG9hZC11cmxcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiaW52YWxpZC1hcmd1bWVudFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UX0NPVU5UXCJdID0gXCJpbnZhbGlkLWFyZ3VtZW50LWNvdW50XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkFQUF9ERUxFVEVEXCJdID0gXCJhcHAtZGVsZXRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX1JPT1RfT1BFUkFUSU9OXCJdID0gXCJpbnZhbGlkLXJvb3Qtb3BlcmF0aW9uXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfRk9STUFUXCJdID0gXCJpbnZhbGlkLWZvcm1hdFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlRFUk5BTF9FUlJPUlwiXSA9IFwiaW50ZXJuYWwtZXJyb3JcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfRU5WSVJPTk1FTlRcIl0gPSBcInVuc3VwcG9ydGVkLWVudmlyb25tZW50XCI7XG59KShTdG9yYWdlRXJyb3JDb2RlIHx8IChTdG9yYWdlRXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIHByZXBlbmRDb2RlKGNvZGUpIHtcbiAgICByZXR1cm4gJ3N0b3JhZ2UvJyArIGNvZGU7XG59XG5mdW5jdGlvbiB1bmtub3duKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCwgcGxlYXNlIGNoZWNrIHRoZSBlcnJvciBwYXlsb2FkIGZvciAnICtcbiAgICAgICAgJ3NlcnZlciByZXNwb25zZS4nO1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5LTk9XTiwgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBvYmplY3ROb3RGb3VuZChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5PQkpFQ1RfTk9UX0ZPVU5ELCBcIk9iamVjdCAnXCIgKyBwYXRoICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcbn1cbmZ1bmN0aW9uIHF1b3RhRXhjZWVkZWQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5RVU9UQV9FWENFRURFRCwgXCJRdW90YSBmb3IgYnVja2V0ICdcIiArXG4gICAgICAgIGJ1Y2tldCArXG4gICAgICAgIFwiJyBleGNlZWRlZCwgcGxlYXNlIHZpZXcgcXVvdGEgb24gXCIgK1xuICAgICAgICAnaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3ByaWNpbmcvLicpO1xufVxuZnVuY3Rpb24gdW5hdXRoZW50aWNhdGVkKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVXNlciBpcyBub3QgYXV0aGVudGljYXRlZCwgcGxlYXNlIGF1dGhlbnRpY2F0ZSB1c2luZyBGaXJlYmFzZSAnICtcbiAgICAgICAgJ0F1dGhlbnRpY2F0aW9uIGFuZCB0cnkgYWdhaW4uJztcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSEVOVElDQVRFRCwgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiB1bmF1dGhvcml6ZWRBcHAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTkFVVEhPUklaRURfQVBQLCAnVGhpcyBhcHAgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyBGaXJlYmFzZSBTdG9yYWdlIG9uIHRoaXMgcHJvamVjdC4nKTtcbn1cbmZ1bmN0aW9uIHVuYXV0aG9yaXplZChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTkFVVEhPUklaRUQsIFwiVXNlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzICdcIiArIHBhdGggKyBcIicuXCIpO1xufVxuZnVuY3Rpb24gcmV0cnlMaW1pdEV4Y2VlZGVkKCkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuUkVUUllfTElNSVRfRVhDRUVERUQsICdNYXggcmV0cnkgdGltZSBmb3Igb3BlcmF0aW9uIGV4Y2VlZGVkLCBwbGVhc2UgdHJ5IGFnYWluLicpO1xufVxuZnVuY3Rpb24gY2FuY2VsZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5DQU5DRUxFRCwgJ1VzZXIgY2FuY2VsZWQgdGhlIHVwbG9hZC9kb3dubG9hZC4nKTtcbn1cbmZ1bmN0aW9uIGludmFsaWRVcmwodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX1VSTCwgXCJJbnZhbGlkIFVSTCAnXCIgKyB1cmwgKyBcIicuXCIpO1xufVxuZnVuY3Rpb24gaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX0RFRkFVTFRfQlVDS0VULCBcIkludmFsaWQgZGVmYXVsdCBidWNrZXQgJ1wiICsgYnVja2V0ICsgXCInLlwiKTtcbn1cbmZ1bmN0aW9uIG5vRGVmYXVsdEJ1Y2tldCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk5PX0RFRkFVTFRfQlVDS0VULCAnTm8gZGVmYXVsdCBidWNrZXQgJyArXG4gICAgICAgIFwiZm91bmQuIERpZCB5b3Ugc2V0IHRoZSAnXCIgK1xuICAgICAgICBDT05GSUdfU1RPUkFHRV9CVUNLRVRfS0VZICtcbiAgICAgICAgXCInIHByb3BlcnR5IHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBhcHA/XCIpO1xufVxuZnVuY3Rpb24gY2Fubm90U2xpY2VCbG9iKCkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuQ0FOTk9UX1NMSUNFX0JMT0IsICdDYW5ub3Qgc2xpY2UgYmxvYiBmb3IgdXBsb2FkLiBQbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC4nKTtcbn1cbmZ1bmN0aW9uIHNlcnZlckZpbGVXcm9uZ1NpemUoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5TRVJWRVJfRklMRV9XUk9OR19TSVpFLCAnU2VydmVyIHJlY29yZGVkIGluY29ycmVjdCB1cGxvYWQgZmlsZSBzaXplLCBwbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC4nKTtcbn1cbmZ1bmN0aW9uIG5vRG93bmxvYWRVUkwoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5OT19ET1dOTE9BRF9VUkwsICdUaGUgZ2l2ZW4gZmlsZSBkb2VzIG5vdCBoYXZlIGFueSBkb3dubG9hZCBVUkxzLicpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW52YWxpZEFyZ3VtZW50KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfQVJHVU1FTlQsIG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gYXBwRGVsZXRlZCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLkFQUF9ERUxFVEVELCAnVGhlIEZpcmViYXNlIGFwcCB3YXMgZGVsZXRlZC4nKTtcbn1cbi8qKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRoYXQgd2FzIGludmFsaWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfUk9PVF9PUEVSQVRJT04sIFwiVGhlIG9wZXJhdGlvbiAnXCIgK1xuICAgICAgICBuYW1lICtcbiAgICAgICAgXCInIGNhbm5vdCBiZSBwZXJmb3JtZWQgb24gYSByb290IHJlZmVyZW5jZSwgY3JlYXRlIGEgbm9uLXJvb3QgXCIgK1xuICAgICAgICBcInJlZmVyZW5jZSB1c2luZyBjaGlsZCwgc3VjaCBhcyAuY2hpbGQoJ2ZpbGUucG5nJykuXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0aGF0IHdhcyBub3QgdmFsaWQuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBmb3JtYXQgdmlvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9GT1JNQVQsIFwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIGZvcm1hdCAnXCIgKyBmb3JtYXQgKyBcIic6IFwiICsgbWVzc2FnZSk7XG59XG4vKipcbiAqIEBwYXJhbSBtZXNzYWdlIC0gQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGludGVybmFsIGVycm9yLlxuICovXG5mdW5jdGlvbiBpbnRlcm5hbEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsICdJbnRlcm5hbCBlcnJvcjogJyArIG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBGaXJlYmFzZSBTdG9yYWdlIGxvY2F0aW9uIGRhdGEuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIExvY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIHBhdGgpIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aF87XG4gICAgfVxuICAgIGdldCBpc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmdWxsU2VydmVyVXJsKCkge1xuICAgICAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAnL2IvJyArIGVuY29kZSh0aGlzLmJ1Y2tldCkgKyAnL28vJyArIGVuY29kZSh0aGlzLnBhdGgpO1xuICAgIH1cbiAgICBidWNrZXRPbmx5U2VydmVyVXJsKCkge1xuICAgICAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAnL2IvJyArIGVuY29kZSh0aGlzLmJ1Y2tldCkgKyAnL28nO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUZyb21CdWNrZXRTcGVjKGJ1Y2tldFN0cmluZywgaG9zdCkge1xuICAgICAgICBsZXQgYnVja2V0TG9jYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBidWNrZXRMb2NhdGlvbiA9IExvY2F0aW9uLm1ha2VGcm9tVXJsKGJ1Y2tldFN0cmluZywgaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5vdCB2YWxpZCBVUkwsIHVzZSBhcy1pcy4gVGhpcyBsZXRzIHlvdSBwdXQgYmFyZSBidWNrZXQgbmFtZXMgaW5cbiAgICAgICAgICAgIC8vIGNvbmZpZy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9jYXRpb24oYnVja2V0U3RyaW5nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1Y2tldExvY2F0aW9uLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVja2V0TG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkRGVmYXVsdEJ1Y2tldChidWNrZXRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlRnJvbVVybCh1cmwsIGhvc3QpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgY29uc3QgYnVja2V0RG9tYWluID0gJyhbQS1aYS16MC05LlxcXFwtX10rKSc7XG4gICAgICAgIGZ1bmN0aW9uIGdzTW9kaWZ5KGxvYykge1xuICAgICAgICAgICAgaWYgKGxvYy5wYXRoLmNoYXJBdChsb2MucGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgbG9jLnBhdGhfID0gbG9jLnBhdGhfLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnc1BhdGggPSAnKC8oLiopKT8kJztcbiAgICAgICAgY29uc3QgZ3NSZWdleCA9IG5ldyBSZWdFeHAoJ15nczovLycgKyBidWNrZXREb21haW4gKyBnc1BhdGgsICdpJyk7XG4gICAgICAgIGNvbnN0IGdzSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAzIH07XG4gICAgICAgIGZ1bmN0aW9uIGh0dHBNb2RpZnkobG9jKSB7XG4gICAgICAgICAgICBsb2MucGF0aF8gPSBkZWNvZGVVUklDb21wb25lbnQobG9jLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAndltBLVphLXowLTlfXSsnO1xuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VIb3N0ID0gaG9zdC5yZXBsYWNlKC9bLl0vZywgJ1xcXFwuJyk7XG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZVBhdGggPSAnKC8oW14/I10qKS4qKT8kJztcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlUmVnRXhwID0gbmV3IFJlZ0V4cChgXmh0dHBzPzovLyR7ZmlyZWJhc2VTdG9yYWdlSG9zdH0vJHt2ZXJzaW9ufS9iLyR7YnVja2V0RG9tYWlufS9vJHtmaXJlYmFzZVN0b3JhZ2VQYXRofWAsICdpJyk7XG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZUluZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VIb3N0ID0gaG9zdCA9PT0gREVGQVVMVF9IT1NUXG4gICAgICAgICAgICA/ICcoPzpzdG9yYWdlLmdvb2dsZWFwaXMuY29tfHN0b3JhZ2UuY2xvdWQuZ29vZ2xlLmNvbSknXG4gICAgICAgICAgICA6IGhvc3Q7XG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZVBhdGggPSAnKFtePyNdKiknO1xuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VSZWdFeHAgPSBuZXcgUmVnRXhwKGBeaHR0cHM/Oi8vJHtjbG91ZFN0b3JhZ2VIb3N0fS8ke2J1Y2tldERvbWFpbn0vJHtjbG91ZFN0b3JhZ2VQYXRofWAsICdpJyk7XG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZUluZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMiB9O1xuICAgICAgICBjb25zdCBncm91cHMgPSBbXG4gICAgICAgICAgICB7IHJlZ2V4OiBnc1JlZ2V4LCBpbmRpY2VzOiBnc0luZGljZXMsIHBvc3RNb2RpZnk6IGdzTW9kaWZ5IH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVnZXg6IGZpcmViYXNlU3RvcmFnZVJlZ0V4cCxcbiAgICAgICAgICAgICAgICBpbmRpY2VzOiBmaXJlYmFzZVN0b3JhZ2VJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHBvc3RNb2RpZnk6IGh0dHBNb2RpZnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVnZXg6IGNsb3VkU3RvcmFnZVJlZ0V4cCxcbiAgICAgICAgICAgICAgICBpbmRpY2VzOiBjbG91ZFN0b3JhZ2VJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHBvc3RNb2RpZnk6IGh0dHBNb2RpZnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBncm91cC5yZWdleC5leGVjKHVybCk7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWNrZXRWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMuYnVja2V0XTtcbiAgICAgICAgICAgICAgICBsZXQgcGF0aFZhbHVlID0gY2FwdHVyZXNbZ3JvdXAuaW5kaWNlcy5wYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24oYnVja2V0VmFsdWUsIHBhdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZ3JvdXAucG9zdE1vZGlmeShsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRVcmwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEEgcmVxdWVzdCB3aG9zZSBwcm9taXNlIGFsd2F5cyBmYWlscy5cbiAqL1xuY2xhc3MgRmFpbFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGdldFByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VfO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBjYW5jZWwoX2FwcERlbGV0ZSA9IGZhbHNlKSB7IH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQWNjZXB0cyBhIGNhbGxiYWNrIGZvciBhbiBhY3Rpb24gdG8gcGVyZm9ybSAoYGRvUmVxdWVzdGApLFxuICogYW5kIHRoZW4gYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgYmFja29mZiBoYXMgY29tcGxldGVkIChgYmFja29mZkNvbXBsZXRlQ2JgKS5cbiAqIFRoZSBjYWxsYmFjayBzZW50IHRvIHN0YXJ0IHJlcXVpcmVzIGFuIGFyZ3VtZW50IHRvIGNhbGwgKGBvblJlcXVlc3RDb21wbGV0ZWApLlxuICogV2hlbiBgc3RhcnRgIGNhbGxzIGBkb1JlcXVlc3RgLCBpdCBwYXNzZXMgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgcmVxdWVzdCBoYXNcbiAqIGNvbXBsZXRlZCwgYG9uUmVxdWVzdENvbXBsZXRlYC4gQmFzZWQgb24gdGhpcywgdGhlIGJhY2tvZmYgY29udGludWVzLCB3aXRoXG4gKiBhbm90aGVyIGNhbGwgdG8gYGRvUmVxdWVzdGAgYW5kIHRoZSBhYm92ZSBsb29wIGNvbnRpbnVlcyB1bnRpbCB0aGUgdGltZW91dFxuICogaXMgaGl0LCBvciBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2NjdXJzLlxuICogQGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0gZG9SZXF1ZXN0IENhbGxiYWNrIHRvIHBlcmZvcm0gcmVxdWVzdFxuICogQHBhcmFtIGJhY2tvZmZDb21wbGV0ZUNiIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBiYWNrb2ZmIGhhcyBiZWVuIGNvbXBsZXRlZFxuICovXG5mdW5jdGlvbiBzdGFydChkb1JlcXVlc3QsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmJhY2tvZmZDb21wbGV0ZUNiLCB0aW1lb3V0KSB7XG4gICAgLy8gVE9ETyhhbmR5c290byk6IG1ha2UgdGhpcyBjb2RlIGNsZWFuZXIgKHByb2JhYmx5IHJlZmFjdG9yIGludG8gYW4gYWN0dWFsXG4gICAgLy8gdHlwZSBpbnN0ZWFkIG9mIGEgYnVuY2ggb2YgZnVuY3Rpb25zIHdpdGggc3RhdGUgc2hhcmVkIGluIHRoZSBjbG9zdXJlKVxuICAgIGxldCB3YWl0U2Vjb25kcyA9IDE7XG4gICAgLy8gV291bGQgdHlwZSB0aGlzIGFzIFwibnVtYmVyXCIgYnV0IHRoYXQgZG9lc24ndCB3b3JrIGZvciBOb2RlIHNvIMKvXFxfKOODhClfL8KvXG4gICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBleGNsdWRlIE5vZGUgdHlwZSBkZWZpbml0aW9uIGZvciBzdG9yYWdlIGJlY2F1c2Ugc3RvcmFnZSBvbmx5IHdvcmtzIGluIGJyb3dzZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCByZXRyeVRpbWVvdXRJZCA9IG51bGw7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgZ2xvYmFsVGltZW91dElkID0gbnVsbDtcbiAgICBsZXQgaGl0VGltZW91dCA9IGZhbHNlO1xuICAgIGxldCBjYW5jZWxTdGF0ZSA9IDA7XG4gICAgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XG4gICAgICAgIHJldHVybiBjYW5jZWxTdGF0ZSA9PT0gMjtcbiAgICB9XG4gICAgbGV0IHRyaWdnZXJlZENhbGxiYWNrID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gdHJpZ2dlckNhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0cmlnZ2VyZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgdHJpZ2dlcmVkQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgYmFja29mZkNvbXBsZXRlQ2IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFdpdGhEZWxheShtaWxsaXMpIHtcbiAgICAgICAgcmV0cnlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHJ5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIGRvUmVxdWVzdChyZXNwb25zZUhhbmRsZXIsIGNhbmNlbGVkKCkpO1xuICAgICAgICB9LCBtaWxsaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckdsb2JhbFRpbWVvdXQoKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChnbG9iYWxUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihzdWNjZXNzLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xuICAgICAgICAgICAgdHJpZ2dlckNhbGxiYWNrLmNhbGwobnVsbCwgc3VjY2VzcywgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXVzdFN0b3AgPSBjYW5jZWxlZCgpIHx8IGhpdFRpbWVvdXQ7XG4gICAgICAgIGlmIChtdXN0U3RvcCkge1xuICAgICAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0cmlnZ2VyQ2FsbGJhY2suY2FsbChudWxsLCBzdWNjZXNzLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FpdFNlY29uZHMgPCA2NCkge1xuICAgICAgICAgICAgLyogVE9ETyhhbmR5c290byk6IGRvbid0IGJhY2sgb2ZmIHNvIHF1aWNrbHkgaWYgd2Uga25vdyB3ZSdyZSBvZmZsaW5lLiAqL1xuICAgICAgICAgICAgd2FpdFNlY29uZHMgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FpdE1pbGxpcztcbiAgICAgICAgaWYgKGNhbmNlbFN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XG4gICAgICAgICAgICB3YWl0TWlsbGlzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAod2FpdFNlY29uZHMgKyBNYXRoLnJhbmRvbSgpKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhEZWxheSh3YWl0TWlsbGlzKTtcbiAgICB9XG4gICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzdG9wKHdhc1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0cmlnZ2VyZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyeVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZW91dElkKTtcbiAgICAgICAgICAgIGNhbGxXaXRoRGVsYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXdhc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbFdpdGhEZWxheSgwKTtcbiAgICBnbG9iYWxUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaGl0VGltZW91dCA9IHRydWU7XG4gICAgICAgIHN0b3AodHJ1ZSk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG4vKipcbiAqIFN0b3BzIHRoZSByZXRyeSBsb29wIGZyb20gcmVwZWF0aW5nLlxuICogSWYgdGhlIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBcImluIGJldHdlZW5cIiByZXRyaWVzLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XG4gKiB3aXRoIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGFzIFwidHJ1ZVwiLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW52b2tlZCBvbmNlIG1vcmVcbiAqIGFmdGVyIHRoZSBjdXJyZW50IGludm9jYXRpb24gZmluaXNoZXMgaWZmIHRoZSBjdXJyZW50IGludm9jYXRpb24gd291bGQgaGF2ZVxuICogdHJpZ2dlcmVkIGFub3RoZXIgcmV0cnkuXG4gKi9cbmZ1bmN0aW9uIHN0b3AoaWQpIHtcbiAgICBpZChmYWxzZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc0p1c3REZWYocCkge1xuICAgIHJldHVybiBwICE9PSB2b2lkIDA7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNGdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNOb25BcnJheU9iamVjdChwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnIHx8IHAgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5mdW5jdGlvbiBpc05hdGl2ZUJsb2IocCkge1xuICAgIHJldHVybiBpc05hdGl2ZUJsb2JEZWZpbmVkKCkgJiYgcCBpbnN0YW5jZW9mIEJsb2I7XG59XG5mdW5jdGlvbiBpc05hdGl2ZUJsb2JEZWZpbmVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihhcmd1bWVudCwgbWluVmFsdWUsIG1heFZhbHVlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IG1pblZhbHVlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudChgSW52YWxpZCB2YWx1ZSBmb3IgJyR7YXJndW1lbnR9Jy4gRXhwZWN0ZWQgJHttaW5WYWx1ZX0gb3IgZ3JlYXRlci5gKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50KGBJbnZhbGlkIHZhbHVlIGZvciAnJHthcmd1bWVudH0nLiBFeHBlY3RlZCAke21heFZhbHVlfSBvciBsZXNzLmApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIG1ha2VVcmwodXJsUGFydCwgaG9zdCwgcHJvdG9jb2wpIHtcbiAgICBsZXQgb3JpZ2luID0gaG9zdDtcbiAgICBpZiAocHJvdG9jb2wgPT0gbnVsbCkge1xuICAgICAgICBvcmlnaW4gPSBgaHR0cHM6Ly8ke2hvc3R9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7b3JpZ2lufS92MCR7dXJsUGFydH1gO1xufVxuZnVuY3Rpb24gbWFrZVF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICBsZXQgcXVlcnlQYXJ0ID0gJz8nO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUocGFyYW1zW2tleV0pO1xuICAgICAgICAgICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0ICsgbmV4dFBhcnQgKyAnJic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hvcCBvZmYgdGhlIGV4dHJhICcmJyBvciAnPycgb24gdGhlIGVuZFxuICAgIHF1ZXJ5UGFydCA9IHF1ZXJ5UGFydC5zbGljZSgwLCAtMSk7XG4gICAgcmV0dXJuIHF1ZXJ5UGFydDtcbn1cblxuLyoqXG4gKiBFcnJvciBjb2RlcyBmb3IgcmVxdWVzdHMgbWFkZSBieSB0aGUgWGhySW8gd3JhcHBlci5cbiAqL1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIk5PX0VSUk9SXCJdID0gMF0gPSBcIk5PX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSAxXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJBQk9SVFwiXSA9IDJdID0gXCJBQk9SVFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDaGVja3MgdGhlIHN0YXR1cyBjb2RlIHRvIHNlZSBpZiB0aGUgYWN0aW9uIHNob3VsZCBiZSByZXRyaWVkLlxuICpcbiAqIEBwYXJhbSBzdGF0dXMgQ3VycmVudCBIVFRQIHN0YXR1cyBjb2RlIHJldHVybmVkIGJ5IHNlcnZlci5cbiAqIEBwYXJhbSBhZGRpdGlvbmFsUmV0cnlDb2RlcyBhZGRpdGlvbmFsIHJldHJ5IGNvZGVzIHRvIGNoZWNrIGFnYWluc3RcbiAqL1xuZnVuY3Rpb24gaXNSZXRyeVN0YXR1c0NvZGUoc3RhdHVzLCBhZGRpdGlvbmFsUmV0cnlDb2Rlcykge1xuICAgIC8vIFRoZSBjb2RlcyBmb3Igd2hpY2ggdG8gcmV0cnkgY2FtZSBmcm9tIHRoaXMgcGFnZTpcbiAgICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2V4cG9uZW50aWFsLWJhY2tvZmZcbiAgICBjb25zdCBpc0ZpdmVIdW5kcmVkQ29kZSA9IHN0YXR1cyA+PSA1MDAgJiYgc3RhdHVzIDwgNjAwO1xuICAgIGNvbnN0IGV4dHJhUmV0cnlDb2RlcyA9IFtcbiAgICAgICAgLy8gUmVxdWVzdCBUaW1lb3V0OiB3ZWIgc2VydmVyIGRpZG4ndCByZWNlaXZlIGZ1bGwgcmVxdWVzdCBpbiB0aW1lLlxuICAgICAgICA0MDgsXG4gICAgICAgIC8vIFRvbyBNYW55IFJlcXVlc3RzOiB5b3UncmUgZ2V0dGluZyByYXRlLWxpbWl0ZWQsIGJhc2ljYWxseS5cbiAgICAgICAgNDI5XG4gICAgXTtcbiAgICBjb25zdCBpc0V4dHJhUmV0cnlDb2RlID0gZXh0cmFSZXRyeUNvZGVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTE7XG4gICAgY29uc3QgaXNBZGRpdGlvbmFsUmV0cnlDb2RlID0gYWRkaXRpb25hbFJldHJ5Q29kZXMuaW5kZXhPZihzdGF0dXMpICE9PSAtMTtcbiAgICByZXR1cm4gaXNGaXZlSHVuZHJlZENvZGUgfHwgaXNFeHRyYVJldHJ5Q29kZSB8fCBpc0FkZGl0aW9uYWxSZXRyeUNvZGU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEhhbmRsZXMgbmV0d29yayBsb2dpYyBmb3IgYWxsIFN0b3JhZ2UgUmVxdWVzdHMsIGluY2x1ZGluZyBlcnJvciByZXBvcnRpbmcgYW5kXG4gKiByZXRyaWVzIHdpdGggYmFja29mZi5cbiAqXG4gKiBAcGFyYW0gSSAtIHRoZSB0eXBlIG9mIHRoZSBiYWNrZW5kJ3MgbmV0d29yayByZXNwb25zZS5cbiAqIEBwYXJhbSAtIE8gdGhlIG91dHB1dCB0eXBlIHVzZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIFNESy4gVGhlIGNvbnZlcnNpb25cbiAqIGhhcHBlbnMgaW4gdGhlIHNwZWNpZmllZCBgY2FsbGJhY2tfYC5cbiAqL1xuY2xhc3MgTmV0d29ya1JlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKHVybF8sIG1ldGhvZF8sIGhlYWRlcnNfLCBib2R5Xywgc3VjY2Vzc0NvZGVzXywgYWRkaXRpb25hbFJldHJ5Q29kZXNfLCBjYWxsYmFja18sIGVycm9yQ2FsbGJhY2tfLCB0aW1lb3V0XywgcHJvZ3Jlc3NDYWxsYmFja18sIGNvbm5lY3Rpb25GYWN0b3J5XywgcmV0cnkgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXJsXyA9IHVybF87XG4gICAgICAgIHRoaXMubWV0aG9kXyA9IG1ldGhvZF87XG4gICAgICAgIHRoaXMuaGVhZGVyc18gPSBoZWFkZXJzXztcbiAgICAgICAgdGhpcy5ib2R5XyA9IGJvZHlfO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2Rlc18gPSBzdWNjZXNzQ29kZXNfO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxSZXRyeUNvZGVzXyA9IGFkZGl0aW9uYWxSZXRyeUNvZGVzXztcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFja187XG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFja18gPSBlcnJvckNhbGxiYWNrXztcbiAgICAgICAgdGhpcy50aW1lb3V0XyA9IHRpbWVvdXRfO1xuICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2tfID0gcHJvZ3Jlc3NDYWxsYmFja187XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkZhY3RvcnlfID0gY29ubmVjdGlvbkZhY3RvcnlfO1xuICAgICAgICB0aGlzLnJldHJ5ID0gcmV0cnk7XG4gICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrb2ZmSWRfID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVfID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBzdGFydHMgdGhlIHJldHJ5IGxvb3AuXG4gICAgICovXG4gICAgc3RhcnRfKCkge1xuICAgICAgICBjb25zdCBkb1RoZVJlcXVlc3QgPSAoYmFja29mZkNhbGxiYWNrLCBjYW5jZWxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25GYWN0b3J5XygpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3NMaXN0ZW5lciA9IHByb2dyZXNzRXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHByb2dyZXNzRXZlbnQubG9hZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gcHJvZ3Jlc3NFdmVudC5sZW5ndGhDb21wdXRhYmxlID8gcHJvZ3Jlc3NFdmVudC50b3RhbCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18obG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5hZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbi5zZW5kKCkgbmV2ZXIgcmVqZWN0cywgc28gd2UgZG9uJ3QgbmVlZCB0byBoYXZlIGEgZXJyb3IgaGFuZGxlciBvciB1c2UgY2F0Y2ggb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgLnNlbmQodGhpcy51cmxfLCB0aGlzLm1ldGhvZF8sIHRoaXMuYm9keV8sIHRoaXMuaGVhZGVyc18pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzc0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpdFNlcnZlciA9IGNvbm5lY3Rpb24uZ2V0RXJyb3JDb2RlKCkgPT09IEVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBjb25uZWN0aW9uLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgICAgIGlmICghaGl0U2VydmVyIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc1JldHJ5U3RhdHVzQ29kZShzdGF0dXMsIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FzQ2FuY2VsZWQgPSBjb25uZWN0aW9uLmdldEVycm9yQ29kZSgpID09PSBFcnJvckNvZGUuQUJPUlQ7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayhmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHdhc0NhbmNlbGVkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc0NvZGUgPSB0aGlzLnN1Y2Nlc3NDb2Rlc18uaW5kZXhPZihzdGF0dXMpICE9PSAtMTtcbiAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2sodHJ1ZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoc3VjY2Vzc0NvZGUsIGNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3RXZW50VGhyb3VnaCAtIFRydWUgaWYgdGhlIHJlcXVlc3QgZXZlbnR1YWxseSB3ZW50XG4gICAgICAgICAqICAgICB0aHJvdWdoLCBmYWxzZSBpZiBpdCBoaXQgdGhlIHJldHJ5IGxpbWl0IG9yIHdhcyBjYW5jZWxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGJhY2tvZmZEb25lID0gKHJlcXVlc3RXZW50VGhyb3VnaCwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5yZXNvbHZlXztcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdCA9IHRoaXMucmVqZWN0XztcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBzdGF0dXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGlmIChzdGF0dXMud2FzU3VjY2Vzc0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNhbGxiYWNrXyhjb25uZWN0aW9uLCBjb25uZWN0aW9uLmdldFJlc3BvbnNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNKdXN0RGVmKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gdW5rbm93bigpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuc2VydmVyUmVzcG9uc2UgPSBjb25uZWN0aW9uLmdldEVycm9yVGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvckNhbGxiYWNrXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZXJyb3JDYWxsYmFja18oY29ubmVjdGlvbiwgZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5hcHBEZWxldGVfID8gYXBwRGVsZXRlZCgpIDogY2FuY2VsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gcmV0cnlMaW1pdEV4Y2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWRfKSB7XG4gICAgICAgICAgICBiYWNrb2ZmRG9uZShmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZklkXyA9IHN0YXJ0KGRvVGhlUmVxdWVzdCwgYmFja29mZkRvbmUsIHRoaXMudGltZW91dF8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGdldFByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VfO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBjYW5jZWwoYXBwRGVsZXRlKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gYXBwRGVsZXRlIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5iYWNrb2ZmSWRfICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wKHRoaXMuYmFja29mZklkXyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXy5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlc3VsdCBvZiBhIG5ldHdvcmsgcmVxdWVzdC5cbiAqIEBwYXJhbSBvcHRfY2FuY2VsZWQgLSBEZWZhdWx0cyB0byBmYWxzZS5cbiAqL1xuY2xhc3MgUmVxdWVzdEVuZFN0YXR1cyB7XG4gICAgY29uc3RydWN0b3Iod2FzU3VjY2Vzc0NvZGUsIGNvbm5lY3Rpb24sIGNhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMud2FzU3VjY2Vzc0NvZGUgPSB3YXNTdWNjZXNzQ29kZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9ICEhY2FuY2VsZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQXV0aEhlYWRlcl8oaGVhZGVycywgYXV0aFRva2VuKSB7XG4gICAgaWYgKGF1dGhUb2tlbiAhPT0gbnVsbCAmJiBhdXRoVG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnRmlyZWJhc2UgJyArIGF1dGhUb2tlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRWZXJzaW9uSGVhZGVyXyhoZWFkZXJzLCBmaXJlYmFzZVZlcnNpb24pIHtcbiAgICBoZWFkZXJzWydYLUZpcmViYXNlLVN0b3JhZ2UtVmVyc2lvbiddID1cbiAgICAgICAgJ3dlYmpzLycgKyAoZmlyZWJhc2VWZXJzaW9uICE9PSBudWxsICYmIGZpcmViYXNlVmVyc2lvbiAhPT0gdm9pZCAwID8gZmlyZWJhc2VWZXJzaW9uIDogJ0FwcE1hbmFnZXInKTtcbn1cbmZ1bmN0aW9uIGFkZEdtcGlkSGVhZGVyXyhoZWFkZXJzLCBhcHBJZCkge1xuICAgIGlmIChhcHBJZCkge1xuICAgICAgICBoZWFkZXJzWydYLUZpcmViYXNlLUdNUElEJ10gPSBhcHBJZDtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRBcHBDaGVja0hlYWRlcl8oaGVhZGVycywgYXBwQ2hlY2tUb2tlbikge1xuICAgIGlmIChhcHBDaGVja1Rva2VuICE9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IGFwcENoZWNrVG9rZW47XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGFwcElkLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJlcXVlc3RGYWN0b3J5LCBmaXJlYmFzZVZlcnNpb24sIHJldHJ5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHF1ZXJ5UGFydCA9IG1ha2VRdWVyeVN0cmluZyhyZXF1ZXN0SW5mby51cmxQYXJhbXMpO1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RJbmZvLnVybCArIHF1ZXJ5UGFydDtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluZm8uaGVhZGVycyk7XG4gICAgYWRkR21waWRIZWFkZXJfKGhlYWRlcnMsIGFwcElkKTtcbiAgICBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pO1xuICAgIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMsIGZpcmViYXNlVmVyc2lvbik7XG4gICAgYWRkQXBwQ2hlY2tIZWFkZXJfKGhlYWRlcnMsIGFwcENoZWNrVG9rZW4pO1xuICAgIHJldHVybiBuZXcgTmV0d29ya1JlcXVlc3QodXJsLCByZXF1ZXN0SW5mby5tZXRob2QsIGhlYWRlcnMsIHJlcXVlc3RJbmZvLmJvZHksIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcywgcmVxdWVzdEluZm8uYWRkaXRpb25hbFJldHJ5Q29kZXMsIHJlcXVlc3RJbmZvLmhhbmRsZXIsIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciwgcmVxdWVzdEluZm8udGltZW91dCwgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjaywgcmVxdWVzdEZhY3RvcnksIHJldHJ5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgIGlmICh0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCbG9iQnVpbGRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gV2ViS2l0QmxvYkJ1aWxkZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIG9uZSBvciBtb3JlIHZhbHVlcyB0b2dldGhlciBhbmQgY29udmVydHMgdGhlbSB0byBhIEJsb2IuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIHZhbHVlcyB0aGF0IHdpbGwgbWFrZSB1cCB0aGUgcmVzdWx0aW5nIGJsb2IuXG4gKiBAcmV0dXJuIFRoZSBibG9iLlxuICovXG5mdW5jdGlvbiBnZXRCbG9iJDEoLi4uYXJncykge1xuICAgIGNvbnN0IEJsb2JCdWlsZGVyID0gZ2V0QmxvYkJ1aWxkZXIoKTtcbiAgICBpZiAoQmxvYkJ1aWxkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJiLmFwcGVuZChhcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmIuZ2V0QmxvYigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYkRlZmluZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0VOVklST05NRU5ULCBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCBjcmVhdGluZyBCbG9ic1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU2xpY2VzIHRoZSBibG9iLiBUaGUgcmV0dXJuZWQgYmxvYiBjb250YWlucyBkYXRhIGZyb20gdGhlIHN0YXJ0IGJ5dGVcbiAqIChpbmNsdXNpdmUpIHRpbGwgdGhlIGVuZCBieXRlIChleGNsdXNpdmUpLiBOZWdhdGl2ZSBpbmRpY2VzIGNhbm5vdCBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBibG9iIFRoZSBibG9iIHRvIGJlIHNsaWNlZC5cbiAqIEBwYXJhbSBzdGFydCBJbmRleCBvZiB0aGUgc3RhcnRpbmcgYnl0ZS5cbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgdGhlIGVuZGluZyBieXRlLlxuICogQHJldHVybiBUaGUgYmxvYiBzbGljZSBvciBudWxsIGlmIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIHNsaWNlQmxvYihibG9iLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGJsb2Iud2Via2l0U2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iud2Via2l0U2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJsb2IubW96U2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2IubW96U2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJsb2Iuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIENvbnZlcnRzIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYmluYXJ5IHN0cmluZy4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XG4gICAgLy8gTm9kZSBhY3R1YWxseSBkb2Vzbid0IHZhbGlkYXRlIGJhc2U2NCBzdHJpbmdzLlxuICAgIC8vIEEgcXVpY2sgc2FuaXR5IGNoZWNrIHRoYXQgaXMgbm90IGEgZm9vbC1wcm9vZiB2YWxpZGF0aW9uXG4gICAgaWYgKC9bXi1BLVphLXowLTkrLz1dLy50ZXN0KGVuY29kZWQpKSB7XG4gICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoJ2Jhc2U2NCcsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZW5jb2RlZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdGhlIHBvc3NpYmxlIHN0cmluZyBmb3JtYXRzIGZvciB1cGxvYWQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFN0cmluZ0Zvcm1hdCA9IHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgXCJyYXdcIiwgdGhhdCBpcywgYXMgbm9ybWFsIHRleHQuXG4gICAgICogVGhlIHN0cmluZyB3aWxsIGJlIGludGVycHJldGVkIGFzIFVURi0xNiwgdGhlbiB1cGxvYWRlZCBhcyBhIFVURi04IGJ5dGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKiBFeGFtcGxlOiBUaGUgc3RyaW5nICdIZWxsbyEgXFxcXHVkODNkXFxcXHVkZTBhJyBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXG4gICAgICogNDggNjUgNmMgNmMgNmYgMjEgMjAgZjAgOWYgOTggOGFcbiAgICAgKi9cbiAgICBSQVc6ICdyYXcnLFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlNjQtZW5jb2RlZCBkYXRhLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyAodHJhaWxpbmcgJz0ncykgYXJlIG9wdGlvbmFsLlxuICAgICAqIEV4YW1wbGU6IFRoZSBzdHJpbmcgJ3JXbU8rK0U2dDcvcmx3PT0nIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcbiAgICAgKiBhZCA2OSA4ZSBmYiBlMSAzYSBiNyBiZiBlYiA5N1xuICAgICAqL1xuICAgIEJBU0U2NDogJ2Jhc2U2NCcsXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2U2NHVybC1lbmNvZGVkIGRhdGEuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzICh0cmFpbGluZyAnPSdzKSBhcmUgb3B0aW9uYWwuXG4gICAgICogRXhhbXBsZTogVGhlIHN0cmluZyAncldtTy0tRTZ0N19ybHc9PScgYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAqIGFkIDY5IDhlIGZiIGUxIDNhIGI3IGJmIGViIDk3XG4gICAgICovXG4gICAgQkFTRTY0VVJMOiAnYmFzZTY0dXJsJyxcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBpcyBhIGRhdGEgVVJMLCBzdWNoIGFzIG9uZSBvYnRhaW5lZCBmcm9tXG4gICAgICogY2FudmFzLnRvRGF0YVVSTCgpLlxuICAgICAqIEV4YW1wbGU6IHRoZSBzdHJpbmcgJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxhYWFhJ1xuICAgICAqIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcbiAgICAgKiA2OSBhNiA5YVxuICAgICAqICh0aGUgY29udGVudC10eXBlIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgaXMgYWxzbyBhcHBsaWVkLCBidXQgY2FuXG4gICAgICogYmUgb3ZlcnJpZGRlbiBpbiB0aGUgbWV0YWRhdGEgb2JqZWN0KS5cbiAgICAgKi9cbiAgICBEQVRBX1VSTDogJ2RhdGFfdXJsJ1xufTtcbmNsYXNzIFN0cmluZ0RhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgc3RyaW5nRGF0YSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LlJBVzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YSh1dGY4Qnl0ZXNfKHN0cmluZ0RhdGEpKTtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0OlxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEoYmFzZTY0Qnl0ZXNfKGZvcm1hdCwgc3RyaW5nRGF0YSkpO1xuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5EQVRBX1VSTDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YShkYXRhVVJMQnl0ZXNfKHN0cmluZ0RhdGEpLCBkYXRhVVJMQ29udGVudFR5cGVfKHN0cmluZ0RhdGEpKTtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICAvLyBhc3NlcnQoZmFsc2UpO1xuICAgIHRocm93IHVua25vd24oKTtcbn1cbmZ1bmN0aW9uIHV0ZjhCeXRlc18odmFsdWUpIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDEyNykge1xuICAgICAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGMgPD0gMjA0Nykge1xuICAgICAgICAgICAgICAgIGIucHVzaCgxOTIgfCAoYyA+PiA2KSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5Nikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBpIDwgdmFsdWUubGVuZ3RoIC0gMSAmJiAodmFsdWUuY2hhckNvZGVBdChpICsgMSkgJiA2NDUxMikgPT09IDU2MzIwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHN1cnJvZ2F0ZSB3YXNuJ3QgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoaSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsbyA9IHZhbHVlLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSA2NTUzNiB8ICgoaGkgJiAxMDIzKSA8PCAxMCkgfCAobG8gJiAxMDIzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyNDAgfCAoYyA+PiAxOCksIDEyOCB8ICgoYyA+PiAxMikgJiA2MyksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU2MzIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxvdyBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjI0IHwgKGMgPj4gMTIpLCAxMjggfCAoKGMgPj4gNikgJiA2MyksIDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG59XG5mdW5jdGlvbiBwZXJjZW50RW5jb2RlZEJ5dGVzXyh2YWx1ZSkge1xuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgJ01hbGZvcm1lZCBkYXRhIFVSTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0ZjhCeXRlc18oZGVjb2RlZCk7XG59XG5mdW5jdGlvbiBiYXNlNjRCeXRlc18oZm9ybWF0LCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NDoge1xuICAgICAgICAgICAgY29uc3QgaGFzTWludXMgPSB2YWx1ZS5pbmRleE9mKCctJykgIT09IC0xO1xuICAgICAgICAgICAgY29uc3QgaGFzVW5kZXIgPSB2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGhhc01pbnVzIHx8IGhhc1VuZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNNaW51cyA/ICctJyA6ICdfJztcbiAgICAgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgXCJJbnZhbGlkIGNoYXJhY3RlciAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBmb3VuZDogaXMgaXQgYmFzZTY0dXJsIGVuY29kZWQ/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0VVJMOiB7XG4gICAgICAgICAgICBjb25zdCBoYXNQbHVzID0gdmFsdWUuaW5kZXhPZignKycpICE9PSAtMTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NsYXNoID0gdmFsdWUuaW5kZXhPZignLycpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChoYXNQbHVzIHx8IGhhc1NsYXNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNQbHVzID8gJysnIDogJy8nO1xuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArIGludmFsaWRDaGFyICsgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjQgZW5jb2RlZD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGxldCBieXRlcztcbiAgICB0cnkge1xuICAgICAgICBieXRlcyA9IGRlY29kZUJhc2U2NCh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ3BvbHlmaWxsJykpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmNsYXNzIERhdGFVUkxQYXJ0cyB7XG4gICAgY29uc3RydWN0b3IoZGF0YVVSTCkge1xuICAgICAgICB0aGlzLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGRhdGFVUkwubWF0Y2goL15kYXRhOihbXixdKyk/LC8pO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChTdHJpbmdGb3JtYXQuREFUQV9VUkwsIFwiTXVzdCBiZSBmb3JtYXR0ZWQgJ2RhdGE6WzxtZWRpYXR5cGU+XVs7YmFzZTY0XSw8ZGF0YT5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlkZGxlID0gbWF0Y2hlc1sxXSB8fCBudWxsO1xuICAgICAgICBpZiAobWlkZGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZTY0ID0gZW5kc1dpdGgobWlkZGxlLCAnO2Jhc2U2NCcpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHRoaXMuYmFzZTY0XG4gICAgICAgICAgICAgICAgPyBtaWRkbGUuc3Vic3RyaW5nKDAsIG1pZGRsZS5sZW5ndGggLSAnO2Jhc2U2NCcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogbWlkZGxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdCA9IGRhdGFVUkwuc3Vic3RyaW5nKGRhdGFVUkwuaW5kZXhPZignLCcpICsgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGF0YVVSTEJ5dGVzXyhkYXRhVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgRGF0YVVSTFBhcnRzKGRhdGFVcmwpO1xuICAgIGlmIChwYXJ0cy5iYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NEJ5dGVzXyhTdHJpbmdGb3JtYXQuQkFTRTY0LCBwYXJ0cy5yZXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhwYXJ0cy5yZXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRhVVJMQ29udGVudFR5cGVfKGRhdGFVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoZGF0YVVybCk7XG4gICAgcmV0dXJuIHBhcnRzLmNvbnRlbnRUeXBlO1xufVxuZnVuY3Rpb24gZW5kc1dpdGgocywgZW5kKSB7XG4gICAgY29uc3QgbG9uZ0Vub3VnaCA9IHMubGVuZ3RoID49IGVuZC5sZW5ndGg7XG4gICAgaWYgKCFsb25nRW5vdWdoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKHMubGVuZ3RoIC0gZW5kLmxlbmd0aCkgPT09IGVuZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHBhcmFtIG9wdF9lbGlkZUNvcHkgLSBJZiB0cnVlLCBkb2Vzbid0IGNvcHkgbXV0YWJsZSBpbnB1dCBkYXRhXG4gKiAgICAgKGUuZy4gVWludDhBcnJheXMpLiBQYXNzIHRydWUgb25seSBpZiB5b3Uga25vdyB0aGUgb2JqZWN0cyB3aWxsIG5vdCBiZVxuICogICAgIG1vZGlmaWVkIGFmdGVyIHRoaXMgYmxvYidzIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmJzQmxvYiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgZWxpZGVDb3B5KSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgbGV0IGJsb2JUeXBlID0gJyc7XG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2IoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICAgIGJsb2JUeXBlID0gZGF0YS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGVsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBuZXcgVWludDhBcnJheShkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8uc2V0KG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmRhdGFfLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgaWYgKGVsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVfID0gc2l6ZTtcbiAgICAgICAgdGhpcy50eXBlXyA9IGJsb2JUeXBlO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9XG4gICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZV87XG4gICAgfVxuICAgIHNsaWNlKHN0YXJ0Qnl0ZSwgZW5kQnl0ZSkge1xuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iKHRoaXMuZGF0YV8pKSB7XG4gICAgICAgICAgICBjb25zdCByZWFsQmxvYiA9IHRoaXMuZGF0YV87XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBzbGljZUJsb2IocmVhbEJsb2IsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhXy5idWZmZXIsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSAtIHN0YXJ0Qnl0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbG9iKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYkRlZmluZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgYmxvYmJ5ID0gYXJncy5tYXAoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGYnNCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZGF0YV87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKGdldEJsb2IkMS5hcHBseShudWxsLCBibG9iYnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVpbnQ4QXJyYXlzID0gYXJncy5tYXAoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhRnJvbVN0cmluZyhTdHJpbmdGb3JtYXQuUkFXLCB2YWwpLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBCbG9icyBkb24ndCBleGlzdCwgc28gdGhpcyBoYXMgdG8gYmUgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmRhdGFfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZpbmFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goKGFycmF5KSA9PiB7XG4gICAgICAgICAgICAgICAgZmluYWxMZW5ndGggKz0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkoZmluYWxMZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goKGFycmF5KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaW5kZXgrK10gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihtZXJnZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwbG9hZERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFfO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgT2JqZWN0IHJlc3VsdGluZyBmcm9tIHBhcnNpbmcgdGhlIGdpdmVuIEpTT04sIG9yIG51bGwgaWYgdGhlXG4gKiBnaXZlbiBzdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgSlNPTiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGpzb25PYmplY3RPck51bGwocykge1xuICAgIGxldCBvYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqID0gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc05vbkFycmF5T2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHBhdGhzLlxuICovXG4vKipcbiAqIEByZXR1cm4gTnVsbCBpZiB0aGUgcGF0aCBpcyBhbHJlYWR5IGF0IHRoZSByb290LlxuICovXG5mdW5jdGlvbiBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbn1cbmZ1bmN0aW9uIGNoaWxkKHBhdGgsIGNoaWxkUGF0aCkge1xuICAgIGNvbnN0IGNhbm9uaWNhbENoaWxkUGF0aCA9IGNoaWxkUGF0aFxuICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAuZmlsdGVyKGNvbXBvbmVudCA9PiBjb21wb25lbnQubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJy8nKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWNhbENoaWxkUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nICsgY2Fub25pY2FsQ2hpbGRQYXRoO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjb21wb25lbnQgb2YgYSBwYXRoLlxuICogJy9mb28vYmFyJyAtPiAnYmFyJ1xuICogJy9mb28vYmFyL2Jhei8nIC0+ICdiYXovJ1xuICogJy9hJyAtPiAnYSdcbiAqL1xuZnVuY3Rpb24gbGFzdENvbXBvbmVudChwYXRoKSB7XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJywgcGF0aC5sZW5ndGggLSAyKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBub1hmb3JtXyhtZXRhZGF0YSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5jbGFzcyBNYXBwaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGxvY2FsLCB3cml0YWJsZSwgeGZvcm0pIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCBzZXJ2ZXI7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhIXdyaXRhYmxlO1xuICAgICAgICB0aGlzLnhmb3JtID0geGZvcm0gfHwgbm9YZm9ybV87XG4gICAgfVxufVxubGV0IG1hcHBpbmdzXyA9IG51bGw7XG5mdW5jdGlvbiB4Zm9ybVBhdGgoZnVsbFBhdGgpIHtcbiAgICBpZiAoIWlzU3RyaW5nKGZ1bGxQYXRoKSB8fCBmdWxsUGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsYXN0Q29tcG9uZW50KGZ1bGxQYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNYXBwaW5ncygpIHtcbiAgICBpZiAobWFwcGluZ3NfKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nc187XG4gICAgfVxuICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnYnVja2V0JykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2dlbmVyYXRpb24nKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWV0YWdlbmVyYXRpb24nKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbmFtZScsICdmdWxsUGF0aCcsIHRydWUpKTtcbiAgICBmdW5jdGlvbiBtYXBwaW5nc1hmb3JtUGF0aChfbWV0YWRhdGEsIGZ1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiB4Zm9ybVBhdGgoZnVsbFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lTWFwcGluZyA9IG5ldyBNYXBwaW5nKCduYW1lJyk7XG4gICAgbmFtZU1hcHBpbmcueGZvcm0gPSBtYXBwaW5nc1hmb3JtUGF0aDtcbiAgICBtYXBwaW5ncy5wdXNoKG5hbWVNYXBwaW5nKTtcbiAgICAvKipcbiAgICAgKiBDb2VyY2VzIHRoZSBzZWNvbmQgcGFyYW0gdG8gYSBudW1iZXIsIGlmIGl0IGlzIGRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24geGZvcm1TaXplKF9tZXRhZGF0YSwgc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2l6ZU1hcHBpbmcgPSBuZXcgTWFwcGluZygnc2l6ZScpO1xuICAgIHNpemVNYXBwaW5nLnhmb3JtID0geGZvcm1TaXplO1xuICAgIG1hcHBpbmdzLnB1c2goc2l6ZU1hcHBpbmcpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3RpbWVDcmVhdGVkJykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3VwZGF0ZWQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWQ1SGFzaCcsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjYWNoZUNvbnRyb2wnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudERpc3Bvc2l0aW9uJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnRFbmNvZGluZycsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50TGFuZ3VhZ2UnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudFR5cGUnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbWV0YWRhdGEnLCAnY3VzdG9tTWV0YWRhdGEnLCB0cnVlKSk7XG4gICAgbWFwcGluZ3NfID0gbWFwcGluZ3M7XG4gICAgcmV0dXJuIG1hcHBpbmdzXztcbn1cbmZ1bmN0aW9uIGFkZFJlZihtZXRhZGF0YSwgc2VydmljZSkge1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmKCkge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBtZXRhZGF0YVsnYnVja2V0J107XG4gICAgICAgIGNvbnN0IHBhdGggPSBtZXRhZGF0YVsnZnVsbFBhdGgnXTtcbiAgICAgICAgY29uc3QgbG9jID0gbmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aCk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShsb2MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICdyZWYnLCB7IGdldDogZ2VuZXJhdGVSZWYgfSk7XG59XG5mdW5jdGlvbiBmcm9tUmVzb3VyY2Uoc2VydmljZSwgcmVzb3VyY2UsIG1hcHBpbmdzKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBtZXRhZGF0YVsndHlwZSddID0gJ2ZpbGUnO1xuICAgIGNvbnN0IGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgICAgbWV0YWRhdGFbbWFwcGluZy5sb2NhbF0gPSBtYXBwaW5nLnhmb3JtKG1ldGFkYXRhLCByZXNvdXJjZVttYXBwaW5nLnNlcnZlcl0pO1xuICAgIH1cbiAgICBhZGRSZWYobWV0YWRhdGEsIHNlcnZpY2UpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbn1cbmZ1bmN0aW9uIGZyb21SZXNvdXJjZVN0cmluZyhzZXJ2aWNlLCByZXNvdXJjZVN0cmluZywgbWFwcGluZ3MpIHtcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvdXJjZSA9IG9iajtcbiAgICByZXR1cm4gZnJvbVJlc291cmNlKHNlcnZpY2UsIHJlc291cmNlLCBtYXBwaW5ncyk7XG59XG5mdW5jdGlvbiBkb3dubG9hZFVybEZyb21SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgcmVzb3VyY2VTdHJpbmcsIGhvc3QsIHByb3RvY29sKSB7XG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdE9yTnVsbChyZXNvdXJjZVN0cmluZyk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhvYmpbJ2Rvd25sb2FkVG9rZW5zJ10pKSB7XG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBvYmplY3RzIGFyZSB1cGxvYWRlZCB0aHJvdWdoIEdDUyBhbmQgcmV0cmlldmVkXG4gICAgICAgIC8vIHRocm91Z2ggbGlzdCwgc28gd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyBhbiBFcnJvci5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IG9ialsnZG93bmxvYWRUb2tlbnMnXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIGNvbnN0IHRva2Vuc0xpc3QgPSB0b2tlbnMuc3BsaXQoJywnKTtcbiAgICBjb25zdCB1cmxzID0gdG9rZW5zTGlzdC5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG1ldGFkYXRhWydidWNrZXQnXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICBjb25zdCB1cmxQYXJ0ID0gJy9iLycgKyBlbmNvZGUoYnVja2V0KSArICcvby8nICsgZW5jb2RlKHBhdGgpO1xuICAgICAgICBjb25zdCBiYXNlID0gbWFrZVVybCh1cmxQYXJ0LCBob3N0LCBwcm90b2NvbCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbWFrZVF1ZXJ5U3RyaW5nKHtcbiAgICAgICAgICAgIGFsdDogJ21lZGlhJyxcbiAgICAgICAgICAgIHRva2VuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmFzZSArIHF1ZXJ5U3RyaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB1cmxzWzBdO1xufVxuZnVuY3Rpb24gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IHt9O1xuICAgIGNvbnN0IGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgICAgaWYgKG1hcHBpbmcud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSA9IG1ldGFkYXRhW21hcHBpbmcubG9jYWxdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvdXJjZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBQUkVGSVhFU19LRVkgPSAncHJlZml4ZXMnO1xuY29uc3QgSVRFTVNfS0VZID0gJ2l0ZW1zJztcbmZ1bmN0aW9uIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSkge1xuICAgIGNvbnN0IGxpc3RSZXN1bHQgPSB7XG4gICAgICAgIHByZWZpeGVzOiBbXSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBuZXh0UGFnZVRva2VuOiByZXNvdXJjZVsnbmV4dFBhZ2VUb2tlbiddXG4gICAgfTtcbiAgICBpZiAocmVzb3VyY2VbUFJFRklYRVNfS0VZXSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcmVzb3VyY2VbUFJFRklYRVNfS0VZXSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoKSk7XG4gICAgICAgICAgICBsaXN0UmVzdWx0LnByZWZpeGVzLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzb3VyY2VbSVRFTVNfS0VZXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzb3VyY2VbSVRFTVNfS0VZXSkge1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgaXRlbVsnbmFtZSddKSk7XG4gICAgICAgICAgICBsaXN0UmVzdWx0Lml0ZW1zLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdFJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21SZXNwb25zZVN0cmluZyhzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlU3RyaW5nKSB7XG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdE9yTnVsbChyZXNvdXJjZVN0cmluZyk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb3VyY2UgPSBvYmo7XG4gICAgcmV0dXJuIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgYSBmdWxseSBzcGVjaWZpZWQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gSSAtIHRoZSB0eXBlIG9mIHRoZSBiYWNrZW5kJ3MgbmV0d29yayByZXNwb25zZS5cbiAqIEBwYXJhbSBPIC0gdGhlIG91dHB1dCByZXNwb25zZSB0eXBlIHVzZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIFNESy5cbiAqL1xuY2xhc3MgUmVxdWVzdEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbWV0aG9kLCBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoIHdoaWNoIHRvIHJlc29sdmUgdGhlIHJlcXVlc3QncyBwcm9taXNlLiBPbmx5IGNhbGxlZFxuICAgICAqIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFRocm93IGZyb20gdGhpcyBmdW5jdGlvbiB0byByZWplY3QgdGhlXG4gICAgICogcmV0dXJuZWQgUmVxdWVzdCdzIHByb21pc2Ugd2l0aCB0aGUgdGhyb3duIGVycm9yLlxuICAgICAqIE5vdGU6IFRoZSBYaHJJbyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBtYXkgYmUgcmV1c2VkIGFmdGVyIHRoaXMgY2FsbGJhY2tcbiAgICAgKiByZXR1cm5zLiBEbyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCBpbiBhbnkgd2F5LlxuICAgICAqL1xuICAgIGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnVybFBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIGFuZCB0b3RhbCBzaXplICgtMSBpZiBub3RcbiAgICAgICAgICogY29tcHV0YWJsZSkgb2YgdGhlIHJlcXVlc3QgYm9keSAoaS5lLiB1c2VkIHRvIHJlcG9ydCB1cGxvYWQgcHJvZ3Jlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWNjZXNzQ29kZXMgPSBbMjAwXTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2RlcyA9IFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhyb3dzIHRoZSBVTktOT1dOIFN0b3JhZ2VFcnJvciBpZiBjbmRuIGlzIGZhbHNlLlxuICovXG5mdW5jdGlvbiBoYW5kbGVyQ2hlY2soY25kbikge1xuICAgIGlmICghY25kbikge1xuICAgICAgICB0aHJvdyB1bmtub3duKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgdGV4dCwgbWFwcGluZ3MpO1xuICAgICAgICBoYW5kbGVyQ2hlY2sobWV0YWRhdGEgIT09IG51bGwpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xufVxuZnVuY3Rpb24gbGlzdEhhbmRsZXIoc2VydmljZSwgYnVja2V0KSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY29uc3QgbGlzdFJlc3VsdCA9IGZyb21SZXNwb25zZVN0cmluZyhzZXJ2aWNlLCBidWNrZXQsIHRleHQpO1xuICAgICAgICBoYW5kbGVyQ2hlY2sobGlzdFJlc3VsdCAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBsaXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVXJsSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncykge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHRleHQsIG1hcHBpbmdzKTtcbiAgICAgICAgaGFuZGxlckNoZWNrKG1ldGFkYXRhICE9PSBudWxsKTtcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkVXJsRnJvbVJlc291cmNlU3RyaW5nKG1ldGFkYXRhLCB0ZXh0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5mdW5jdGlvbiBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcbiAgICAgICAgbGV0IG5ld0VycjtcbiAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAxKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIGV4YWN0IG1lc3NhZ2Ugc3RyaW5nIGlzIHRoZSBvbmx5IGNvbnNpc3RlbnQgcGFydCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlcnZlcidzIGVycm9yIHJlc3BvbnNlIHRoYXQgaWRlbnRpZmllcyBpdCBhcyBhbiBBcHAgQ2hlY2sgZXJyb3IuXG4gICAgICAgICAgICB4aHIuZ2V0RXJyb3JUZXh0KCkuaW5jbHVkZXMoJ0ZpcmViYXNlIEFwcCBDaGVjayB0b2tlbiBpcyBpbnZhbGlkJykpIHtcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSB1bmF1dGhvcml6ZWRBcHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aGVudGljYXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAyKSB7XG4gICAgICAgICAgICAgICAgbmV3RXJyID0gcXVvdGFFeGNlZWRlZChsb2NhdGlvbi5idWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aG9yaXplZChsb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnN0YXR1cyA9IHhoci5nZXRTdGF0dXMoKTtcbiAgICAgICAgbmV3RXJyLnNlcnZlclJlc3BvbnNlID0gZXJyLnNlcnZlclJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZnVuY3Rpb24gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKSB7XG4gICAgY29uc3Qgc2hhcmVkID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcbiAgICAgICAgbGV0IG5ld0VyciA9IHNoYXJlZCh4aHIsIGVycik7XG4gICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwNCkge1xuICAgICAgICAgICAgbmV3RXJyID0gb2JqZWN0Tm90Rm91bmQobG9jYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnNlcnZlclJlc3BvbnNlID0gZXJyLnNlcnZlclJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZnVuY3Rpb24gZ2V0TWV0YWRhdGEkMihzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGxpc3QkMihzZXJ2aWNlLCBsb2NhdGlvbiwgZGVsaW1pdGVyLCBwYWdlVG9rZW4sIG1heFJlc3VsdHMpIHtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcbiAgICBpZiAobG9jYXRpb24uaXNSb290KSB7XG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSBsb2NhdGlvbi5wYXRoICsgJy8nO1xuICAgIH1cbiAgICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVybFBhcmFtc1snZGVsaW1pdGVyJ10gPSBkZWxpbWl0ZXI7XG4gICAgfVxuICAgIGlmIChwYWdlVG9rZW4pIHtcbiAgICAgICAgdXJsUGFyYW1zWydwYWdlVG9rZW4nXSA9IHBhZ2VUb2tlbjtcbiAgICB9XG4gICAgaWYgKG1heFJlc3VsdHMpIHtcbiAgICAgICAgdXJsUGFyYW1zWydtYXhSZXN1bHRzJ10gPSBtYXhSZXN1bHRzO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBsaXN0SGFuZGxlcihzZXJ2aWNlLCBsb2NhdGlvbi5idWNrZXQpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBnZXRCeXRlcyQxKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKSArICc/YWx0PW1lZGlhJztcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIChfLCBkYXRhKSA9PiBkYXRhLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIGlmIChtYXhEb3dubG9hZFNpemVCeXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcXVlc3RJbmZvLmhlYWRlcnNbJ1JhbmdlJ10gPSBgYnl0ZXM9MC0ke21heERvd25sb2FkU2l6ZUJ5dGVzfWA7XG4gICAgICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAgLyogT0sgKi8sIDIwNiAvKiBQYXJ0aWFsIENvbnRlbnQgKi9dO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBkb3dubG9hZFVybEhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhJDIoc2VydmljZSwgbG9jYXRpb24sIG1ldGFkYXRhLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUEFUQ0gnO1xuICAgIGNvbnN0IGJvZHkgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhLCBtYXBwaW5ncyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyB9O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBkZWxldGVPYmplY3QkMihzZXJ2aWNlLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlcihfeGhyLCBfdGV4dCkgeyB9XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAsIDIwNF07XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVDb250ZW50VHlwZV8obWV0YWRhdGEsIGJsb2IpIHtcbiAgICByZXR1cm4gKChtZXRhZGF0YSAmJiBtZXRhZGF0YVsnY29udGVudFR5cGUnXSkgfHxcbiAgICAgICAgKGJsb2IgJiYgYmxvYi50eXBlKCkpIHx8XG4gICAgICAgICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbn1cbmZ1bmN0aW9uIG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgbWV0YWRhdGEpIHtcbiAgICBjb25zdCBtZXRhZGF0YUNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xuICAgIG1ldGFkYXRhQ2xvbmVbJ2Z1bGxQYXRoJ10gPSBsb2NhdGlvbi5wYXRoO1xuICAgIG1ldGFkYXRhQ2xvbmVbJ3NpemUnXSA9IGJsb2Iuc2l6ZSgpO1xuICAgIGlmICghbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSkge1xuICAgICAgICBtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID0gZGV0ZXJtaW5lQ29udGVudFR5cGVfKG51bGwsIGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGFDbG9uZTtcbn1cbi8qKlxuICogUHJlcGFyZSBSZXF1ZXN0SW5mbyBmb3IgdXBsb2FkcyBhcyBDb250ZW50LVR5cGU6IG11bHRpcGFydC5cbiAqL1xuZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncywgYmxvYiwgbWV0YWRhdGEpIHtcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ211bHRpcGFydCdcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdlbkJvdW5kYXJ5KCkge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRhcnkgPSBnZW5Cb3VuZGFyeSgpO1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0nICsgYm91bmRhcnk7XG4gICAgY29uc3QgbWV0YWRhdGFfID0gbWV0YWRhdGFGb3JVcGxvYWRfKGxvY2F0aW9uLCBibG9iLCBtZXRhZGF0YSk7XG4gICAgY29uc3QgbWV0YWRhdGFTdHJpbmcgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhXywgbWFwcGluZ3MpO1xuICAgIGNvbnN0IHByZUJsb2JQYXJ0ID0gJy0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1ldGFkYXRhU3RyaW5nICtcbiAgICAgICAgJ1xcclxcbi0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiAnICtcbiAgICAgICAgbWV0YWRhdGFfWydjb250ZW50VHlwZSddICtcbiAgICAgICAgJ1xcclxcblxcclxcbic7XG4gICAgY29uc3QgcG9zdEJsb2JQYXJ0ID0gJ1xcclxcbi0tJyArIGJvdW5kYXJ5ICsgJy0tJztcbiAgICBjb25zdCBib2R5ID0gRmJzQmxvYi5nZXRCbG9iKHByZUJsb2JQYXJ0LCBibG9iLCBwb3N0QmxvYlBhcnQpO1xuICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhX1snZnVsbFBhdGgnXSB9O1xuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbi8qKlxuICogQHBhcmFtIGN1cnJlbnQgVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlbiB1cGxvYWRlZCBzbyBmYXIuXG4gKiBAcGFyYW0gdG90YWwgVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiB0aGUgdXBsb2FkLlxuICogQHBhcmFtIG9wdF9maW5hbGl6ZWQgVHJ1ZSBpZiB0aGUgc2VydmVyIGhhcyBmaW5pc2hlZCB0aGUgdXBsb2FkLlxuICogQHBhcmFtIG9wdF9tZXRhZGF0YSBUaGUgdXBsb2FkIG1ldGFkYXRhLCBzaG91bGRcbiAqICAgICBvbmx5IGJlIHBhc3NlZCBpZiBvcHRfZmluYWxpemVkIGlzIHRydWUuXG4gKi9cbmNsYXNzIFJlc3VtYWJsZVVwbG9hZFN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoY3VycmVudCwgdG90YWwsIGZpbmFsaXplZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEhZmluYWxpemVkO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBhbGxvd2VkKSB7XG4gICAgbGV0IHN0YXR1cyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdHVzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVN0YXR1cycpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd2VkU3RhdHVzID0gYWxsb3dlZCB8fCBbJ2FjdGl2ZSddO1xuICAgIGhhbmRsZXJDaGVjayghIXN0YXR1cyAmJiBhbGxvd2VkU3RhdHVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTEpO1xuICAgIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXN1bWFibGVVcGxvYWQoc2VydmljZSwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5idWNrZXRPbmx5U2VydmVyVXJsKCk7XG4gICAgY29uc3QgbWV0YWRhdGFGb3JVcGxvYWQgPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKTtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhRm9yVXBsb2FkWydmdWxsUGF0aCddIH07XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtUHJvdG9jb2wnOiAncmVzdW1hYmxlJyxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdzdGFydCcsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LUxlbmd0aCc6IGAke2Jsb2Iuc2l6ZSgpfWAsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LVR5cGUnOiBtZXRhZGF0YUZvclVwbG9hZFsnY29udGVudFR5cGUnXSxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xuICAgIH07XG4gICAgY29uc3QgYm9keSA9IHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGFGb3JVcGxvYWQsIG1hcHBpbmdzKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIpIHtcbiAgICAgICAgY2hlY2tSZXN1bWVIZWFkZXJfKHhocik7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlckNoZWNrKGlzU3RyaW5nKHVybCkpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzZXJ2aWNlLCBsb2NhdGlvbiwgdXJsLCBibG9iKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdxdWVyeScgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhocikge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBbJ2FjdGl2ZScsICdmaW5hbCddKTtcbiAgICAgICAgbGV0IHNpemVTdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2l6ZVN0cmluZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1TaXplLVJlY2VpdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaXplU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBudWxsIG9yIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyKHNpemVTdHJpbmcpO1xuICAgICAgICBoYW5kbGVyQ2hlY2soIWlzTmFOKHNpemUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMoc2l6ZSwgYmxvYi5zaXplKCksIHN0YXR1cyA9PT0gJ2ZpbmFsJyk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBBbnkgdXBsb2FkcyB2aWEgdGhlIHJlc3VtYWJsZSB1cGxvYWQgQVBJIG11c3QgdHJhbnNmZXIgYSBudW1iZXIgb2YgYnl0ZXNcbiAqIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGlzIG51bWJlci5cbiAqL1xuY29uc3QgUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcbi8qKlxuICogQHBhcmFtIHVybCBGcm9tIGEgY2FsbCB0byBmYnMucmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkLlxuICogQHBhcmFtIGNodW5rU2l6ZSBOdW1iZXIgb2YgYnl0ZXMgdG8gdXBsb2FkLlxuICogQHBhcmFtIHN0YXR1cyBUaGUgcHJldmlvdXMgc3RhdHVzLlxuICogICAgIElmIG5vdCBwYXNzZWQgb3IgbnVsbCwgd2Ugc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICogQHRocm93cyBmYnMuRXJyb3IgSWYgdGhlIHVwbG9hZCBpcyBhbHJlYWR5IGNvbXBsZXRlLCB0aGUgcGFzc2VkIGluIHN0YXR1c1xuICogICAgIGhhcyBhIGZpbmFsIHNpemUgaW5jb25zaXN0ZW50IHdpdGggdGhlIGJsb2IsIG9yIHRoZSBibG9iIGNhbm5vdCBiZSBzbGljZWRcbiAqICAgICBmb3IgdXBsb2FkLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVJlc3VtYWJsZVVwbG9hZChsb2NhdGlvbiwgc2VydmljZSwgdXJsLCBibG9iLCBjaHVua1NpemUsIG1hcHBpbmdzLCBzdGF0dXMsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogc3RhbmRhcmRpemUgb24gaW50ZXJuYWwgYXNzZXJ0c1xuICAgIC8vIGFzc2VydCghKG9wdF9zdGF0dXMgJiYgb3B0X3N0YXR1cy5maW5hbGl6ZWQpKTtcbiAgICBjb25zdCBzdGF0dXNfID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cygwLCAwKTtcbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1c18uY3VycmVudCA9IHN0YXR1cy5jdXJyZW50O1xuICAgICAgICBzdGF0dXNfLnRvdGFsID0gc3RhdHVzLnRvdGFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdHVzXy5jdXJyZW50ID0gMDtcbiAgICAgICAgc3RhdHVzXy50b3RhbCA9IGJsb2Iuc2l6ZSgpO1xuICAgIH1cbiAgICBpZiAoYmxvYi5zaXplKCkgIT09IHN0YXR1c18udG90YWwpIHtcbiAgICAgICAgdGhyb3cgc2VydmVyRmlsZVdyb25nU2l6ZSgpO1xuICAgIH1cbiAgICBjb25zdCBieXRlc0xlZnQgPSBzdGF0dXNfLnRvdGFsIC0gc3RhdHVzXy5jdXJyZW50O1xuICAgIGxldCBieXRlc1RvVXBsb2FkID0gYnl0ZXNMZWZ0O1xuICAgIGlmIChjaHVua1NpemUgPiAwKSB7XG4gICAgICAgIGJ5dGVzVG9VcGxvYWQgPSBNYXRoLm1pbihieXRlc1RvVXBsb2FkLCBjaHVua1NpemUpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEJ5dGUgPSBzdGF0dXNfLmN1cnJlbnQ7XG4gICAgY29uc3QgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIGJ5dGVzVG9VcGxvYWQ7XG4gICAgbGV0IHVwbG9hZENvbW1hbmQgPSAnJztcbiAgICBpZiAoYnl0ZXNUb1VwbG9hZCA9PT0gMCkge1xuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ2ZpbmFsaXplJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZXNMZWZ0ID09PSBieXRlc1RvVXBsb2FkKSB7XG4gICAgICAgIHVwbG9hZENvbW1hbmQgPSAndXBsb2FkLCBmaW5hbGl6ZSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBgJHtzdGF0dXNfLmN1cnJlbnR9YFxuICAgIH07XG4gICAgY29uc3QgYm9keSA9IGJsb2Iuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBjYW5ub3RTbGljZUJsb2IoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IFZlcmlmeSB0aGUgTUQ1IG9mIGVhY2ggdXBsb2FkZWQgcmFuZ2U6XG4gICAgICAgIC8vIHRoZSAneC1yYW5nZS1tZDUnIGhlYWRlciBjb21lcyBiYWNrIHdpdGggc3RhdHVzIGNvZGUgMzA4IHJlc3BvbnNlcy5cbiAgICAgICAgLy8gV2UnbGwgb25seSBiZSBhYmxlIHRvIGJhaWwgb3V0IHRob3VnaCwgYmVjYXVzZSB5b3UgY2FuJ3QgcmUtdXBsb2FkIGFcbiAgICAgICAgLy8gcmFuZ2UgdGhhdCB5b3UgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgICAgY29uc3QgdXBsb2FkU3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIGNvbnN0IG5ld0N1cnJlbnQgPSBzdGF0dXNfLmN1cnJlbnQgKyBieXRlc1RvVXBsb2FkO1xuICAgICAgICBjb25zdCBzaXplID0gYmxvYi5zaXplKCk7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgaWYgKHVwbG9hZFN0YXR1cyA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpKHhociwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMobmV3Q3VycmVudCwgc2l6ZSwgdXBsb2FkU3RhdHVzID09PSAnZmluYWwnLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcbiAgICByZXF1ZXN0SW5mby5wcm9ncmVzc0NhbGxiYWNrID0gcHJvZ3Jlc3NDYWxsYmFjayB8fCBudWxsO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBvbiBhIHRhc2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVGFza0V2ZW50ID0ge1xuICAgIC8qKlxuICAgICAqIEZvciB0aGlzIGV2ZW50LFxuICAgICAqIDx1bD5cbiAgICAgKiAgIDxsaT5UaGUgYG5leHRgIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZCBvbiBwcm9ncmVzcyB1cGRhdGVzIGFuZCB3aGVuIHRoZVxuICAgICAqICAgICAgIHRhc2sgaXMgcGF1c2VkL3Jlc3VtZWQgd2l0aCBhbiBgVXBsb2FkVGFza1NuYXBzaG90YCBhcyB0aGUgZmlyc3RcbiAgICAgKiAgICAgICBhcmd1bWVudC48L2xpPlxuICAgICAqICAgPGxpPlRoZSBgZXJyb3JgIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZCBpZiB0aGUgdXBsb2FkIGlzIGNhbmNlbGVkIG9yIGZhaWxzXG4gICAgICogICAgICAgZm9yIGFub3RoZXIgcmVhc29uLjwvbGk+XG4gICAgICogICA8bGk+VGhlIGBjb21wbGV0ZWAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIGlmIHRoZSB1cGxvYWQgY29tcGxldGVzXG4gICAgICogICAgICAgc3VjY2Vzc2Z1bGx5LjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKi9cbiAgICBTVEFURV9DSEFOR0VEOiAnc3RhdGVfY2hhbmdlZCdcbn07XG4vLyB0eXBlIGtleXMgPSBrZXlvZiBUYXNrU3RhdGVcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHJ1bm5pbmcgdXBsb2FkLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFRhc2tTdGF0ZSA9IHtcbiAgICAvKiogVGhlIHRhc2sgaXMgY3VycmVudGx5IHRyYW5zZmVycmluZyBkYXRhLiAqL1xuICAgIFJVTk5JTkc6ICdydW5uaW5nJyxcbiAgICAvKiogVGhlIHRhc2sgd2FzIHBhdXNlZCBieSB0aGUgdXNlci4gKi9cbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxuICAgIC8qKiBUaGUgdGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiAqL1xuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbiAgICAvKiogVGhlIHRhc2sgd2FzIGNhbmNlbGVkLiAqL1xuICAgIENBTkNFTEVEOiAnY2FuY2VsZWQnLFxuICAgIC8qKiBUaGUgdGFzayBmYWlsZWQgd2l0aCBhbiBlcnJvci4gKi9cbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbmZ1bmN0aW9uIHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZShzdGF0ZSkge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxuICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XG4gICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlJVTk5JTkc7XG4gICAgICAgIGNhc2UgXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlBBVVNFRDtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5TVUNDRVNTO1xuICAgICAgICBjYXNlIFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuQ0FOQ0VMRUQ7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBjb25zdCBhc0Z1bmN0aW9ucyA9IGlzRnVuY3Rpb24obmV4dE9yT2JzZXJ2ZXIpIHx8IGVycm9yICE9IG51bGwgfHwgY29tcGxldGUgIT0gbnVsbDtcbiAgICAgICAgaWYgKGFzRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwID8gZXJyb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGUgIT09IG51bGwgJiYgY29tcGxldGUgIT09IHZvaWQgMCA/IGNvbXBsZXRlIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG9ic2VydmVyLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgZiB3aXRoIGl0cyBhcmd1bWVudHMgYXN5bmNocm9ub3VzbHkgYXMgYVxuICogbWljcm90YXNrLCBpLmUuIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0IHJldHVybnMgYmFja1xuICogaW50byBicm93c2VyIGNvZGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBhc3luYyhmKSB7XG4gICAgcmV0dXJuICguLi5hcmdzVG9Gb3J3YXJkKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBmKC4uLmFyZ3NUb0ZvcndhcmQpKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIEFuIG92ZXJyaWRlIGZvciB0aGUgdGV4dC1iYXNlZCBDb25uZWN0aW9uLiBVc2VkIGluIHRlc3RzLiAqL1xubGV0IHRleHRGYWN0b3J5T3ZlcnJpZGUgPSBudWxsO1xuLyoqXG4gKiBOZXR3b3JrIGxheWVyIHRoYXQgd29ya3MgaW4gTm9kZS5cbiAqXG4gKiBUaGlzIG5ldHdvcmsgaW1wbGVtZW50YXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkIGluIGJyb3dzZXJzIGFzIGl0IGRvZXMgbm90XG4gKiBzdXBwb3J0IHByb2dyZXNzIHVwZGF0ZXMuXG4gKi9cbmNsYXNzIEZldGNoQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JUZXh0XyA9ICcnO1xuICAgICAgICB0aGlzLnNlbnRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5OT19FUlJPUjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh1cmwsIG1ldGhvZCwgYm9keSwgaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5zZW5kKCkgbW9yZSB0aGFuIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbnRfID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMgfHwge30sXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNfID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZV8gPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTk9fRVJST1I7XG4gICAgICAgICAgICB0aGlzLmJvZHlfID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvclRleHRfID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAvLyBlbXVsYXRlIFhIUiB3aGljaCBzZXRzIHN0YXR1cyB0byAwIHdoZW4gZW5jb3VudGVyaW5nIGEgbmV0d29yayBlcnJvclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IDA7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTkVUV09SS19FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFcnJvckNvZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yQ29kZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRFcnJvckNvZGUoKSBiZWZvcmUgcmVjZWl2aW5nIHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb2RlXztcbiAgICB9XG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNDb2RlXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFN0YXR1cygpIGJlZm9yZSByZWNlaXZpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNDb2RlXztcbiAgICB9XG4gICAgZ2V0RXJyb3JUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvclRleHRfO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgLy8gTm90IHN1cHBvcnRlZFxuICAgIH1cbiAgICBnZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnNfKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlSGVhZGVyKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNfLmdldChoZWFkZXIpO1xuICAgIH1cbiAgICBhZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIE5vdCBzdXBwb3J0ZWRcbiAgICB9XG4gICAgcmVtb3ZlVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgfVxufVxuY2xhc3MgRmV0Y2hUZXh0Q29ubmVjdGlvbiBleHRlbmRzIEZldGNoQ29ubmVjdGlvbiB7XG4gICAgZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5ib2R5Xykge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZSgpIGJlZm9yZSByZWNlaXZpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5ib2R5XykudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3VGV4dENvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRleHRGYWN0b3J5T3ZlcnJpZGVcbiAgICAgICAgPyB0ZXh0RmFjdG9yeU92ZXJyaWRlKClcbiAgICAgICAgOiBuZXcgRmV0Y2hUZXh0Q29ubmVjdGlvbigpO1xufVxuY2xhc3MgRmV0Y2hCeXRlc0Nvbm5lY3Rpb24gZXh0ZW5kcyBGZXRjaENvbm5lY3Rpb24ge1xuICAgIGdldFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYm9keV8pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHlfO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0J5dGVzQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEZldGNoQnl0ZXNDb25uZWN0aW9uKCk7XG59XG5jbGFzcyBGZXRjaFN0cmVhbUNvbm5lY3Rpb24gZXh0ZW5kcyBGZXRjaENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0cmVhbV8gPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHVybCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbnRfKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudF8gPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7fSxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc18gPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtXyA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JUZXh0XyA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlO1xuICAgICAgICAgICAgLy8gZW11bGF0ZSBYSFIgd2hpY2ggc2V0cyBzdGF0dXMgdG8gMCB3aGVuIGVuY291bnRlcmluZyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZV8gPSAwO1xuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5FVFdPUktfRVJST1I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1fKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlKCkgYmVmb3JlIHNlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1fO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1N0cmVhbUNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFN0cmVhbUNvbm5lY3Rpb24oKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGJsb2IgYmVpbmcgdXBsb2FkZWQuIENhbiBiZSB1c2VkIHRvIHBhdXNlL3Jlc3VtZS9jYW5jZWwgdGhlXG4gKiB1cGxvYWQgYW5kIG1hbmFnZSBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFVwbG9hZFRhc2sge1xuICAgIGlzRXhwb25lbnRpYWxCYWNrb2ZmRXhwaXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xlZXBUaW1lID4gdGhpcy5tYXhTbGVlcFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBvYmplY3QgdGhpcyB0YXNrIGNhbWVcbiAgICAgKiAgICAgZnJvbSwgdW50eXBlZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jaWVzLlxuICAgICAqIEBwYXJhbSBibG9iIC0gVGhlIGJsb2IgdG8gdXBsb2FkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZiwgYmxvYiwgbWV0YWRhdGEgPSBudWxsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYnl0ZXMgdHJhbnNmZXJyZWQgc28gZmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhbnNmZXJyZWQgPSAwO1xuICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXBsb2FkVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jaHVua011bHRpcGxpZXIgPSAxO1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlZiA9IHJlZjtcbiAgICAgICAgdGhpcy5fYmxvYiA9IGJsb2I7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuX21hcHBpbmdzID0gZ2V0TWFwcGluZ3MoKTtcbiAgICAgICAgdGhpcy5fcmVzdW1hYmxlID0gdGhpcy5fc2hvdWxkRG9SZXN1bWFibGUodGhpcy5fYmxvYik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLztcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciA9IDE7XG4gICAgICAgICAgICBpZiAoZXJyb3IuX2NvZGVFcXVhbHMoU3RvcmFnZUVycm9yQ29kZS5DQU5DRUxFRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja29mZkV4cGlyZWQgPSB0aGlzLmlzRXhwb25lbnRpYWxCYWNrb2ZmRXhwaXJlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldHJ5U3RhdHVzQ29kZShlcnJvci5zdGF0dXMsIFtdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja29mZkV4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gcmV0cnlMaW1pdEV4Y2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsZWVwVGltZSA9IE1hdGgubWF4KHRoaXMuc2xlZXBUaW1lICogMiwgREVGQVVMVF9NSU5fU0xFRVBfVElNRV9NSUxMSVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tZXRhZGF0YUVycm9ySGFuZGxlciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZXJyb3IuX2NvZGVFcXVhbHMoU3RvcmFnZUVycm9yQ29kZS5DQU5DRUxFRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zbGVlcFRpbWUgPSAwO1xuICAgICAgICB0aGlzLm1heFNsZWVwVGltZSA9IHRoaXMuX3JlZi5zdG9yYWdlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFByZXZlbnQgdW5jYXVnaHQgcmVqZWN0aW9ucyBvbiB0aGUgaW50ZXJuYWwgcHJvbWlzZSBmcm9tIGJ1YmJsaW5nIG91dFxuICAgICAgICAvLyB0byB0aGUgdG9wIGxldmVsIHdpdGggYSBkdW1teSBoYW5kbGVyLlxuICAgICAgICB0aGlzLl9wcm9taXNlLnRoZW4obnVsbCwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgX21ha2VQcm9ncmVzc0NhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBzaXplQmVmb3JlID0gdGhpcy5fdHJhbnNmZXJyZWQ7XG4gICAgICAgIHJldHVybiBsb2FkZWQgPT4gdGhpcy5fdXBkYXRlUHJvZ3Jlc3Moc2l6ZUJlZm9yZSArIGxvYWRlZCk7XG4gICAgfVxuICAgIF9zaG91bGREb1Jlc3VtYWJsZShibG9iKSB7XG4gICAgICAgIHJldHVybiBibG9iLnNpemUoKSA+IDI1NiAqIDEwMjQ7XG4gICAgfVxuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgc29tZW9uZSBwYXVzZXMgdXMgaW4gYSByZXN1bWUgY2FsbGJhY2ssIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzdW1hYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXN1bWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaFN0YXR1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRUb0ZldGNoTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaWYgd2UgbWlzcyB0aGUgbWV0YWRhdGEgb24gdXBsb2FkIGNvbXBsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250aW51ZVVwbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zbGVlcFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25lU2hvdFVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXNvbHZlVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9yZWYuc3RvcmFnZS5fZ2V0QXV0aFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLl9yZWYuc3RvcmFnZS5fZ2V0QXBwQ2hlY2tUb2tlbigpXG4gICAgICAgIF0pLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCBmYWxzZVxuICAgIF9jcmVhdGVSZXN1bWFibGUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGNyZWF0ZVJlc3VtYWJsZVVwbG9hZCh0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdGhpcy5fbWFwcGluZ3MsIHRoaXMuX2Jsb2IsIHRoaXMuX21ldGFkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3Q7XG4gICAgICAgICAgICBjcmVhdGVSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKCh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZFVybCA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZmV0Y2hTdGF0dXMoKSB7XG4gICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQodGhpcy51cGxvYWRVcmxfICE9PSBudWxsKTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdXBsb2FkVXJsO1xuICAgICAgICB0aGlzLl9yZXNvbHZlVG9rZW4oKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRSZXN1bWFibGVVcGxvYWRTdGF0dXModGhpcy5fcmVmLnN0b3JhZ2UsIHRoaXMuX3JlZi5fbG9jYXRpb24sIHVybCwgdGhpcy5fYmxvYik7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBzdGF0dXNSZXF1ZXN0O1xuICAgICAgICAgICAgc3RhdHVzUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKHN0YXR1cy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NvbnRpbnVlVXBsb2FkKCkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgKiB0aGlzLl9jaHVua011bHRpcGxpZXI7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXModGhpcy5fdHJhbnNmZXJyZWQsIHRoaXMuX2Jsb2Iuc2l6ZSgpKTtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91cGxvYWRVcmw7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdEluZm87XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmZvID0gY29udGludWVSZXN1bWFibGVVcGxvYWQodGhpcy5fcmVmLl9sb2NhdGlvbiwgdGhpcy5fcmVmLnN0b3JhZ2UsIHVybCwgdGhpcy5fYmxvYiwgY2h1bmtTaXplLCB0aGlzLl9tYXBwaW5ncywgc3RhdHVzLCB0aGlzLl9tYWtlUHJvZ3Jlc3NDYWxsYmFjaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBcbiAgICAgICAgICAgIC8qcmV0cnk9Ki8gZmFsc2UgLy8gVXBsb2FkIHJlcXVlc3RzIHNob3VsZCBub3QgYmUgcmV0cmllZCBhcyBlYWNoIHJldHJ5IHNob3VsZCBiZSBwcmVjZWRlZCBieSBhbm90aGVyIHF1ZXJ5IHJlcXVlc3QuIFdoaWNoIGlzIGhhbmRsZWQgaW4gdGhpcyBmaWxlLlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1cGxvYWRSZXF1ZXN0O1xuICAgICAgICAgICAgdXBsb2FkUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbigobmV3U3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVhc2VNdWx0aXBsaWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyhuZXdTdGF0dXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBuZXdTdGF0dXMubWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbmNyZWFzZU11bHRpcGxpZXIoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFICogdGhpcy5fY2h1bmtNdWx0aXBsaWVyO1xuICAgICAgICAvLyBNYXggY2h1bmsgc2l6ZSBpcyAzMk0uXG4gICAgICAgIGlmIChjdXJyZW50U2l6ZSAqIDIgPCAzMiAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgICB0aGlzLl9jaHVua011bHRpcGxpZXIgKj0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmV0Y2hNZXRhZGF0YSgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0TWV0YWRhdGEkMih0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdGhpcy5fbWFwcGluZ3MpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBtZXRhZGF0YVJlcXVlc3Q7XG4gICAgICAgICAgICBtZXRhZGF0YVJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4obWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi8pO1xuICAgICAgICAgICAgfSwgdGhpcy5fbWV0YWRhdGFFcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uZVNob3RVcGxvYWQoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG11bHRpcGFydFVwbG9hZCh0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdGhpcy5fbWFwcGluZ3MsIHRoaXMuX2Jsb2IsIHRoaXMuX21ldGFkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGFydFJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG11bHRpcGFydFJlcXVlc3Q7XG4gICAgICAgICAgICBtdWx0aXBhcnRSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3ModGhpcy5fYmxvYi5zaXplKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3VwZGF0ZVByb2dyZXNzKHRyYW5zZmVycmVkKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX3RyYW5zZmVycmVkO1xuICAgICAgICB0aGlzLl90cmFuc2ZlcnJlZCA9IHRyYW5zZmVycmVkO1xuICAgICAgICAvLyBBIHByb2dyZXNzIHVwZGF0ZSBjYW4gbWFrZSB0aGUgXCJ0cmFuc2ZlcnJlZFwiIHZhbHVlIHNtYWxsZXIgKGUuZy4gYVxuICAgICAgICAvLyBwYXJ0aWFsIHVwbG9hZCBub3QgY29tcGxldGVkIGJ5IHNlcnZlciwgYWZ0ZXIgd2hpY2ggdGhlIFwidHJhbnNmZXJyZWRcIlxuICAgICAgICAvLyB2YWx1ZSBtYXkgcmVzZXQgdG8gdGhlIHZhbHVlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlcXVlc3QpLlxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmZXJyZWQgIT09IG9sZCkge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3RyYW5zaXRpb24oc3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuX3N0YXRlID09PSBcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICh3YXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNFRCB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGNhbmNlbGVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBsZXRlVHJhbnNpdGlvbnNfKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGFzayBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgc25hcHNob3QoKSB7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsU3RhdGUgPSB0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5fc3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXNUcmFuc2ZlcnJlZDogdGhpcy5fdHJhbnNmZXJyZWQsXG4gICAgICAgICAgICB0b3RhbEJ5dGVzOiB0aGlzLl9ibG9iLnNpemUoKSxcbiAgICAgICAgICAgIHN0YXRlOiBleHRlcm5hbFN0YXRlLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuX21ldGFkYXRhLFxuICAgICAgICAgICAgdGFzazogdGhpcyxcbiAgICAgICAgICAgIHJlZjogdGhpcy5fcmVmXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjYWxsYmFjayBmb3IgYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtXG4gICAgICogICAgIFRoZSBgbmV4dGAgZnVuY3Rpb24sIHdoaWNoIGdldHMgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW5cbiAgICAgKiAgICAgdGhlIGV2ZW50IHN0cmVhbSwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdpdGggc29tZSBvciBhbGwgb2YgdGhlc2UgdGhyZWVcbiAgICAgKiAgICAgcHJvcGVydGllcyAoYG5leHRgLCBgZXJyb3JgLCBgY29tcGxldGVgKS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2l0aCBhIGBTdG9yYWdlRXJyb3JgXG4gICAgICogICAgIGlmIHRoZSBldmVudCBzdHJlYW0gZW5kcyBkdWUgdG8gYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIGNvbXBsZXRlZCAtIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBpZiB0aGVcbiAgICAgKiAgICAgZXZlbnQgc3RyZWFtIGVuZHMgbm9ybWFsbHkuXG4gICAgICogQHJldHVybnNcbiAgICAgKiAgICAgSWYgb25seSB0aGUgZXZlbnQgYXJndW1lbnQgaXMgcGFzc2VkLCByZXR1cm5zIGEgZnVuY3Rpb24geW91IGNhbiB1c2UgdG9cbiAgICAgKiAgICAgYWRkIGNhbGxiYWNrcyAoc2VlIHRoZSBleGFtcGxlcyBhYm92ZSkuIElmIG1vcmUgdGhhbiBqdXN0IHRoZSBldmVudFxuICAgICAqICAgICBhcmd1bWVudCBpcyBwYXNzZWQsIHJldHVybnMgYSBmdW5jdGlvbiB5b3UgY2FuIGNhbGwgdG8gdW5yZWdpc3RlciB0aGVcbiAgICAgKiAgICAgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIG9uKHR5cGUsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIC8vIE5vdGU6IGB0eXBlYCBpc24ndCBiZWluZyB1c2VkLiBJdHMgdHlwZSBpcyBhbHNvIGluY29ycmVjdC4gVGFza0V2ZW50IHNob3VsZCBub3QgYmUgYSBzdHJpbmcuXG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyKG5leHRPck9ic2VydmVyIHx8IHVuZGVmaW5lZCwgZXJyb3IgfHwgdW5kZWZpbmVkLCBjb21wbGV0ZWQgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCBiZWhhdmVzIGxpa2UgYSBQcm9taXNlLCBhbmQgcmVzb2x2ZXMgd2l0aCBpdHMgc25hcHNob3QgZGF0YVxuICAgICAqIHdoZW4gdGhlIHVwbG9hZCBjb21wbGV0ZXMuXG4gICAgICogQHBhcmFtIG9uRnVsZmlsbGVkIC0gVGhlIGZ1bGZpbGxtZW50IGNhbGxiYWNrLiBQcm9taXNlIGNoYWluaW5nIHdvcmtzIGFzIG5vcm1hbC5cbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIFRoZSByZWplY3Rpb24gY2FsbGJhY2suXG4gICAgICovXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBUaGVzZSBjYXN0cyBhcmUgbmVlZGVkIHNvIHRoYXQgVHlwZVNjcmlwdCBjYW4gaW5mZXIgdGhlIHR5cGVzIG9mIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgUHJvbWlzZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgdGhlbihudWxsLCBvblJlamVjdGVkKWAuXG4gICAgICovXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBfYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIF9yZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5fb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeU9ic2VydmVycygpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZpbmlzaFByb21pc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3dpdGNoICh0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5fc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICAgICAgYXN5bmModGhpcy5fcmVzb2x2ZS5iaW5kKG51bGwsIHRoaXMuc25hcHNob3QpKSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5DQU5DRUxFRDpcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9DYWxsID0gdGhpcy5fcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICBhc3luYyh0b0NhbGwuYmluZChudWxsLCB0aGlzLl9lcnJvcikpKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfbm90aWZ5T2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTdGF0ZSA9IHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSk7XG4gICAgICAgIHN3aXRjaCAoZXh0ZXJuYWxTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhc3luYyhvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIsIHRoaXMuc25hcHNob3QpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLlNVQ0NFU1M6XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmNvbXBsZXRlLmJpbmQob2JzZXJ2ZXIpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuRVJST1I6XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuX2Vycm9yKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhc3luYyhvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyLCB0aGlzLl9lcnJvcikpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYSBwYXVzZWQgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIGN1cnJlbnRseSBydW5uaW5nIG9yIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc3RhdGUgPT09IFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGEgY3VycmVudGx5IHJ1bm5pbmcgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIHBhdXNlZCBvciBmYWlsZWQgdGFzay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcGVyYXRpb24gdG9vayBlZmZlY3QsIGZhbHNlIGlmIGlnbm9yZWQuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc3RhdGUgPT09IFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi87XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBjdXJyZW50bHkgcnVubmluZyBvciBwYXVzZWQgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIGNvbXBsZXRlIG9yXG4gICAgICogZmFpbGVkIHRhc2suXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLyB8fFxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi87XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyB0byBpbnRlcmFjdCB3aXRoIGEgYnVja2V0IGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIHNlcnZpY2UuXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBfbG9jYXRpb24gLSBBbiBmYnMubG9jYXRpb24sIG9yIHRoZSBVUkwgYXRcbiAqICAgICB3aGljaCB0byBiYXNlIHRoaXMgb2JqZWN0LCBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqICAgICAgICAgZ3M6Ly88YnVja2V0Pi88b2JqZWN0LXBhdGg+XG4gKiAgICAgICAgIGh0dHBbc106Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vXG4gKiAgICAgICAgICAgICAgICAgICAgIDxhcGktdmVyc2lvbj4vYi88YnVja2V0Pi9vLzxvYmplY3QtcGF0aD5cbiAqICAgICBBbnkgcXVlcnkgb3IgZnJhZ21lbnQgc3RyaW5ncyB3aWxsIGJlIGlnbm9yZWQgaW4gdGhlIGh0dHBbc11cbiAqICAgICBmb3JtYXQuIElmIG5vIHZhbHVlIGlzIHBhc3NlZCwgdGhlIHN0b3JhZ2Ugb2JqZWN0IHdpbGwgdXNlIGEgVVJMIGJhc2VkIG9uXG4gKiAgICAgdGhlIHByb2plY3QgSUQgb2YgdGhlIGJhc2UgZmlyZWJhc2UuQXBwIGluc3RhbmNlLlxuICovXG5jbGFzcyBSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9zZXJ2aWNlLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlID0gX3NlcnZpY2U7XG4gICAgICAgIGlmIChsb2NhdGlvbiBpbnN0YW5jZW9mIExvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBMb2NhdGlvbi5tYWtlRnJvbVVybChsb2NhdGlvbiwgX3NlcnZpY2UuaG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIGZvciB0aGUgYnVja2V0IGFuZCBwYXRoIHRoaXMgb2JqZWN0IHJlZmVyZW5jZXMsXG4gICAgICogICAgIGluIHRoZSBmb3JtIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ2dzOi8vJyArIHRoaXMuX2xvY2F0aW9uLmJ1Y2tldCArICcvJyArIHRoaXMuX2xvY2F0aW9uLnBhdGg7XG4gICAgfVxuICAgIF9uZXdSZWYoc2VydmljZSwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgbG9jYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBvZiB0aGlzIG9iamVjdCdzIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcy5fbG9jYXRpb24uYnVja2V0LCAnJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdSZWYodGhpcy5fc2VydmljZSwgbG9jYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnVja2V0IGNvbnRhaW5pbmcgdGhpcyByZWZlcmVuY2UncyBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmJ1Y2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgcGF0aCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXQgZnVsbFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5wYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2hvcnQgbmFtZSBvZiB0aGlzIG9iamVjdCwgd2hpY2ggaXMgdGhlIGxhc3QgY29tcG9uZW50IG9mIHRoZSBmdWxsIHBhdGguXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGZ1bGxQYXRoIGlzICdmdWxsL3BhdGgvaW1hZ2UucG5nJywgbmFtZSBpcyAnaW1hZ2UucG5nJy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RDb21wb25lbnQodGhpcy5fbG9jYXRpb24ucGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgU3RvcmFnZVNlcnZpY2VgIGluc3RhbmNlIHRoaXMgYFN0b3JhZ2VSZWZlcmVuY2VgIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgYFN0b3JhZ2VSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZSBwYXJlbnQgbG9jYXRpb24gb2YgdGhpcyBgU3RvcmFnZVJlZmVyZW5jZWAsIG9yIG51bGwgaWZcbiAgICAgKiB0aGlzIHJlZmVyZW5jZSBpcyB0aGUgcm9vdC5cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGFyZW50KHRoaXMuX2xvY2F0aW9uLnBhdGgpO1xuICAgICAgICBpZiAobmV3UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcy5fbG9jYXRpb24uYnVja2V0LCBuZXdQYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UodGhpcy5fc2VydmljZSwgbG9jYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHRocm93IGFuIGVycm9yIGluIG1ldGhvZHMgdGhhdCBkbyBub3QgYWNjZXB0IGEgcm9vdCByZWZlcmVuY2UuXG4gICAgICovXG4gICAgX3Rocm93SWZSb290KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2F0aW9uLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUm9vdE9wZXJhdGlvbihuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRG93bmxvYWQgdGhlIGJ5dGVzIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIHRoZSBkb3dubG9hZGVkIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRCeXRlc0ludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXRCeXRlcycpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0Qnl0ZXMkMShyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZVxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdCeXRlc0Nvbm5lY3Rpb24pXG4gICAgICAgIC50aGVuKGJ5dGVzID0+IG1heERvd25sb2FkU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyAvLyBHQ1MgbWF5IG5vdCBob25vciB0aGUgUmFuZ2UgaGVhZGVyIGZvciBzbWFsbCBmaWxlc1xuICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMCwgbWF4RG93bmxvYWRTaXplQnl0ZXMpXG4gICAgICAgIDogYnl0ZXMpO1xufVxuLyoqIFN0cmVhbSB0aGUgYnl0ZXMgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLiAqL1xuZnVuY3Rpb24gZ2V0U3RyZWFtSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldFN0cmVhbScpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0Qnl0ZXMkMShyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xuICAgIC8vIFRyYW5zZm9ybXMgdGhlIHN0cmVhbSBzbyB0aGF0IG9ubHkgYG1heERvd25sb2FkU2l6ZUJ5dGVzYCBieXRlcyBhcmUgcGlwZWQgdG8gdGhlIHJlc3VsdFxuICAgIGNvbnN0IG5ld01heFNpemVUcmFuc2Zvcm0gPSAobikgPT4ge1xuICAgICAgICBsZXQgbWlzc2luZ0J5dGVzID0gbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIC8vIEdDUyBtYXkgbm90IGhvbm9yIHRoZSBSYW5nZSBoZWFkZXIgZm9yIHNtYWxsIGZpbGVzXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA8IG1pc3NpbmdCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nQnl0ZXMgLT0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnNsaWNlKDAsIG1pc3NpbmdCeXRlcykpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IG1heERvd25sb2FkU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBuZXcgVHJhbnNmb3JtU3RyZWFtKG5ld01heFNpemVUcmFuc2Zvcm0obWF4RG93bmxvYWRTaXplQnl0ZXMpKVxuICAgICAgICA6IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTsgLy8gVGhlIGRlZmF1bHQgdHJhbnNmb3JtZXIgZm9yd2FyZHMgYWxsIGNodW5rcyB0byBpdHMgcmVhZGFibGUgc2lkZVxuICAgIHJlZi5zdG9yYWdlXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1N0cmVhbUNvbm5lY3Rpb24pXG4gICAgICAgIC50aGVuKHJlYWRhYmxlU3RyZWFtID0+IHJlYWRhYmxlU3RyZWFtLnBpcGVUaHJvdWdoKHJlc3VsdCkpXG4gICAgICAgIC5jYXRjaChlcnIgPT4gcmVzdWx0LndyaXRhYmxlLmFib3J0KGVycikpO1xuICAgIHJldHVybiByZXN1bHQucmVhZGFibGU7XG59XG4vKipcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxuICpcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIG5ld2x5IHVwbG9hZGVkIGRhdGEuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcbiAqL1xuZnVuY3Rpb24gdXBsb2FkQnl0ZXMkMShyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkQnl0ZXMnKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG11bHRpcGFydFVwbG9hZChyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSwgbmV3IEZic0Jsb2IoZGF0YSwgdHJ1ZSksIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2VcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pXG4gICAgICAgIC50aGVuKGZpbmFsTWV0YWRhdGEgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IGZpbmFsTWV0YWRhdGEsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogVXBsb2FkcyBkYXRhIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGNhbiBiZSBwYXVzZWQgYW5kIHJlc3VtZWQsIGFuZCBleHBvc2VzIHByb2dyZXNzIHVwZGF0ZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBuZXdseSB1cGxvYWRlZCBkYXRhLlxuICogQHJldHVybnMgQW4gVXBsb2FkVGFza1xuICovXG5mdW5jdGlvbiB1cGxvYWRCeXRlc1Jlc3VtYWJsZSQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGxvYWRCeXRlc1Jlc3VtYWJsZScpO1xuICAgIHJldHVybiBuZXcgVXBsb2FkVGFzayhyZWYsIG5ldyBGYnNCbG9iKGRhdGEpLCBtZXRhZGF0YSk7XG59XG4vKipcbiAqIFVwbG9hZHMgYSBzdHJpbmcgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgaXMgbm90IHJlc3VtYWJsZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIHN0cmluZyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBuZXdseSB1cGxvYWRlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcbiAqL1xuZnVuY3Rpb24gdXBsb2FkU3RyaW5nJDEocmVmLCB2YWx1ZSwgZm9ybWF0ID0gU3RyaW5nRm9ybWF0LlJBVywgbWV0YWRhdGEpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGxvYWRTdHJpbmcnKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YUZyb21TdHJpbmcoZm9ybWF0LCB2YWx1ZSk7XG4gICAgY29uc3QgbWV0YWRhdGFDbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKTtcbiAgICBpZiAobWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSA9PSBudWxsICYmIGRhdGEuY29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID0gZGF0YS5jb250ZW50VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwbG9hZEJ5dGVzJDEocmVmLCBkYXRhLmRhdGEsIG1ldGFkYXRhQ2xvbmUpO1xufVxuLyoqXG4gKiBMaXN0IGFsbCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cbiAqXG4gKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCBmb3IgY2FsbGluZyBsaXN0KCkgcmVwZWF0ZWRseSB1bnRpbCB0aGVyZSBhcmVcbiAqIG5vIG1vcmUgcmVzdWx0cy4gVGhlIGRlZmF1bHQgcGFnaW5hdGlvbiBzaXplIGlzIDEwMDAuXG4gKlxuICogTm90ZTogVGhlIHJlc3VsdHMgbWF5IG5vdCBiZSBjb25zaXN0ZW50IGlmIG9iamVjdHMgYXJlIGNoYW5nZWQgd2hpbGUgdGhpc1xuICogb3BlcmF0aW9uIGlzIHJ1bm5pbmcuXG4gKlxuICogV2FybmluZzogbGlzdEFsbCBtYXkgcG90ZW50aWFsbHkgY29uc3VtZSB0b28gbWFueSByZXNvdXJjZXMgaWYgdGhlcmUgYXJlXG4gKiB0b28gbWFueSByZXN1bHRzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGxpc3QgZnJvbS5cbiAqXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFsbCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzIHVuZGVyXG4gKiAgICAgIHRoZSBjdXJyZW50IHN0b3JhZ2UgcmVmZXJlbmNlLiBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG9cbiAqICAgICAgc3ViLWRpcmVjdG9yaWVzIGFuZCBgaXRlbXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzXG4gKiAgICAgIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gIGlzIG5ldmVyIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBsaXN0QWxsJDEocmVmKSB7XG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSB7XG4gICAgICAgIHByZWZpeGVzOiBbXSxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yKS50aGVuKCgpID0+IGFjY3VtdWxhdG9yKTtcbn1cbi8qKlxuICogU2VwYXJhdGVkIGZyb20gbGlzdEFsbCBiZWNhdXNlIGFzeW5jIGZ1bmN0aW9ucyBjYW4ndCB1c2UgXCJhcmd1bWVudHNcIi5cbiAqIEBwYXJhbSByZWZcbiAqIEBwYXJhbSBhY2N1bXVsYXRvclxuICogQHBhcmFtIHBhZ2VUb2tlblxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0QWxsSGVscGVyKHJlZiwgYWNjdW11bGF0b3IsIHBhZ2VUb2tlbikge1xuICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgLy8gbWF4UmVzdWx0cyBpcyAxMDAwIGJ5IGRlZmF1bHQuXG4gICAgICAgIHBhZ2VUb2tlblxuICAgIH07XG4gICAgY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBsaXN0JDEocmVmLCBvcHQpO1xuICAgIGFjY3VtdWxhdG9yLnByZWZpeGVzLnB1c2goLi4ubmV4dFBhZ2UucHJlZml4ZXMpO1xuICAgIGFjY3VtdWxhdG9yLml0ZW1zLnB1c2goLi4ubmV4dFBhZ2UuaXRlbXMpO1xuICAgIGlmIChuZXh0UGFnZS5uZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yLCBuZXh0UGFnZS5uZXh0UGFnZVRva2VuKTtcbiAgICB9XG59XG4vKipcbiAqIExpc3QgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXG4gKlxuICogTGlzdCBBUEkgaXMgb25seSBhdmFpbGFibGUgZm9yIEZpcmViYXNlIFJ1bGVzIFZlcnNpb24gMi5cbiAqXG4gKiBHQ1MgaXMgYSBrZXktYmxvYiBzdG9yZS4gRmlyZWJhc2UgU3RvcmFnZSBpbXBvc2VzIHRoZSBzZW1hbnRpYyBvZiAnLydcbiAqIGRlbGltaXRlZCBmb2xkZXIgc3RydWN0dXJlLlxuICogUmVmZXIgdG8gR0NTJ3MgTGlzdCBBUEkgaWYgeW91IHdhbnQgdG8gbGVhcm4gbW9yZS5cbiAqXG4gKiBUbyBhZGhlcmUgdG8gRmlyZWJhc2UgUnVsZXMncyBTZW1hbnRpY3MsIEZpcmViYXNlIFN0b3JhZ2UgZG9lcyBub3RcbiAqIHN1cHBvcnQgb2JqZWN0cyB3aG9zZSBwYXRocyBlbmQgd2l0aCBcIi9cIiBvciBjb250YWluIHR3byBjb25zZWN1dGl2ZVxuICogXCIvXCJzLiBGaXJlYmFzZSBTdG9yYWdlIExpc3QgQVBJIHdpbGwgZmlsdGVyIHRoZXNlIHVuc3VwcG9ydGVkIG9iamVjdHMuXG4gKiBsaXN0KCkgbWF5IGZhaWwgaWYgdGhlcmUgYXJlIHRvbyBtYW55IHVuc3VwcG9ydGVkIG9iamVjdHMgaW4gdGhlIGJ1Y2tldC5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgbGlzdCBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMgLSBTZWUgTGlzdE9wdGlvbnMgZm9yIGRldGFpbHMuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMuXG4gKiAgICAgIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBzdWItZm9sZGVycyBhbmQgYGl0ZW1zYFxuICogICAgICBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpcyBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYFxuICogICAgICBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHJlc3Qgb2YgdGhlIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3QkMShyZWYsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhSZXN1bHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ29wdGlvbnMubWF4UmVzdWx0cycsIFxuICAgICAgICAgICAgLyogbWluVmFsdWU9ICovIDEsIFxuICAgICAgICAgICAgLyogbWF4VmFsdWU9ICovIDEwMDAsIG9wdGlvbnMubWF4UmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3AgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbGlzdCQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBcbiAgICAvKmRlbGltaXRlcj0gKi8gJy8nLCBvcC5wYWdlVG9rZW4sIG9wLm1heFJlc3VsdHMpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcbn1cbi8qKlxuICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXNcbiAqIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIG1ldGFkYXRhIGNhbm5vdCBiZSByZXRyaWV2ZWQsIHRoZSBwcm9taXNlIGlzXG4gKiByZWplY3RlZC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBtZXRhZGF0YSBmcm9tLlxuICovXG5mdW5jdGlvbiBnZXRNZXRhZGF0YSQxKHJlZikge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldE1ldGFkYXRhJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRNZXRhZGF0YSQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBnZXRNYXBwaW5ncygpKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIHVwZGF0ZSBtZXRhZGF0YSBmb3IuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgbmV3IG1ldGFkYXRhIGZvciB0aGUgb2JqZWN0LlxuICogICAgIE9ubHkgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc2V0IHdpbGwgYmUgY2hhbmdlZC4gRXhwbGljaXRseVxuICogICAgIHNldHRpbmcgYSB2YWx1ZSB0byBudWxsIHdpbGwgcmVtb3ZlIHRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXNcbiAqICAgICB3aXRoIHRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICogICAgIFNlZSBgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0TWV0YWRhdGFgXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhJDEocmVmLCBtZXRhZGF0YSkge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwZGF0ZU1ldGFkYXRhJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSB1cGRhdGVNZXRhZGF0YSQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtZXRhZGF0YSwgZ2V0TWFwcGluZ3MoKSk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkb3dubG9hZCBVUkwgZm9yIHRoZSBnaXZlbiBSZWZlcmVuY2UuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRvd25sb2FkXG4gKiAgICAgVVJMIGZvciB0aGlzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwkMShyZWYpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXREb3dubG9hZFVSTCcpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0RG93bmxvYWRVcmwocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIGdldE1hcHBpbmdzKCkpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZVxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbilcbiAgICAgICAgLnRoZW4odXJsID0+IHtcbiAgICAgICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbm9Eb3dubG9hZFVSTCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG59XG4vKipcbiAqIERlbGV0ZXMgdGhlIG9iamVjdCBhdCB0aGlzIGxvY2F0aW9uLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgZm9yIG9iamVjdCB0byBkZWxldGUuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBkZWxldGlvbiBzdWNjZWVkcy5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlT2JqZWN0JDEocmVmKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZGVsZXRlT2JqZWN0Jyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBkZWxldGVPYmplY3QkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9idGFpbmVkIGJ5IGFwcGVuZGluZyBgY2hpbGRQYXRoYCB0byBgcmVmYC5cbiAqXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgY2hpbGQgb2YuXG4gKiBAcGFyYW0gY2hpbGRQYXRoIC0gQ2hpbGQgcGF0aCBmcm9tIHByb3ZpZGVkIHJlZi5cbiAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3Qgb2J0YWluZWQgYnlcbiAqIGFwcGVuZGluZyBjaGlsZFBhdGgsIHJlbW92aW5nIGFueSBkdXBsaWNhdGUsIGJlZ2lubmluZywgb3IgdHJhaWxpbmdcbiAqIHNsYXNoZXMuXG4gKlxuICovXG5mdW5jdGlvbiBfZ2V0Q2hpbGQkMShyZWYsIGNoaWxkUGF0aCkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBjaGlsZChyZWYuX2xvY2F0aW9uLnBhdGgsIGNoaWxkUGF0aCk7XG4gICAgY29uc3QgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24ocmVmLl9sb2NhdGlvbi5idWNrZXQsIG5ld1BhdGgpO1xuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHJlZi5zdG9yYWdlLCBsb2NhdGlvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc1VybChwYXRoKSB7XG4gICAgcmV0dXJuIC9eW0EtWmEtel0rOlxcL1xcLy8udGVzdChwYXRoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiB1cmwuXG4gKi9cbmZ1bmN0aW9uIHJlZkZyb21VUkwoc2VydmljZSwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgdXJsKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiBwYXRoIGluIHRoZSBkZWZhdWx0XG4gKiBidWNrZXQuXG4gKi9cbmZ1bmN0aW9uIHJlZkZyb21QYXRoKHJlZiwgcGF0aCkge1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBGaXJlYmFzZVN0b3JhZ2VJbXBsKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSByZWY7XG4gICAgICAgIGlmIChzZXJ2aWNlLl9idWNrZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbm9EZWZhdWx0QnVja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCBzZXJ2aWNlLl9idWNrZXQpO1xuICAgICAgICBpZiAocGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmRnJvbVBhdGgocmVmZXJlbmNlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHJlZiBpcyBhIFJlZmVyZW5jZVxuICAgICAgICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldENoaWxkJDEocmVmLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZWYkMShzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCkge1xuICAgIGlmIChwYXRoT3JVcmwgJiYgaXNVcmwocGF0aE9yVXJsKSkge1xuICAgICAgICBpZiAoc2VydmljZU9yUmVmIGluc3RhbmNlb2YgRmlyZWJhc2VTdG9yYWdlSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZkZyb21VUkwoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50KCdUbyB1c2UgcmVmKHNlcnZpY2UsIHVybCksIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RvcmFnZSBpbnN0YW5jZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZkZyb21QYXRoKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0QnVja2V0KGhvc3QsIGNvbmZpZykge1xuICAgIGNvbnN0IGJ1Y2tldFN0cmluZyA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ1tDT05GSUdfU1RPUkFHRV9CVUNLRVRfS0VZXTtcbiAgICBpZiAoYnVja2V0U3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nLCBob3N0KTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3RTdG9yYWdlRW11bGF0b3IkMShzdG9yYWdlLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcbiAgICBzdG9yYWdlLmhvc3QgPSBgJHtob3N0fToke3BvcnR9YDtcbiAgICBzdG9yYWdlLl9wcm90b2NvbCA9ICdodHRwJztcbiAgICBjb25zdCB7IG1vY2tVc2VyVG9rZW4gfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgc3RvcmFnZS5fb3ZlcnJpZGVBdXRoVG9rZW4gPVxuICAgICAgICAgICAgdHlwZW9mIG1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtb2NrVXNlclRva2VuXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG1vY2tVc2VyVG9rZW4sIHN0b3JhZ2UuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIEZpcmViYXNlIFN0b3JhZ2UgUmVmZXJlbmNlIGluc3RhbmNlcy5cbiAqIEBwYXJhbSBvcHRfdXJsIC0gZ3M6Ly8gdXJsIHRvIGEgY3VzdG9tIFN0b3JhZ2UgQnVja2V0XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEZpcmViYXNlU3RvcmFnZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIEZpcmViYXNlQXBwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFN0b3JhZ2VTZXJ2aWNlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFwcCwgX2F1dGhQcm92aWRlciwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2FwcENoZWNrUHJvdmlkZXIsIFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF91cmwsIF9maXJlYmFzZVZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuX2F1dGhQcm92aWRlciA9IF9hdXRoUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX2FwcENoZWNrUHJvdmlkZXIgPSBfYXBwQ2hlY2tQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fdXJsID0gX3VybDtcbiAgICAgICAgdGhpcy5fZmlyZWJhc2VWZXJzaW9uID0gX2ZpcmViYXNlVmVyc2lvbjtcbiAgICAgICAgdGhpcy5fYnVja2V0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgc3RyaW5nIGNhbiBiZSBpbiB0aGUgZm9ybWF0czpcbiAgICAgICAgICogLSBob3N0XG4gICAgICAgICAqIC0gaG9zdDpwb3J0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3N0ID0gREVGQVVMVF9IT1NUO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9ICdodHRwcyc7XG4gICAgICAgIHRoaXMuX2FwcElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tYXhPcGVyYXRpb25SZXRyeVRpbWUgPSBERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRTtcbiAgICAgICAgdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lID0gREVGQVVMVF9NQVhfVVBMT0FEX1JFVFJZX1RJTUU7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoX3VybCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoX3VybCwgdGhpcy5faG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBleHRyYWN0QnVja2V0KHRoaXMuX2hvc3QsIHRoaXMuYXBwLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBob3N0IHN0cmluZyBmb3IgdGhpcyBzZXJ2aWNlLCBpbiB0aGUgZm9ybSBvZiBgaG9zdGAgb3JcbiAgICAgKiBgaG9zdDpwb3J0YC5cbiAgICAgKi9cbiAgICBnZXQgaG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3Q7XG4gICAgfVxuICAgIHNldCBob3N0KGhvc3QpIHtcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gICAgICAgIGlmICh0aGlzLl91cmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYnVja2V0ID0gTG9jYXRpb24ubWFrZUZyb21CdWNrZXRTcGVjKHRoaXMuX3VybCwgaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBleHRyYWN0QnVja2V0KGhvc3QsIHRoaXMuYXBwLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gcmV0cnkgdXBsb2FkcyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgZ2V0IG1heFVwbG9hZFJldHJ5VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFVwbG9hZFJldHJ5VGltZTtcbiAgICB9XG4gICAgc2V0IG1heFVwbG9hZFJldHJ5VGltZSh0aW1lKSB7XG4gICAgICAgIHZhbGlkYXRlTnVtYmVyKCd0aW1lJywgXG4gICAgICAgIC8qIG1pblZhbHVlPSovIDAsIFxuICAgICAgICAvKiBtYXhWYWx1ZT0gKi8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0aW1lKTtcbiAgICAgICAgdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lID0gdGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdGltZSB0byByZXRyeSBvcGVyYXRpb25zIG90aGVyIHRoYW4gdXBsb2FkcyBvciBkb3dubG9hZHMgaW5cbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgZ2V0IG1heE9wZXJhdGlvblJldHJ5VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICB9XG4gICAgc2V0IG1heE9wZXJhdGlvblJldHJ5VGltZSh0aW1lKSB7XG4gICAgICAgIHZhbGlkYXRlTnVtYmVyKCd0aW1lJywgXG4gICAgICAgIC8qIG1pblZhbHVlPSovIDAsIFxuICAgICAgICAvKiBtYXhWYWx1ZT0gKi8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0aW1lKTtcbiAgICAgICAgdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lID0gdGltZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldEF1dGhUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlQXV0aFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcnJpZGVBdXRoVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aCA9IHRoaXMuX2F1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGF1dGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGF0YSA9IGF3YWl0IGF1dGguZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIGlmICh0b2tlbkRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5EYXRhLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSAmJiB0aGlzLmFwcC5zZXR0aW5ncy5hcHBDaGVja1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHAuc2V0dGluZ3MuYXBwQ2hlY2tUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBDaGVjayA9IHRoaXMuX2FwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgICAgIGlmIChhcHBDaGVjaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXBwQ2hlY2suZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgZG8gd2Ugd2FudCB0byBkbyBpZiB0aGVyZSBpcyBhbiBlcnJvciBnZXR0aW5nIHRoZSB0b2tlbj9cbiAgICAgICAgICAgIC8vIENvbnRleHQ6IGFwcENoZWNrLmdldFRva2VuKCkgd2lsbCBuZXZlciB0aHJvdyBldmVuIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBJbiB0aGUgZXJyb3IgY2FzZSwgYSBkdW1teSB0b2tlbiB3aWxsIGJlXG4gICAgICAgICAgICAvLyByZXR1cm5lZCBhbG9uZyB3aXRoIGFuIGVycm9yIGZpZWxkIGRlc2NyaWJpbmcgdGhlIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBzaG91bGRuJ3QgY2FyZSBhYm91dCB0aGUgZXJyb3IgY29uZGl0aW9uIGFuZCBqdXN0IHVzZVxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHJ1bm5pbmcgcmVxdWVzdHMgYW5kIHByZXZlbnQgbW9yZSBmcm9tIGJlaW5nIGNyZWF0ZWQuXG4gICAgICovXG4gICAgX2RlbGV0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LmNhbmNlbCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2Ugb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgU3RvcmFnZVNlcnZpY2VcbiAgICAgKiBhdCB0aGUgZ2l2ZW4gTG9jYXRpb24uXG4gICAgICovXG4gICAgX21ha2VTdG9yYWdlUmVmZXJlbmNlKGxvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLCBsb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVxdWVzdEluZm8gLSBIVFRQIFJlcXVlc3RJbmZvIG9iamVjdFxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW4gLSBGaXJlYmFzZSBhdXRoIHRva2VuXG4gICAgICovXG4gICAgX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCByZXRyeSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHRoaXMuX2FwcElkLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJlcXVlc3RGYWN0b3J5LCB0aGlzLl9maXJlYmFzZVZlcnNpb24sIHJldHJ5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmFkZChyZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgcmVtb3ZlcyBpdHNlbGYgZnJvbSBzZXQgd2hlbiBjb21wbGV0ZS5cbiAgICAgICAgICAgIHJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKCkgPT4gdGhpcy5fcmVxdWVzdHMuZGVsZXRlKHJlcXVlc3QpLCAoKSA9PiB0aGlzLl9yZXF1ZXN0cy5kZWxldGUocmVxdWVzdCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhaWxSZXF1ZXN0KGFwcERlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSkge1xuICAgICAgICBjb25zdCBbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX2dldEF1dGhUb2tlbigpLFxuICAgICAgICAgICAgdGhpcy5fZ2V0QXBwQ2hlY2tUb2tlbigpXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pLmdldFByb21pc2UoKTtcbiAgICB9XG59XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjEzLjZcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVHlwZSBjb25zdGFudCBmb3IgRmlyZWJhc2UgU3RvcmFnZS5cbiAqL1xuY29uc3QgU1RPUkFHRV9UWVBFID0gJ3N0b3JhZ2UnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb3dubG9hZHMgdGhlIGRhdGEgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBvYmplY3RcbiAqIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbmFsaXR5LCB5b3UgaGF2ZSB0byB3aGl0ZWxpc3QgeW91ciBhcHAncyBvcmlnaW4gaW4geW91clxuICogQ2xvdWQgU3RvcmFnZSBidWNrZXQuIFNlZSBhbHNvXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2NvbmZpZ3VyaW5nLWNvcnNcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxuICogQHBhcmFtIG1heERvd25sb2FkU2l6ZUJ5dGVzIC0gSWYgc2V0LCB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUgaW4gYnl0ZXMgdG9cbiAqIHJldHJpZXZlLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIG9iamVjdCdzIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVzKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gZ2V0Qnl0ZXNJbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKTtcbn1cbi8qKlxuICogVXBsb2FkcyBkYXRhIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHdoZXJlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XG4gKi9cbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gdXBsb2FkQnl0ZXMkMShyZWYsIGRhdGEsIG1ldGFkYXRhKTtcbn1cbi8qKlxuICogVXBsb2FkcyBhIHN0cmluZyB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBzdHJpbmcgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxuICovXG5mdW5jdGlvbiB1cGxvYWRTdHJpbmcocmVmLCB2YWx1ZSwgZm9ybWF0LCBtZXRhZGF0YSkge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiB1cGxvYWRTdHJpbmckMShyZWYsIHZhbHVlLCBmb3JtYXQsIG1ldGFkYXRhKTtcbn1cbi8qKlxuICogVXBsb2FkcyBkYXRhIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGNhbiBiZSBwYXVzZWQgYW5kIHJlc3VtZWQsIGFuZCBleHBvc2VzIHByb2dyZXNzIHVwZGF0ZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHdoZXJlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIGRhdGEgdG8gdXBsb2FkLlxuICogQHJldHVybnMgQW4gVXBsb2FkVGFza1xuICovXG5mdW5jdGlvbiB1cGxvYWRCeXRlc1Jlc3VtYWJsZShyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIHVwbG9hZEJ5dGVzUmVzdW1hYmxlJDEocmVmLCBkYXRhLCBtZXRhZGF0YSk7XG59XG4vKipcbiAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzXG4gKiBvYmplY3QgZG9lc24ndCBleGlzdCBvciBtZXRhZGF0YSBjYW5ub3QgYmUgcmV0cmlldmVkLCB0aGUgcHJvbWlzZSBpc1xuICogcmVqZWN0ZWQuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBtZXRhZGF0YSBmcm9tLlxuICovXG5mdW5jdGlvbiBnZXRNZXRhZGF0YShyZWYpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gZ2V0TWV0YWRhdGEkMShyZWYpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIHVwZGF0ZSBtZXRhZGF0YSBmb3IuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgbmV3IG1ldGFkYXRhIGZvciB0aGUgb2JqZWN0LlxuICogICAgIE9ubHkgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc2V0IHdpbGwgYmUgY2hhbmdlZC4gRXhwbGljaXRseVxuICogICAgIHNldHRpbmcgYSB2YWx1ZSB0byBudWxsIHdpbGwgcmVtb3ZlIHRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV3IG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEocmVmLCBtZXRhZGF0YSkge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiB1cGRhdGVNZXRhZGF0YSQxKHJlZiwgbWV0YWRhdGEpO1xufVxuLyoqXG4gKiBMaXN0IGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxuICpcbiAqIExpc3QgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBGaXJlYmFzZSBSdWxlcyBWZXJzaW9uIDIuXG4gKlxuICogR0NTIGlzIGEga2V5LWJsb2Igc3RvcmUuIEZpcmViYXNlIFN0b3JhZ2UgaW1wb3NlcyB0aGUgc2VtYW50aWMgb2YgJy8nXG4gKiBkZWxpbWl0ZWQgZm9sZGVyIHN0cnVjdHVyZS5cbiAqIFJlZmVyIHRvIEdDUydzIExpc3QgQVBJIGlmIHlvdSB3YW50IHRvIGxlYXJuIG1vcmUuXG4gKlxuICogVG8gYWRoZXJlIHRvIEZpcmViYXNlIFJ1bGVzJ3MgU2VtYW50aWNzLCBGaXJlYmFzZSBTdG9yYWdlIGRvZXMgbm90XG4gKiBzdXBwb3J0IG9iamVjdHMgd2hvc2UgcGF0aHMgZW5kIHdpdGggXCIvXCIgb3IgY29udGFpbiB0d28gY29uc2VjdXRpdmVcbiAqIFwiL1wicy4gRmlyZWJhc2UgU3RvcmFnZSBMaXN0IEFQSSB3aWxsIGZpbHRlciB0aGVzZSB1bnN1cHBvcnRlZCBvYmplY3RzLlxuICogbGlzdCgpIG1heSBmYWlsIGlmIHRoZXJlIGFyZSB0b28gbWFueSB1bnN1cHBvcnRlZCBvYmplY3RzIGluIHRoZSBidWNrZXQuXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byBnZXQgbGlzdCBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIExpc3RPcHRpb25zfSBmb3IgZGV0YWlscy5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzLlxuICogICAgICBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gc3ViLWZvbGRlcnMgYW5kIGBpdGVtc2BcbiAqICAgICAgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXMgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmBcbiAqICAgICAgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSByZXN0IG9mIHRoZSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBsaXN0KHJlZiwgb3B0aW9ucykge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBsaXN0JDEocmVmLCBvcHRpb25zKTtcbn1cbi8qKlxuICogTGlzdCBhbGwgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXG4gKlxuICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgZm9yIGNhbGxpbmcgbGlzdCgpIHJlcGVhdGVkbHkgdW50aWwgdGhlcmUgYXJlXG4gKiBubyBtb3JlIHJlc3VsdHMuIFRoZSBkZWZhdWx0IHBhZ2luYXRpb24gc2l6ZSBpcyAxMDAwLlxuICpcbiAqIE5vdGU6IFRoZSByZXN1bHRzIG1heSBub3QgYmUgY29uc2lzdGVudCBpZiBvYmplY3RzIGFyZSBjaGFuZ2VkIHdoaWxlIHRoaXNcbiAqIG9wZXJhdGlvbiBpcyBydW5uaW5nLlxuICpcbiAqIFdhcm5pbmc6IGBsaXN0QWxsYCBtYXkgcG90ZW50aWFsbHkgY29uc3VtZSB0b28gbWFueSByZXNvdXJjZXMgaWYgdGhlcmUgYXJlXG4gKiB0b28gbWFueSByZXN1bHRzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byBnZXQgbGlzdCBmcm9tLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbGwgdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcyB1bmRlclxuICogICAgICB0aGUgY3VycmVudCBzdG9yYWdlIHJlZmVyZW5jZS4gYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvXG4gKiAgICAgIHN1Yi1kaXJlY3RvcmllcyBhbmQgYGl0ZW1zYCBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpc1xuICogICAgICBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYCBpcyBuZXZlciByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gbGlzdEFsbChyZWYpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gbGlzdEFsbCQxKHJlZik7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRvd25sb2FkIFVSTCBmb3IgdGhlIGdpdmVuIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IHRoZSBkb3dubG9hZCBVUkwgZm9yLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkb3dubG9hZFxuICogICAgIFVSTCBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldERvd25sb2FkVVJMKHJlZikge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBnZXREb3dubG9hZFVSTCQxKHJlZik7XG59XG4vKipcbiAqIERlbGV0ZXMgdGhlIG9iamVjdCBhdCB0aGlzIGxvY2F0aW9uLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSBmb3Igb2JqZWN0IHRvIGRlbGV0ZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIGRlbGV0aW9uIHN1Y2NlZWRzLlxuICovXG5mdW5jdGlvbiBkZWxldGVPYmplY3QocmVmKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGRlbGV0ZU9iamVjdCQxKHJlZik7XG59XG5mdW5jdGlvbiByZWYoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpIHtcbiAgICBzZXJ2aWNlT3JSZWYgPSBnZXRNb2R1bGFySW5zdGFuY2Uoc2VydmljZU9yUmVmKTtcbiAgICByZXR1cm4gcmVmJDEoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2dldENoaWxkKHJlZiwgY2hpbGRQYXRoKSB7XG4gICAgcmV0dXJuIF9nZXRDaGlsZCQxKHJlZiwgY2hpbGRQYXRoKTtcbn1cbi8qKlxuICogR2V0cyBhIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gRmlyZWJhc2UgYXBwLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlIGFwcCB0byBnZXQge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UgZm9yLlxuICogQHBhcmFtIGJ1Y2tldFVybCAtIFRoZSBnczovLyB1cmwgdG8geW91ciBGaXJlYmFzZSBTdG9yYWdlIEJ1Y2tldC5cbiAqIElmIG5vdCBwYXNzZWQsIHVzZXMgdGhlIGFwcCdzIGRlZmF1bHQgU3RvcmFnZSBCdWNrZXQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTdG9yYWdlKGFwcCA9IGdldEFwcCgpLCBidWNrZXRVcmwpIHtcbiAgICBhcHAgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXBwKTtcbiAgICBjb25zdCBzdG9yYWdlUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCBTVE9SQUdFX1RZUEUpO1xuICAgIGNvbnN0IHN0b3JhZ2VJbnN0YW5jZSA9IHN0b3JhZ2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBpZGVudGlmaWVyOiBidWNrZXRVcmxcbiAgICB9KTtcbiAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnc3RvcmFnZScpO1xuICAgIGlmIChlbXVsYXRvcikge1xuICAgICAgICBjb25uZWN0U3RvcmFnZUVtdWxhdG9yKHN0b3JhZ2VJbnN0YW5jZSwgLi4uZW11bGF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmFnZUluc3RhbmNlO1xufVxuLyoqXG4gKiBNb2RpZnkgdGhpcyB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBTdG9yYWdlIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSBzdG9yYWdlIC0gVGhlIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlXG4gKiBAcGFyYW0gaG9zdCAtIFRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KVxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDUwMDEpXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVtdWxhdG9yIG9wdGlvbnMuIGBvcHRpb25zLm1vY2tVc2VyVG9rZW5gIGlzIHRoZSBtb2NrIGF1dGhcbiAqIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25uZWN0U3RvcmFnZUVtdWxhdG9yKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbm5lY3RTdG9yYWdlRW11bGF0b3IkMShzdG9yYWdlLCBob3N0LCBwb3J0LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgb2JqZWN0XG4gKiBpcyBub3QgZm91bmQuXG4gKlxuICogVG8gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eSwgeW91IGhhdmUgdG8gd2hpdGVsaXN0IHlvdXIgYXBwJ3Mgb3JpZ2luIGluIHlvdXJcbiAqIENsb3VkIFN0b3JhZ2UgYnVja2V0LiBTZWUgYWxzb1xuICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2UvZG9jcy9jb25maWd1cmluZy1jb3JzXG4gKlxuICogVGhpcyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiBOb2RlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xuICogcmV0cmlldmUuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgQmxvYiBjb250YWluaW5nIHRoZSBvYmplY3QncyBieXRlc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiBnZXRCbG9iKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJsb2IoKSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBCcm93c2VyLWxpa2UgZW52aXJvbm1lbnRzJyk7XG59XG4vKipcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJhaXNlcyBhbiBlcnJvciBldmVudCBpZiB0aGVcbiAqIG9iamVjdCBpcyBub3QgZm91bmQuXG4gKlxuICogVGhpcyBBUEkgaXMgb25seSBhdmFpbGFibGUgaW4gTm9kZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxuICogQHBhcmFtIG1heERvd25sb2FkU2l6ZUJ5dGVzIC0gSWYgc2V0LCB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUgaW4gYnl0ZXMgdG9cbiAqIHJldHJpZXZlLlxuICogQHJldHVybnMgQSBzdHJlYW0gd2l0aCB0aGUgb2JqZWN0J3MgZGF0YSBhcyBieXRlc1xuICovXG5mdW5jdGlvbiBnZXRTdHJlYW0ocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBnZXRTdHJlYW1JbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKTtcbn1cblxuLyoqXG4gKiBDbG91ZCBTdG9yYWdlIGZvciBGaXJlYmFzZVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiBmYWN0b3J5KGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHVybCB9KSB7XG4gICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcbiAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUltcGwoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgU0RLX1ZFUlNJT04pO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdG9yYWdlKCkge1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFNUT1JBR0VfVFlQRSwgZmFjdG9yeSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcbn1cbnJlZ2lzdGVyU3RvcmFnZSgpO1xuXG5leHBvcnQgeyBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvckNvZGUsIFN0cmluZ0Zvcm1hdCwgRmJzQmxvYiBhcyBfRmJzQmxvYiwgTG9jYXRpb24gYXMgX0xvY2F0aW9uLCBUYXNrRXZlbnQgYXMgX1Rhc2tFdmVudCwgVGFza1N0YXRlIGFzIF9UYXNrU3RhdGUsIFVwbG9hZFRhc2sgYXMgX1VwbG9hZFRhc2ssIGRhdGFGcm9tU3RyaW5nIGFzIF9kYXRhRnJvbVN0cmluZywgX2dldENoaWxkLCBpbnZhbGlkQXJndW1lbnQgYXMgX2ludmFsaWRBcmd1bWVudCwgaW52YWxpZFJvb3RPcGVyYXRpb24gYXMgX2ludmFsaWRSb290T3BlcmF0aW9uLCBjb25uZWN0U3RvcmFnZUVtdWxhdG9yLCBkZWxldGVPYmplY3QsIGdldEJsb2IsIGdldEJ5dGVzLCBnZXREb3dubG9hZFVSTCwgZ2V0TWV0YWRhdGEsIGdldFN0b3JhZ2UsIGdldFN0cmVhbSwgbGlzdCwgbGlzdEFsbCwgcmVmLCB1cGRhdGVNZXRhZGF0YSwgdXBsb2FkQnl0ZXMsIHVwbG9hZEJ5dGVzUmVzdW1hYmxlLCB1cGxvYWRTdHJpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isCloudflareWorker: () => (/* binding */ isCloudflareWorker),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return (getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLHdFQUF3RSxLQUFLOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLElBQUksU0FBUyxHQUFHLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsTUFBTSxJQUFJOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRLFVBQVUsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxL0I7QUFDci9CIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxuICovXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxuICovXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgICAgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbi8vIFRPRE8oZGxhcm9jcXVlKTogRGVmaW5lIHRoaXMgYXMgYSBjbGFzcywgc2luY2Ugd2Ugbm8gbG9uZ2VyIHRhcmdldCBFUzUuXG5jb25zdCBiYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAgICovXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0XygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cbiAqL1xuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXG4gKlxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXG4gKi9cbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xufVxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXG4gKiAoYW5kIHJldHVybmVkKS5cbiAqXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxuICpcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAqL1xuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuLyoqXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xuICAgIH1cbn07XG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xuICogcHJlZml4ZWQgYnkgXCJfXCIpXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAgICovXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcbiAgICBpZiAodG9rZW4udWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xuICAgIH1cbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogJ25vbmUnLFxuICAgICAgICB0eXBlOiAnSldUJ1xuICAgIH07XG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgICAgIH0gfSwgdG9rZW4pO1xuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXG4gICAgICAgIHNpZ25hdHVyZVxuICAgIF0uam9pbignLicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldFVBKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcbn1cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnQuXG4gKiBOb3RlOiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGNlcnRhaW4gdGVzdCBmcmFtZXdvcmtzIHRoYXQgYXJlIGluY29tcGxldGVseVxuICogbWltaWNraW5nIGEgYnJvd3NlciwgYW5kIHNob3VsZCBub3QgbGVhZCB0byBhc3N1bWluZyBhbGwgYnJvd3NlciBBUElzIGFyZVxuICogYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnIHx8IGlzV2ViV29ya2VyKCk7XG59XG4vKipcbiAqIERldGVjdCBXZWIgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKTtcbn1cbi8qKlxuICogRGV0ZWN0IENsb3VkZmxhcmUgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRmbGFyZVdvcmtlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdDbG91ZGZsYXJlLVdvcmtlcnMnKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcbn1cbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XG59XG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xufVxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cbmZ1bmN0aW9uIGlzVVdQKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXG4gKlxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxuICogcHJpdmF0ZSBicm93c2luZylcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICovXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgLy8gVHlwZVNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xuICogICB0eXBlIEVyciA9XG4gKiAgICAgJ3Vua25vd24nIHxcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcbiAqICAgICA7XG4gKlxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XG4gKiAgIHZhciBFcnIgPSB7XG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcbiAqICAgfVxuICpcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxuICogICB9O1xuICpcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xuICpcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xuICogICAuLi5cbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXG4gKlxuICogICBjYXRjaCAoZSkge1xuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBjb2RlLCBtZXNzYWdlLCBcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgY3VzdG9tRGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xuICAgICAgICAvLyBGaXggRm9yIEVTNVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgICAgICAvLyBUT0RPKGRsYXJvY3F1ZSk6IFJlcGxhY2UgdGhpcyB3aXRoIGBuZXcudGFyZ2V0YDogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI3N1cHBvcnQtZm9yLW5ld3RhcmdldFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICB3aGljaCB3ZSBjYW4gbm93IHVzZSBzaW5jZSB3ZSBubyBsb25nZXIgdGFyZ2V0IEVTNS5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVycm9yRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XG4gICAgfSk7XG59XG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgY2xhaW1zLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmVcbiAgICB9O1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoISFub3cgJiZcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59XG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xuICogICBzaGExLnVwZGF0ZShieXRlcyk7XG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcbiAqXG4gKiBQZXJmb3JtYW5jZTpcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xuICpcbiAqL1xuLyoqXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG5jbGFzcyBTaGExIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIGxldCBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH1cbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICMgYml0cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcbiAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxuICogVGhlbmFibGUpLlxuICpcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICogICAgIGFzIGEgcHJveHkuXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG4vKipcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcbiAqIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxuICAgICAqXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xuICAgICAgICBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcbiAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgc2VuZE9uZShpLCBmbikge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcbiAgICBsZXQgYXJnRXJyb3I7XG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgICB9XG4gICAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXG4gICAgICAgICAgICBhcmdDb3VudCArXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXG4gICAgICAgICAgICBhcmdFcnJvciArXG4gICAgICAgICAgICAnLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xufVxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcbi8qKlxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxuICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcbi8qKlxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXG4vKipcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXG4gKiBTZWVcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xuICogZm9yIGNvbnRleHQuXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xuLyoqXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cbiAgICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xuICAgIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXG4gICAgUkFORE9NX0ZBQ1RPUiAqXG4gICAgICAgIGN1cnJCYXNlVmFsdWUgKlxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxuICAgICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxuICAgICAgICAyKTtcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXG4gICAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxuICovXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xuICAgICAgICByZXR1cm4gYCR7aX1gO1xuICAgIH1cbiAgICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcbn1cbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XG4gICAgaSA9IE1hdGguYWJzKGkpO1xuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcbiAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgfVxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcbiAgICBpZiAoZGVjID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnc3QnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnbmQnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAzKSB7XG4gICAgICAgIHJldHVybiAncmQnO1xuICAgIH1cbiAgICByZXR1cm4gJ3RoJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XG4gICAgaWYgKHNlcnZpY2UgJiYgc2VydmljZS5fZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXG5DT05TVEFOVFMuTk9ERV9DTElFTlQgPSB0cnVlO1xuXG5leHBvcnQgeyBDT05TVEFOVFMsIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yLCBEZWZlcnJlZCwgRXJyb3JGYWN0b3J5LCBGaXJlYmFzZUVycm9yLCBNQVhfVkFMVUVfTUlMTElTLCBSQU5ET01fRkFDVE9SLCBTaGExLCBhcmVDb29raWVzRW5hYmxlZCwgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciwgYXN5bmMsIGJhc2U2NCwgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzLCBjb250YWlucywgY3JlYXRlTW9ja1VzZXJUb2tlbiwgY3JlYXRlU3Vic2NyaWJlLCBkZWNvZGUsIGRlZXBDb3B5LCBkZWVwRXF1YWwsIGRlZXBFeHRlbmQsIGVycm9yUHJlZml4LCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRBcHBDb25maWcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0RGVmYXVsdHMsIGdldEV4cGVyaW1lbnRhbFNldHRpbmcsIGdldEdsb2JhbCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXRVQSwgaXNBZG1pbiwgaXNCcm93c2VyLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzQ2xvdWRmbGFyZVdvcmtlciwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNXZWJXb3JrZXIsIGlzc3VlZEF0VGltZSwganNvbkV2YWwsIG1hcCwgb3JkaW5hbCwgcHJvbWlzZVdpdGhUaW1lb3V0LCBxdWVyeXN0cmluZywgcXVlcnlzdHJpbmdEZWNvZGUsIHNhZmVHZXQsIHN0cmluZ0xlbmd0aCwgc3RyaW5nVG9CeXRlQXJyYXksIHN0cmluZ2lmeSwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCB2YWxpZGF0ZU5hbWVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Md5: () => (/* binding */ Md5),\n/* harmony export */   \"default\": () => (/* binding */ bloom_blob_es2018)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar bloom_blob_es2018 = {};\n\n/** @license\nCopyright The Closure Library Authors.\nSPDX-License-Identifier: Apache-2.0\n*/\n\nvar Integer;\nvar Md5;\n(function() {var h;/** @license\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\nfunction k(f,a){function c(){}c.prototype=a.prototype;f.D=a.prototype;f.prototype=new c;f.prototype.constructor=f;f.C=function(d,e,g){for(var b=Array(arguments.length-2),r=2;r<arguments.length;r++)b[r-2]=arguments[r];return a.prototype[e].apply(d,b)};}function l(){this.blockSize=-1;}function m(){this.blockSize=-1;this.blockSize=64;this.g=Array(4);this.B=Array(this.blockSize);this.o=this.h=0;this.s();}k(m,l);m.prototype.s=function(){this.g[0]=1732584193;this.g[1]=4023233417;this.g[2]=2562383102;this.g[3]=271733878;this.o=this.h=0;};\nfunction n(f,a,c){c||(c=0);var d=Array(16);if(\"string\"===typeof a)for(var e=0;16>e;++e)d[e]=a.charCodeAt(c++)|a.charCodeAt(c++)<<8|a.charCodeAt(c++)<<16|a.charCodeAt(c++)<<24;else for(e=0;16>e;++e)d[e]=a[c++]|a[c++]<<8|a[c++]<<16|a[c++]<<24;a=f.g[0];c=f.g[1];e=f.g[2];var g=f.g[3];var b=a+(g^c&(e^g))+d[0]+3614090360&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[1]+3905402710&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[2]+606105819&4294967295;e=g+(b<<17&4294967295|b>>>15);\nb=c+(a^e&(g^a))+d[3]+3250441966&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[4]+4118548399&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[5]+1200080426&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[6]+2821735955&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[7]+4249261313&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[8]+1770035416&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[9]+2336552879&4294967295;g=a+(b<<12&4294967295|\nb>>>20);b=e+(c^g&(a^c))+d[10]+4294925233&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[11]+2304563134&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[12]+1804603682&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[13]+4254626195&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[14]+2792965006&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[15]+1236535329&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(e^g&(c^e))+d[1]+4129170786&4294967295;a=c+(b<<\n5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[6]+3225465664&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[11]+643717713&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[0]+3921069994&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[5]+3593408605&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[10]+38016083&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[15]+3634488961&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[4]+3889429448&4294967295;c=\ne+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[9]+568446438&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[14]+3275163606&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[3]+4107603335&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[8]+1163531501&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[13]+2850285829&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[2]+4243563512&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[7]+1735328473&4294967295;\ne=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[12]+2368359562&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(c^e^g)+d[5]+4294588738&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[8]+2272392833&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[11]+1839030562&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[14]+4259657740&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[1]+2763975236&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[4]+1272893353&4294967295;g=a+(b<<11&4294967295|\nb>>>21);b=e+(g^a^c)+d[7]+4139469664&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[10]+3200236656&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[13]+681279174&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[0]+3936430074&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[3]+3572445317&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[6]+76029189&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[9]+3654602809&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[12]+\n3873151461&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[15]+530742520&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[2]+3299628645&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(e^(c|~g))+d[0]+4096336452&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[7]+1126891415&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[14]+2878612391&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[5]+4237533241&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[12]+1700485571&\n4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[3]+2399980690&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[10]+4293915773&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[1]+2240044497&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[8]+1873313359&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[15]+4264355552&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[6]+2734768916&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[13]+1309151649&\n4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[4]+4149444226&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[11]+3174756917&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[2]+718787259&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[9]+3951481745&4294967295;f.g[0]=f.g[0]+a&4294967295;f.g[1]=f.g[1]+(e+(b<<21&4294967295|b>>>11))&4294967295;f.g[2]=f.g[2]+e&4294967295;f.g[3]=f.g[3]+g&4294967295;}\nm.prototype.u=function(f,a){void 0===a&&(a=f.length);for(var c=a-this.blockSize,d=this.B,e=this.h,g=0;g<a;){if(0==e)for(;g<=c;)n(this,f,g),g+=this.blockSize;if(\"string\"===typeof f)for(;g<a;){if(d[e++]=f.charCodeAt(g++),e==this.blockSize){n(this,d);e=0;break}}else for(;g<a;)if(d[e++]=f[g++],e==this.blockSize){n(this,d);e=0;break}}this.h=e;this.o+=a;};\nm.prototype.v=function(){var f=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);f[0]=128;for(var a=1;a<f.length-8;++a)f[a]=0;var c=8*this.o;for(a=f.length-8;a<f.length;++a)f[a]=c&255,c/=256;this.u(f);f=Array(16);for(a=c=0;4>a;++a)for(var d=0;32>d;d+=8)f[c++]=this.g[a]>>>d&255;return f};function p(f,a){var c=q;return Object.prototype.hasOwnProperty.call(c,f)?c[f]:c[f]=a(f)}function t(f,a){this.h=a;for(var c=[],d=!0,e=f.length-1;0<=e;e--){var g=f[e]|0;d&&g==a||(c[e]=g,d=!1);}this.g=c;}var q={};function u(f){return -128<=f&&128>f?p(f,function(a){return new t([a|0],0>a?-1:0)}):new t([f|0],0>f?-1:0)}function v(f){if(isNaN(f)||!isFinite(f))return w;if(0>f)return x(v(-f));for(var a=[],c=1,d=0;f>=c;d++)a[d]=f/c|0,c*=4294967296;return new t(a,0)}\nfunction y(f,a){if(0==f.length)throw Error(\"number format error: empty string\");a=a||10;if(2>a||36<a)throw Error(\"radix out of range: \"+a);if(\"-\"==f.charAt(0))return x(y(f.substring(1),a));if(0<=f.indexOf(\"-\"))throw Error('number format error: interior \"-\" character');for(var c=v(Math.pow(a,8)),d=w,e=0;e<f.length;e+=8){var g=Math.min(8,f.length-e),b=parseInt(f.substring(e,e+g),a);8>g?(g=v(Math.pow(a,g)),d=d.j(g).add(v(b))):(d=d.j(c),d=d.add(v(b)));}return d}var w=u(0),z=u(1),A=u(16777216);h=t.prototype;\nh.m=function(){if(B(this))return -x(this).m();for(var f=0,a=1,c=0;c<this.g.length;c++){var d=this.i(c);f+=(0<=d?d:4294967296+d)*a;a*=4294967296;}return f};h.toString=function(f){f=f||10;if(2>f||36<f)throw Error(\"radix out of range: \"+f);if(C(this))return \"0\";if(B(this))return \"-\"+x(this).toString(f);for(var a=v(Math.pow(f,6)),c=this,d=\"\";;){var e=D(c,a).g;c=F(c,e.j(a));var g=((0<c.g.length?c.g[0]:c.h)>>>0).toString(f);c=e;if(C(c))return g+d;for(;6>g.length;)g=\"0\"+g;d=g+d;}};\nh.i=function(f){return 0>f?0:f<this.g.length?this.g[f]:this.h};function C(f){if(0!=f.h)return !1;for(var a=0;a<f.g.length;a++)if(0!=f.g[a])return !1;return !0}function B(f){return -1==f.h}h.l=function(f){f=F(this,f);return B(f)?-1:C(f)?0:1};function x(f){for(var a=f.g.length,c=[],d=0;d<a;d++)c[d]=~f.g[d];return (new t(c,~f.h)).add(z)}h.abs=function(){return B(this)?x(this):this};\nh.add=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0,e=0;e<=a;e++){var g=d+(this.i(e)&65535)+(f.i(e)&65535),b=(g>>>16)+(this.i(e)>>>16)+(f.i(e)>>>16);d=b>>>16;g&=65535;b&=65535;c[e]=b<<16|g;}return new t(c,c[c.length-1]&-2147483648?-1:0)};function F(f,a){return f.add(x(a))}\nh.j=function(f){if(C(this)||C(f))return w;if(B(this))return B(f)?x(this).j(x(f)):x(x(this).j(f));if(B(f))return x(this.j(x(f)));if(0>this.l(A)&&0>f.l(A))return v(this.m()*f.m());for(var a=this.g.length+f.g.length,c=[],d=0;d<2*a;d++)c[d]=0;for(d=0;d<this.g.length;d++)for(var e=0;e<f.g.length;e++){var g=this.i(d)>>>16,b=this.i(d)&65535,r=f.i(e)>>>16,E=f.i(e)&65535;c[2*d+2*e]+=b*E;G(c,2*d+2*e);c[2*d+2*e+1]+=g*E;G(c,2*d+2*e+1);c[2*d+2*e+1]+=b*r;G(c,2*d+2*e+1);c[2*d+2*e+2]+=g*r;G(c,2*d+2*e+2);}for(d=0;d<\na;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=a;d<2*a;d++)c[d]=0;return new t(c,0)};function G(f,a){for(;(f[a]&65535)!=f[a];)f[a+1]+=f[a]>>>16,f[a]&=65535,a++;}function H(f,a){this.g=f;this.h=a;}\nfunction D(f,a){if(C(a))throw Error(\"division by zero\");if(C(f))return new H(w,w);if(B(f))return a=D(x(f),a),new H(x(a.g),x(a.h));if(B(a))return a=D(f,x(a)),new H(x(a.g),a.h);if(30<f.g.length){if(B(f)||B(a))throw Error(\"slowDivide_ only works with positive integers.\");for(var c=z,d=a;0>=d.l(f);)c=I(c),d=I(d);var e=J(c,1),g=J(d,1);d=J(d,2);for(c=J(c,2);!C(d);){var b=g.add(d);0>=b.l(f)&&(e=e.add(c),g=b);d=J(d,1);c=J(c,1);}a=F(f,e.j(a));return new H(e,a)}for(e=w;0<=f.l(a);){c=Math.max(1,Math.floor(f.m()/\na.m()));d=Math.ceil(Math.log(c)/Math.LN2);d=48>=d?1:Math.pow(2,d-48);g=v(c);for(b=g.j(a);B(b)||0<b.l(f);)c-=d,g=v(c),b=g.j(a);C(g)&&(g=z);e=e.add(g);f=F(f,b);}return new H(e,f)}h.A=function(f){return D(this,f).h};h.and=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)&f.i(d);return new t(c,this.h&f.h)};h.or=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)|f.i(d);return new t(c,this.h|f.h)};\nh.xor=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)^f.i(d);return new t(c,this.h^f.h)};function I(f){for(var a=f.g.length+1,c=[],d=0;d<a;d++)c[d]=f.i(d)<<1|f.i(d-1)>>>31;return new t(c,f.h)}function J(f,a){var c=a>>5;a%=32;for(var d=f.g.length-c,e=[],g=0;g<d;g++)e[g]=0<a?f.i(g+c)>>>a|f.i(g+c+1)<<32-a:f.i(g+c);return new t(e,f.h)}m.prototype.digest=m.prototype.v;m.prototype.reset=m.prototype.s;m.prototype.update=m.prototype.u;Md5 = bloom_blob_es2018.Md5=m;t.prototype.add=t.prototype.add;t.prototype.multiply=t.prototype.j;t.prototype.modulo=t.prototype.A;t.prototype.compare=t.prototype.l;t.prototype.toNumber=t.prototype.m;t.prototype.toString=t.prototype.toString;t.prototype.getBits=t.prototype.i;t.fromNumber=v;t.fromString=y;Integer = bloom_blob_es2018.Integer=t;}).apply( typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self  : typeof window !== 'undefined' ? window  : {});\n\n\n//# sourceMappingURL=bloom_blob_es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2Jsb29tLWJsb2IvZXNtL2Jsb29tX2Jsb2JfZXMyMDE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLHdCQUF3QixnQkFBZ0Isa0JBQWtCLDBCQUEwQixvQkFBb0Isd0NBQXdDLG1CQUFtQix3QkFBd0IsbUNBQW1DLGFBQWEsbUJBQW1CLGFBQWEsa0JBQWtCLGtCQUFrQixnQkFBZ0IsNkJBQTZCLGdCQUFnQixVQUFVLE9BQU8seUJBQXlCLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQjtBQUN2Z0Isa0JBQWtCLFNBQVMsZ0JBQWdCLG1DQUFtQyxLQUFLLDRGQUE0RixhQUFhLEtBQUssZ0RBQWdELFNBQVMsU0FBUyxTQUFTLGFBQWEsK0NBQStDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDBDQUEwQztBQUN4ZCwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDZCQUE2QiwyQ0FBMkM7QUFDL2QsUUFBUSw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsNENBQTRDLDhCQUE4QiwyQ0FBMkM7QUFDOWUscUJBQXFCLDJDQUEyQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsOEJBQThCLDJDQUEyQztBQUNuZiw0QkFBNEIsMENBQTBDLDZCQUE2Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4Qiw0Q0FBNEMsNkJBQTZCLDJDQUEyQyw2QkFBNkI7QUFDL2MsOEJBQThCLDRDQUE0Qyw4QkFBOEIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsOEJBQThCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1QztBQUN2ZSxRQUFRLHVDQUF1Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCLHVDQUF1Qyw4QkFBOEIsdUNBQXVDLDhCQUE4QixxQ0FBcUMsNkJBQTZCLHVDQUF1Qyw2QkFBNkI7QUFDdGUsc0JBQXNCLDhCQUE4Qix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsMENBQTBDLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUM3ZCxXQUFXLDZCQUE2QiwwQ0FBMEMsOEJBQThCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMENBQTBDLDhCQUE4QjtBQUN6ZCxXQUFXLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLDJDQUEyQyw4QkFBOEIseUNBQXlDLDhCQUE4QiwwQ0FBMEMsMkJBQTJCLHVEQUF1RCwyQkFBMkI7QUFDdlosNEJBQTRCLHlCQUF5QixpREFBaUQsSUFBSSxFQUFFLGFBQWEsS0FBSywrQkFBK0IsNEJBQTRCLElBQUksRUFBRSwrQ0FBK0MsVUFBVSxJQUFJLE9BQU8sVUFBVSxJQUFJLHFDQUFxQyxVQUFVLElBQUksT0FBTyxTQUFTO0FBQ3BWLHlCQUF5QixnRUFBZ0UsU0FBUyxZQUFZLGFBQWEsV0FBVyxlQUFlLGlCQUFpQixXQUFXLHNCQUFzQixVQUFVLFlBQVksVUFBVSxJQUFJLGdCQUFnQixLQUFLLDhCQUE4QixVQUFVLGdCQUFnQixRQUFRLGdFQUFnRSxnQkFBZ0IsU0FBUywrQkFBK0IsS0FBSyxLQUFLLGFBQWEsd0JBQXdCLFVBQVUsU0FBUyxjQUFjLHNDQUFzQyw2QkFBNkIsd0JBQXdCLGNBQWMsbUNBQW1DLHVCQUF1QixxQkFBcUIsS0FBSyw2QkFBNkI7QUFDbHVCLGdCQUFnQixnRUFBZ0UsUUFBUSxtREFBbUQsa0RBQWtELGdGQUFnRixtQ0FBbUMsV0FBVyxNQUFNLDhEQUE4RCxzRUFBc0UsU0FBUyxnQ0FBZ0M7QUFDOWUsZUFBZSwrQkFBK0Isb0JBQW9CLGdCQUFnQixLQUFLLGdCQUFnQiwyQkFBMkIsZUFBZSxVQUFVLHVCQUF1QixRQUFRLG1EQUFtRCxzQkFBc0IsMENBQTBDLHdDQUF3QyxFQUFFLGVBQWUsY0FBYyxrREFBa0QsSUFBSSxtQkFBbUIsS0FBSyxXQUFXLFNBQVM7QUFDdGQsZ0JBQWdCLCtDQUErQyxjQUFjLG9CQUFvQixZQUFZLGFBQWEsMkJBQTJCLFVBQVUsY0FBYyxlQUFlLGdCQUFnQixZQUFZLHlCQUF5QixjQUFjLDhCQUE4QixJQUFJLGlCQUFpQiw4QkFBOEIsaUJBQWlCO0FBQ2pXLGtCQUFrQiwwREFBMEQsS0FBSyxLQUFLLG1GQUFtRixTQUFTLFNBQVMsU0FBUyxjQUFjLGdEQUFnRCxnQkFBZ0I7QUFDbFIsZ0JBQWdCLDBCQUEwQix1REFBdUQsK0JBQStCLGtEQUFrRCw0Q0FBNEMsTUFBTSxXQUFXLFFBQVEsZ0JBQWdCLGdCQUFnQixhQUFhLEtBQUssb0VBQW9FLGdCQUFnQixhQUFhLGtCQUFrQixlQUFlLGtCQUFrQixlQUFlLGtCQUFrQixnQkFBZ0IsUUFBUTtBQUN0ZixFQUFFLDZCQUE2QixRQUFRLE1BQU0sV0FBVyxtQkFBbUIsZ0JBQWdCLEtBQUssbUJBQW1CLG9DQUFvQyxnQkFBZ0IsU0FBUztBQUNoTCxnQkFBZ0Isd0NBQXdDLDBCQUEwQixnREFBZ0QsNkNBQTZDLGtCQUFrQiw0RUFBNEUsZ0JBQWdCLFVBQVUsZUFBZSxzQkFBc0IsU0FBUyxhQUFhLE1BQU0sRUFBRSxlQUFlLDRCQUE0QixTQUFTLFVBQVUsY0FBYyxrQkFBa0IsUUFBUSxVQUFVLEVBQUU7QUFDNWQsUUFBUSxrQ0FBa0MsMkJBQTJCLE9BQU8sYUFBYSxlQUFlLHNCQUFzQixZQUFZLFdBQVcsVUFBVSxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0Isc0RBQXNELElBQUksMEJBQTBCLDRCQUE0QixpQkFBaUIsc0RBQXNELElBQUksMEJBQTBCO0FBQzViLGtCQUFrQixzREFBc0QsSUFBSSwwQkFBMEIsNEJBQTRCLGNBQWMsZ0NBQWdDLElBQUksaUNBQWlDLG9CQUFvQixnQkFBZ0IsV0FBVyxNQUFNLGdDQUFnQyxJQUFJLG9EQUFvRCxvQkFBb0IsaUNBQWlDLGdDQUFnQyxpQ0FBaUMsOEJBQThCLGdDQUFnQyxtQ0FBbUMsaUNBQWlDLGtDQUFrQyxtQ0FBbUMsMENBQTBDLGtDQUFrQyxlQUFlLGVBQWUsdUNBQXVDLG9KQUFvSjs7QUFFOTRCO0FBQ3REIiwic291cmNlcyI6WyIvVXNlcnMvb2xpdmlhbGV3YW5kb3dza2kvRGVza3RvcC9mcnVpdGlvbi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2Jsb29tLWJsb2IvZXNtL2Jsb29tX2Jsb2JfZXMyMDE4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgYmxvb21fYmxvYl9lczIwMTggPSB7fTtcblxuLyoqIEBsaWNlbnNlXG5Db3B5cmlnaHQgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLlxuU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiovXG5cbnZhciBJbnRlZ2VyO1xudmFyIE1kNTtcbihmdW5jdGlvbigpIHt2YXIgaDsvKiogQGxpY2Vuc2VcblxuIENvcHlyaWdodCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuXG4gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiovXG5mdW5jdGlvbiBrKGYsYSl7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1hLnByb3RvdHlwZTtmLkQ9YS5wcm90b3R5cGU7Zi5wcm90b3R5cGU9bmV3IGM7Zi5wcm90b3R5cGUuY29uc3RydWN0b3I9ZjtmLkM9ZnVuY3Rpb24oZCxlLGcpe2Zvcih2YXIgYj1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLHI9MjtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWJbci0yXT1hcmd1bWVudHNbcl07cmV0dXJuIGEucHJvdG90eXBlW2VdLmFwcGx5KGQsYil9O31mdW5jdGlvbiBsKCl7dGhpcy5ibG9ja1NpemU9LTE7fWZ1bmN0aW9uIG0oKXt0aGlzLmJsb2NrU2l6ZT0tMTt0aGlzLmJsb2NrU2l6ZT02NDt0aGlzLmc9QXJyYXkoNCk7dGhpcy5CPUFycmF5KHRoaXMuYmxvY2tTaXplKTt0aGlzLm89dGhpcy5oPTA7dGhpcy5zKCk7fWsobSxsKTttLnByb3RvdHlwZS5zPWZ1bmN0aW9uKCl7dGhpcy5nWzBdPTE3MzI1ODQxOTM7dGhpcy5nWzFdPTQwMjMyMzM0MTc7dGhpcy5nWzJdPTI1NjIzODMxMDI7dGhpcy5nWzNdPTI3MTczMzg3ODt0aGlzLm89dGhpcy5oPTA7fTtcbmZ1bmN0aW9uIG4oZixhLGMpe2N8fChjPTApO3ZhciBkPUFycmF5KDE2KTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZm9yKHZhciBlPTA7MTY+ZTsrK2UpZFtlXT1hLmNoYXJDb2RlQXQoYysrKXxhLmNoYXJDb2RlQXQoYysrKTw8OHxhLmNoYXJDb2RlQXQoYysrKTw8MTZ8YS5jaGFyQ29kZUF0KGMrKyk8PDI0O2Vsc2UgZm9yKGU9MDsxNj5lOysrZSlkW2VdPWFbYysrXXxhW2MrK108PDh8YVtjKytdPDwxNnxhW2MrK108PDI0O2E9Zi5nWzBdO2M9Zi5nWzFdO2U9Zi5nWzJdO3ZhciBnPWYuZ1szXTt2YXIgYj1hKyhnXmMmKGVeZykpK2RbMF0rMzYxNDA5MDM2MCY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbMV0rMzkwNTQwMjcxMCY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxiPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzJdKzYwNjEwNTgxOSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTcmNDI5NDk2NzI5NXxiPj4+MTUpO1xuYj1jKyhhXmUmKGdeYSkpK2RbM10rMzI1MDQ0MTk2NiY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjImNDI5NDk2NzI5NXxiPj4+MTApO2I9YSsoZ15jJihlXmcpKStkWzRdKzQxMTg1NDgzOTkmNDI5NDk2NzI5NTthPWMrKGI8PDcmNDI5NDk2NzI5NXxiPj4+MjUpO2I9ZysoZV5hJihjXmUpKStkWzVdKzEyMDAwODA0MjYmNDI5NDk2NzI5NTtnPWErKGI8PDEyJjQyOTQ5NjcyOTV8Yj4+PjIwKTtiPWUrKGNeZyYoYV5jKSkrZFs2XSsyODIxNzM1OTU1JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7Yj1jKyhhXmUmKGdeYSkpK2RbN10rNDI0OTI2MTMxMyY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjImNDI5NDk2NzI5NXxiPj4+MTApO2I9YSsoZ15jJihlXmcpKStkWzhdKzE3NzAwMzU0MTYmNDI5NDk2NzI5NTthPWMrKGI8PDcmNDI5NDk2NzI5NXxiPj4+MjUpO2I9ZysoZV5hJihjXmUpKStkWzldKzIzMzY1NTI4NzkmNDI5NDk2NzI5NTtnPWErKGI8PDEyJjQyOTQ5NjcyOTV8XG5iPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzEwXSs0Mjk0OTI1MjMzJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7Yj1jKyhhXmUmKGdeYSkpK2RbMTFdKzIzMDQ1NjMxMzQmNDI5NDk2NzI5NTtjPWUrKGI8PDIyJjQyOTQ5NjcyOTV8Yj4+PjEwKTtiPWErKGdeYyYoZV5nKSkrZFsxMl0rMTgwNDYwMzY4MiY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbMTNdKzQyNTQ2MjYxOTUmNDI5NDk2NzI5NTtnPWErKGI8PDEyJjQyOTQ5NjcyOTV8Yj4+PjIwKTtiPWUrKGNeZyYoYV5jKSkrZFsxNF0rMjc5Mjk2NTAwNiY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTcmNDI5NDk2NzI5NXxiPj4+MTUpO2I9YysoYV5lJihnXmEpKStkWzE1XSsxMjM2NTM1MzI5JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhlXmcmKGNeZSkpK2RbMV0rNDEyOTE3MDc4NiY0Mjk0OTY3Mjk1O2E9YysoYjw8XG41JjQyOTQ5NjcyOTV8Yj4+PjI3KTtiPWcrKGNeZSYoYV5jKSkrZFs2XSszMjI1NDY1NjY0JjQyOTQ5NjcyOTU7Zz1hKyhiPDw5JjQyOTQ5NjcyOTV8Yj4+PjIzKTtiPWUrKGFeYyYoZ15hKSkrZFsxMV0rNjQzNzE3NzEzJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNCY0Mjk0OTY3Mjk1fGI+Pj4xOCk7Yj1jKyhnXmEmKGVeZykpK2RbMF0rMzkyMTA2OTk5NCY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjAmNDI5NDk2NzI5NXxiPj4+MTIpO2I9YSsoZV5nJihjXmUpKStkWzVdKzM1OTM0MDg2MDUmNDI5NDk2NzI5NTthPWMrKGI8PDUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzEwXSszODAxNjA4MyY0Mjk0OTY3Mjk1O2c9YSsoYjw8OSY0Mjk0OTY3Mjk1fGI+Pj4yMyk7Yj1lKyhhXmMmKGdeYSkpK2RbMTVdKzM2MzQ0ODg5NjEmNDI5NDk2NzI5NTtlPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFs0XSszODg5NDI5NDQ4JjQyOTQ5NjcyOTU7Yz1cbmUrKGI8PDIwJjQyOTQ5NjcyOTV8Yj4+PjEyKTtiPWErKGVeZyYoY15lKSkrZFs5XSs1Njg0NDY0MzgmNDI5NDk2NzI5NTthPWMrKGI8PDUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzE0XSszMjc1MTYzNjA2JjQyOTQ5NjcyOTU7Zz1hKyhiPDw5JjQyOTQ5NjcyOTV8Yj4+PjIzKTtiPWUrKGFeYyYoZ15hKSkrZFszXSs0MTA3NjAzMzM1JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNCY0Mjk0OTY3Mjk1fGI+Pj4xOCk7Yj1jKyhnXmEmKGVeZykpK2RbOF0rMTE2MzUzMTUwMSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjAmNDI5NDk2NzI5NXxiPj4+MTIpO2I9YSsoZV5nJihjXmUpKStkWzEzXSsyODUwMjg1ODI5JjQyOTQ5NjcyOTU7YT1jKyhiPDw1JjQyOTQ5NjcyOTV8Yj4+PjI3KTtiPWcrKGNeZSYoYV5jKSkrZFsyXSs0MjQzNTYzNTEyJjQyOTQ5NjcyOTU7Zz1hKyhiPDw5JjQyOTQ5NjcyOTV8Yj4+PjIzKTtiPWUrKGFeYyYoZ15hKSkrZFs3XSsxNzM1MzI4NDczJjQyOTQ5NjcyOTU7XG5lPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFsxMl0rMjM2ODM1OTU2MiY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjAmNDI5NDk2NzI5NXxiPj4+MTIpO2I9YSsoY15lXmcpK2RbNV0rNDI5NDU4ODczOCY0Mjk0OTY3Mjk1O2E9YysoYjw8NCY0Mjk0OTY3Mjk1fGI+Pj4yOCk7Yj1nKyhhXmNeZSkrZFs4XSsyMjcyMzkyODMzJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMSY0Mjk0OTY3Mjk1fGI+Pj4yMSk7Yj1lKyhnXmFeYykrZFsxMV0rMTgzOTAzMDU2MiY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTYmNDI5NDk2NzI5NXxiPj4+MTYpO2I9YysoZV5nXmEpK2RbMTRdKzQyNTk2NTc3NDAmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoY15lXmcpK2RbMV0rMjc2Mzk3NTIzNiY0Mjk0OTY3Mjk1O2E9YysoYjw8NCY0Mjk0OTY3Mjk1fGI+Pj4yOCk7Yj1nKyhhXmNeZSkrZFs0XSsxMjcyODkzMzUzJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMSY0Mjk0OTY3Mjk1fFxuYj4+PjIxKTtiPWUrKGdeYV5jKStkWzddKzQxMzk0Njk2NjQmNDI5NDk2NzI5NTtlPWcrKGI8PDE2JjQyOTQ5NjcyOTV8Yj4+PjE2KTtiPWMrKGVeZ15hKStkWzEwXSszMjAwMjM2NjU2JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMyY0Mjk0OTY3Mjk1fGI+Pj45KTtiPWErKGNeZV5nKStkWzEzXSs2ODEyNzkxNzQmNDI5NDk2NzI5NTthPWMrKGI8PDQmNDI5NDk2NzI5NXxiPj4+MjgpO2I9ZysoYV5jXmUpK2RbMF0rMzkzNjQzMDA3NCY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTEmNDI5NDk2NzI5NXxiPj4+MjEpO2I9ZSsoZ15hXmMpK2RbM10rMzU3MjQ0NTMxNyY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTYmNDI5NDk2NzI5NXxiPj4+MTYpO2I9YysoZV5nXmEpK2RbNl0rNzYwMjkxODkmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoY15lXmcpK2RbOV0rMzY1NDYwMjgwOSY0Mjk0OTY3Mjk1O2E9YysoYjw8NCY0Mjk0OTY3Mjk1fGI+Pj4yOCk7Yj1nKyhhXmNeZSkrZFsxMl0rXG4zODczMTUxNDYxJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMSY0Mjk0OTY3Mjk1fGI+Pj4yMSk7Yj1lKyhnXmFeYykrZFsxNV0rNTMwNzQyNTIwJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFsyXSszMjk5NjI4NjQ1JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMyY0Mjk0OTY3Mjk1fGI+Pj45KTtiPWErKGVeKGN8fmcpKStkWzBdKzQwOTYzMzY0NTImNDI5NDk2NzI5NTthPWMrKGI8PDYmNDI5NDk2NzI5NXxiPj4+MjYpO2I9ZysoY14oYXx+ZSkpK2RbN10rMTEyNjg5MTQxNSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbMTRdKzI4Nzg2MTIzOTEmNDI5NDk2NzI5NTtlPWcrKGI8PDE1JjQyOTQ5NjcyOTV8Yj4+PjE3KTtiPWMrKGdeKGV8fmEpKStkWzVdKzQyMzc1MzMyNDEmNDI5NDk2NzI5NTtjPWUrKGI8PDIxJjQyOTQ5NjcyOTV8Yj4+PjExKTtiPWErKGVeKGN8fmcpKStkWzEyXSsxNzAwNDg1NTcxJlxuNDI5NDk2NzI5NTthPWMrKGI8PDYmNDI5NDk2NzI5NXxiPj4+MjYpO2I9ZysoY14oYXx+ZSkpK2RbM10rMjM5OTk4MDY5MCY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbMTBdKzQyOTM5MTU3NzMmNDI5NDk2NzI5NTtlPWcrKGI8PDE1JjQyOTQ5NjcyOTV8Yj4+PjE3KTtiPWMrKGdeKGV8fmEpKStkWzFdKzIyNDAwNDQ0OTcmNDI5NDk2NzI5NTtjPWUrKGI8PDIxJjQyOTQ5NjcyOTV8Yj4+PjExKTtiPWErKGVeKGN8fmcpKStkWzhdKzE4NzMzMTMzNTkmNDI5NDk2NzI5NTthPWMrKGI8PDYmNDI5NDk2NzI5NXxiPj4+MjYpO2I9ZysoY14oYXx+ZSkpK2RbMTVdKzQyNjQzNTU1NTImNDI5NDk2NzI5NTtnPWErKGI8PDEwJjQyOTQ5NjcyOTV8Yj4+PjIyKTtiPWUrKGFeKGd8fmMpKStkWzZdKzI3MzQ3Njg5MTYmNDI5NDk2NzI5NTtlPWcrKGI8PDE1JjQyOTQ5NjcyOTV8Yj4+PjE3KTtiPWMrKGdeKGV8fmEpKStkWzEzXSsxMzA5MTUxNjQ5JlxuNDI5NDk2NzI5NTtjPWUrKGI8PDIxJjQyOTQ5NjcyOTV8Yj4+PjExKTtiPWErKGVeKGN8fmcpKStkWzRdKzQxNDk0NDQyMjYmNDI5NDk2NzI5NTthPWMrKGI8PDYmNDI5NDk2NzI5NXxiPj4+MjYpO2I9ZysoY14oYXx+ZSkpK2RbMTFdKzMxNzQ3NTY5MTcmNDI5NDk2NzI5NTtnPWErKGI8PDEwJjQyOTQ5NjcyOTV8Yj4+PjIyKTtiPWUrKGFeKGd8fmMpKStkWzJdKzcxODc4NzI1OSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbOV0rMzk1MTQ4MTc0NSY0Mjk0OTY3Mjk1O2YuZ1swXT1mLmdbMF0rYSY0Mjk0OTY3Mjk1O2YuZ1sxXT1mLmdbMV0rKGUrKGI8PDIxJjQyOTQ5NjcyOTV8Yj4+PjExKSkmNDI5NDk2NzI5NTtmLmdbMl09Zi5nWzJdK2UmNDI5NDk2NzI5NTtmLmdbM109Zi5nWzNdK2cmNDI5NDk2NzI5NTt9XG5tLnByb3RvdHlwZS51PWZ1bmN0aW9uKGYsYSl7dm9pZCAwPT09YSYmKGE9Zi5sZW5ndGgpO2Zvcih2YXIgYz1hLXRoaXMuYmxvY2tTaXplLGQ9dGhpcy5CLGU9dGhpcy5oLGc9MDtnPGE7KXtpZigwPT1lKWZvcig7Zzw9Yzspbih0aGlzLGYsZyksZys9dGhpcy5ibG9ja1NpemU7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmKWZvcig7ZzxhOyl7aWYoZFtlKytdPWYuY2hhckNvZGVBdChnKyspLGU9PXRoaXMuYmxvY2tTaXplKXtuKHRoaXMsZCk7ZT0wO2JyZWFrfX1lbHNlIGZvcig7ZzxhOylpZihkW2UrK109ZltnKytdLGU9PXRoaXMuYmxvY2tTaXplKXtuKHRoaXMsZCk7ZT0wO2JyZWFrfX10aGlzLmg9ZTt0aGlzLm8rPWE7fTtcbm0ucHJvdG90eXBlLnY9ZnVuY3Rpb24oKXt2YXIgZj1BcnJheSgoNTY+dGhpcy5oP3RoaXMuYmxvY2tTaXplOjIqdGhpcy5ibG9ja1NpemUpLXRoaXMuaCk7ZlswXT0xMjg7Zm9yKHZhciBhPTE7YTxmLmxlbmd0aC04OysrYSlmW2FdPTA7dmFyIGM9OCp0aGlzLm87Zm9yKGE9Zi5sZW5ndGgtODthPGYubGVuZ3RoOysrYSlmW2FdPWMmMjU1LGMvPTI1Njt0aGlzLnUoZik7Zj1BcnJheSgxNik7Zm9yKGE9Yz0wOzQ+YTsrK2EpZm9yKHZhciBkPTA7MzI+ZDtkKz04KWZbYysrXT10aGlzLmdbYV0+Pj5kJjI1NTtyZXR1cm4gZn07ZnVuY3Rpb24gcChmLGEpe3ZhciBjPXE7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLGYpP2NbZl06Y1tmXT1hKGYpfWZ1bmN0aW9uIHQoZixhKXt0aGlzLmg9YTtmb3IodmFyIGM9W10sZD0hMCxlPWYubGVuZ3RoLTE7MDw9ZTtlLS0pe3ZhciBnPWZbZV18MDtkJiZnPT1hfHwoY1tlXT1nLGQ9ITEpO310aGlzLmc9Yzt9dmFyIHE9e307ZnVuY3Rpb24gdShmKXtyZXR1cm4gLTEyODw9ZiYmMTI4PmY/cChmLGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgdChbYXwwXSwwPmE/LTE6MCl9KTpuZXcgdChbZnwwXSwwPmY/LTE6MCl9ZnVuY3Rpb24gdihmKXtpZihpc05hTihmKXx8IWlzRmluaXRlKGYpKXJldHVybiB3O2lmKDA+ZilyZXR1cm4geCh2KC1mKSk7Zm9yKHZhciBhPVtdLGM9MSxkPTA7Zj49YztkKyspYVtkXT1mL2N8MCxjKj00Mjk0OTY3Mjk2O3JldHVybiBuZXcgdChhLDApfVxuZnVuY3Rpb24geShmLGEpe2lmKDA9PWYubGVuZ3RoKXRocm93IEVycm9yKFwibnVtYmVyIGZvcm1hdCBlcnJvcjogZW1wdHkgc3RyaW5nXCIpO2E9YXx8MTA7aWYoMj5hfHwzNjxhKXRocm93IEVycm9yKFwicmFkaXggb3V0IG9mIHJhbmdlOiBcIithKTtpZihcIi1cIj09Zi5jaGFyQXQoMCkpcmV0dXJuIHgoeShmLnN1YnN0cmluZygxKSxhKSk7aWYoMDw9Zi5pbmRleE9mKFwiLVwiKSl0aHJvdyBFcnJvcignbnVtYmVyIGZvcm1hdCBlcnJvcjogaW50ZXJpb3IgXCItXCIgY2hhcmFjdGVyJyk7Zm9yKHZhciBjPXYoTWF0aC5wb3coYSw4KSksZD13LGU9MDtlPGYubGVuZ3RoO2UrPTgpe3ZhciBnPU1hdGgubWluKDgsZi5sZW5ndGgtZSksYj1wYXJzZUludChmLnN1YnN0cmluZyhlLGUrZyksYSk7OD5nPyhnPXYoTWF0aC5wb3coYSxnKSksZD1kLmooZykuYWRkKHYoYikpKTooZD1kLmooYyksZD1kLmFkZCh2KGIpKSk7fXJldHVybiBkfXZhciB3PXUoMCksej11KDEpLEE9dSgxNjc3NzIxNik7aD10LnByb3RvdHlwZTtcbmgubT1mdW5jdGlvbigpe2lmKEIodGhpcykpcmV0dXJuIC14KHRoaXMpLm0oKTtmb3IodmFyIGY9MCxhPTEsYz0wO2M8dGhpcy5nLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuaShjKTtmKz0oMDw9ZD9kOjQyOTQ5NjcyOTYrZCkqYTthKj00Mjk0OTY3Mjk2O31yZXR1cm4gZn07aC50b1N0cmluZz1mdW5jdGlvbihmKXtmPWZ8fDEwO2lmKDI+Znx8MzY8Zil0aHJvdyBFcnJvcihcInJhZGl4IG91dCBvZiByYW5nZTogXCIrZik7aWYoQyh0aGlzKSlyZXR1cm4gXCIwXCI7aWYoQih0aGlzKSlyZXR1cm4gXCItXCIreCh0aGlzKS50b1N0cmluZyhmKTtmb3IodmFyIGE9dihNYXRoLnBvdyhmLDYpKSxjPXRoaXMsZD1cIlwiOzspe3ZhciBlPUQoYyxhKS5nO2M9RihjLGUuaihhKSk7dmFyIGc9KCgwPGMuZy5sZW5ndGg/Yy5nWzBdOmMuaCk+Pj4wKS50b1N0cmluZyhmKTtjPWU7aWYoQyhjKSlyZXR1cm4gZytkO2Zvcig7Nj5nLmxlbmd0aDspZz1cIjBcIitnO2Q9ZytkO319O1xuaC5pPWZ1bmN0aW9uKGYpe3JldHVybiAwPmY/MDpmPHRoaXMuZy5sZW5ndGg/dGhpcy5nW2ZdOnRoaXMuaH07ZnVuY3Rpb24gQyhmKXtpZigwIT1mLmgpcmV0dXJuICExO2Zvcih2YXIgYT0wO2E8Zi5nLmxlbmd0aDthKyspaWYoMCE9Zi5nW2FdKXJldHVybiAhMTtyZXR1cm4gITB9ZnVuY3Rpb24gQihmKXtyZXR1cm4gLTE9PWYuaH1oLmw9ZnVuY3Rpb24oZil7Zj1GKHRoaXMsZik7cmV0dXJuIEIoZik/LTE6QyhmKT8wOjF9O2Z1bmN0aW9uIHgoZil7Zm9yKHZhciBhPWYuZy5sZW5ndGgsYz1bXSxkPTA7ZDxhO2QrKyljW2RdPX5mLmdbZF07cmV0dXJuIChuZXcgdChjLH5mLmgpKS5hZGQoeil9aC5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzKT94KHRoaXMpOnRoaXN9O1xuaC5hZGQ9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTAsZT0wO2U8PWE7ZSsrKXt2YXIgZz1kKyh0aGlzLmkoZSkmNjU1MzUpKyhmLmkoZSkmNjU1MzUpLGI9KGc+Pj4xNikrKHRoaXMuaShlKT4+PjE2KSsoZi5pKGUpPj4+MTYpO2Q9Yj4+PjE2O2cmPTY1NTM1O2ImPTY1NTM1O2NbZV09Yjw8MTZ8Zzt9cmV0dXJuIG5ldyB0KGMsY1tjLmxlbmd0aC0xXSYtMjE0NzQ4MzY0OD8tMTowKX07ZnVuY3Rpb24gRihmLGEpe3JldHVybiBmLmFkZCh4KGEpKX1cbmguaj1mdW5jdGlvbihmKXtpZihDKHRoaXMpfHxDKGYpKXJldHVybiB3O2lmKEIodGhpcykpcmV0dXJuIEIoZik/eCh0aGlzKS5qKHgoZikpOngoeCh0aGlzKS5qKGYpKTtpZihCKGYpKXJldHVybiB4KHRoaXMuaih4KGYpKSk7aWYoMD50aGlzLmwoQSkmJjA+Zi5sKEEpKXJldHVybiB2KHRoaXMubSgpKmYubSgpKTtmb3IodmFyIGE9dGhpcy5nLmxlbmd0aCtmLmcubGVuZ3RoLGM9W10sZD0wO2Q8MiphO2QrKyljW2RdPTA7Zm9yKGQ9MDtkPHRoaXMuZy5sZW5ndGg7ZCsrKWZvcih2YXIgZT0wO2U8Zi5nLmxlbmd0aDtlKyspe3ZhciBnPXRoaXMuaShkKT4+PjE2LGI9dGhpcy5pKGQpJjY1NTM1LHI9Zi5pKGUpPj4+MTYsRT1mLmkoZSkmNjU1MzU7Y1syKmQrMiplXSs9YipFO0coYywyKmQrMiplKTtjWzIqZCsyKmUrMV0rPWcqRTtHKGMsMipkKzIqZSsxKTtjWzIqZCsyKmUrMV0rPWIqcjtHKGMsMipkKzIqZSsxKTtjWzIqZCsyKmUrMl0rPWcqcjtHKGMsMipkKzIqZSsyKTt9Zm9yKGQ9MDtkPFxuYTtkKyspY1tkXT1jWzIqZCsxXTw8MTZ8Y1syKmRdO2ZvcihkPWE7ZDwyKmE7ZCsrKWNbZF09MDtyZXR1cm4gbmV3IHQoYywwKX07ZnVuY3Rpb24gRyhmLGEpe2Zvcig7KGZbYV0mNjU1MzUpIT1mW2FdOylmW2ErMV0rPWZbYV0+Pj4xNixmW2FdJj02NTUzNSxhKys7fWZ1bmN0aW9uIEgoZixhKXt0aGlzLmc9Zjt0aGlzLmg9YTt9XG5mdW5jdGlvbiBEKGYsYSl7aWYoQyhhKSl0aHJvdyBFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7aWYoQyhmKSlyZXR1cm4gbmV3IEgodyx3KTtpZihCKGYpKXJldHVybiBhPUQoeChmKSxhKSxuZXcgSCh4KGEuZykseChhLmgpKTtpZihCKGEpKXJldHVybiBhPUQoZix4KGEpKSxuZXcgSCh4KGEuZyksYS5oKTtpZigzMDxmLmcubGVuZ3RoKXtpZihCKGYpfHxCKGEpKXRocm93IEVycm9yKFwic2xvd0RpdmlkZV8gb25seSB3b3JrcyB3aXRoIHBvc2l0aXZlIGludGVnZXJzLlwiKTtmb3IodmFyIGM9eixkPWE7MD49ZC5sKGYpOyljPUkoYyksZD1JKGQpO3ZhciBlPUooYywxKSxnPUooZCwxKTtkPUooZCwyKTtmb3IoYz1KKGMsMik7IUMoZCk7KXt2YXIgYj1nLmFkZChkKTswPj1iLmwoZikmJihlPWUuYWRkKGMpLGc9Yik7ZD1KKGQsMSk7Yz1KKGMsMSk7fWE9RihmLGUuaihhKSk7cmV0dXJuIG5ldyBIKGUsYSl9Zm9yKGU9dzswPD1mLmwoYSk7KXtjPU1hdGgubWF4KDEsTWF0aC5mbG9vcihmLm0oKS9cbmEubSgpKSk7ZD1NYXRoLmNlaWwoTWF0aC5sb2coYykvTWF0aC5MTjIpO2Q9NDg+PWQ/MTpNYXRoLnBvdygyLGQtNDgpO2c9dihjKTtmb3IoYj1nLmooYSk7QihiKXx8MDxiLmwoZik7KWMtPWQsZz12KGMpLGI9Zy5qKGEpO0MoZykmJihnPXopO2U9ZS5hZGQoZyk7Zj1GKGYsYik7fXJldHVybiBuZXcgSChlLGYpfWguQT1mdW5jdGlvbihmKXtyZXR1cm4gRCh0aGlzLGYpLmh9O2guYW5kPWZ1bmN0aW9uKGYpe2Zvcih2YXIgYT1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGYuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YTtkKyspY1tkXT10aGlzLmkoZCkmZi5pKGQpO3JldHVybiBuZXcgdChjLHRoaXMuaCZmLmgpfTtoLm9yPWZ1bmN0aW9uKGYpe2Zvcih2YXIgYT1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGYuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YTtkKyspY1tkXT10aGlzLmkoZCl8Zi5pKGQpO3JldHVybiBuZXcgdChjLHRoaXMuaHxmLmgpfTtcbmgueG9yPWZ1bmN0aW9uKGYpe2Zvcih2YXIgYT1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGYuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YTtkKyspY1tkXT10aGlzLmkoZCleZi5pKGQpO3JldHVybiBuZXcgdChjLHRoaXMuaF5mLmgpfTtmdW5jdGlvbiBJKGYpe2Zvcih2YXIgYT1mLmcubGVuZ3RoKzEsYz1bXSxkPTA7ZDxhO2QrKyljW2RdPWYuaShkKTw8MXxmLmkoZC0xKT4+PjMxO3JldHVybiBuZXcgdChjLGYuaCl9ZnVuY3Rpb24gSihmLGEpe3ZhciBjPWE+PjU7YSU9MzI7Zm9yKHZhciBkPWYuZy5sZW5ndGgtYyxlPVtdLGc9MDtnPGQ7ZysrKWVbZ109MDxhP2YuaShnK2MpPj4+YXxmLmkoZytjKzEpPDwzMi1hOmYuaShnK2MpO3JldHVybiBuZXcgdChlLGYuaCl9bS5wcm90b3R5cGUuZGlnZXN0PW0ucHJvdG90eXBlLnY7bS5wcm90b3R5cGUucmVzZXQ9bS5wcm90b3R5cGUuczttLnByb3RvdHlwZS51cGRhdGU9bS5wcm90b3R5cGUudTtNZDUgPSBibG9vbV9ibG9iX2VzMjAxOC5NZDU9bTt0LnByb3RvdHlwZS5hZGQ9dC5wcm90b3R5cGUuYWRkO3QucHJvdG90eXBlLm11bHRpcGx5PXQucHJvdG90eXBlLmo7dC5wcm90b3R5cGUubW9kdWxvPXQucHJvdG90eXBlLkE7dC5wcm90b3R5cGUuY29tcGFyZT10LnByb3RvdHlwZS5sO3QucHJvdG90eXBlLnRvTnVtYmVyPXQucHJvdG90eXBlLm07dC5wcm90b3R5cGUudG9TdHJpbmc9dC5wcm90b3R5cGUudG9TdHJpbmc7dC5wcm90b3R5cGUuZ2V0Qml0cz10LnByb3RvdHlwZS5pO3QuZnJvbU51bWJlcj12O3QuZnJvbVN0cmluZz15O0ludGVnZXIgPSBibG9vbV9ibG9iX2VzMjAxOC5JbnRlZ2VyPXQ7fSkuYXBwbHkoIHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBjb21tb25qc0dsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgIDoge30pO1xuXG5leHBvcnQgeyBJbnRlZ2VyLCBNZDUsIGJsb29tX2Jsb2JfZXMyMDE4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb29tX2Jsb2JfZXMyMDE4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\n");

/***/ })

};
;